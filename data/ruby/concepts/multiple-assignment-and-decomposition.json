{
  "language": "ruby",
  "slug": "multiple-assignment-and-decomposition",
  "title": "Multiple Assignment And Decomposition",
  "docs": {
    "about": "# Decomposition and Multiple Assignment\r\n\r\nDecomposition refers to the act of extracting the elements of a collection, such as an `Array` or `Hash`.\r\nDecomposed values can then be assigned to variables within the same statement.\r\n\r\n[Multiple assignment][multiple assignment] is the ability to assign multiple variables to decompose values within one statement.\r\nThis allows for code to be more concise and readable, and is done by separating the variables to be assigned with a comma such as `first, second, third = [1, 2, 3]`.\r\n\r\nThe splat operator(`*`), and double splat operator, (`**`), are often used in decomposition contexts.\r\nSplat operator, (`*`), can be used to combine multiple **arrays** into one **array** by _decomposing_ each into a new common **array**.\r\nDouble splat operator, (`**`), can be used to combine multiple **hashes** into one **hash** by _decomposing_ each into a new common **hash**.\r\nThis is syntax used to differentiate from multiple values accepted as a positional argument, to one where we accept any/many key word arguments.\r\n\r\nWhen the splat operator, (`*`), is used without a collection, it _packs_ (or composes) a number of values into an **array**.\r\nThis is often used in multiple assignment to group all \"remaining\" elements that do not have individual assignments into a single variable.\r\n\r\nIt is common in Ruby to use this decomposing/composing behavior when using or defining methods that take an arbitrary number of positional or keyword arguments.\r\nYou will often see these arguments defined as `def some_method(*arguments, **keyword_arguments)` and the arguments used as `some_method(*some_array, **some_hash)`.\r\n\r\n~~~~exercism/caution\r\n`*<variable_name>` and `**<variable_name>` should not be confused with `*` and `**`.\r\nWhile `*` and `**` are used for multiplication and exponentiation, respectively, `*<variable_name>` and `**<variable_name>` are used as composition and decomposition operators.\r\n~~~~\r\n\r\n## Multiple assignment\r\n\r\nMultiple assignment allows you to assign multiple variables in one line.\r\nTo separate the values, use a comma `,`:\r\n\r\n```irb\r\n>> a, b = 1, 2\r\n=> [1, 2]\r\n>> a\r\n=> 1\r\n```\r\n\r\nMultiple assignment is not limited to one data type:\r\n\r\n```irb\r\n>> x, y, z = 1, \"Hello\", true\r\n=> [1, \"Hello\", true]\r\n>> x\r\n=> 1\r\n>> y\r\n=> 'Hello'\r\n>> z\r\n=> true\r\n```\r\n\r\nMultiple assignment can be used to swap elements in **arrays**.\r\nThis practice is pretty common in [sorting algorithms][sorting algorithms].\r\nFor example:\r\n\r\n```irb\r\n>> numbers = [1, 2]\r\n=> [1, 2]\r\n>> numbers[0], numbers[1] = numbers[1], numbers[0]\r\n=> [2, 1]\r\n>> numbers\r\n=> [2, 1]\r\n```\r\n\r\n~~~~exercism/note\r\nThis is also known as \"Parallel Assignment\", and can be used to avoid a temporary variable.\r\n~~~~\r\n\r\nIf there are more variables than values, the extra variables will be assigned `nil`:\r\n\r\n```irb\r\n>> a, b, c = 1, 2\r\n=> [1, 2]\r\n>> b\r\n=> 2\r\n>> c\r\n=> nil\r\n```\r\n\r\nIf there are more values than variables, the extra values will be ignored:\r\n\r\n\r\n```irb\r\n>> a, b, c = 1, 2, 3, 4\r\n>> b\r\n=> 2\r\n>> c\r\n=> 3\r\n```\r\n\r\n## Decomposition\r\n\r\nIn Ruby, it is possible to [decompose the elements of **arrays**/**hashes**][decompose] into distinct variables.\r\nSince values appear within **arrays** in a index order, they are unpacked into variables in the same order:\r\n\r\n```irb\r\n>> fruits = [\"apple\", \"banana\", \"cherry\"]\r\n>> x, y, z = fruits\r\n>> x\r\n=> \"apple\"\r\n```\r\n\r\nIf there are values that are not needed then you can use `_` to indicate \"collected but not used\":\r\n\r\n```irb\r\n>> fruits = [\"apple\", \"banana\", \"cherry\"]\r\n>> _, _, z = fruits\r\n>> z\r\n=> \"cherry\"\r\n```\r\n\r\n### Deep decomposing\r\n\r\nDecomposing and assigning values from **arrays** inside of an **array** (_also known as a nested array_), works in the same way a shallow decomposing does, but needs [delimited decomposition expression (`()`)][delimited decomposition expression] to clarify the values context or position:\r\n\r\n```irb\r\n>> fruits_vegetables = [[\"apple\", \"banana\"], [\"carrot\", \"potato\"]]\r\n>> (a, b), (c, d) = fruits_vegetables\r\n>> a\r\n=> \"apple\"\r\n>> d\r\n=> \"potato\"\r\n```\r\n\r\nYou can also deeply unpack just a portion of a nested **array**:\r\n\r\n```irb\r\n>> fruits_vegetables = [[\"apple\", \"banana\"], [\"carrot\", \"potato\"]]\r\n>> a, (c, d) = fruits_vegetables\r\n>> a\r\n=> [\"apple\", \"banana\"]\r\n>> c\r\n=> \"carrot\"\r\n```\r\n\r\nIf the decomposition has variables with incorrect placement and/or an incorrect number of values, you will get a **syntax error**:\r\n\r\n```ruby\r\nfruits_vegetables = [[\"apple\", \"banana\"], [\"carrot\", \"potato\"]]\r\n(a, b), (d) = fruits_vegetables\r\n\r\nsyntax error, unexpected ')', expecting '.' or &. or :: or '['\r\n((a, b), (d)) = fruits_vegetables\r\n```\r\n\r\nExperiment here, and you will notice that the first pattern dictates, not the available values on the right hand side.\r\nThe syntax error is not tied to the data structure.\r\n\r\n### Decomposing an array with the single splat operator (`*`)\r\n\r\nWhen [decomposing an **array**][decomposition] you can use the splat operator (`*`) to capture the \"leftover\" values.\r\nThis is clearer than slicing the **array** (_which in some situations is less readable_).\r\nFor example, we can extract the first element and then assign the remaining values into a new **array** without the first element:\r\n\r\n```irb\r\n>> fruits = [\"apple\", \"banana\", \"cherry\", \"orange\", \"kiwi\", \"melon\", \"mango\"]\r\n>> x, *last = fruits\r\n>> x\r\n=> \"apple\"\r\n>> last\r\n=> [\"banana\", \"cherry\", \"orange\", \"kiwi\", \"melon\", \"mango\"]\r\n```\r\n\r\nWe can also extract the values at the beginning and end of the **array** while grouping all the values in the middle:\r\n\r\n```irb\r\n>> fruits = [\"apple\", \"banana\", \"cherry\", \"orange\", \"kiwi\", \"melon\", \"mango\"]\r\n>> x, *middle, y, z = fruits\r\n>> y\r\n=> \"melon\"\r\n>> middle\r\n=> [\"banana\", \"cherry\", \"orange\", \"kiwi\"]\r\n```\r\n\r\nWe can also use `*` in deep decomposition:\r\n\r\n```irb\r\n>> fruits_vegetables = [[\"apple\", \"banana\", \"melon\"], [\"carrot\", \"potato\", \"tomato\"]]\r\n>> (a, *rest), b = fruits_vegetables\r\n>> a\r\n=> \"apple\"\r\n>> rest\r\n=> [\"banana\", \"melon\"]\r\n```\r\n\r\n### Decomposing a `Hash`\r\n\r\nDecomposing a **hash** is a bit different than decomposing an **array**.\r\nTo be able to unpack a **hash** you need to convert it to an **array** first.\r\nOtherwise there will be no decomposing:\r\n\r\n```irb\r\n>> fruits_inventory = {apple: 6, banana: 2, cherry: 3}\r\n>> x, y, z = fruits_inventory\r\n>> x\r\n=> {:apple=>6, :banana=>2, :cherry=>3}\r\n>> y\r\n=> nil\r\n```\r\n\r\nTo coerce a `Hash` to an **array** you can use the `to_a` method:\r\n\r\n```irb\r\n>> fruits_inventory = {apple: 6, banana: 2, cherry: 3}\r\n>> fruits_inventory.to_a\r\n=> [[:apple, 6], [:banana, 2], [:cherry, 3]]\r\n>> x, y, z = fruits_inventory.to_a\r\n>> x\r\n=> [:apple, 6]\r\n```\r\n\r\nIf you want to unpack the keys then you can use the `keys` method:\r\n\r\n```irb\r\n>> fruits_inventory = {apple: 6, banana: 2, cherry: 3}\r\n>> x, y, z = fruits_inventory.keys\r\n>> x\r\n=> :apple\r\n```\r\n\r\nIf you want to unpack the values then you can use the `values` method:\r\n\r\n```irb\r\n>> fruits_inventory = {apple: 6, banana: 2, cherry: 3}\r\n>> x, y, z = fruits_inventory.values\r\n>> x\r\n=> 6\r\n```\r\n\r\n## Composition\r\n\r\nComposing is the ability to group multiple values into one **array** that is assigned to a variable.\r\nThis is useful when you want to _decomposition_ values, make changes, and then _composition_ the results back into a variable.\r\nIt also makes it possible to perform merges on 2 or more **arrays**/**hashes**.\r\n\r\n### Composition an array with splat operator(`*`)\r\n\r\nComposing an **array** can be done using the splat operator, (`*`).\r\nThis will pack all the values into an **array**.\r\n\r\n```irb\r\n>> fruits = [\"apple\", \"banana\", \"cherry\"]\r\n>> more_fruits = [\"orange\", \"kiwi\", \"melon\", \"mango\"]\r\n\r\n# fruits and more_fruits are unpacked and then their elements are packed into combined_fruits\r\n>> combined_fruits = *fruits, *more_fruits\r\n\r\n>> combined_fruits\r\n=> [\"apple\", \"banana\", \"cherry\", \"orange\", \"kiwi\", \"melon\", \"mango\"]\r\n```\r\n\r\n### Composition a hash with double splat operator(`**`)\r\n\r\nComposing a hash is done by using the double splat operator(`**`).\r\nThis will pack all **key**/**value** pairs from one hash into another hash, or combine two hashes together.\r\n\r\n```irb\r\n>> fruits_inventory = {apple: 6, banana: 2, cherry: 3}\r\n>> more_fruits_inventory = {orange: 4, kiwi: 1, melon: 2, mango: 3}\r\n\r\n# fruits_inventory and more_fruits_inventory are unpacked into key-values pairs and combined.\r\n>> combined_fruits_inventory = {**fruits_inventory, **more_fruits_inventory}\r\n\r\n# then the pairs are packed into combined_fruits_inventory\r\n>> combined_fruits_inventory\r\n=> {:apple=>6, :banana=>2, :cherry=>3, :orange=>4, :kiwi=>1, :melon=>2, :mango=>3}\r\n```\r\n\r\n## Usage of splat operator(`*`) and double splat operator(`**`) with methods\r\n\r\n### Composition with method parameters\r\n\r\nWhen you create a method that accepts an arbitrary number of arguments, you can use [`*arguments`][arguments] or [`**keyword_arguments`][keyword arguments] in the method definition.\r\n`*arguments` is used to pack an arbitrary number of positional (non-keyworded) arguments and\r\n`**keyword_arguments` is used to pack an arbitrary number of keyword arguments.\r\n\r\nUsage of `*arguments`:\r\n\r\n```irb\r\n# This method is defined to take any number of positional arguments\r\n# (Using the single line form of the definition of a method.)\r\n\r\n>> def my_method(*arguments)= arguments\r\n\r\n# Arguments given to the method are packed into an array\r\n\r\n>> my_method(1, 2, 3)\r\n=> [1, 2, 3]\r\n\r\n>> my_method(\"Hello\")\r\n=> [\"Hello\"]\r\n\r\n>> my_method(1, 2, 3, \"Hello\", \"Mars\")\r\n=> [1, 2, 3, \"Hello\", \"Mars\"]\r\n```\r\n\r\nUsage of `**keyword_arguments`:\r\n\r\n```irb\r\n# This method is defined to take any number of keyword arguments\r\n\r\n>> def my_method(**keyword_arguments)= keyword_arguments\r\n\r\n# Arguments given to the method are packed into a dictionary\r\n\r\n>> my_method(a: 1, b: 2, c: 3)\r\n=> {:a => 1, :b => 2, :c => 3}\r\n```\r\n\r\nIf the method defined does not have any defined parameters for keyword arguments(`**keyword_arguments` or `<key_word>: <value>`) then the keyword arguments will be packed into a hash and assigned to the last parameter.\r\n\r\n```irb\r\n>> def my_method(a)= a\r\n\r\n>> my_method(a: 1, b: 2, c: 3)\r\n=> {:a => 1, :b => 2, :c => 3}\r\n```\r\n\r\n`*arguments` and `**keyword_arguments` can also be used in combination with one another:\r\n\r\n```ruby\r\ndef my_method(*arguments, **keyword_arguments)\r\n  p arguments.sum\r\n  for (key, value) in keyword_arguments.to_a\r\n    p key.to_s + \" = \" + value.to_s\r\n  end\r\nend\r\n\r\n\r\nmy_method(1, 2, 3, a: 1, b: 2, c: 3)\r\n6\r\n\"a = 1\"\r\n\"b = 2\"\r\n\"c = 3\"\r\n```\r\n\r\nYou can also write arguments before and after `*arguments` to allow for specific positional arguments.\r\nThis works the same way as decomposing an array.\r\n\r\n~~~~exercism/caution\r\nArguments have to be structured in a specific order:\r\n\r\n`def my_method(<positional_arguments>, *arguments, <positional_arguments>, <key-word_arguments>, **keyword_arguments)`\r\n\r\nIf you don't follow this order then you will get an error.\r\n~~~~\r\n\r\n```ruby\r\ndef my_method(a, b, *arguments)\r\n  p a\r\n  p b\r\n  p arguments\r\nend\r\n\r\nmy_method(1, 2, 3, 4, 5)\r\n1\r\n2\r\n[3, 4, 5]\r\n```\r\n\r\nYou can write positional arguments before and after `*arguments`:\r\n\r\n```irb\r\n>> def my_method(a, *middle, b)= middle\r\n\r\n>> my_method(1, 2, 3, 4, 5)\r\n=> [2, 3, 4]\r\n```\r\n\r\nYou can also combine positional arguments, \\*arguments, key-word arguments and \\*\\*keyword_arguments:\r\n\r\n```irb\r\n>> def my_method(first, *many, last, a:, **keyword_arguments)\r\n     p first\r\n     p many\r\n     p last\r\n     p a\r\n     p keyword_arguments\r\n     end\r\n\r\n>> my_method(1, 2, 3, 4, 5, a: 6, b: 7, c: 8)\r\n1\r\n[2, 3, 4]\r\n5\r\n6\r\n{:b => 7, :c => 8}\r\n```\r\n\r\nWriting arguments in an incorrect order will result in an error:\r\n\r\n```ruby\r\ndef my_method(a:, **keyword_arguments, first, *arguments, last)\r\n  arguments\r\nend\r\n\r\nmy_method(1, 2, 3, 4, a: 5)\r\n\r\nsyntax error, unexpected local variable or method, expecting & or '&'\r\n... my_method(a:, **keyword_arguments, first, *arguments, last)\r\n```\r\n\r\n### Decomposing into method calls\r\n\r\nYou can use splat operator (`*`) to unpack an **array** of arguments into a method call:\r\n\r\n```ruby\r\ndef my_method(a, b, c)\r\n  p c\r\n  p b\r\n  p a\r\nend\r\n\r\nnumbers = [1, 2, 3]\r\nmy_method(*numbers)\r\n3\r\n2\r\n1\r\n```\r\n\r\nYou can also use double splat operator(`**`) to unpack a **hash** of arguments into a method call:\r\n\r\n```ruby\r\ndef my_method(a:, b:, c:)\r\n  p c\r\n  p b\r\n  p a\r\nend\r\n\r\nnumbers = {a: 1, b: 2, c: 3}\r\nmy_method(**numbers)\r\n3\r\n2\r\n1\r\n```\r\n\r\n[arguments]: https://docs.ruby-lang.org/en/3.1/syntax/methods_rdoc.html#label-Array-2FHash+Argument\r\n[keyword arguments]: https://docs.ruby-lang.org/en/3.1/syntax/methods_rdoc.html#label-Keyword+Arguments\r\n[multiple assignment]: https://docs.ruby-lang.org/en/3.1/syntax/assignment_rdoc.html#label-Multiple+Assignment\r\n[sorting algorithms]: https://en.wikipedia.org/wiki/Sorting_algorithm\r\n[decompose]: https://docs.ruby-lang.org/en/3.1/syntax/assignment_rdoc.html#label-Array+Decomposition\r\n[delimited decomposition expression]: https://riptutorial.com/ruby/example/8798/decomposition\r\n",
    "introduction": "# Decomposition and Multiple Assignment\r\n\r\nDecomposition refers to the act of extracting the elements of a collection, such as an `Array` or `Hash`.\r\nDecomposed values can then be assigned to variables within the same statement.\r\n\r\n[Multiple assignment][multiple assignment] is the ability to assign multiple variables to decompose values within one statement.\r\nThis allows for code to be more concise and readable, and is done by separating the variables to be assigned with a comma such as `first, second, third = [1, 2, 3]`.\r\n\r\nThe splat operator(`*`), and double splat operator, (`**`), are often used in decomposition contexts.\r\nSplat operator, (`*`), can be used to combine multiple **arrays** into one **array** by _decomposing_ each into a new common **array**.\r\nDouble splat operator, (`**`), can be used to combine multiple **hashes** into one **hash** by _decomposing_ each into a new common **hash**.\r\nThis is syntax used to differentiate from multiple values accepted as a positional argument, to one where we accept any/many key word arguments.\r\n\r\nWhen the splat operator, (`*`), is used without a collection, it _packs_ (or composes) a number of values into an **array**.\r\nThis is often used in multiple assignment to group all \"remaining\" elements that do not have individual assignments into a single variable.\r\n\r\nIt is common in Ruby to use this decomposing/composing behavior when using or defining methods that take an arbitrary number of positional or keyword arguments.\r\nYou will often see these arguments defined as `def some_method(*args, **kwargs)` and the arguments used as `some_method(*some_array, **some_hash)`.\r\n\r\n~~~~exercism/caution\r\n`*<variable_name>` and `**<variable_name>` should not be confused with `*` and `**`.\r\nWhile `*` and `**` are used for multiplication and exponentiation, respectively, `*<variable_name>` and `**<variable_name>` are used as composition and decomposition operators.\r\n~~~~\r\n\r\n[multiple assignment]: https://docs.ruby-lang.org/en/3.1/syntax/assignment_rdoc.html#label-Multiple+Assignment\r\n"
  },
  "meta": {
    "blurb": "Decomposition is the process of extracting individual elements of a collection, such as an array or hash. Decomposited values can be assigned to variables within the same step. Multiple assignment is the ability to assign values to multiple variables in one line.",
    "authors": [
      "meatball133",
      "kotp"
    ],
    "contributors": []
  },
  "links": []
}