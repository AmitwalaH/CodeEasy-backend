{
  "language": "ruby",
  "slug": "advanced-enumeration",
  "title": "Advanced Enumeration",
  "docs": {
    "about": "# About\r\n\r\n## More enumeration methods\r\n\r\nIn Enumeration, you were introduced to the `count`, `any?`, `select`, `all` and `map` enumeration methods.\r\nHere's a recap of those, with a few extras added:\r\n\r\n```ruby\r\nfibonacci = [0, 1, 1, 2, 3, 5, 8, 13]\r\n\r\nfibonacci.count  { |number| number == 1 }   #=> 2\r\nfibonacci.any?   { |number| number > 20 }   #=> false\r\nfibonacci.none?  { |number| number > 20 }   #=> true\r\nfibonacci.select { |number| number.odd? }   #=> [1, 1, 3, 5, 13]\r\nfibonacci.all?   { |number| number < 20 }   #=> true\r\nfibonacci.map    { |number| number * 2  }   #=> [0, 2, 2, 4, 6, 10, 16, 26]\r\nfibonacci.select { |number| number >= 5}    #=> [5, 8, 13]\r\nfibonacci.find   { |number| number >= 5}    #=> 5\r\n\r\n# Some methods work with or without a block\r\nfibonacci.sum  #=> 33\r\nfibonacci.sum {| number | number * number }  #=> 273\r\n\r\n# There are also methods to help with nested arrays:\r\nanimals = [ ['cat', 'bob'], ['horse', 'caris'], ['mouse', 'arya'] ]\r\nanimals.flatten  #=> [\"cat\", \"bob\", \"horse\", \"caris\", \"mouse\", \"arya\"]\r\n```\r\n\r\n## Enumerating Hashes\r\n\r\nEnumerating `Hash` objects is exactly the same as enumerating `Array` objects, except that the block receives two arguments: the key and the value:\r\n\r\n```ruby\r\npet_names = {cat: \"bob\", horse: \"caris\", mouse: \"arya\"}\r\npet_names.each { |animal, name| ... }\r\n```\r\n\r\nIf you only need one of the values, you can use the special `_` symbol to indicate that one value is not needed.\r\nThis helps both in terms of developer clarity and also is a performance optimisation.\r\n\r\n```ruby\r\npet_names = {cat: \"bob\", horse: \"caris\", mouse: \"arya\"}\r\npet_names.map { |_, name| name }  #=> [\"bob, \"caris\", \"arya\"]\r\n```\r\n\r\n## Nested Enumerations\r\n\r\nYou can also enumerate in nested blocks, and daisy chain methods together.\r\nFor example, if we have an array of hashes of animals, and we want extract the animals with short names, we might want to do something like:\r\n\r\n```ruby\r\npets = [\r\n  { animal: \"cats\", names: [\"bob\", \"fred\", \"sandra\"] },\r\n  { animal: \"horses\", names: [\"caris\", \"black beard\", \"speedy\"] },\r\n  { animal: \"mice\", names: [\"arya\", \"jerry\"] }\r\n]\r\n\r\npets.map { |pet|\r\n  pet[:names].select { |name| name.length <= 5 }\r\n}.flatten.sort\r\n#=> [\"arya\", \"bob\", \"caris\", \"fred\", \"jerry\"]\r\n```\r\n",
    "introduction": "# Introduction\r\n\r\n## More enumeration methods\r\n\r\nIn Enumeration, you were introduced to the `count`, `any?`, `select`, `all` and `map` enumeration methods.\r\nHere's a recap of those, with a few extras added:\r\n\r\n```ruby\r\nfibonacci = [0, 1, 1, 2, 3, 5, 8, 13]\r\n\r\nfibonacci.count  { |number| number == 1 }   #=> 2\r\nfibonacci.any?   { |number| number > 20 }   #=> false\r\nfibonacci.none?  { |number| number > 20 }   #=> true\r\nfibonacci.select { |number| number.odd? }   #=> [1, 1, 3, 5, 13]\r\nfibonacci.all?   { |number| number < 20 }   #=> true\r\nfibonacci.map    { |number| number * 2  }   #=> [0, 2, 2, 4, 6, 10, 16, 26]\r\nfibonacci.select { |number| number >= 5}    #=> [5, 8, 13]\r\nfibonacci.find   { |number| number >= 5}    #=> 5\r\n\r\n# Some methods work with or without a block\r\nfibonacci.sum  #=> 33\r\nfibonacci.sum {| number | number * number }  #=> 273\r\n\r\n# There are also methods to help with nested arrays:\r\nanimals = [ ['cat', 'bob'], ['horse', 'caris'], ['mouse', 'arya'] ]\r\nanimals.flatten  #=> [\"cat\", \"bob\", \"horse\", \"caris\", \"mouse\", \"arya\"]\r\n```\r\n\r\n## Enumerating Hashes\r\n\r\nEnumerating `Hash` objects is exactly the same as enumerating `Array` objects, except that the block receives two arguments: the key and the value:\r\n\r\n```ruby\r\npet_names = {cat: \"bob\", horse: \"caris\", mouse: \"arya\"}\r\npet_names.each { |animal, name| ... }\r\n```\r\n\r\nIf you only need one of the values, you can use the special `_` symbol to indicate that one value is not needed.\r\nThis helps both in terms of developer clarity and also is a performance optimisation.\r\n\r\n```ruby\r\npet_names = {cat: \"bob\", horse: \"caris\", mouse: \"arya\"}\r\npet_names.map { |_, name| name }  #=> [\"bob, \"caris\", \"arya\"]\r\n```\r\n\r\n## Nested Enumerations\r\n\r\nYou can also enumerate in nested blocks, and daisy chain methods together.\r\nFor example, if we have an array of hashes of animals, and we want extract the animals with short names, we might want to do something like:\r\n\r\n```ruby\r\npets = [\r\n  { animal: \"cats\", names: [\"bob\", \"fred\", \"sandra\"] },\r\n  { animal: \"horses\", names: [\"caris\", \"black beard\", \"speedy\"] },\r\n  { animal: \"mice\", names: [\"arya\", \"jerry\"] }\r\n]\r\n\r\npets.map { |pet|\r\n  pet[:names].select { |name| name.length <= 5 }\r\n}.flatten.sort\r\n#=> [\"arya\", \"bob\", \"caris\", \"fred\", \"jerry\"]\r\n```\r\n"
  },
  "meta": {
    "blurb": "Enumeration also works for hashes and can be nested.",
    "authors": [
      "iHiD"
    ],
    "contributors": []
  },
  "links": []
}