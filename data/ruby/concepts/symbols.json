{
  "language": "ruby",
  "slug": "symbols",
  "title": "Symbols",
  "docs": {
    "about": "# About\r\n\r\n[Symbols][symbols] are named identifiers that can be used to refer to a value.\r\nSymbols are created through a symbol literal, which is by prefixing a name with a `:` character, e.g. `:foo`.\r\nThey also allow for being written with quotes, e.g. `:\"foo\"`, which allows, for example, spaces in the name.\r\n\r\n```ruby\r\n:foo # => :foo\r\n:\"foo boo\" # => :\"foo boo\"\r\n```\r\n\r\nSymbols are used in many places in the language, including as keys in hashes, to represent method names and variable names.\r\n\r\n## Identifier\r\n\r\nWhat makes symbols different from strings is that they are identifiers, and do not represent data or text.\r\nThis means that two symbols with the same name are always the same object.\r\n\r\n```ruby\r\n\"foo\".object_id # => 60\r\n\"foo\".object_id # => 80\r\n:foo.object_id # => 1086748\r\n:foo.object_id # => 1086748\r\n```\r\n\r\n## Modifying Symbols\r\n\r\nSymbols are immutable, which means that they cannot be modified.\r\nThis means that when you \"modify\" a symbol, you are actually creating a new symbol.\r\nThere are a few methods that can be used to manipulate symbols, they all return new symbols.\r\nAll methods can be found in the [Symbol API][symbols-api].\r\n\r\n```ruby\r\n:foo.upcase # => :FOO\r\n\r\n:foo.object_id # => 1086748\r\n:foo.upcase.object_id # => 60\r\n```\r\n\r\nThe benefit of symbols being immutable is that they are more memory efficient than strings, but also safer to use as identifiers.\r\n\r\n## Conversion\r\n\r\nSymbols can be converted to strings and vice versa.\r\nThis can be useful when you want to modify a symbol, or when you want to use a symbol as a string.\r\nTo present a string as a symbol, you can use the `String#to_sym` method, and to do the opposite, you can use the `Symbol#to_s` method.\r\nDue to symbols having a limited set of methods, it can be useful to convert a symbol to a string to use string methods on it, if a new symbol is needed.\r\n\r\n```ruby\r\n:foo.to_s # => \"foo\"\r\n\"foo\".to_sym # => :foo\r\n```\r\n\r\n## Getting names in scopes\r\n\r\nIn Ruby you can get names in scopes by using various methods to get names of constants, methods, and variables.\r\nThese methods returns arrays of symbols.\r\n\r\nSome methods are `Module#constants`, `Module#instance_methods`, `Module#class_variables`, `global_variables` and `local_variables`.\r\n\r\n```ruby\r\nmodule Foo\r\n  BAR = 1\r\n  def self.baz; end\r\nend\r\n\r\na = 1\r\n\r\nFoo.constants # => [:BAR]\r\nFoo.instance_methods # => [:baz]\r\n\r\nlocal_variables # => [:a]\r\n```\r\n\r\nAll methods can be found in the [Kernel API][kernal-api] and [Module API][module-api].\r\n\r\n[symbols]: https://www.rubyguides.com/2018/02/ruby-symbols/\r\n[symbols-api]: https://rubyapi.org/o/symbol\r\n[kernal-api]: https://rubyapi.org/o/kernel\r\n[module-api]: https://rubyapi.org/o/module\r\n",
    "introduction": "# About\r\n\r\n[Symbols][symbols] are named identifiers that can be used to refer to a value.\r\nSymbols are created through a symbol literal, which is by prefixing a name with a `:` character, e.g. `:foo`.\r\nThey also allow for being written with quotes, e.g. `:\"foo\"`, which allows, for example, spaces in the name.\r\n\r\n```ruby\r\n:foo # => :foo\r\n:\"foo boo\" # => :\"foo boo\"\r\n```\r\n\r\nSymbols are used in many places in the language, including as keys in hashes, to represent method names and variable names.\r\n\r\n## Identifier\r\n\r\nWhat makes symbols different from strings is that they are identifiers, and do not represent data or text.\r\nThis means that two symbols with the same name are always the same object.\r\n\r\n```ruby\r\n\"foo\".object_id # => 60\r\n\"foo\".object_id # => 80\r\n:foo.object_id # => 1086748\r\n:foo.object_id # => 1086748\r\n```\r\n\r\n## Modifying Symbols\r\n\r\nSymbols are immutable, which means that they cannot be modified.\r\nThis means that when you \"modify\" a symbol, you are actually creating a new symbol.\r\nThere are a few methods that can be used to manipulate symbols, they all return new symbols.\r\nAll methods can be found in the [Symbol API][symbols-api].\r\n\r\n```ruby\r\n:foo.upcase # => :FOO\r\n\r\n:foo.object_id # => 1086748\r\n:foo.upcase.object_id # => 60\r\n```\r\n\r\nThe benefit of symbols being immutable is that they are more memory efficient than strings, but also safer to use as identifiers.\r\n\r\n## Conversion\r\n\r\nSymbols can be converted to strings and vice versa.\r\nThis can be useful when you want to modify a symbol, or when you want to use a symbol as a string.\r\nTo present a string as a symbol, you can use the `String#to_sym` method, and to do the opposite, you can use the `Symbol#to_s` method.\r\nDue to symbols having a limited set of methods, it can be useful to convert a symbol to a string to use string methods on it, if a new symbol is needed.\r\n\r\n```ruby\r\n:foo.to_s # => \"foo\"\r\n\"foo\".to_sym # => :foo\r\n```\r\n\r\n[symbols]: https://www.rubyguides.com/2018/02/ruby-symbols/\r\n[symbols-api]: https://rubyapi.org/o/symbol\r\n"
  },
  "meta": {
    "blurb": "Symbols are very important in Ruby.  They are used as \"identity\".  They are immutable, guaranteed to be a single item no matter where it is used or referenced.  They are used internally as variable, method, constants, and keyword identifiers.  They are also useful, and often used, as keys in a `Hash`.",
    "authors": [
      "meatball133"
    ],
    "contributors": [
      "kotp"
    ]
  },
  "links": [
    {
      "url": "https://www.rubyguides.com/2018/02/ruby-symbols/",
      "description": "Ruby Guides: Ruby Symbols"
    },
    {
      "url": "https://rubyapi.org/symbol/",
      "description": "Ruby API: Symbol"
    }
  ]
}