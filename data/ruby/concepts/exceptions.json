{
  "language": "ruby",
  "slug": "exceptions",
  "title": "Exceptions",
  "docs": {
    "about": "# About\r\n\r\nExceptions are a form of error handling.\r\nThey are called exceptions, as they normally appear when dealing with some unexpected event.\r\n\r\nAt any point in our code, we can \"raise\" an exception.\r\nWe do this using the `raise` method, passing in an object - normally an Exception object, although we can also use basic strings.\r\nFor example, you'll see in the exercise stubs that we use the built-in `RuntimeError` to tell Ruby that a method hasn't been implemented.\r\nYou can also use the shorthand syntax of `raise(ExceptionObject, params)`.\r\nIf the exception class is omitted, `RuntimeError` is used by default.\r\nFor example:\r\n\r\n```ruby\r\n# These are equivalent\r\nraise RuntimeError.new(\"Please implement this method\")\r\nraise RuntimeError, \"Please implement this method\"\r\nraise \"Please implement this method\"\r\n```\r\n\r\nWhen Ruby sees this it bubbles the error to the top of the program and then exits.\r\nFor example, if you try dividing something by zero, you will see something like this:\r\n```ruby\r\n5/0\r\n\r\n#=> Traceback (most recent call last):\r\n#=> ...\r\n#=> ZeroDivisionError (divided by 0)\r\n```\r\n\r\nIt is important to note that exceptions should be used in cases where something exceptional happens, an error that needs special handling.\r\nExceptions should not be used for control-flow of a program, as that is considered bad design, which often leads to bad performance and maintainability.\r\n\r\n## Class hierarchy\r\n\r\nIn Ruby exceptions follow a class hierarchy where `Exception` is the base class. These are the most common Ruby's built-in exceptions:\r\n\r\n```\r\nException\r\n  NoMemoryError\r\n  ScriptError\r\n    LoadError\r\n    NotImplementedError\r\n    SyntaxError\r\n  SignalException\r\n    Interrupt\r\n  StandardError\r\n    ArgumentError\r\n    IOError\r\n    EOFError\r\n    IndexError\r\n    LocalJumpError\r\n    NameError\r\n      NoMethodError\r\n    RangeError\r\n      FloatDomainError\r\n    RegexpError\r\n    RuntimeError\r\n    SecurityError\r\n    SystemCallError\r\n    SystemStackError\r\n    ThreadError\r\n    TypeError\r\n    ZeroDivisionError\r\n  SystemExit\r\n```\r\n\r\nRescuing errors of a specific class also rescues errors of its children. This is why rescuing from `Exception` can be dangerous.\r\nRuby uses exceptions to also handle messages from the operative system \"Signals\", for example `ctrl-c`.\r\nThis means that rescuing from `Exception` will also capture this system \"Signals\".\r\nSo in order to prevent unexpected behaviours the common practice to capture \"all errors\" is to rescue form `StandardError`.\r\n\r\n## Rescue Syntax\r\nRuby also provide extended rescue clauses for situations that require an special treatment:\r\n\r\n```ruby\r\nbegin\r\n  # ...\r\nrescue CustomError => error\r\n  # This block is run if a CustomError occurs\r\nrescue AnotherCustomError => error\r\n  # This block is run if a AnotherCustomError occurs\r\nelse\r\n  # This block is run if no exception occurred at all\r\nensure\r\n  # This block always run, regardless of whether an exception occurred\r\nend\r\n```\r\n\r\nThis can be useful for example when working with network IO where we always need to remember to close a connection.\r\n\r\nRuby rescue blocks can also use the `retry` keyword which re-runs everything between begin and rescue:\r\n\r\n```ruby\r\ncounter = 0\r\nbegin\r\n  counter += 1\r\n  api_request\r\nrescue\r\n  retry if counter <= 3\r\nend\r\n```\r\n",
    "introduction": "# Introduction\r\n\r\nExceptions are a form of error handling.\r\nThey are called exceptions, as they normally appear when dealing with some unexpected event.\r\n\r\nAt any point in our code, we can \"raise\" an exception. \r\nWe do this using the `raise` method, passing in an object - normally an Exception object, although we can also use basic strings.\r\nFor example, you'll see in the exercise stubs that we use the built-in `RuntimeError` to tell Ruby that a method hasn't been implemented.\r\nYou can also use the shorthand syntax of `raise(ExceptionObject, params)`.\r\nIf the exception class is omitted, `RuntimeError` is used by default.\r\nFor example:\r\n\r\n```ruby\r\n# These are equivalent\r\nraise RuntimeError.new(\"Please implement this method\")\r\nraise RuntimeError, \"Please implement this method\"\r\nraise \"Please implement this method\"\r\n```\r\n\r\nWhen Ruby sees this it bubbles the error to the top of the program and then exits.\r\nFor example, if you try dividing something by zero, you will see something like this:\r\n```ruby\r\n5/0\r\n\r\n#=> Traceback (most recent call last):\r\n#=> ...\r\n#=> ZeroDivisionError (divided by 0)\r\n```\r\n"
  },
  "meta": {
    "blurb": "Exceptions should be thrown when an error that needs special handling occurs.",
    "authors": [
      "iHiD"
    ],
    "contributors": []
  },
  "links": []
}