{
  "language": "ruby",
  "slug": "locomotive-engineer",
  "docs": {
    "introduction": "# Decomposition and Multiple Assignment\r\n\r\nDecomposition refers to the act of extracting the elements of a collection, such as an `Array` or `Hash`.\r\nDecomposed values can then be assigned to variables within the same statement.\r\n\r\n[Multiple assignment][multiple assignment] is the ability to assign multiple variables to decompose values within one statement.\r\nThis allows for code to be more concise and readable, and is done by separating the variables to be assigned with a comma such as `first, second, third = [1, 2, 3]`.\r\n\r\nThe splat operator(`*`), and double splat operator, (`**`), are often used in decomposition contexts.\r\n\r\n~~~~exercism/caution\r\n`*<variable_name>` and `**<variable_name>` should not be confused with `*` and `**`.\r\nWhile `*` and `**` are used for multiplication and exponentiation, respectively, `*<variable_name>` and `**<variable_name>` are used as composition and decomposition operators.\r\n~~~~\r\n\r\n## Multiple assignment\r\n\r\nMultiple assignment allows you to assign multiple variables in one line.\r\nTo separate the values, use a comma `,`:\r\n\r\n```irb\r\n>> a, b = 1, 2\r\n=> [1, 2]\r\n>> a\r\n=> 1\r\n```\r\n\r\nMultiple assignment is not limited to one data type:\r\n\r\n```irb\r\n>> x, y, z = 1, \"Hello\", true\r\n=> [1, \"Hello\", true]\r\n>> x\r\n=> 1\r\n>> y\r\n=> 'Hello'\r\n>> z\r\n=> true\r\n```\r\n\r\nMultiple assignment can be used to swap elements in **arrays**.\r\nThis practice is pretty common in [sorting algorithms][sorting algorithms].\r\nFor example:\r\n\r\n```irb\r\n>> numbers = [1, 2]\r\n=> [1, 2]\r\n>> numbers[0], numbers[1] = numbers[1], numbers[0]\r\n=> [2, 1]\r\n>> numbers\r\n=> [2, 1]\r\n```\r\n\r\n~~~~exercism/note\r\nThis is also known as \"Parallel Assignment\", and can be used to avoid a temporary variable.\r\n~~~~\r\n\r\nIf there are more variables than values, the extra variables will be assigned `nil`:\r\n\r\n```irb\r\n>> a, b, c = 1, 2\r\n=> [1, 2]\r\n>> b\r\n=> 2\r\n>> c\r\n=> nil\r\n```\r\n\r\n## Decomposition\r\n\r\nIn Ruby, it is possible to [decompose the elements of **arrays**/**hashes**][decompose] into distinct variables.\r\nSince values appear within **arrays** in a index order, they are unpacked into variables in the same order:\r\n\r\n```irb\r\n>> fruits = [\"apple\", \"banana\", \"cherry\"]\r\n>> x, y, z = fruits\r\n>> x\r\n=> \"apple\"\r\n```\r\n\r\nIf there are values that are not needed then you can use `_` to indicate \"collected but not used\":\r\n\r\n```irb\r\n>> fruits = [\"apple\", \"banana\", \"cherry\"]\r\n>> _, _, z = fruits\r\n>> z\r\n=> \"cherry\"\r\n```\r\n\r\n### Deep decomposing\r\n\r\nDecomposing and assigning values from **arrays** inside of an **array** (_also known as a nested array_), works in the same way a shallow decomposing does, but needs [delimited decomposition expression (`()`)][delimited decomposition expression] to clarify the values context or position:\r\n\r\n```irb\r\n>> fruits_vegetables = [[\"apple\", \"banana\"], [\"carrot\", \"potato\"]]\r\n>> (a, b), (c, d) = fruits_vegetables\r\n>> a\r\n=> \"apple\"\r\n>> d\r\n=> \"potato\"\r\n```\r\n\r\nYou can also deeply unpack just a portion of a nested **array**:\r\n\r\n```irb\r\n>> fruits_vegetables = [[\"apple\", \"banana\"], [\"carrot\", \"potato\"]]\r\n>> a, (c, d) = fruits_vegetables\r\n>> a\r\n=> [\"apple\", \"banana\"]\r\n>> c\r\n=> \"carrot\"\r\n```\r\n\r\nIf the decomposition has variables with incorrect placement and/or an incorrect number of values, you will get a **syntax error**:\r\n\r\n```ruby\r\nfruits_vegetables = [[\"apple\", \"banana\"], [\"carrot\", \"potato\"]]\r\n\r\n(a, b), (d) = fruits_vegetables\r\n# syntax error, unexpected '=', expecting '.' or &. or :: or '['\r\n\r\n((a, b), (d)) = fruits_vegetables\r\n# syntax error, unexpected ')', expecting '.' or &. or :: or '['\r\n```\r\n\r\nExperiment here, and you will notice that the first pattern dictates, not the available values on the right hand side.\r\nThe syntax error is not tied to the data structure.\r\n\r\n### Decomposing an array with the single splat operator (`*`)\r\n\r\nWhen [decomposing an **array**][decompose] you can use the splat operator (`*`) to capture the \"leftover\" values.\r\nThis is clearer than slicing the **array** (_which in some situations is less readable_).\r\nFor example, we can extract the first element and then assign the remaining values into a new **array** without the first element:\r\n\r\n```irb\r\n>> fruits = [\"apple\", \"banana\", \"cherry\", \"orange\", \"kiwi\", \"melon\", \"mango\"]\r\n>> x, *last = fruits\r\n>> x\r\n=> \"apple\"\r\n>> last\r\n=> [\"banana\", \"cherry\", \"orange\", \"kiwi\", \"melon\", \"mango\"]\r\n```\r\n\r\nWe can also extract the values at the beginning and end of the **array** while grouping all the values in the middle:\r\n\r\n```irb\r\n>> fruits = [\"apple\", \"banana\", \"cherry\", \"orange\", \"kiwi\", \"melon\", \"mango\"]\r\n>> x, *middle, y, z = fruits\r\n>> y\r\n=> \"melon\"\r\n>> middle\r\n=> [\"banana\", \"cherry\", \"orange\", \"kiwi\"]\r\n```\r\n\r\nWe can also use `*` in deep decomposition:\r\n\r\n```irb\r\n>> fruits_vegetables = [[\"apple\", \"banana\", \"melon\"], [\"carrot\", \"potato\", \"tomato\"]]\r\n>> (a, *rest), b = fruits_vegetables\r\n>> a\r\n=> \"apple\"\r\n>> rest\r\n=> [\"banana\", \"melon\"]\r\n```\r\n\r\n### Decomposing a `Hash`\r\n\r\nDecomposing a **hash** is a bit different than decomposing an **array**.\r\nTo be able to unpack a **hash** you need to convert it to an **array** first.\r\nOtherwise there will be no decomposing:\r\n\r\n```irb\r\n>> fruits_inventory = {apple: 6, banana: 2, cherry: 3}\r\n>> x, y, z = fruits_inventory\r\n>> x\r\n=> {:apple=>6, :banana=>2, :cherry=>3}\r\n>> y\r\n=> nil\r\n```\r\n\r\nTo coerce a `Hash` to an **array** you can use the `to_a` method:\r\n\r\n```irb\r\n>> fruits_inventory = {apple: 6, banana: 2, cherry: 3}\r\n>> fruits_inventory.to_a\r\n=> [[:apple, 6], [:banana, 2], [:cherry, 3]]\r\n>> x, y, z = fruits_inventory.to_a\r\n>> x\r\n=> [:apple, 6]\r\n```\r\n\r\nIf you want to unpack the keys then you can use the `keys` method:\r\n\r\n```irb\r\n>> fruits_inventory = {apple: 6, banana: 2, cherry: 3}\r\n>> x, y, z = fruits_inventory.keys\r\n>> x\r\n=> :apple\r\n```\r\n\r\nIf you want to unpack the values then you can use the `values` method:\r\n\r\n```irb\r\n>> fruits_inventory = {apple: 6, banana: 2, cherry: 3}\r\n>> x, y, z = fruits_inventory.values\r\n>> x\r\n=> 6\r\n```\r\n\r\n## Composition\r\n\r\nComposing is the ability to group multiple values into one **array** that is assigned to a variable.\r\nThis is useful when you want to _decomposition_ values, make changes, and then _composition_ the results back into a variable.\r\nIt also makes it possible to perform merges on 2 or more **arrays**/**hashes**.\r\n\r\n### Composition an array with splat operator(`*`)\r\n\r\nComposing an **array** can be done using the splat operator, (`*`).\r\nThis will pack all the values into an **array**.\r\n\r\n```irb\r\n>> fruits = [\"apple\", \"banana\", \"cherry\"]\r\n>> more_fruits = [\"orange\", \"kiwi\", \"melon\", \"mango\"]\r\n\r\n# fruits and more_fruits are unpacked and then their elements are packed into combined_fruits\r\n>> combined_fruits = *fruits, *more_fruits\r\n\r\n>> combined_fruits\r\n=> [\"apple\", \"banana\", \"cherry\", \"orange\", \"kiwi\", \"melon\", \"mango\"]\r\n```\r\n\r\n### Composition a hash with double splat operator(`**`)\r\n\r\nComposing a hash is done by using the double splat operator(`**`).\r\nThis will pack all **key**/**value** pairs from one hash into another hash, or combine two hashes together.\r\n\r\n```irb\r\n>> fruits_inventory = {apple: 6, banana: 2, cherry: 3}\r\n>> more_fruits_inventory = {orange: 4, kiwi: 1, melon: 2, mango: 3}\r\n\r\n# fruits_inventory and more_fruits_inventory are unpacked into key-values pairs and combined.\r\n>> combined_fruits_inventory = {**fruits_inventory, **more_fruits_inventory}\r\n\r\n# then the pairs are packed into combined_fruits_inventory\r\n>> combined_fruits_inventory\r\n=> {:apple=>6, :banana=>2, :cherry=>3, :orange=>4, :kiwi=>1, :melon=>2, :mango=>3}\r\n```\r\n\r\n## Usage of splat operator(`*`) and double splat operator(`**`) with methods\r\n\r\n### Composition with method parameters\r\n\r\nWhen you create a method that accepts an arbitrary number of arguments, you can use [`*arguments`][arguments] or [`**keyword_arguments`][keyword arguments] in the method definition.\r\n`*arguments` is used to pack an arbitrary number of positional (non-keyworded) arguments and\r\n`**keyword_arguments` is used to pack an arbitrary number of keyword arguments.\r\n\r\nUsage of `*arguments`:\r\n\r\n```irb\r\n# This method is defined to take any number of positional arguments\r\n# (Using the single line form of the definition of a method.)\r\n\r\n>> def my_method(*arguments)= arguments\r\n\r\n# Arguments given to the method are packed into an array\r\n\r\n>> my_method(1, 2, 3)\r\n=> [1, 2, 3]\r\n\r\n>> my_method(\"Hello\")\r\n=> [\"Hello\"]\r\n\r\n>> my_method(1, 2, 3, \"Hello\", \"Mars\")\r\n=> [1, 2, 3, \"Hello\", \"Mars\"]\r\n```\r\n\r\nUsage of `**keyword_arguments`:\r\n\r\n```irb\r\n# This method is defined to take any number of keyword arguments\r\n\r\n>> def my_method(**keyword_arguments)= keyword_arguments\r\n\r\n# Arguments given to the method are packed into a dictionary\r\n\r\n>> my_method(a: 1, b: 2, c: 3)\r\n=> {:a => 1, :b => 2, :c => 3}\r\n```\r\n\r\nIf the method defined does not have any defined parameters for keyword arguments(`**keyword_arguments` or `<key_word>: <value>`) then the keyword arguments will be packed into a hash and assigned to the last parameter.\r\n\r\n```irb\r\n>> def my_method(a)= a\r\n\r\n>> my_method(a: 1, b: 2, c: 3)\r\n=> {:a => 1, :b => 2, :c => 3}\r\n```\r\n\r\n`*arguments` and `**keyword_arguments` can also be used in combination with one another:\r\n\r\n```ruby\r\ndef my_method(*arguments, **keyword_arguments)\r\n  p arguments.sum\r\n  for (key, value) in keyword_arguments.to_a\r\n    p key.to_s + \" = \" + value.to_s\r\n  end\r\nend\r\n\r\n\r\nmy_method(1, 2, 3, a: 1, b: 2, c: 3)\r\n6\r\n\"a = 1\"\r\n\"b = 2\"\r\n\"c = 3\"\r\n```\r\n\r\nYou can also write arguments before and after `*arguments` to allow for specific positional arguments.\r\nThis works the same way as decomposing an array.\r\n\r\n~~~~exercism/caution\r\nArguments have to be structured in a specific order:\r\n\r\n`def my_method(<positional_arguments>, *arguments, <positional_arguments>, <keyword_arguments>, **keyword_arguments)`\r\n\r\nIf you don't follow this order then you will get an error.\r\n~~~~\r\n\r\n```ruby\r\ndef my_method(a, b, *arguments)\r\n  p a\r\n  p b\r\n  p arguments\r\nend\r\n\r\nmy_method(1, 2, 3, 4, 5)\r\n1\r\n2\r\n[3, 4, 5]\r\n```\r\n\r\nYou can write positional arguments before and after `*arguments`:\r\n\r\n```irb\r\n>> def my_method(a, *middle, b)= middle\r\n\r\n>> my_method(1, 2, 3, 4, 5)\r\n=> [2, 3, 4]\r\n```\r\n\r\nYou can also combine positional arguments, \\*arguments, key-word arguments and \\*\\*keyword_arguments:\r\n\r\n```irb\r\n>> def my_method(first, *many, last, a:, **keyword_arguments)\r\n     p first\r\n     p many\r\n     p last\r\n     p a\r\n     p keyword_arguments\r\n     end\r\n\r\n>> my_method(1, 2, 3, 4, 5, a: 6, b: 7, c: 8)\r\n1\r\n[2, 3, 4]\r\n5\r\n6\r\n{:b => 7, :c => 8}\r\n```\r\n\r\nWriting arguments in an incorrect order will result in an error:\r\n\r\n```ruby\r\ndef my_method(a:, **keyword_arguments, first, *arguments, last)\r\n  arguments\r\nend\r\n\r\nmy_method(1, 2, 3, 4, a: 5)\r\n\r\nsyntax error, unexpected local variable or method, expecting & or '&'\r\n... my_method(a:, **keyword_arguments, first, *arguments, last)\r\n```\r\n\r\n### Decomposing into method calls\r\n\r\nYou can use splat operator (`*`) to unpack an **array** of arguments into a method call:\r\n\r\n```ruby\r\ndef my_method(a, b, c)\r\n  p c\r\n  p b\r\n  p a\r\nend\r\n\r\nnumbers = [1, 2, 3]\r\nmy_method(*numbers)\r\n3\r\n2\r\n1\r\n```\r\n\r\nYou can also use double splat operator(`**`) to unpack a **hash** of arguments into a method call:\r\n\r\n```ruby\r\ndef my_method(a:, b:, c:)\r\n  p c\r\n  p b\r\n  p a\r\nend\r\n\r\nnumbers = {a: 1, b: 2, c: 3}\r\nmy_method(**numbers)\r\n3\r\n2\r\n1\r\n```\r\n\r\n[arguments]: https://docs.ruby-lang.org/en/3.1/syntax/methods_rdoc.html#label-Array-2FHash+Argument\r\n[keyword arguments]: https://docs.ruby-lang.org/en/3.1/syntax/methods_rdoc.html#label-Keyword+Arguments\r\n[multiple assignment]: https://docs.ruby-lang.org/en/3.1/syntax/assignment_rdoc.html#label-Multiple+Assignment\r\n[sorting algorithms]: https://en.wikipedia.org/wiki/Sorting_algorithm\r\n[decompose]: https://docs.ruby-lang.org/en/3.1/syntax/assignment_rdoc.html#label-Array+Decomposition\r\n[delimited decomposition expression]: https://riptutorial.com/ruby/example/8798/decomposition\r\n",
    "instructions": "# Instructions\r\n\r\nYour friend Linus is a Locomotive Engineer who drives cargo trains between cities.\r\nAlthough they are amazing at handling trains, they are not amazing at handling logistics or computers.\r\nThey would like to enlist your programming help organizing train details and correcting mistakes in route data.\r\n\r\n~~~~exercism/note\r\nThis exercise could easily be solved using slicing, indexing, and various `hash` methods.\r\nHowever, we would like you to practice packing, unpacking, and multiple assignment in solving each of the tasks below.\r\n~~~~\r\n\r\n## 1. Create a list of all wagons\r\n\r\nYour friend has been keeping track of each wagon identifier (ID), but they are never sure how many wagons the system is going to have to process at any given time. It would be much easier for the rest of the logistics program to have this data packaged into a unified **array**.\r\n\r\nImplement a method `generate_list_of_wagons()` that accepts an arbitrary number of wagon IDs.\r\nEach ID will be a positive integer.\r\nThe method should then `return` the given IDs as a single **array**.\r\n\r\n```ruby\r\nLocomotiveEngineer.generate_list_of_wagons(1, 7, 12, 3, 14, 8, 5)\r\n# => [1, 7, 12, 3, 14, 8, 5]\r\n```\r\n\r\n## 2. Fix the list of wagons\r\n\r\nAt this point, you are starting to get a feel for the data and how it's used in the logistics program.\r\nThe ID system always assigns the locomotive an ID of **1**, with the remainder of the wagons in the train assigned a randomly chosen ID greater than **1**.\r\n\r\nYour friend had to connect two new wagons to the train and forgot to update the system!\r\nNow, the first two wagons in the train **array** have to be moved to the end, or everything will be out of order.\r\n\r\nTo make matters more complicated, your friend just uncovered a second **array** that appears to contain missing wagon IDs.\r\nAll they can remember is that once the new wagons are moved, the IDs from this second **array** should be placed directly after the designated locomotive.\r\n\r\nLinus would be really grateful to you for fixing their mistakes and consolidating the data.\r\n\r\nImplement a method `fix_list_of_wagons()` that takes two **arrays** containing wagon IDs.\r\nIt should reposition the first two items of the first **array** to the end, and insert the values from the second **array** behind (_on the right hand side of_) the locomotive ID (**1**).\r\nThe method should then `return` an **array** with the modifications.\r\n\r\n```ruby\r\nLocomotiveEngineer.fix_list_of_wagons([2, 5, 1, 7, 4, 12, 6, 3, 13], [3, 17, 6, 15])\r\n# => [1, 3, 17, 6, 15, 7, 4, 12, 6, 3, 13, 2, 5]\r\n```\r\n\r\n## 3. Add missing stops\r\n\r\nNow that all the wagon data is correct, Linus would like you to update the system's routing information.\r\nAlong a transport route, a train might make stops at a few different stations to pick up and/or drop off cargo.\r\nEach journey could have a different amount of these intermediary delivery points.\r\nYour friend would like you to update the systems routing **hash** with any missing/additional delivery information.\r\n\r\nImplement a method `add_missing_stops()` that accepts a routing **hash** followed by a variable number of keyword arguments.\r\nThese arguments could be in the form of a **hash** holding one or more stops, or any number of `stop_<number>: \"city\"` keyword pairs.\r\nYour method should then return the routing **hash** updated with an additional **key** that holds a **array** of all the added stops in order.\r\n\r\n```ruby\r\nLocomotiveEngineer.add_missing_stops({from: \"New York\", to: \"Miami\"},\r\n                    stop_1: \"Washington, DC\", stop_2: \"Charlotte\", stop_3: \"Atlanta\",\r\n                    stop_4: \"Jacksonville\", stop_5: \"Orlando\")\r\n# => {from: \"New York\", to: \"Miami\", stops: [\"Washington, DC\", \"Charlotte\", \"Atlanta\", \"Jacksonville\", \"Orlando\"]}\r\n```\r\n\r\n## 4. Extend routing information\r\n\r\nLinus has been working on the routing program and has noticed that certain routes are missing some important details.\r\nInitial route information has been constructed as a **hash** and your friend would like you to update that **hash** with whatever might be missing.\r\nEvery route in the system requires slightly different details, so Linus would really prefer a generic solution.\r\n\r\nImplement a method called `extend_route_information()` that accepts two **hashes**.\r\nThe first **hash** contains the origin and destination cities the train route runs between.\r\n\r\nThe second **hash** contains other routing details such as train speed, length, or temperature.\r\nThe method should return a consolidated **hash** with all routing information.\r\n\r\n~~~~exercism/note\r\nThe second **hash** can contain different/more properties than the ones shown in the example.\r\n~~~~\r\n\r\n```ruby\r\nLocomotiveEngineer.extend_route_information({\"from\": \"Berlin\", \"to\": \"Hamburg\"}, {\"length\": \"100\", \"speed\": \"50\"})\r\n# => {\"from\": \"Berlin\", \"to\": \"Hamburg\", \"length\": \"100\", \"speed\": \"50\"}\r\n```\r\n",
    "hints": "# Hints\r\n\r\n## General\r\n\r\n- To extract multiple arguments in the function parameters so can you pack them with the `*arguments` operator for **array** or `**keyword_arguments` for keyword-based arguments.\r\n- To pack or unpack use the splat operators (`*` or `**`).\r\n\r\n## 1. Create a list of all wagons\r\n\r\n- Multiple arguments in the function parameters can be packed with the `*arguments` operator.\r\n\r\n## 2. Fix the list of wagons\r\n\r\n- Using unpacking with the splat operator(`*`), lets you extract the first two elements of an **array** while keeping the rest intact.\r\n- To add another **array** into an existing **array**, you can use the splat operator (`*`) to \"spread\" the **array**.\r\n\r\n## 3. Add missing stops\r\n\r\n- Using `**keyword_arguments` as a method argument will allow an arbitrary amount of keyword arguments to be passed.\r\n- Using `**<hash>` as an argument will unpack a `Hash` into keyword arguments.\r\n- You can put keyword arguments in a `{}`, which is another way to create a `Hash`.\r\n- To get the values out of a `Hash`, you can use the `Hash#values` method.\r\n\r\n## 4. Extend routing information\r\n\r\n- Using `**{some_hash: value}` as an argument will unpack the `Hash` into keyword arguments.\r\n\r\n"
  },
  "starter_code": "class LocomotiveEngineer\r\n  def self.generate_list_of_wagons\r\n    raise 'Please implement the LocomotiveEngineer.generate_list_of_wagons method'\r\n  end\r\n\r\n  def self.fix_list_of_wagons(each_wagons_id, missing_wagons)\r\n    raise 'Please implement the LocomotiveEngineer.fix_list_of_wagons method'\r\n  end\r\n\r\n  def self.add_missing_stops\r\n    raise 'Please implement the LocomotiveEngineer.add_missing_stops method'\r\n  end\r\n\r\n  def self.extend_route_information(route, more_route_information)\r\n    raise 'Please implement the LocomotiveEngineer.extend_route_information method'\r\n  end\r\nend\r\n",
  "tests": "require 'minitest/autorun'\r\nrequire_relative 'locomotive_engineer'\r\n\r\nclass LocomotiveEngineerTest < Minitest::Test\r\n  def test_get_array_of_wagons_with_a_few_inputs\r\n    assert_equal [1, 5, 2, 7, 4], LocomotiveEngineer.generate_list_of_wagons(1, 5, 2, 7, 4)\r\n  end\r\n\r\n  def test_get_array_of_wagons_with_two_inputs\r\n    assert_equal [1, 5], LocomotiveEngineer.generate_list_of_wagons(1, 5)\r\n  end\r\n\r\n  def test_get_array_of_wagons_with_one_inputs\r\n    assert_equal [1], LocomotiveEngineer.generate_list_of_wagons(1)\r\n  end\r\n\r\n  def test_get_array_of_wagons_with_many_inputs\r\n    assert_equal [1, 10, 6, 3, 9, 8, 4, 14, 24, 7], LocomotiveEngineer.generate_list_of_wagons(1, 10, 6, 3, 9, 8, 4, 14, 24, 7)\r\n  end\r\n\r\n  def test_fix_array_of_wagons_a_few_inputs\r\n    assert_equal [1, 3, 17, 6, 15, 7, 4, 12, 6, 3, 13, 2, 5],\r\n      LocomotiveEngineer.fix_list_of_wagons([2, 5, 1, 7, 4, 12, 6, 3, 13], [3, 17, 6, 15])\r\n  end\r\n\r\n  def test_fix_array_of_wagons_many_inputs\r\n    assert_equal [1, 8, 10, 5, 9, 36, 7, 20, 14, 10, 4, 12, 6, 23, 17, 13, 22, 28, 19, 3, 27],\r\n      LocomotiveEngineer.fix_list_of_wagons([3, 27, 1, 14, 10, 4, 12, 6, 23, 17, 13, 22, 28, 19], [8, 10, 5, 9, 36, 7, 20])\r\n  end\r\n\r\n  def test_fix_array_of_wagons_the_inputs_are_same_length\r\n    assert_equal [1, 8, 6, 15, 4, 2],\r\n      LocomotiveEngineer.fix_list_of_wagons([4, 2, 1], [8, 6, 15])\r\n  end\r\n\r\n  def test_fix_array_of_wagons_the_missing_wagons_input_is_longer\r\n    assert_equal [1, 8, 6, 4, 5, 9, 21, 2, 13, 25, 7, 19, 10, 3, 14],\r\n      LocomotiveEngineer.fix_list_of_wagons([3, 14, 1, 25, 7, 19, 10], [8, 6, 4, 5, 9, 21, 2, 13])\r\n  end\r\n\r\n  def test_add_missing_stops_a_few_stops\r\n    assert_equal({ from: 'Berlin', to: 'Hamburg', stops: %w[Leipzig Hannover Frankfurt] },\r\n      LocomotiveEngineer.add_missing_stops({ from: 'Berlin', to: 'Hamburg' }, stop_1: 'Leipzig', stop_2: 'Hannover', stop_3: 'Frankfurt'))\r\n  end\r\n\r\n  def test_add_missing_stops_with_one_stop\r\n    assert_equal({ from: 'Paris', to: 'London', stops: ['Lille'] },\r\n      LocomotiveEngineer.add_missing_stops({ from: 'Paris', to: 'London' }, stop_1: 'Lille'))\r\n  end\r\n\r\n  def test_add_missing_stops_with_zero_stops\r\n    assert_equal({ from: 'New York', to: 'Philadelphia', stops: [] },\r\n      LocomotiveEngineer.add_missing_stops({ from: 'New York', to: 'Philadelphia' }))\r\n  end\r\n\r\n  def test_add_missing_stops_with_many_stops\r\n    assert_equal({ from: 'Gothenburg', to: 'Copenhagen', stops: %w[Kungsbacka Varberg Halmstad Angelholm Lund Malmo] },\r\n      LocomotiveEngineer.add_missing_stops({ from: 'Gothenburg', to: 'Copenhagen' }, stop_1: 'Kungsbacka', stop_2: 'Varberg', stop_3: 'Halmstad', stop_4: 'Angelholm', stop_5: 'Lund', stop_6: 'Malmo'))\r\n  end\r\n\r\n  def test_extend_route_information_with_four_extra_inputs\r\n    assert_equal({ from: 'Berlin', to: 'Hamburg', timeOfArrival: '12:00', precipitation: '10', temperature: '5', caboose: 'yes' },\r\n      LocomotiveEngineer.extend_route_information({ from: 'Berlin', to: 'Hamburg' }, { timeOfArrival: '12:00', precipitation: '10', temperature: '5', caboose: 'yes' }))\r\n  end\r\n\r\n  def test_extend_route_information_with_three_extra_inputs\r\n    assert_equal({ from: 'Paris', to: 'London', timeOfArrival: '10:30', temperature: '20', length: '15' },\r\n      LocomotiveEngineer.extend_route_information({ from: 'Paris', to: 'London' }, { timeOfArrival: '10:30', temperature: '20', length: '15' }))\r\n  end\r\n\r\n  def test_extend_route_information_with_three_extra_inputs_with_different_information\r\n    assert_equal({ from: 'Gothenburg', to: 'Copenhagen', precipitation: '1', timeOfArrival: '21:20', temperature: '-6' },\r\n      LocomotiveEngineer.extend_route_information({ from: 'Gothenburg', to: 'Copenhagen' }, { precipitation: '1', timeOfArrival: '21:20', temperature: '-6' }))\r\n  end\r\nend\r\n"
}