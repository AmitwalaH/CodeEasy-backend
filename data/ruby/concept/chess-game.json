{
  "language": "ruby",
  "slug": "chess-game",
  "docs": {
    "introduction": "# Ranges\r\n\r\n[Ranges][range] represent an interval between two values.\r\nThe most common types that support ranges are `Integer` and `String`.\r\nThey can be used for many things like quickly creating a collection, slicing strings, checking if a value is in a range, and iteration.\r\nThey are created using the range operator `..` or `...` (inclusive and exclusive, respectively).\r\n\r\n```ruby\r\n1..5  # => 1..5\r\n1...5 # => 1...5\r\n\r\n(1..5).to_a # => [1, 2, 3, 4, 5]\r\n(1...5).to_a # => [1, 2, 3, 4]\r\n```\r\n\r\nThe reason for having two range operators is to allow to create ranges that are inclusive or exclusive of the end value, which can be useful when for example working with indexes that are zero based.\r\n\r\nRanges can also be created using the `Range` constructor, `new`.\r\n\r\n```ruby\r\nRange.new(1, 5) # A range containing 1, 2, 3, 4, 5\r\n```\r\n\r\n~~~~exercism/note\r\nWhen creating a range in Ruby using the range operators `..` or `...`, and wanting to call a method on the range, you need to wrap the range in parentheses.\r\nThis is because, otherwise, the method will be called on the 2nd argument of the range operator.\r\n\r\n```ruby\r\n(1..5).sum # => 15\r\n1..5.sum # => Error: undefined method `sum' for 5:Integer (NoMethodError)\r\n```\r\n~~~~\r\n\r\n## Getting substrings\r\n\r\nWhen wanting to slice a string, you can use the range operator to get a substring.\r\nThat is, by creating a range with the start and end index of the sub-string.\r\n\r\n```ruby\r\n\"Hello World\"[0..4] # => \"Hello\"\r\n\"Hello World\"[6..10] # => \"World\"\r\n```\r\n\r\nYou can also use negative indexes to get the substring from the end of the string.\r\n\r\n```ruby\r\n\"Hello World\"[-5..-1] # => \"World\"\r\n\"Hello World\"[6..-4] # => \"Wo\"\r\n```\r\n\r\n## Range methods\r\n\r\nRanges do have a set of methods that can be used to work with them.\r\nFor example, these methods can be used to get the sum of all the values in the range or check if the range includes a value.\r\n\r\n| Method                  | Description                                                             | Example                         |\r\n| ----------------------- | ----------------------------------------------------------------------- | ------------------------------- |\r\n| [`sum`][sum]            | Returns the sum of all the values in the range                          | `(1..5).sum # => 15`            |\r\n| [`size`][size]          | Returns the size of the range                                           | `(1..5).size # => 5`            |\r\n| [`include?`][indlude]   | Returns `true` if the range includes the given value, otherwise `false` | `(1..5).include?(3) # => true` |\r\n\r\n## Endless & Beginless ranges\r\n\r\nA range can be endless and beginless.\r\nThe endless or beginless range has their start or end value being `nil`, but when defining the range the `nil` can be omitted.\r\n\r\nUsing beginless and endless ranges is useful when you want to, for example, slice a string from the beginning or to the end.\r\n\r\n```ruby\r\n\"Hello World\"[0..] # => \"Hello World\"\r\n\"Hello World\"[4..] # => \"o World\"\r\n\"Hello World\"[..5] # => \"Hello \"\r\n```\r\n\r\n~~~~exercism/caution\r\nIf not used on a collection, the endless range can cause an endless sequence, if not used with caution.\r\n~~~~\r\n\r\n## String ranges\r\n\r\nStrings can also be used in ranges and allow one to get an interval of strings between two strings.\r\nIts behavior can be a bit unexpected when using certain strings, so use it with caution.\r\n\r\n```ruby\r\n(\"aa\"..\"az\").to_a # => [\"aa\", \"ab\", \"ac\", ..., \"az\"]\r\n```\r\n\r\n[range]: https://rubyapi.org/o/range\r\n[sum]: https://rubyapi.org/o/enumerable#method-i-sum\r\n[size]: https://rubyapi.org/o/range#method-i-size\r\n[indlude]: https://rubyapi.org/o/range#method-i-include-3F\r\n",
    "instructions": "# Instructions\r\n\r\nAs a chess enthusiast, you would like to write your own version of the game.\r\nYes, there maybe plenty of implementations of chess available online already, but yours will be unique!\r\n\r\nYou start with implementing a basic movement system for the pieces.\r\n\r\nThe chess game will be played on a board that is 8 squares wide and 8 squares long.\r\nThe squares are identified by a letter and a number.\r\n\r\n## 1. Define rank & file range\r\n\r\nThe game will have to store the ranks of the board.\r\nThe ranks are the rows of the board, and are numbered from 1 to 8.\r\n\r\nThe game will also have to store the files of the board.\r\nThe files are the columns of the board and are identified by the letters A to H.\r\n\r\nDefine the `Chess::RANKS` and `Chess::FILES` constants that store the range of ranks and files respectively.\r\n\r\n```ruby\r\nChess::RANKS\r\n# => 1..8\r\n\r\nChess::FILES\r\n# => 'A'..'H'\r\n```\r\n\r\n## 2. Check if square is valid\r\n\r\nThe game will have to check if a square is valid.\r\nA square is valid if the rank and file are within the ranges of the ranks and files.\r\n\r\nDefine the `Chess.valid_square?` method that takes the arguments `rank` that holds an integer of the rank and `file` that holds a char of the file.\r\nThe method should return `true` if the rank and file are within the ranges of the ranks and files and return `false` otherwise.\r\n\r\n```ruby\r\nChess.valid_square?(1, 'A')\r\n# => true\r\n```\r\n\r\n## 3. Get player's nickname\r\n\r\nThe game will have to get the nickname of the player.\r\nThe nickname is the first 2 characters of the player's first name and the last 2 characters of the player's last name.\r\nThe nickname should be capitalized.\r\n\r\nDefine the `Chess.nickname` method that takes the arguments `first_name` that holds a string of the player's first name and `last_name` that holds a string of the player's last name.\r\nThe method should return the nickname of the player as capitalized string.\r\n\r\n```ruby\r\nChess.nickname(\"John\", \"Doe\")\r\n# => \"JOOE\"\r\n```\r\n\r\n## 4. Create move message\r\n\r\nThe game will have to create a message for a move to say which player moved to which square.\r\nThe message should use the player's nickname and the square they moved to.\r\nThe game also has to determine if the move is valid by checking if the file and rank of the square are within the ranges of the files and ranks.\r\n\r\nIf the move is valid, the message should be: `\"{nickname} moved to {square}\"`\r\nIf the move is invalid, the message should be: `\"{nickname} attempted to move to {square}, but that is not a valid square\"`\r\n\r\nDefine the `Chess.move_message` method that takes the arguments `first_name` that holds a string of the player's first_name, `last_name` that holds a string of the player's last_name, and `square` that holds a string of the square the player moved to.\r\nThe method should return the message for the move as a string.\r\n\r\n```ruby\r\nChess.move_message(\"John\", \"Doe\", \"A1\")\r\n# => \"JOOE moved to A1\"\r\n```\r\n",
    "hints": "# Hints\r\n\r\n## 1. Define rank & file range\r\n\r\n- You need to define two [constant][constants] that should hold a [`Range`][range] of ranks and files.\r\n- The ranks should be an [`Integer`][integers] `range` from 1 to 8.\r\n- The files should be a [`String`][string] `Range` from 'A' to 'H'.\r\n- The constant needs to be defined in the `Chess` [module][module].\r\n\r\n## 2. Check if square is valid\r\n\r\n- You need to check if a value is within a range.\r\n- There is [a method][include] that can be used to check if a value is within a range.\r\n\r\n## 3. Get player's nickname\r\n\r\n- You can get a slice by using a `Range` as input.\r\n- There is a [method][upcase] that can be used to upcase a string.\r\n\r\n## 4. Create move message\r\n\r\n- You can index the square string to get the rank and file.\r\n- You can use already defined methods to get the nickname of the player and to check if the move is valid.\r\n\r\n[constants]: https://www.rubyguides.com/2017/07/ruby-constants/\r\n[integers]: https://rubyapi.org/o/integer\r\n[string]: https://rubyapi.org/o/string\r\n[module]: https://rubyapi.org/o/module\r\n[include]: https://rubyapi.org/o/range#method-i-include-3F\r\n[range]: https://rubyapi.org/o/range\r\n[upcase]: https://rubyapi.org/o/string#method-i-upcase\r\n"
  },
  "starter_code": "module Chess\r\n  # TODO: define the 'RANKS' constant\r\n  # TODO: define the 'FILES' constant\r\n\r\n  def self.valid_square?(rank, file)\r\n    raise \"Please implement the Chess.valid_square? method\"\r\n  end\r\n\r\n  def self.nickname(first_name, last_name)\r\n    raise \"Please implement the Chess.nickname method\"\r\n  end\r\n\r\n  def self.move_message(first_name, last_name, square)\r\n    raise \"Please implement the Chess.move_message method\"\r\n  end\r\nend\r\n",
  "tests": "require 'minitest/autorun'\r\nrequire_relative 'chess_game'\r\n\r\nclass ChessTest < Minitest::Test\r\n  def test_have_8_files\r\n    assert_equal 'A'..'H', Chess::FILES\r\n  end\r\n\r\n  def test_have_8_ranks\r\n    assert_equal 1..8, Chess::RANKS\r\n  end\r\n\r\n  def test_true_when_given_a_valid_square\r\n    assert Chess.valid_square?(1, 'A')\r\n  end\r\n\r\n  def test_true_for_another_valid_square\r\n    assert Chess.valid_square?(8, 'H')\r\n  end\r\n\r\n  def test_false_when_rank_is_out_of_range\r\n    refute Chess.valid_square?(9, 'B')\r\n  end\r\n\r\n  def test_false_when_file_is_out_of_range\r\n    refute Chess.valid_square?(1, 'I')\r\n  end\r\n\r\n  def test_false_when_rank_is_less_than_one\r\n    refute Chess.valid_square?(0, 'A')\r\n  end\r\n\r\n  def test_correct_player_nickname\r\n    assert_equal \"JOOE\", Chess.nickname(\"John\", \"Doe\")\r\n  end\r\n\r\n  def test_correct_nickname_for_2_letter_last_name\r\n    assert_equal \"LILI\", Chess.nickname(\"Lisa\", \"Li\")\r\n  end\r\n\r\n  def test_correct_nickname_for_2_letter_first_name\r\n    assert_equal \"DJER\", Chess.nickname(\"Dj\", \"Walker\")\r\n  end\r\n\r\n  def test_correct_message_for_a_move\r\n    assert_equal \"JOOE moved to A2\", Chess.move_message(\"John\", \"Doe\", \"A2\")\r\n  end\r\n\r\n  def test_correct_message_when_moving_to_corner\r\n    assert_equal \"LILI moved to H8\", Chess.move_message(\"Lisa\", \"Li\", \"H8\")\r\n  end\r\n\r\n  def test_incorrect_message_when_out_of_board\r\n    assert_equal \"DJER attempted to move to I9, but that is not a valid square\", Chess.move_message(\"Dj\", \"Walker\", \"I9\")\r\n  end\r\n\r\n  def test_incorrect_message_when_being_on_rank_0\r\n    assert_equal \"TOON attempted to move to A0, but that is not a valid square\", Chess.move_message(\"Tore\", \"Anderson\", \"A0\")\r\n  end\r\nend\r\n"
}