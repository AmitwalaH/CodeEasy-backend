{
  "language": "ruby",
  "slug": "simple-calculator",
  "docs": {
    "introduction": "# Introduction\r\n\r\nExceptions in Ruby, as in many languages, provide a way of dealing with unexpected events. Proper handling of exceptions is important when trying to prevent your program from crashing.\r\n\r\nWhen an exception is raised, either by raising it explicitly or by the Ruby interpreter raising it, the program diverts normal operation and eventually exits with an error message:\r\n\r\n```ruby\r\nraise ArgumentError.new(\"Something went wrong!\")\r\n=> Traceback (most recent call last):\r\n.\r\n.\r\nArgumentError (Something went wrong!)\r\n```\r\n\r\n```ruby\r\n1/0\r\n=> Traceback (most recent call last):\r\n.\r\n.\r\nZeroDivisionError (divided by 0)\r\n```\r\n\r\nIn case we want to stop this shut down process we need to react to the exception. This is called \"rescuing\" an exception:\r\n\r\n```ruby\r\nbegin\r\n  # ...any code that raises an exception\r\nrescue\r\n  puts 'Got an exception'\r\nend\r\n```\r\n\r\nThis program will not crash and it'll output \"Got an exception\". Instead of exiting, Ruby runs the code in the rescue block, which prints out a message.\r\n\r\nAs everything in Ruby, exceptions are also objects and they usually hold data about the exception. This is how we can get the exception object:\r\n\r\n```ruby\r\nbegin\r\n  # ...any code that raises an exception\r\nrescue => e\r\n  puts \"Exception class: #{ e.class.name }\"\r\n  puts \"Exception Message:#{e.message}\"\r\nend\r\n```\r\n\r\nIn Ruby it's also possible to raise your own exceptions. For example:\r\n\r\n```ruby\r\nbegin\r\n  raise ArgumentError.new(\"Invalid argument\")\r\nrescue ArgumentError => e\r\n  puts e.message\r\nend\r\n```\r\n\r\nThe previous exception is one of the Ruby's built in exceptions but it's also possible to define custom exceptions and raise them:\r\n\r\n```ruby\r\nclass CustomError < StandardError\r\nend\r\n\r\nraise CustomError.new(\"Something went wrong\")\r\n```\r\n",
    "instructions": "# Instructions\r\n\r\nIn this exercise you will be building error handling for a simple calculator.\r\n\r\nThe goal is to have a working calculator that returns a string with the following pattern: `16 + 51 = 67`, when provided with arguments `16`, `51` and `+`.\r\n\r\n```ruby\r\nSimpleCalculator.calculate(16, 51, \"+\")\r\n# => \"16 + 51 = 67\"\r\nSimpleCalculator.calculate(32, 6, \"*\")\r\n# => \"32 * 6 = 192\"\r\nSimpleCalculator.calculate(512, 4, \"/\")\r\n# => \"512 / 4 = 128\"\r\n```\r\n\r\n## 1. Handle the code that may raise errors within the method `calculate`\r\n\r\nThe main method for implementation in this task will be the class method `SimpleCalculator.calculate()` method.\r\nIt takes three arguments.\r\nThe first two arguments are numbers on which an operation is going to be conducted.\r\nThe third argument is of type string and for this exercise it is necessary to implement the following operations:\r\n\r\n- addition using the `+` string\r\n- multiplication using the `*` string\r\n- division using the `/` string\r\n\r\n## 2. Handle illegal operations\r\n\r\nUpdate the `SimpleCalculator.calculate()` method to raise an `UnsupportedOperation` exception for unknown operation symbols.\r\n\r\n```ruby\r\nSimpleCalculator.calculate(1, 2, '-')\r\n# => Raises an UnsupportedOperation\r\n```\r\n\r\n## 3. Handle invalid arguments\r\n\r\nUpdate the `SimpleCalculator.calculate()` method to raise an `ArgumentError` exception for invalid argument types.\r\n\r\n```ruby\r\nSimpleCalculator.calculate(1, '2', '*')\r\n# => Raises an ArgumentError\r\n```\r\n\r\n## 4. Handle DivideByZero exceptions\r\n\r\nUpdate the `SimpleCalculator.calculate()` to handle `ZeroDivisionError` exceptions.\r\nThe handling code should return the string with the content `Division by zero is not allowed.`.\r\nAny other exception should not be handled by the `SimpleCalculator.calculate()` method.\r\n\r\n```ruby\r\nSimpleCalculator.calculate(512, 0, \"/\")\r\n# => returns \"Division by zero is not allowed.\"\r\n```\r\n",
    "hints": "# Hints\r\n\r\n## General\r\n\r\n- Knowing about control flow such as `if/else` or `unless` is a prerequisite.\r\n- Having a collection of permitted operations can be useful and can make your code more readable.\r\n"
  },
  "starter_code": "class SimpleCalculator\r\n  ALLOWED_OPERATIONS = ['+', '/', '*'].freeze\r\n\r\n  def self.calculate(first_operand, second_operand, operation)\r\n    raise 'Please implement the SimpleCalculator.calculate method'\r\n  end\r\nend\r\n",
  "tests": "require 'minitest/autorun'\r\nrequire_relative 'simple_calculator'\r\n\r\nclass SimpleCalculatorTest < Minitest::Test\r\n  def test_addition_with\r\n    assert_equal '22 + 25 = 47', SimpleCalculator.calculate(22, 25, '+')\r\n  end\r\n\r\n  def test_multiplication\r\n    assert_equal '3 * 21 = 63', SimpleCalculator.calculate(3, 21, '*')\r\n  end\r\n\r\n  def test_division\r\n    assert_equal '72 / 9 = 8', SimpleCalculator.calculate(72, 9, '/')\r\n  end\r\n\r\n  def test_rescues_division_by_0_exception\r\n    assert_equal \"Division by zero is not allowed.\", SimpleCalculator.calculate(33, 0, \"/\")\r\n  end\r\n\r\n  def test_no_number_first_operand_raises_exception\r\n    assert_raises(ArgumentError) { SimpleCalculator.calculate('1', 2, '+') }\r\n  end\r\n\r\n  def test_no_number_second_operand_raises_exception\r\n    assert_raises(ArgumentError) { SimpleCalculator.calculate(1, '2', '+') }\r\n  end\r\n\r\n  def test_raises_exception_for_non_valid_operations\r\n    assert_raises(SimpleCalculator::UnsupportedOperation) { SimpleCalculator.calculate(1, 2, '**') }\r\n  end\r\n\r\n  def test_raises_exception_when_operation_is_nil\r\n    assert_raises(SimpleCalculator::UnsupportedOperation) { SimpleCalculator.calculate(1, 2, nil) }\r\n  end\r\n\r\n  def test_raises_exception_when_operation_is_an_empty_string\r\n    assert_raises(SimpleCalculator::UnsupportedOperation) { SimpleCalculator.calculate(1, 2, '') }\r\n  end\r\nend\r\n"
}