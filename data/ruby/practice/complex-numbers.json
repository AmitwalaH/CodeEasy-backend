{
  "language": "ruby",
  "type": "practice",
  "slug": "complex-numbers",
  "title": "Complex Numbers",
  "docs": {
    "instructions": "# Instructions\r\n\r\nA **complex number** is expressed in the form `z = a + b * i`, where:\r\n\r\n- `a` is the **real part** (a real number),\r\n\r\n- `b` is the **imaginary part** (also a real number), and\r\n\r\n- `i` is the **imaginary unit** satisfying `i^2 = -1`.\r\n\r\n## Operations on Complex Numbers\r\n\r\n### Conjugate\r\n\r\nThe conjugate of the complex number `z = a + b * i` is given by:\r\n\r\n```text\r\nzc = a - b * i\r\n```\r\n\r\n### Absolute Value\r\n\r\nThe absolute value (or modulus) of `z` is defined as:\r\n\r\n```text\r\n|z| = sqrt(a^2 + b^2)\r\n```\r\n\r\nThe square of the absolute value is computed as the product of `z` and its conjugate `zc`:\r\n\r\n```text\r\n|z|^2 = z * zc = a^2 + b^2\r\n```\r\n\r\n### Addition\r\n\r\nThe sum of two complex numbers `z1 = a + b * i` and `z2 = c + d * i` is computed by adding their real and imaginary parts separately:\r\n\r\n```text\r\nz1 + z2 = (a + b * i) + (c + d * i)\r\n        = (a + c) + (b + d) * i\r\n```\r\n\r\n### Subtraction\r\n\r\nThe difference of two complex numbers is obtained by subtracting their respective parts:\r\n\r\n```text\r\nz1 - z2 = (a + b * i) - (c + d * i)\r\n        = (a - c) + (b - d) * i\r\n```\r\n\r\n### Multiplication\r\n\r\nThe product of two complex numbers is defined as:\r\n\r\n```text\r\nz1 * z2 = (a + b * i) * (c + d * i)\r\n        = (a * c - b * d) + (b * c + a * d) * i\r\n```\r\n\r\n### Reciprocal\r\n\r\nThe reciprocal of a non-zero complex number is given by:\r\n\r\n```text\r\n1 / z = 1 / (a + b * i)\r\n      = a / (a^2 + b^2) - b / (a^2 + b^2) * i\r\n```\r\n\r\n### Division\r\n\r\nThe division of one complex number by another is given by:\r\n\r\n```text\r\nz1 / z2 = z1 * (1 / z2)\r\n        = (a + b * i) / (c + d * i)\r\n        = (a * c + b * d) / (c^2 + d^2) + (b * c - a * d) / (c^2 + d^2) * i\r\n```\r\n\r\n### Exponentiation\r\n\r\nRaising _e_ (the base of the natural logarithm) to a complex exponent can be expressed using Euler's formula:\r\n\r\n```text\r\ne^(a + b * i) = e^a * e^(b * i)\r\n              = e^a * (cos(b) + i * sin(b))\r\n```\r\n\r\n## Implementation Requirements\r\n\r\nGiven that you should not use built-in support for complex numbers, implement the following operations:\r\n\r\n- **addition** of two complex numbers\r\n- **subtraction** of two complex numbers\r\n- **multiplication** of two complex numbers\r\n- **division** of two complex numbers\r\n- **conjugate** of a complex number\r\n- **absolute value** of a complex number\r\n- **exponentiation** of _e_ (the base of the natural logarithm) to a complex number\r\n",
    "hints": ""
  },
  "starter_code": "=begin\r\nWrite your code for the 'Complex Numbers' exercise in this file. Make the tests in\r\n`complex_numbers_test.rb` pass.\r\n\r\nTo get started with TDD, see the `README.md` file in your\r\n`ruby/complex-numbers` directory.\r\n=end\r\n",
  "tests": "require 'minitest/autorun'\r\nrequire_relative 'complex_numbers'\r\n\r\nclass ComplexNumbersTest < Minitest::Test\r\n  def test_real_part_real_part_of_a_purely_real_number\r\n    # skip\r\n    assert_equal 1, ComplexNumber.new(1, 0).real\r\n  end\r\n\r\n  def test_real_part_real_part_of_a_purely_imaginary_number\r\n    skip\r\n    assert_equal 0, ComplexNumber.new(0, 1).real\r\n  end\r\n\r\n  def test_real_part_real_part_of_a_number_with_real_and_imaginary_part\r\n    skip\r\n    assert_equal 1, ComplexNumber.new(1, 2).real\r\n  end\r\n\r\n  def test_imaginary_part_imaginary_part_of_a_purely_real_number\r\n    skip\r\n    assert_equal 0, ComplexNumber.new(1, 0).imaginary\r\n  end\r\n\r\n  def test_imaginary_part_imaginary_part_of_a_purely_imaginary_number\r\n    skip\r\n    assert_equal 1, ComplexNumber.new(0, 1).imaginary\r\n  end\r\n\r\n  def test_imaginary_part_imaginary_part_of_a_number_with_real_and_imaginary_part\r\n    skip\r\n    assert_equal 2, ComplexNumber.new(1, 2).imaginary\r\n  end\r\n\r\n  def test_imaginary_unit\r\n    skip\r\n    product = ComplexNumber.new(0, 1) * ComplexNumber.new(0, 1)\r\n    assert_equal ComplexNumber.new(-1, 0), product\r\n  end\r\n\r\n  def test_arithmetic_addition_add_purely_real_numbers\r\n    skip\r\n    sum = ComplexNumber.new(1, 0) + ComplexNumber.new(2, 0)\r\n    assert_equal ComplexNumber.new(3, 0), sum\r\n  end\r\n\r\n  def test_arithmetic_addition_add_purely_imaginary_numbers\r\n    skip\r\n    sum = ComplexNumber.new(0, 1) + ComplexNumber.new(0, 2)\r\n    assert_equal ComplexNumber.new(0, 3), sum\r\n  end\r\n\r\n  def test_arithmetic_addition_add_numbers_with_real_and_imaginary_part\r\n    skip\r\n    sum = ComplexNumber.new(1, 2) + ComplexNumber.new(3, 4)\r\n    assert_equal ComplexNumber.new(4, 6), sum\r\n  end\r\n\r\n  def test_arithmetic_subtraction_subtract_purely_real_numbers\r\n    skip\r\n    difference = ComplexNumber.new(1, 0) - ComplexNumber.new(2, 0)\r\n    assert_equal ComplexNumber.new(-1, 0), difference\r\n  end\r\n\r\n  def test_arithmetic_subtraction_subtract_purely_imaginary_numbers\r\n    skip\r\n    difference = ComplexNumber.new(0, 1) - ComplexNumber.new(0, 2)\r\n    assert_equal ComplexNumber.new(0, -1), difference\r\n  end\r\n\r\n  def test_arithmetic_subtraction_subtract_numbers_with_real_and_imaginary_part\r\n    skip\r\n    difference = ComplexNumber.new(1, 2) - ComplexNumber.new(3, 4)\r\n    assert_equal ComplexNumber.new(-2, -2), difference\r\n  end\r\n\r\n  def test_arithmetic_multiplication_multiply_purely_real_numbers\r\n    skip\r\n    product = ComplexNumber.new(1, 0) * ComplexNumber.new(2, 0)\r\n    assert_equal ComplexNumber.new(2, 0), product\r\n  end\r\n\r\n  def test_arithmetic_multiplication_multiply_purely_imaginary_numbers\r\n    skip\r\n    product = ComplexNumber.new(0, 1) * ComplexNumber.new(0, 2)\r\n    assert_equal ComplexNumber.new(-2, 0), product\r\n  end\r\n\r\n  def test_arithmetic_multiplication_multiply_numbers_with_real_and_imaginary_part\r\n    skip\r\n    product = ComplexNumber.new(1, 2) * ComplexNumber.new(3, 4)\r\n    assert_equal ComplexNumber.new(-5, 10), product\r\n  end\r\n\r\n  def test_arithmetic_division_divide_purely_real_numbers\r\n    skip\r\n    quotient = ComplexNumber.new(1, 0) / ComplexNumber.new(2, 0)\r\n    assert_equal ComplexNumber.new(0.5, 0), quotient\r\n  end\r\n\r\n  def test_arithmetic_division_divide_purely_imaginary_numbers\r\n    skip\r\n    quotient = ComplexNumber.new(0, 1) / ComplexNumber.new(0, 2)\r\n    assert_equal ComplexNumber.new(0.5, 0), quotient\r\n  end\r\n\r\n  def test_arithmetic_division_divide_numbers_with_real_and_imaginary_part\r\n    skip\r\n    quotient = ComplexNumber.new(1, 2) / ComplexNumber.new(3, 4)\r\n    assert_equal ComplexNumber.new(0.44, 0.08), quotient\r\n  end\r\n\r\n  def test_absolute_value_absolute_value_of_a_positive_purely_real_number\r\n    skip\r\n    assert_equal 5, ComplexNumber.new(5, 0).abs\r\n  end\r\n\r\n  def test_absolute_value_absolute_value_of_a_negative_purely_real_number\r\n    skip\r\n    assert_equal 5, ComplexNumber.new(-5, 0).abs\r\n  end\r\n\r\n  def test_absolute_value_absolute_value_of_a_purely_imaginary_number_with_positive_imaginary_part\r\n    skip\r\n    assert_equal 5, ComplexNumber.new(0, 5).abs\r\n  end\r\n\r\n  def test_absolute_value_absolute_value_of_a_purely_imaginary_number_with_negative_imaginary_part\r\n    skip\r\n    assert_equal 5, ComplexNumber.new(0, -5).abs\r\n  end\r\n\r\n  def test_absolute_value_absolute_value_of_a_number_with_real_and_imaginary_part\r\n    skip\r\n    assert_equal 5, ComplexNumber.new(3, 4).abs\r\n  end\r\n\r\n  def test_complex_conjugate_conjugate_a_purely_real_number\r\n    skip\r\n    assert_equal ComplexNumber.new(5, 0), ComplexNumber.new(5, 0).conjugate\r\n  end\r\n\r\n  def test_complex_conjugate_conjugate_a_purely_imaginary_number\r\n    skip\r\n    assert_equal ComplexNumber.new(0, -5), ComplexNumber.new(0, 5).conjugate\r\n  end\r\n\r\n  def test_complex_conjugate_conjugate_a_number_with_real_and_imaginary_part\r\n    skip\r\n    assert_equal ComplexNumber.new(1, -1), ComplexNumber.new(1, 1).conjugate\r\n  end\r\n\r\n  def test_complex_exponential_function_eulers_identityformula\r\n    skip\r\n    assert_equal ComplexNumber.new(-1, 0), ComplexNumber.new(0, Math::PI).exp\r\n  end\r\n\r\n  def test_complex_exponential_function_exponential_of_0\r\n    skip\r\n    assert_equal ComplexNumber.new(1, 0), ComplexNumber.new(0, 0).exp\r\n  end\r\n\r\n  def test_complex_exponential_function_exponential_of_a_purely_real_number\r\n    skip\r\n    assert_equal ComplexNumber.new(Math::E, 0), ComplexNumber.new(1, 0).exp\r\n  end\r\n\r\n  def test_complex_exponential_function_exponential_of_a_number_with_real_and_imaginary_part\r\n    skip\r\n    assert_equal ComplexNumber.new(-2, 0), ComplexNumber.new(Math.log(2), Math::PI).exp\r\n  end\r\n\r\n  def test_complex_exponential_function_exponential_resulting_in_a_number_with_real_and_imaginary_part\r\n    skip\r\n    assert_equal ComplexNumber.new(1, 1), ComplexNumber.new(Math.log(2) / 2, Math::PI / 4).exp\r\n  end\r\n\r\n  def test_operations_between_real_numbers_and_complex_numbers_add_real_number_to_complex_number\r\n    skip\r\n    sum = ComplexNumber.new(1, 2) + ComplexNumber.new(5)\r\n    assert_equal ComplexNumber.new(6, 2), sum\r\n  end\r\n\r\n  def test_operations_between_real_numbers_and_complex_numbers_add_complex_number_to_real_number\r\n    skip\r\n    sum = ComplexNumber.new(5) + ComplexNumber.new(1, 2)\r\n    assert_equal ComplexNumber.new(6, 2), sum\r\n  end\r\n\r\n  def test_operations_between_real_numbers_and_complex_numbers_subtract_real_number_from_complex_number\r\n    skip\r\n    difference = ComplexNumber.new(5, 7) - ComplexNumber.new(4)\r\n    assert_equal ComplexNumber.new(1, 7), difference\r\n  end\r\n\r\n  def test_operations_between_real_numbers_and_complex_numbers_subtract_complex_number_from_real_number\r\n    skip\r\n    difference = ComplexNumber.new(4) - ComplexNumber.new(5, 7)\r\n    assert_equal ComplexNumber.new(-1, -7), difference\r\n  end\r\n\r\n  def test_operations_between_real_numbers_and_complex_numbers_multiply_complex_number_by_real_number\r\n    skip\r\n    product = ComplexNumber.new(2, 5) * ComplexNumber.new(5)\r\n    assert_equal ComplexNumber.new(10, 25), product\r\n  end\r\n\r\n  def test_operations_between_real_numbers_and_complex_numbers_multiply_real_number_by_complex_number\r\n    skip\r\n    product = ComplexNumber.new(5) * ComplexNumber.new(2, 5)\r\n    assert_equal ComplexNumber.new(10, 25), product\r\n  end\r\n\r\n  def test_operations_between_real_numbers_and_complex_numbers_divide_complex_number_by_real_number\r\n    skip\r\n    quotient = ComplexNumber.new(10, 100) / ComplexNumber.new(10)\r\n    assert_equal ComplexNumber.new(1, 10), quotient\r\n  end\r\n\r\n  def test_operations_between_real_numbers_and_complex_numbers_divide_real_number_by_complex_number\r\n    skip\r\n    quotient = ComplexNumber.new(5) / ComplexNumber.new(1, 1)\r\n    assert_equal ComplexNumber.new(2.5, -2.5), quotient\r\n  end\r\nend\r\n"
}