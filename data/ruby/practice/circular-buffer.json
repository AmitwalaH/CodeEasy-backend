{
  "language": "ruby",
  "type": "practice",
  "slug": "circular-buffer",
  "title": "Circular Buffer",
  "docs": {
    "instructions": "# Instructions\r\n\r\nA circular buffer, cyclic buffer or ring buffer is a data structure that uses a single, fixed-size buffer as if it were connected end-to-end.\r\n\r\nA circular buffer first starts empty and of some predefined length.\r\nFor example, this is a 7-element buffer:\r\n\r\n```text\r\n[ ][ ][ ][ ][ ][ ][ ]\r\n```\r\n\r\nAssume that a 1 is written into the middle of the buffer (exact starting location does not matter in a circular buffer):\r\n\r\n```text\r\n[ ][ ][ ][1][ ][ ][ ]\r\n```\r\n\r\nThen assume that two more elements are added — 2 & 3 — which get appended after the 1:\r\n\r\n```text\r\n[ ][ ][ ][1][2][3][ ]\r\n```\r\n\r\nIf two elements are then removed from the buffer, the oldest values inside the buffer are removed.\r\nThe two elements removed, in this case, are 1 & 2, leaving the buffer with just a 3:\r\n\r\n```text\r\n[ ][ ][ ][ ][ ][3][ ]\r\n```\r\n\r\nIf the buffer has 7 elements then it is completely full:\r\n\r\n```text\r\n[5][6][7][8][9][3][4]\r\n```\r\n\r\nWhen the buffer is full an error will be raised, alerting the client that further writes are blocked until a slot becomes free.\r\n\r\nWhen the buffer is full, the client can opt to overwrite the oldest data with a forced write.\r\nIn this case, two more elements — A & B — are added and they overwrite the 3 & 4:\r\n\r\n```text\r\n[5][6][7][8][9][A][B]\r\n```\r\n\r\n3 & 4 have been replaced by A & B making 5 now the oldest data in the buffer.\r\nFinally, if two elements are removed then what would be returned is 5 & 6 yielding the buffer:\r\n\r\n```text\r\n[ ][ ][7][8][9][A][B]\r\n```\r\n\r\nBecause there is space available, if the client again uses overwrite to store C & D then the space where 5 & 6 were stored previously will be used not the location of 7 & 8.\r\n7 is still the oldest element and the buffer is once again full.\r\n\r\n```text\r\n[C][D][7][8][9][A][B]\r\n```\r\n",
    "hints": ""
  },
  "starter_code": "=begin\r\nWrite your code for the 'Circular Buffer' exercise in this file. Make the tests in\r\n`circular_buffer_test.rb` pass.\r\n\r\nTo get started with TDD, see the `README.md` file in your\r\n`ruby/circular-buffer` directory.\r\n=end\r\n",
  "tests": "require 'minitest/autorun'\r\nrequire_relative 'circular_buffer'\r\n\r\nclass CircularBufferTest < Minitest::Test\r\n  def test_reading_empty_buffer_should_fail\r\n    # skip\r\n    buffer = CircularBuffer.new(1)\r\n    assert_raises(CircularBuffer::BufferEmptyException) { buffer.read }\r\n  end\r\n\r\n  def test_can_read_an_item_just_written\r\n    skip\r\n    buffer = CircularBuffer.new(1)\r\n    buffer.write('1')\r\n    assert_equal '1', buffer.read\r\n  end\r\n\r\n  def test_each_item_may_only_be_read_once\r\n    skip\r\n    buffer = CircularBuffer.new(1)\r\n    buffer.write('1')\r\n    assert_equal '1', buffer.read\r\n    assert_raises(CircularBuffer::BufferEmptyException) { buffer.read }\r\n  end\r\n\r\n  def test_items_are_read_in_the_order_they_are_written\r\n    skip\r\n    buffer = CircularBuffer.new(2)\r\n    buffer.write('1')\r\n    buffer.write('2')\r\n    assert_equal '1', buffer.read\r\n    assert_equal '2', buffer.read\r\n  end\r\n\r\n  def test_full_buffer_cant_be_written_to\r\n    skip\r\n    buffer = CircularBuffer.new(1)\r\n    buffer.write('1')\r\n    assert_raises(CircularBuffer::BufferFullException) { buffer.write('2') }\r\n  end\r\n\r\n  def test_a_read_frees_up_capacity_for_another_write\r\n    skip\r\n    buffer = CircularBuffer.new(1)\r\n    buffer.write('1')\r\n    assert_equal '1', buffer.read\r\n    buffer.write('2')\r\n    assert_equal '2', buffer.read\r\n  end\r\n\r\n  def test_read_position_is_maintained_even_across_multiple_writes\r\n    skip\r\n    buffer = CircularBuffer.new(3)\r\n    buffer.write('1')\r\n    buffer.write('2')\r\n    assert_equal '1', buffer.read\r\n    buffer.write('3')\r\n    assert_equal '2', buffer.read\r\n    assert_equal '3', buffer.read\r\n  end\r\n\r\n  def test_items_cleared_out_of_buffer_cant_be_read\r\n    skip\r\n    buffer = CircularBuffer.new(1)\r\n    buffer.write('1')\r\n    buffer.clear\r\n    assert_raises(CircularBuffer::BufferEmptyException) { buffer.read }\r\n  end\r\n\r\n  def test_clear_frees_up_capacity_for_another_write\r\n    skip\r\n    buffer = CircularBuffer.new(1)\r\n    buffer.write('1')\r\n    buffer.clear\r\n    buffer.write('2')\r\n    assert_equal '2', buffer.read\r\n  end\r\n\r\n  def test_clear_does_nothing_on_empty_buffer\r\n    skip\r\n    buffer = CircularBuffer.new(1)\r\n    buffer.clear\r\n    buffer.write('1')\r\n    assert_equal '1', buffer.read\r\n  end\r\n\r\n  def test_overwrite_acts_like_write_on_non_full_buffer\r\n    skip\r\n    buffer = CircularBuffer.new(2)\r\n    buffer.write('1')\r\n    buffer.write!('2')\r\n    assert_equal '1', buffer.read\r\n    assert_equal '2', buffer.read\r\n  end\r\n\r\n  def test_overwrite_replaces_the_oldest_item_on_full_buffer\r\n    skip\r\n    buffer = CircularBuffer.new(2)\r\n    buffer.write('1')\r\n    buffer.write('2')\r\n    buffer.write!('3')\r\n    assert_equal '2', buffer.read\r\n    assert_equal '3', buffer.read\r\n  end\r\n\r\n  def test_overwrite_replaces_the_oldest_item_remaining_in_buffer_following_a_read\r\n    skip\r\n    buffer = CircularBuffer.new(3)\r\n    buffer.write('1')\r\n    buffer.write('2')\r\n    buffer.write('3')\r\n    assert_equal '1', buffer.read\r\n    buffer.write('4')\r\n    buffer.write!('5')\r\n    assert_equal '3', buffer.read\r\n    assert_equal '4', buffer.read\r\n    assert_equal '5', buffer.read\r\n  end\r\n\r\n  def test_initial_clear_does_not_affect_wrapping_around\r\n    skip\r\n    buffer = CircularBuffer.new(2)\r\n    buffer.clear\r\n    buffer.write('1')\r\n    buffer.write('2')\r\n    buffer.write!('3')\r\n    buffer.write!('4')\r\n    assert_equal '3', buffer.read\r\n    assert_equal '4', buffer.read\r\n    assert_raises(CircularBuffer::BufferEmptyException) { buffer.read }\r\n  end\r\nend\r\n"
}