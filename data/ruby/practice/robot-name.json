{
  "language": "ruby",
  "type": "practice",
  "slug": "robot-name",
  "title": "Robot Name",
  "docs": {
    "instructions": "# Instructions\r\n\r\nManage robot factory settings.\r\n\r\nWhen a robot comes off the factory floor, it has no name.\r\n\r\nThe first time you turn on a robot, a random name is generated in the format of two uppercase letters followed by three digits, such as RX837 or BC811.\r\n\r\nEvery once in a while we need to reset a robot to its factory settings, which means that its name gets wiped.\r\nThe next time you ask, that robot will respond with a new random name.\r\n\r\nThe names must be random: they should not follow a predictable sequence.\r\nUsing random names means a risk of collisions.\r\nYour solution must ensure that every existing robot has a unique name.\r\n",
    "hints": ""
  },
  "starter_code": "=begin\r\nWrite your code for the 'Robot Name' exercise in this file. Make the tests in\r\n`robot_name_test.rb` pass.\r\n\r\nTo get started with TDD, see the `README.md` file in your\r\n`ruby/robot-name` directory.\r\n=end\r\n",
  "tests": "require 'minitest/autorun'\r\nrequire_relative 'robot_name'\r\n\r\nclass RobotTest < Minitest::Test\r\n  NAME_REGEXP = /^[A-Z]{2}\\d{3}$/\r\n\r\n  def setup\r\n    Robot.forget\r\n  end\r\n\r\n  def test_can_create_a_robot\r\n    skip\r\n    refute_nil Robot.new\r\n  end\r\n\r\n  def test_has_name\r\n    skip\r\n    assert_match NAME_REGEXP, Robot.new.name\r\n  end\r\n\r\n  def test_name_sticks\r\n    skip\r\n    robot = Robot.new\r\n    original_name = robot.name\r\n    assert_equal original_name, robot.name\r\n  end\r\n\r\n  def test_reset_changes_name\r\n    skip\r\n    robot = Robot.new\r\n    original_name = robot.name\r\n    robot.reset\r\n    refute_equal original_name, robot.name\r\n  end\r\n\r\n  def test_reset_before_name_called_does_not_cause_an_error\r\n    skip\r\n    robot = Robot.new\r\n    robot.reset\r\n    assert_match NAME_REGEXP, Robot.new.name\r\n  end\r\n\r\n  def test_reset_multiple_times\r\n    skip\r\n    robot = Robot.new\r\n    names = []\r\n    5.times do\r\n      robot.reset\r\n      names << robot.name\r\n    end\r\n    # This will probably be 5, but name uniqueness is only a requirement\r\n    # accross multiple robots and consecutive calls to reset.\r\n    assert names.uniq.size > 1\r\n  end\r\n\r\n  def test_different_robots_have_different_names\r\n    skip\r\n    refute_equal Robot.new.name, Robot.new.name\r\n  end\r\n\r\n  # This test assumes you're using Kernel.rand as a source of randomness\r\n  def test_different_name_when_chosen_name_is_taken\r\n    skip\r\n    same_seed = 1234\r\n    Kernel.srand same_seed\r\n    robot1 = Robot.new\r\n    name1  = robot1.name\r\n    Kernel.srand same_seed\r\n    robot2 = Robot.new\r\n    name2 = robot2.name\r\n    refute_equal name1, name2\r\n  end\r\n\r\n  def test_generate_all_robots\r\n    skip\r\n    all_names_count = 26 * 26 * 1000\r\n    time_limit = Time.now + 60 # seconds\r\n    seen_names = Hash.new(0)\r\n    robots = []\r\n    while seen_names.size < all_names_count && Time.now < time_limit\r\n      robot = Robot.new\r\n      seen_names[robot.name] += 1\r\n      robots << robot\r\n    end\r\n    timeout_message = \"Timed out trying to generate all possible robots\"\r\n    assert_equal all_names_count, robots.size, timeout_message\r\n    assert seen_names.values.all? { |count| count == 1 }, \"Some names used more than once\"\r\n    assert seen_names.keys.all? { |name| name.match(NAME_REGEXP) }, \"Not all names match #{NAME_REGEXP}\"\r\n  end\r\nend\r\n"
}