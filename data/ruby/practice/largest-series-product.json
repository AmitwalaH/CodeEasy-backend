{
  "language": "ruby",
  "type": "practice",
  "slug": "largest-series-product",
  "title": "Largest Series Product",
  "docs": {
    "instructions": "# Instructions\r\n\r\nYour task is to look for patterns in the long sequence of digits in the encrypted signal.\r\n\r\nThe technique you're going to use here is called the largest series product.\r\n\r\nLet's define a few terms, first.\r\n\r\n- **input**: the sequence of digits that you need to analyze\r\n- **series**: a sequence of adjacent digits (those that are next to each other) that is contained within the input\r\n- **span**: how many digits long each series is\r\n- **product**: what you get when you multiply numbers together\r\n\r\nLet's work through an example, with the input `\"63915\"`.\r\n\r\n- To form a series, take adjacent digits in the original input.\r\n- If you are working with a span of `3`, there will be three possible series:\r\n  - `\"639\"`\r\n  - `\"391\"`\r\n  - `\"915\"`\r\n- Then we need to calculate the product of each series:\r\n  - The product of the series `\"639\"` is 162 (`6 × 3 × 9 = 162`)\r\n  - The product of the series `\"391\"` is 27 (`3 × 9 × 1 = 27`)\r\n  - The product of the series `\"915\"` is 45 (`9 × 1 × 5 = 45`)\r\n- 162 is bigger than both 27 and 45, so the largest series product of `\"63915\"` is from the series `\"639\"`.\r\n  So the answer is **162**.\r\n",
    "hints": ""
  },
  "starter_code": "=begin\r\nWrite your code for the 'Largest Series Product' exercise in this file. Make the tests in\r\n`largest_series_product_test.rb` pass.\r\n\r\nTo get started with TDD, see the `README.md` file in your\r\n`ruby/largest-series-product` directory.\r\n=end\r\n",
  "tests": "require 'minitest/autorun'\r\nrequire_relative 'largest_series_product'\r\n\r\nclass LargestSeriesProductTest < Minitest::Test\r\n  def test_finds_the_largest_product_if_span_equals_length\r\n    # skip\r\n    assert_equal 18, Series.new('29').largest_product(2)\r\n  end\r\n\r\n  def test_can_find_the_largest_product_of_2_with_numbers_in_order\r\n    skip\r\n    assert_equal 72, Series.new('0123456789').largest_product(2)\r\n  end\r\n\r\n  def test_can_find_the_largest_product_of_2\r\n    skip\r\n    assert_equal 48, Series.new('576802143').largest_product(2)\r\n  end\r\n\r\n  def test_can_find_the_largest_product_of_3_with_numbers_in_order\r\n    skip\r\n    assert_equal 504, Series.new('0123456789').largest_product(3)\r\n  end\r\n\r\n  def test_can_find_the_largest_product_of_3\r\n    skip\r\n    assert_equal 270, Series.new('1027839564').largest_product(3)\r\n  end\r\n\r\n  def test_can_find_the_largest_product_of_5_with_numbers_in_order\r\n    skip\r\n    assert_equal 15_120, Series.new('0123456789').largest_product(5)\r\n  end\r\n\r\n  def test_can_get_the_largest_product_of_a_big_number\r\n    skip\r\n    assert_equal 23_520, Series.new('73167176531330624919225119674426574742355349194934').largest_product(6)\r\n  end\r\n\r\n  def test_reports_zero_if_the_only_digits_are_zero\r\n    skip\r\n    assert_equal 0, Series.new('0000').largest_product(2)\r\n  end\r\n\r\n  def test_reports_zero_if_all_spans_include_zero\r\n    skip\r\n    assert_equal 0, Series.new('99099').largest_product(3)\r\n  end\r\n\r\n  def test_rejects_span_longer_than_string_length\r\n    skip\r\n    assert_raises(ArgumentError) do\r\n      Series.new('123').largest_product(4)\r\n    end\r\n  end\r\n\r\n  def test_rejects_empty_string_and_nonzero_span\r\n    skip\r\n    assert_raises(ArgumentError) do\r\n      Series.new('').largest_product(1)\r\n    end\r\n  end\r\n\r\n  def test_rejects_invalid_character_in_digits\r\n    skip\r\n    assert_raises(ArgumentError) do\r\n      Series.new('1234a5').largest_product(2)\r\n    end\r\n  end\r\n\r\n  def test_rejects_negative_span\r\n    skip\r\n    assert_raises(ArgumentError) do\r\n      Series.new('12345').largest_product(-1)\r\n    end\r\n  end\r\nend\r\n"
}