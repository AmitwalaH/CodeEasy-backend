{
  "language": "ruby",
  "type": "practice",
  "slug": "knapsack",
  "title": "Knapsack",
  "docs": {
    "instructions": "# Instructions\r\n\r\nYour task is to determine which items to take so that the total value of her selection is maximized, taking into account the knapsack's carrying capacity.\r\n\r\nItems will be represented as a list of items.\r\nEach item will have a weight and value.\r\nAll values given will be strictly positive.\r\nLhakpa can take only one of each item.\r\n\r\nFor example:\r\n\r\n```text\r\nItems: [\r\n  { \"weight\": 5, \"value\": 10 },\r\n  { \"weight\": 4, \"value\": 40 },\r\n  { \"weight\": 6, \"value\": 30 },\r\n  { \"weight\": 4, \"value\": 50 }\r\n]\r\n\r\nKnapsack Maximum Weight: 10\r\n```\r\n\r\nFor the above, the first item has weight 5 and value 10, the second item has weight 4 and value 40, and so on.\r\nIn this example, Lhakpa should take the second and fourth item to maximize her value, which, in this case, is 90.\r\nShe cannot get more than 90 as her knapsack has a weight limit of 10.\r\n",
    "hints": "# Hints\r\n\r\n## General\r\n\r\n- If you're not sure where to start, try a brute-force solution:\r\n  - First, generate all possible combinations of items. [`Array#combination`](https://rubyapi.org/3.3/o/array#method-i-combination) might come in handy.\r\n  - Then, find the combination that has the highest value and is within the weight limit.\r\n- If you want to make your solution as efficient as possible, look into an algorithmic technique called _dynamic programming_. Here are some resources:\r\n  - [\"Demystifying the 0-1 knapsack problem: top solutions explained\"](demystifying-the-knapsack-problem).\r\n  - [\"5 Simple Steps for Solving Dynamic Programming Problems\"](solving-dynamic-programming-problems)\r\n  - [\"0/1 Knapsack problem | Dynamic Programming\"](0-1-knapsack-problem).\r\n  - [This answer](intuition-of-dp-for-knapsack-problem) to a question on Reddit, _\"What is the intuition behind Knapsack problem solution using dynamic programming?\"_. Below is the answer in full.\r\n\r\n> The intuition behind the solution is basically like any dynamic programming solution: split the task into many sub-tasks, and save solutions to these sub-tasks for later use.\r\n>\r\n> In this case the sub task is to **\"Try to fit x items into a knapsack of a smaller size\"** instead of trying all possible variations in the whole thing right away.\r\n>\r\n> The idea here is that at any point you can ask, *\"Does this item fit into the sack at all?\"*\r\n> If not, you repeat by looking at a bigger portion of the sack until you reach the whole size of it.\r\n> If the item still doesn't fit, then it's simply not part of any solution.\r\n>\r\n> If it does fit, however, then there are two options.\r\n> Either the maximum value for that portion of the sack is achieved without the item, or with the item.\r\n> If the former is true then we can just take the previous solution because we already tried the previous items.\r\n> (For example, if we try item 4 and it doesn't increase our maximum then we can just use our previous solution for items 1-3.)\r\n> If the latter is true then we put item 4 in, which takes some value off of our capacity.\r\n> The remaining capacity gets filled with a previous solution.\r\n> How?\r\n> Well, we already tried smaller capacities beforehand, so there should be a solution for that smaller, in this case remaining, capacity.\r\n>\r\n> So the idea is to split the entire knapsack problem into smaller knapsack problems.\r\n> Instead of testing 10 items with capacity 50, you first try (after the trivial case of 0) 1 item and capacity 10, 20, 30, 40 and 50 (or however many sub tasks you want to create) and then take another item and start again at capacity 10.\r\n>\r\n> If you see item 1 fits into capacity 20+, then all these slots in the table now contain this value.\r\n> Then you look at item 2 from capacity 10-50 again.\r\n> Let's assume item 2 fits into capacity 20 as well.\r\n> Then now you check whether it is a new maximum or not, and if it is, then you update the table.\r\n> Now you look at capacity 30 for item 2.\r\n> You see that item 2 fits; this means 10 capacity would remain if you take it.\r\n> However there, as of now, was no item that fits into 10 capacity, thus the solution remains the same as before.\r\n> At 40 this changes: you now realize that even if you include item 2 there are 20 capacity remaining, thus you can fill that space with the previous solution, which was item 1.\r\n> Thus for 40 capacity, as of now, the optimal solution is to take item 1 and 2.\r\n> And so on.\r\n\r\n[demystifying-the-knapsack-problem]: https://www.educative.io/blog/0-1-knapsack-problem-dynamic-solution\r\n[solving-dynamic-programming-problems]: https://www.youtube.com/watch?v=aPQY__2H3tE\r\n[0-1-knapsack-problem]: https://www.youtube.com/watch?v=cJ21moQpofY\r\n[intuition-of-dp-for-knapsack-problem]: https://www.reddit.com/r/explainlikeimfive/comments/junw6n/comment/gces429\r\n"
  },
  "starter_code": "=begin\r\nWrite your code for the 'Knapsack' exercise in this file. Make the tests in\r\n`knapsack_test.rb` pass.\r\n\r\nTo get started with TDD, see the `README.md` file in your\r\n`ruby/knapsack` directory.\r\n=end\r\n",
  "tests": "require 'minitest/autorun'\r\nrequire_relative 'knapsack'\r\n\r\nif RUBY_VERSION < '3.2.0'\r\n  class Data\r\n    def self.define(*attributes)\r\n      self\r\n    end\r\n\r\n    private\r\n    attr_writer :weight, :value\r\n\r\n    def initialize(weight:, value:)\r\n      self.weight = weight\r\n      self.value = value\r\n    end\r\n\r\n    public\r\n\r\n    attr_reader :weight, :value\r\n  end\r\nend\r\n\r\nclass KnapsackTest < Minitest::Test\r\n  Item = Data.define(:weight, :value)\r\n\r\n  def test_no_items\r\n    # skip\r\n    max_weight = 100\r\n    items = []\r\n    expected = 0\r\n    actual = Knapsack.new(max_weight).max_value(items)\r\n\r\n    assert_equal expected, actual,\r\n      \"When there are no items, the resulting value must be 0.\"\r\n  end\r\n\r\n  def test_one_item_too_heavy\r\n    skip\r\n    max_weight = 10\r\n    items = [Item.new(weight: 100, value: 1)]\r\n    expected = 0\r\n    actual = Knapsack.new(max_weight).max_value(items)\r\n\r\n    assert_equal expected, actual,\r\n      \"When there is one item that is too heavy, the resulting value must be 0.\"\r\n  end\r\n\r\n  def test_five_items_cannot_be_greedy_by_weight\r\n    skip\r\n    max_weight = 10\r\n    items = [\r\n      Item.new(weight: 2, value: 5),\r\n      Item.new(weight: 2, value: 5),\r\n      Item.new(weight: 2, value: 5),\r\n      Item.new(weight: 2, value: 5),\r\n      Item.new(weight: 10, value: 21)\r\n    ]\r\n    expected = 21\r\n    actual = Knapsack.new(max_weight).max_value(items)\r\n\r\n    assert_equal expected, actual,\r\n      \"Do not prioritize the most valuable items per weight when that would \" \\\r\n      \"result in a lower total value.\"\r\n  end\r\n\r\n  def test_five_items_cannot_be_greedy_by_value\r\n    skip\r\n    max_weight = 10\r\n    items = [\r\n      Item.new(weight: 2, value: 20),\r\n      Item.new(weight: 2, value: 20),\r\n      Item.new(weight: 2, value: 20),\r\n      Item.new(weight: 2, value: 20),\r\n      Item.new(weight: 10, value: 50)\r\n    ]\r\n    expected = 80\r\n    actual = Knapsack.new(max_weight).max_value(items)\r\n\r\n    assert_equal expected, actual,\r\n      \"Do not prioritize the items with the highest value when that would \" \\\r\n      \"result in a lower total value.\"\r\n  end\r\n\r\n  def test_example_knapsack\r\n    skip\r\n    max_weight = 10\r\n    items = [\r\n      Item.new(weight: 5, value: 10),\r\n      Item.new(weight: 4, value: 40),\r\n      Item.new(weight: 6, value: 30),\r\n      Item.new(weight: 4, value: 50)\r\n    ]\r\n    expected = 90\r\n    actual = Knapsack.new(max_weight).max_value(items)\r\n\r\n    assert_equal expected, actual,\r\n      \"A small example knapsack must result in a value of 90.\"\r\n  end\r\n\r\n  def test_eight_items\r\n    skip\r\n    max_weight = 104\r\n    items = [\r\n      Item.new(weight: 25, value: 350),\r\n      Item.new(weight: 35, value: 400),\r\n      Item.new(weight: 45, value: 450),\r\n      Item.new(weight: 5, value: 20),\r\n      Item.new(weight: 25, value: 70),\r\n      Item.new(weight: 3, value: 8),\r\n      Item.new(weight: 2, value: 5),\r\n      Item.new(weight: 2, value: 5)\r\n    ]\r\n    expected = 900\r\n    actual = Knapsack.new(max_weight).max_value(items)\r\n\r\n    assert_equal expected, actual,\r\n      \"A larger example knapsack with 8 items must result in a value of 900.\"\r\n  end\r\n\r\n  def test_fifteen_items\r\n    skip\r\n    max_weight = 750\r\n    items = [\r\n      Item.new(weight: 70, value: 135),\r\n      Item.new(weight: 73, value: 139),\r\n      Item.new(weight: 77, value: 149),\r\n      Item.new(weight: 80, value: 150),\r\n      Item.new(weight: 82, value: 156),\r\n      Item.new(weight: 87, value: 163),\r\n      Item.new(weight: 90, value: 173),\r\n      Item.new(weight: 94, value: 184),\r\n      Item.new(weight: 98, value: 192),\r\n      Item.new(weight: 106, value: 201),\r\n      Item.new(weight: 110, value: 210),\r\n      Item.new(weight: 113, value: 214),\r\n      Item.new(weight: 115, value: 221),\r\n      Item.new(weight: 118, value: 229),\r\n      Item.new(weight: 120, value: 240)\r\n    ]\r\n    expected = 1458\r\n    actual = Knapsack.new(max_weight).max_value(items)\r\n\r\n    assert_equal expected, actual,\r\n      \"A very large example knapsack with 15 items must result in a value of 1458.\"\r\n  end\r\nend\r\n"
}