{
  "language": "csharp",
  "slug": "casting",
  "title": "Casting",
  "docs": {
    "about": "# About\r\n\r\nCasting and type conversion [are different ways of changing an expression from one data type to another][wiki-casting].\r\n\r\nThe [C# documentation][type-testing-and-cast-operators] classifies type conversion as the use of the [`as` operator][as-operator] or [`is` operator][is-operator]. Casting is defined as the use of the [cast operator][cast-operator].\r\n\r\nIn C# very often, outside of the realm of numeric values and class hierarchies, you will have to make a conversion by calling some member of the \"to\" type such as [`Int32.Parse()`][int32-parse] which converts a string to an integer or by calling a member of the \"from\" type e.g. `object.ToString()`. Javascript and developers in other dynamic languages should be aware.\r\n\r\nNote that implicit an explicit cast [operators][operator-overloading] (discussed in [concept:csharp/operator-overloading]()) are available which can bring fairly arbitrary casting to your own types.\r\n\r\n## Casting Primitive Types - Implicit\r\n\r\nC#'s type system is somewhat stricter than _C_'s or Javascript's and as a consequence, casting operations are more restricted. [Implicit casting][implicit-casts] takes place between two numeric types as long as the \"to\" type can preserve the scale and sign of the \"from\" type's value. Note in the documentation the exception for converting to real numbers where precision may be lost.\r\n\r\nAn implicit cast is not signified by any special syntax. For example:\r\n\r\n```csharp\r\nint myInt = 1729;\r\nlong myLong = myInt;\r\n```\r\n\r\nThere is no implicit conversion of a numeric (or string) expression to `bool`. The Base Class Library (BCL) provides `Convert.ToBoolean()` for this purpose.\r\n\r\nAn expression of type `char` can be implicitly cast to `int`. The cast in the opposite direction must be explicit. Not all values of `int` are valid utf 16 chars.\r\n\r\n## Casting Primitive Types - Explicit\r\n\r\nWhere numeric types cannot be cast implicitly you can generally use the explicit cast [operator][cast-operator].\r\n\r\nWhere the value being cast cannot be represented by the \"to\" type because it is insufficiently wide or there is a sign conflict then an overflow exception may be thrown in the case of integers, or the \"to\" type variable may take a value of `Infinity` in the case of floats and doubles.\r\n\r\nAn expression of type `int` can be explicitly cast to `char`. This may result in an invalid `char`.\r\n\r\n## Casting Primitive Types - Examples\r\n\r\n```csharp\r\nint largeInt = Int32.MaxValue;\r\nint largeNegInt = Int32.MinValue;\r\nushort shortUnsignedInt = ushort.MaxValue;\r\nfloat largeFloat = float.MaxValue;\r\nfloat smallFloat = 17.29f;\r\n\r\n// implicit cast\r\nint from_ushort = shortUnsignedInt;          // 65535\r\nfloat from_int = largeInt;                   // -21474836E+09\r\nint from_char = 'a';                         // 96\r\n\r\n// explicit cast\r\nuint from_largeInt = (uint)largeInt;         // 2147483647\r\nuint from_neg = (uint) largeNegInt;          // 2147483648 or OverflowException is thrown (if checked)\r\nint from_smallFloat = (int) smallFloat;      // 17\r\nint from_largeFloat = (int) largeFloat;      // -2147483648 or OverflowException is thrown (if checked)\r\nchar from_intc = (char) 32;                  // ' '\r\nchar from_invalid_int = (char) 0xdcbf;       // invalid char - no exception thrown\r\n\r\n// no cast available\r\nint fromString = Int32.Parse(\"42\");          // 42\r\nstring toString = largeInt.ToString();       // \"2147483647\"\r\nint fromString_bad = Int32.Parse(\"forty two\");     // FormatException is thrown\r\n```\r\n\r\nSee this [article][checked] for the _**checked**_ keyword.\r\n\r\n## Type Conversion for types in a hierarchy\r\n\r\nAny type can be implicitly converted to its base class or interface.\r\n\r\n```csharp\r\nIList<int> ll = new List<int>();\r\n```\r\n\r\nA cast operator can be used to convert from a base to a derived class.\r\n\r\n```csharp\r\nIList<int> ll = new List<int>();\r\nList<int> l = (List<int>)ll;\r\n```\r\n\r\nIf the cast fails because the type of the expression being cast is not related to the type it is being cast to an instance of `InvalidCastException` is thrown.\r\n\r\nA more usual approach to these type conversions is to use the [`is`][is-operator] keyword:\r\n\r\n```csharp\r\ninterface IFoo { int Bar(); }\r\nclass Foo : IFoo { public int Bar() { return 42; }}\r\nObject r = new Random();\r\nIFoo ifoo = new Foo();\r\nObject o = new Foo();\r\n\r\nint result = 1729;\r\n\r\nif (ifoo is Foo foo)\r\n{\r\n    result = foo.Bar();\r\n}\r\n// result == 42\r\n\r\nresult = 1729;\r\nif (o is Foo foo2)\r\n{\r\n    result = foo2.Bar();\r\n}\r\n// result == 42\r\n\r\nresult = 1729;\r\nif (r is Foo foo3)\r\n{\r\n    result = foo3.Bar();\r\n}\r\n// result == 1729\r\n```\r\n\r\nThe [`as`][as-operator] keyword fulfills a similar function to `is` e.g. `var foo = ifoo as Foo;`. In this example `foo` will be `null` if `ifoo` is not of type `Foo` otherwise `ifoo` will be assigned to it.\r\n\r\n## Custom Cast Operator\r\n\r\nTypes can define their own custom explicit and implicit [cast operators][custom-casts].\r\n\r\nExamples of [explicit][big-integer-explicit] and [implicit][big-integer-implicit] casts in the BCL is conversions from the `BigInteger` struct to and from other numeric types\r\n\r\n## Using `typeof`\r\n\r\nIf you need to detect the precise type of an object then `is` may be a little too permissive as it will convert an object to a class or any of its base classes. `typeof` and `Object.GetType()` are the solution in this case.\r\n\r\n```csharp\r\nobject o = new List<int>();\r\n\r\no is ICollection<int> // true\r\no.GetType() == typeof(ICollection<int>) // false\r\no is List<int> // true\r\no.GetType() == typeof(List<int>) // true\r\n```\r\n\r\n[type-testing-and-cast-operators]: https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/operators/type-testing-and-cast\r\n[is-operator]: https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/operators/type-testing-and-cast#is-operator\r\n[as-operator]: https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/operators/type-testing-and-cast#as-operator\r\n[cast-operator]: https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/operators/type-testing-and-cast#cast-expression\r\n[typeof-operator]: https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/operators/type-testing-and-cast#typeof-operator\r\n[type-conversion-exceptions]: https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/types/casting-and-type-conversions#type-conversion-exceptions-at-run-time\r\n[wiki-casting]: https://en.wikipedia.org/wiki/Type_conversion\r\n[implicit-casts]: https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/builtin-types/numeric-conversions\r\n[explicit-casts]: https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/builtin-types/numeric-conversions#explicit-numeric-conversions\r\n[int32-parse]: https://docs.microsoft.com/en-us/dotnet/api/system.int32.parse\r\n[operator-overloading]: https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/operators/operator-overloading\r\n[checked]: https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/keywords/checked\r\n[custom-casts]: https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/operators/user-defined-conversion-operators\r\n[big-integer-implicit]: https://docs.microsoft.com/en-us/dotnet/api/system.numerics.biginteger.op_implicit\r\n[big-integer-explicit]: https://docs.microsoft.com/en-us/dotnet/api/system.numerics.biginteger.op_explicit\r\n",
    "introduction": "# Introduction\r\n\r\nCasting and type conversion are different ways of changing an expression from one data type to another.\r\n\r\nAn expression can be cast to another type with the cast operator `(<type>)`.\r\n\r\n```csharp\r\nlong l = 1000L;\r\nint i = (int)l;\r\n\r\nobject o = new Random();\r\nRandom r = (Random)o;\r\n```\r\n\r\nIf the types are not compatible an instance of `InvalidCastException` is thrown. In the case of numbers this indicates that the receiving type cannot represent the cast value. In the case of classes, one of the types must be derived from the other (this also applies trivially to structs).\r\n\r\nAn alternative to _casting_ is _type conversion_ using the `is` operator. This is typically applied to reference and nullable types.\r\n\r\n```csharp\r\nobject o = new Random();\r\nif (o is Random rand)\r\n{\r\n    int ii = rand.Next();\r\n    // now, do something random\r\n}\r\n```\r\n\r\nIf you need to detect the precise type of an object then `is` may be a little too permissive as it will return true for a class and any of the classes and interfaces from which it is derived directly or indirectly. `typeof` and `Object.GetType()` are the solution in this case.\r\n\r\n```csharp\r\nobject o = new List<int>();\r\n\r\no is ICollection<int> // true\r\no.GetType() == typeof(ICollection<int>) // false\r\no is List<int> // true\r\no.GetType() == typeof(List<int>) // true\r\n```\r\n"
  },
  "links": [
    {
      "url": "https://en.wikipedia.org/wiki/Type_conversion",
      "description": "wiki-casting"
    },
    {
      "url": "https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/operators/type-testing-and-cast",
      "description": "type-testing-and-cast-operators"
    },
    {
      "url": "https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/operators/type-testing-and-cast#as-operator",
      "description": "as-operator"
    },
    {
      "url": "https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/operators/type-testing-and-cast#is-operator",
      "description": "is-operator"
    },
    {
      "url": "https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/operators/type-testing-and-cast#cast-expression",
      "description": "cast-operator"
    },
    {
      "url": "https://docs.microsoft.com/en-us/dotnet/api/system.int32.parse?view=netcore-3.1",
      "description": "int32-parse"
    },
    {
      "url": "https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/operators/operator-overloading",
      "description": "operator-overloading"
    },
    {
      "url": "https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/builtin-types/numeric-conversions",
      "description": "implicit-casts"
    },
    {
      "url": "https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/keywords/checked",
      "description": "checked"
    },
    {
      "url": "https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/operators/user-defined-conversion-operators",
      "description": "custom-casts"
    },
    {
      "url": "https://docs.microsoft.com/en-us/dotnet/api/system.numerics.biginteger.op_explicit?view=netcore-3.1",
      "description": "big-integer-explicit"
    },
    {
      "url": "https://docs.microsoft.com/en-us/dotnet/api/system.numerics.biginteger.op_implicit?view=netcore-3.1",
      "description": "big-integer-implicit"
    },
    {
      "url": "https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/operators/type-testing-and-cast",
      "description": "type-testing-and-cast-operators"
    },
    {
      "url": "https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/operators/type-testing-and-cast#typeof-operator",
      "description": "typeof-operator"
    },
    {
      "url": "https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/types/casting-and-type-conversions#type-conversion-exceptions-at-run-time",
      "description": "type-conversion-exceptions"
    }
  ]
}