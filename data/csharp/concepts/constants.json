{
  "language": "csharp",
  "slug": "constants",
  "title": "Constants",
  "docs": {
    "about": "# About\r\n\r\n## const\r\n\r\nThe [`const`][constants] modifier can be (and generally should be) applied to any field where its value is known at compile time and will not change during the lifetime of the program.\r\n\r\n```csharp\r\nprivate const int num = 1729;\r\npublic const string title = \"Grand\" + \" Master\";\r\n```\r\n\r\nThe compiler will guide you as to what expressions can be evaluated at compile-time. Simple arithmetic operations are allowed as is string concatenation. This excludes any evaluation that would require use of the heap or stack so all method calls and references to non-primitive types are not available.\r\n\r\nThere is some discussion on the web about the performance advantages of `const` over variables. In the case of a comparison with instance non-const fields there could be a noticeable saving in memory but compared to static variables that is decidedly trivial. Any consideration of CPU performance is likely to be seen by your colleagues as [premature optimization][premature-optimization].\r\n\r\nA more compelling reason to use `const` is that it enhances a maintainer's ability to reason about the code. Glimpsing that a field is marked as `const` or `readonly` or that a property has no setter allows the maintainer largely to dismiss it from their analysis. It is unlikely to be the seat of bugs. It is unlikely to pose difficulties in a refactoring exercise. This [Stack Overflow comment][so-consts] addresses this.\r\n\r\nThe `const` modifier can also be applied to values within methods:\r\n\r\n```csharp\r\npublic double Area(double r)\r\n{\r\n    const double π = 3.142;\r\n    return System.Math.Pow((π * r), 2);\r\n}\r\n```\r\n\r\nIdentifying a value with `const` in this way can be useful if it is used multiple times in the method or you want to draw attention to its meaning. There is no performance gain over using literals inline.\r\n\r\n## readonly\r\n\r\nThe [`readonly`][readonly-fields] modifier can be (and generally should be) applied to any field that cannot be made `const` where its value will not change during the lifetime of the program and is either set by an inline initializer or during instantiation (by the constructor or a method called by the constructor).\r\n\r\n```csharp\r\nprivate readonly int num;\r\nprivate readonly System.Random rand = new System.Random();\r\n\r\npublic MyClass(int num)\r\n{\r\n    this.num = num;\r\n}\r\n```\r\n\r\nUse of the `readonly` modifier is encouraged for the same reasons that apply to `const`. The practice of constraining fields in this way helps maintainers reason about the code.\r\n\r\nNote that adding the `readonly` modifier to a field prevents only the value of the field from being changed. In the case of aggregate types it does not protect the fields or properties of that type. In particular, it does not protect the contents of arrays.\r\n\r\n```csharp\r\nprivate readonly IList list = new List();\r\n\r\npublic void Foo()\r\n{\r\n    list = new List();  // does not compile\r\n\r\n    list.Add(\"new stuff\");  // succeeds at runtime\r\n}\r\n```\r\n\r\nTo ensure that all members of a reference type are protected the fields can be made `readonly` and automatic properties can be defined without a `set` accessor.\r\n\r\nYou should examine [read-only collections][readonly-collections] in the Base Class Library.\r\n\r\nFor arrays the closest you can get to a read-only version is the [`Array.AsReadOnly<T>()`][as-read-only] method.\r\n\r\n[readonly-fields]: https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/keywords/readonly#readonly-field-example\r\n[constants]: https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/classes-and-structs/constants\r\n[so-consts]: https://stackoverflow.com/a/5834473/96167\r\n[premature-optimization]: https://wiki.c2.com/?PrematureOptimization\r\n[as-read-only]: https://docs.microsoft.com/en-us/dotnet/api/system.array.asreadonly\r\n[readonly-collections]: https://docs.microsoft.com/en-us/dotnet/api/system.collections.objectmodel.readonlycollection-1\r\n",
    "introduction": "# Introduction\r\n\r\nThe `const` modifier can be (and generally should be) applied to any field where its value is known at compile time and will not change during the lifetime of the program.\r\n\r\n```csharp\r\nprivate const int num = 1729;\r\npublic const string title = \"Grand\" + \" Master\";\r\n```\r\n\r\nThe `readonly` modifier can be (and generally should be) applied to any field that cannot be made `const` where its value will not change during the lifetime of the program and is either set by an inline initializer or during instantiation (by the constructor or a method called by the constructor).\r\n\r\n```csharp\r\nprivate readonly int num;\r\nprivate readonly System.Random rand = new System.Random();\r\n\r\npublic MyClass(int num)\r\n{\r\n    this.num = num;\r\n}\r\n```\r\n"
  },
  "links": [
    {
      "url": "https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/classes-and-structs/constants",
      "description": "constants"
    },
    {
      "url": "https://wiki.c2.com/?PrematureOptimization",
      "description": "premature-optimization"
    },
    {
      "url": "https://stackoverflow.com/a/5834473/96167",
      "description": "so-consts"
    },
    {
      "url": "https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/keywords/readonly#readonly-field-example",
      "description": "readonly-fields"
    },
    {
      "url": "https://docs.microsoft.com/en-us/dotnet/api/system.collections.objectmodel.readonlycollection-1?view=netcore-3.1",
      "description": "readonly-collections"
    },
    {
      "url": "https://docs.microsoft.com/en-us/dotnet/api/system.array.asreadonly?view=netcore-3.1",
      "description": "as-read-only"
    }
  ]
}