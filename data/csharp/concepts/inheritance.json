{
  "language": "csharp",
  "slug": "inheritance",
  "title": "Inheritance",
  "docs": {
    "about": "# About\r\n\r\nIn C#, a _class_ hierarchy can be defined using _inheritance_, which allows a derived class (`Car`) to inherit the behavior and data of its parent class (`Vehicle`). If no parent is specified, the class inherits from the `object` class.\r\n\r\nParent classes can provide functionality to derived classes in three ways:\r\n\r\n- Define a regular method.\r\n- Define a [`virtual` method][virtual-keyword], which is like a regular method but one that derived classes _can_ change.\r\n- Define an [`abstract` method][abstract-keyword], which is a method without an implementation that derived classes _must_ implement. A class with `abstract` methods must be marked as [`abstract`][abstract-classes] too. Abstract classes cannot be instantiated.\r\n\r\nThe [`protected` access modifier][protected-keyword] allows a parent class member to be accessed in a derived class, but blocks access from other classes. Derived classes thus can access `public` and `protected` parent class members, but not `private` parent class members.\r\n\r\nDerived classes can access parent class members through the [`base` keyword][base-keyword].\r\n\r\n```csharp\r\n// Inherits from the 'object' class\r\nabstract class Vehicle\r\n{\r\n    // Can be overridden\r\n    public virtual void Drive()\r\n    {\r\n    }\r\n\r\n    // Must be overridden\r\n    protected abstract int Speed();\r\n}\r\n\r\n// Cannot be inherited from\r\nsealed class Car : Vehicle\r\n{\r\n    public override void Drive()\r\n    {\r\n        // Override virtual method\r\n\r\n        // Call parent implementation\r\n        base.Drive();\r\n    }\r\n\r\n    protected override int Speed()\r\n    {\r\n        // Implement abstract method\r\n    }\r\n}\r\n```\r\n\r\nThe constructor of a derived class will [automatically call its parent's constructor][constructors] _before_ executing its own constructor's logic. Arguments can be passed to a parent class' constructor using the [`base` keyword][base-keyword-constructor]. As abstract classes cannot be instantiated, their constructors can be made `protected`.\r\n\r\n```csharp\r\nabstract class Vehicle\r\n{\r\n    protected Vehicle(int wheels)\r\n    {\r\n        Console.WriteLine(\"Called first\");\r\n    }\r\n}\r\n\r\nclass Car : Vehicle\r\n{\r\n    public Car() : base(4)\r\n    {\r\n        Console.WriteLine(\"Called second\");\r\n    }\r\n}\r\n```\r\n\r\nWhere more than one class is derived from a base class the two (or more) sub-classes will often implement different versions of a base class method. This is a very important principle called [polymorphism][polymorphism]. For instance in a variation on the above example we show how code using `Vehicle` can change its behavior depending on what type of vehicle has been instantiated.\r\n\r\n```csharp\r\nabstract class Vehicle\r\n{\r\n   public abstract string GetDescription();\r\n}\r\n\r\nclass Car : Vehicle\r\n{\r\n   public Car()\r\n   {\r\n   }\r\n\r\n   public override string GetDescription()\r\n   {\r\n      return \"Runabout\";\r\n   }\r\n}\r\n\r\nclass Rig : Vehicle\r\n{\r\n   public Rig()\r\n   {\r\n   }\r\n\r\n   public override string GetDescription()\r\n   {\r\n      return \"Big Rig\";\r\n   }\r\n}\r\n\r\nVehicle v1 = new Car();\r\nVehicle v2 = new Rig();\r\n\r\nv1.GetDescription();\r\n// => Runabout\r\nv2.GetDescription();\r\n// => Big Rig\r\n```\r\n\r\nTo prevent a class being inherited, add the [`sealed` modifier][sealed-classes].\r\nSome practitioners try to avoid inheriting from concrete classes (as discussed in [this SO question][pro-sealed]) and the _sealed_ modifier supports this approach. On the other hand many C# developers consider them a hindrance to maintenance as discussed in some of the comments on [this question][anti-sealed]. The advice is to use the sealed modifier sparingly until you have gained confidence in their use for your requirements.\r\n\r\nThe following [article][new-vs-override] describes `new` as an alternative to the `override` modifier. This is occasionally useful, perhaps with convoluted class hierarchies and/or some sort of clash of libraries.\r\n\r\n[abstract-keyword]: https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/keywords/abstract\r\n[virtual-keyword]: https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/keywords/virtual\r\n[override-keyword]: https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/keywords/override\r\n[base-keyword]: https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/keywords/base\r\n[base-keyword-constructor]: https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/keywords/base#example-1\r\n[protected-keyword]: https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/keywords/protected\r\n[sealed-keyword]: https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/keywords/sealed\r\n[constructors]: https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/classes-and-structs/using-constructors\r\n[abstract-classes]: https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/classes-and-structs/abstract-and-sealed-classes-and-class-members#abstract-classes-and-class-members\r\n[sealed-classes]: https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/classes-and-structs/abstract-and-sealed-classes-and-class-members#sealed-classes-and-class-members\r\n[pro-sealed]: https://stackoverflow.com/questions/16724946/why-derive-from-a-concrete-class-is-a-poor-design\r\n[anti-sealed]: https://stackoverflow.com/questions/7777611/when-and-why-would-you-seal-a-class\r\n[new-vs-override]: https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/classes-and-structs/knowing-when-to-use-override-and-new-keywords\r\n[polymorphism]: https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/classes-and-structs/polymorphism\r\n",
    "introduction": "# Introduction\r\n\r\nIn C#, a _class_ hierarchy can be defined using _inheritance_, which allows a derived class (`Car`) to inherit the behavior and data of its parent class (`Vehicle`). If no parent is specified, the class inherits from the `object` class.\r\n\r\nParent classes can provide functionality to derived classes in three ways:\r\n\r\n- Define a regular method.\r\n- Define a `virtual` method, which is like a regular method but one that derived classes _can_ change.\r\n- Define an `abstract` method, which is a method without an implementation that derived classes _must_ implement. A class with `abstract` methods must be marked as `abstract` too. Abstract classes cannot be instantiated.\r\n\r\nThe `protected` access modifier allows a parent class member to be accessed in a derived class, but blocks access from other classes.\r\n\r\nDerived classes can access parent class members through the `base` keyword.\r\n\r\n```csharp\r\n// Inherits from the 'object' class\r\nabstract class Vehicle\r\n{\r\n    // Can be overridden\r\n    public virtual void Drive()\r\n    {\r\n    }\r\n\r\n    // Must be overridden\r\n    protected abstract int Speed();\r\n}\r\n\r\nclass Car : Vehicle\r\n{\r\n    public override void Drive()\r\n    {\r\n        // Override virtual method\r\n\r\n        // Call parent implementation\r\n        base.Drive();\r\n    }\r\n\r\n    protected override int Speed()\r\n    {\r\n        // Implement abstract method\r\n    }\r\n}\r\n```\r\n\r\nThe constructor of a derived class will automatically call its parent's constructor _before_ executing its own constructor's logic. Arguments can be passed to a parent class' constructor using the `base` keyword:\r\n\r\n```csharp\r\nabstract class Vehicle\r\n{\r\n    protected Vehicle(int wheels)\r\n    {\r\n        Console.WriteLine(\"Called first\");\r\n    }\r\n}\r\n\r\nclass Car : Vehicle\r\n{\r\n    public Car() : base(4)\r\n    {\r\n        Console.WriteLine(\"Called second\");\r\n    }\r\n}\r\n```\r\n\r\nWhere more than one class is derived from a base class the two (or more) classes will often implement different versions of a base class method. This is a very important principle called polymorphism. For instance in a variation on the above example we show how code using `Vehicle` can change its behavior depending on what type of vehicle has been instantiated.\r\n\r\n```csharp\r\nabstract class Vehicle\r\n{\r\n   public abstract string GetDescription();\r\n}\r\n\r\nclass Car : Vehicle\r\n{\r\n   public Car()\r\n   {\r\n   }\r\n\r\n   public override string GetDescription()\r\n   {\r\n      return \"Runabout\";\r\n   }\r\n}\r\n\r\nclass Rig : Vehicle\r\n{\r\n   public Rig()\r\n   {\r\n   }\r\n\r\n   public override string GetDescription()\r\n   {\r\n      return \"Big Rig\";\r\n   }\r\n}\r\n\r\nVehicle v1 = new Car();\r\nVehicle v2 = new Rig();\r\n\r\nv1.GetDescription();\r\n// => Runabout\r\nv2.GetDescription();\r\n// => Big Rig\r\n```\r\n"
  },
  "links": [
    {
      "url": "https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/keywords/virtual",
      "description": "virtual-keyword"
    },
    {
      "url": "https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/keywords/abstract",
      "description": "abstract-keyword"
    },
    {
      "url": "https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/classes-and-structs/abstract-and-sealed-classes-and-class-members#abstract-classes-and-class-members",
      "description": "abstract-classes"
    },
    {
      "url": "https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/keywords/protected",
      "description": "protected-keyword"
    },
    {
      "url": "https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/keywords/base",
      "description": "base-keyword"
    },
    {
      "url": "https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/classes-and-structs/using-constructors",
      "description": "constructors"
    },
    {
      "url": "https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/keywords/base#example-1",
      "description": "base-keyword-constructor"
    },
    {
      "url": "https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/classes-and-structs/abstract-and-sealed-classes-and-class-members#sealed-classes-and-class-members",
      "description": "sealed-classes"
    },
    {
      "url": "https://stackoverflow.com/questions/16724946/why-derive-from-a-concrete-class-is-a-poor-design",
      "description": "pro-sealed"
    },
    {
      "url": "https://stackoverflow.com/questions/7777611/when-and-why-would-you-seal-a-class",
      "description": "anti-sealed"
    }
  ]
}