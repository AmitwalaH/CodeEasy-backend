{
  "language": "csharp",
  "slug": "interfaces",
  "title": "Interfaces",
  "docs": {
    "about": "# About\r\n\r\n[`interfaces`][interfaces] are the primary means of [decoupling][wiki-loose-coupling] the uses of a class from its implementation. This decoupling provides flexibility for maintenance of the implementation and helps support type safe generic behavior.\r\n\r\nThe syntax of an interface is similar to that of a class or struct except that methods and properties appear as the signature only and no body is provided.\r\n\r\n```csharp\r\npublic interface ILanguage\r\n{\r\n    string Speak();\r\n}\r\n\r\npublic interface IItalianLanguage : ILanguage\r\n{\r\n    string Speak();\r\n    string SpeakItalian();\r\n}\r\n\r\npublic interface IScriptConverter\r\n{\r\n    string Version { get; set; }\r\n    string ConvertCyrillicToLatin(string cyrillic);\r\n}\r\n```\r\n\r\nThe implementing class or struct must implement all operations defined by the interface.\r\n\r\nInterfaces typically do one or more of the following:\r\n\r\n- allow a number of different classes to be treated generically by the using code. In this case interfaces are playing the same role as a base class\r\n- expose a subset of functionality for some specific purpose (such as [`IComparable<T>`][icomparable]) or\r\n- expose the public API of a class so that multiple implementations can co-exist. One example is that of a [test double][wiki-test-double]\r\n\r\n```csharp\r\npublic class ItalianTraveller : IItalianLanguage\r\n{\r\n    public string Speak()\r\n    {\r\n        return \"Ciao mondo\";\r\n    }\r\n\r\n    public string SpeakItalian()\r\n    {\r\n        return Speak();\r\n    }\r\n}\r\n\r\npublic class ItalianTravellerV2 : IItalianLanguage\r\n{\r\n    public string Speak()\r\n    {\r\n        return \"migliorata - Ciao mondo\";\r\n    }\r\n\r\n    public string SpeakItalian()\r\n    {\r\n        return Speak();\r\n    }\r\n}\r\n\r\npublic class FrenchTraveller : ILanguage\r\n{\r\n    public string Speak()\r\n    {\r\n        return \"Ça va?\";\r\n    }\r\n}\r\n\r\npublic class RussianTraveller : ILanguage, IScriptConverter\r\n{\r\n    public string Version { get; set; } = \"1.0\";\r\n\r\n    public string Speak()\r\n    {\r\n        return \"Привет мир\";\r\n    }\r\n\r\n    public string ConvertCyrillicToLatin(string cyrillic)\r\n    {\r\n        throw new NotImplementedException();\r\n    }\r\n}\r\n\r\npublic class DocumentTranslator : IScriptConverter\r\n{\r\n    public string Version { get; set; } = \"1.0\";\r\n\r\n    public string Translate(string russian)\r\n    {\r\n        throw new NotImplementedException();\r\n    }\r\n\r\n    public string ConvertCyrillicToLatin(string cyrillic)\r\n    {\r\n        throw new NotImplementedException();\r\n    }\r\n}\r\n```\r\n\r\nCode which uses the above interfaces and classes can:\r\n\r\n- treat all speakers in the same way irrespective of language.\r\n- allow some subsystem handling script conversion to operate without caring about what specific types it is dealing with.\r\n- remain unaware of the changes to the italian speaker which is convenient if the class code and user code are maintained by different teams\r\n\r\nInterfaces are widely used to support testing as they allow for easy [mocking][so-mocking-interfaces].\r\n\r\nSee this [article][dt-interfaces] for details of what types of member can be included in an interface.\r\n\r\nInterfaces can inherit from other interfaces.\r\n\r\nMembers of an interface are public by default.\r\n\r\nInterfaces can contain nested types, such as `const` literals, `enums`, `delegates`, `classes` and `structs`. Here, the interfaces act as [namespaces][wiki-namespaces] in the same way that classes and structs do and the behavior and syntax is identical.\r\n\r\nBy design, C# does not support multiple inheritance, but it facilitates a kind of multiple inheritance through interfaces.\r\n\r\nMoreover, the concept of [polymorphism can be implemented through interfaces][interface-polymorphism] underpins the interface mechanism.\r\n\r\n## Explicit interface implementation\r\n\r\nSometimes method names and signatures can be shared in two different interfaces.\r\nIn order provide a distinct implementation of these methods, C# provides [explicit implementation of interfaces][explicit-implementation]. Note that to use a particular implementation of an interface you need to convert the expression containing referencing the object to that interface. Assignment, casting or passing as a parameter will achieve this.\r\n\r\n```csharp\r\npublic interface IFoo\r\n{\r\n    void X();\r\n}\r\n\r\npublic interface IBar\r\n{\r\n    void X();\r\n}\r\n\r\npublic class Census : IFoo, IBar\r\n{\r\n    void IFoo.X()\r\n    {\r\n        Console.Write(\"This is from Foo\");\r\n    }\r\n\r\n    void IBar.X()\r\n    {\r\n        Console.Write(\"This is from Bar\");\r\n    }\r\n}\r\n\r\npublic class User\r\n{\r\n    public void Use()\r\n    {\r\n        IFoo foo = new Census();\r\n        IBar bar = new Census();\r\n        foo.X();\r\n        // => \"This is from Foo\"\r\n        bar.X();\r\n        // => \"This is from Bar\"\r\n    }\r\n}\r\n```\r\n\r\nThere are a number of use cases:\r\n\r\n- A clash of domains (as illustrated above) where methods have identical signatures.\r\n- Methods with the same name but different return types: if you implement your own collection classes you may find that an explicit interface for the legacy `IEnumerable.GetEnumerator()`, alongside `IEnumerable<T>.GetEnuerator()`, is required. You may never make use of such the interface but the compiler may insist.\r\n- Methods where there is no clash of names between interfaces but it is desirable that the implementing class uses the name for some related purpose: `IFormattable` has a `ToString()` method which takes a _format type_ parameter as well as parameter of type `IFormatProvider`. A class like `FormattableString` from the Base Class Library (BCL) has the interface to ensure it can be used by routines that take an `IFormattable` but it is more expressive for its main version of `ToString(IFormatProvider)` to omit the _format type_ parameter as it is not used in the implementation and would confuse API users.\r\n\r\n## Default implementation\r\n\r\nVersion 8 of C# addresses a nagging problem with APIs. If you add methods to an interface to enhance functionality for new implementations then it is necessary to modify all the existing implementations of the interface so that they comply with the API-contract even though they have no implementation specific behavior. C# now allows for a _default method_ to be provided as part of the interface (Java developers will be familiar). Previously, when such a change occurred a _version 2_ of the interface would exist alongside the original.\r\n\r\nThis [article][dt-interfaces] is an excellent primer on interfaces and focuses on _default implementation_ and other supporting innovations such as `static`, `private` and `virtual` members.\r\n\r\n[interface-polymorphism]: https://www.cs.utexas.edu/~mitra/csSummer2013/cs312/lectures/interfaces.html\r\n[explicit-implementation]: https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/interfaces/explicit-interface-implementation\r\n[so-mocking-interfaces]: https://stackoverflow.com/a/9226437/96167\r\n[icomparable]: https://docs.microsoft.com/en-us/dotnet/api/system.icomparable-1\r\n[wiki-test-double]: https://en.wikipedia.org/wiki/Test_double\r\n[wiki-polymorphism]: https://en.wikipedia.org/wiki/Polymorphism_(computer_science)\r\n[wiki-namespaces]: https://en.wikipedia.org/wiki/Namespace\r\n[dt-interfaces]: https://www.talkingdotnet.com/default-implementations-in-interfaces-in-c-sharp-8/\r\n[wiki-loose-coupling]: https://en.wikipedia.org/wiki/Loose_coupling\r\n[interfaces]: https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/interfaces/\r\n",
    "introduction": "# Introduction\r\n\r\nAn interface is a type containing members defining a group of related functionality. It distances the uses of a class from the implementation allowing multiple different implementations or support for some generic behavior such as formatting, comparison or conversion.\r\n\r\nThe syntax of an interface is similar to that of a class or struct except that methods and properties appear as the signature only and no body is provided.\r\n\r\n```csharp\r\npublic interface ILanguage\r\n{\r\n    string LanguageName { get; set; }\r\n    string Speak();\r\n}\r\n\r\npublic class ItalianTaveller : ILanguage, ICloneable\r\n{\r\n    public string LanguageName { get; set; } =  \"Italiano\";\r\n\r\n    public string Speak()\r\n    {\r\n        return \"Ciao mondo\";\r\n    }\r\n\r\n    public object Clone()\r\n    {\r\n        ItalianTaveller it = new ItalianTaveller();\r\n        it.LanguageName = this.LanguageName;\r\n        return it;\r\n    }\r\n}\r\n```\r\n\r\nAll operations defined by the interface must be implemented.\r\n\r\nInterfaces can contain instance methods and properties amongst other members\r\n"
  },
  "links": [
    {
      "url": "https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/interfaces/",
      "description": "interfaces"
    },
    {
      "url": "https://en.wikipedia.org/wiki/Loose_coupling",
      "description": "wiki-loose-coupling"
    },
    {
      "url": "https://docs.microsoft.com/en-us/dotnet/api/system.icomparable-1?view=netcore-3.1",
      "description": "icomparable"
    },
    {
      "url": "https://en.wikipedia.org/wiki/Test_double",
      "description": "wiki-test-double"
    },
    {
      "url": "https://stackoverflow.com/a/9226437/96167",
      "description": "so-mocking-interfaces"
    },
    {
      "url": "https://www.talkingdotnet.com/default-implementations-in-interfaces-in-c-sharp-8/",
      "description": "dt-interfaces"
    },
    {
      "url": "https://en.wikipedia.org/wiki/Namespace",
      "description": "wiki-namespaces"
    },
    {
      "url": "https://www.cs.utexas.edu/~mitra/csSummer2013/cs312/lectures/interfaces.html",
      "description": "interface-polymorphism"
    },
    {
      "url": "https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/interfaces/explicit-interface-implementation",
      "description": "explicit-implementation"
    }
  ]
}