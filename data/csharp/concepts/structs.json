{
  "language": "csharp",
  "slug": "structs",
  "title": "Structs",
  "docs": {
    "about": "# About\r\n\r\nC# `struct`s are closely related to `class`es.\r\nThey have state and behavior.\r\nThey can have the same kinds of members: constructors, methods, fields, properties, etc.\r\n\r\nFields and properties can be simple types, `struct`s or reference types.\r\n`struct`s observe the same rules about scope, read/write rules and access levels as do `class`es.\r\n\r\n```csharp\r\nenum Unit\r\n{\r\n    Kg,\r\n    Lb\r\n}\r\n\r\nstruct Weight\r\n{\r\n    private double count;\r\n    private Unit unit;\r\n\r\n    public Weight(double count, Unit unit)\r\n    {\r\n        this.count = count;\r\n        this.unit = unit;\r\n    }\r\n\r\n    public override string ToString()\r\n    {\r\n        return count.ToString() + unit.ToString();\r\n    }\r\n}\r\n\r\nnew Weight(77.5, Unit.Kg).ToString();\r\n// => \"77.6Kg\"\r\n```\r\n\r\nOne of the main things to remember is that when one struct is assigned to a variable or passed as a parameter the values are copied across so changes to the original variable will not affect the copied one and vice versa.\r\nIn summary, `struct`s are **value types**.\r\n\r\nThis [article][class-or-struct] discusses the differences between `struct`s and `class`es.\r\nYou will see from the article that `struct`s tend to be lightweight and [immutable][structs-immutable] although this guidance is not enforced (by default) by the compiler or runtime.\r\n\r\nThere are a couple of things that you will come up against (and about which the compiler will remind you):\r\n\r\n1. Members of a `struct` cannot be initialized inline.\r\n2. A `struct` cannot be inherited\r\n3. A `struct` always has a default constructor even if a non-default one is provided, and you cannot provide an explicit parameterless constructor.\r\n\r\nAs a result of points 1 and 3 above there is no way for the developer of a `struct` to prevent invalid instances from coming into existence.\r\n\r\n## Common structs\r\n\r\nYou will see from the documentation that there is a close relationship between primitives and structs.\r\nSee [`Int32/int`][int32], for an example.\r\nA more conventional example of a`struct`is the type [`TimeSpan`][time-span].\r\n\r\nInstances of `TimeSpan` behave much like numbers with comparison operators like `>` and `<` and arithmetic operators.\r\nYou can implement these operators for your own `struct`s when you need them.\r\n\r\nOne thing to note about `TimeSpan` is that it implements a number of interfaces e.g. `IComparable<TimeSpan>`.\r\nAlthough `struct`s cannot be derived from other `struct`s they can implement interfaces.\r\n\r\n## Equality\r\n\r\nEquality testing for `struct`s can often be much simpler than that for `class`es as it simply compares fields for equality by default.\r\nThere is no need to override `object.Equals()` (or `GetHashCode()`).\r\nRemember that if you are relying on `Object.GetHashCode()` you must still ensure that the fields involved in generating the hash code (i.e. all the fields) must not change while a hashed collection is use.\r\nEffectively, this means that structs used in this way should be immutable.\r\n\r\nIn contrast to the method, `Equals()`, there is no default implementation of the equality operators, `==` and `!=`.\r\nIf your `struct` needs them then you will have to implement them.\r\n\r\nOn the other hand, this [article][equality] describes how performance can be optimised by creating your own custom `Equals()` and `GetHashCode()` method as is often done with `class`es.\r\nThe difference in the case of this exercise was about 20% in a not very rigorous comparison but that may be on the low side because all the fields are of the same type - see below.\r\n\r\nThere are discussions on the [web][equality-performance] about speed improvements, where the `Equals()` method is not overridden, if all fields are of the same type.\r\nThe difference in this exercise of including disparate fields was about 60%.\r\nThis is not mentioned in Microsoft's documentation so that makes it an un-documented implementation detail, and it should be exploited judiciously.\r\n\r\n```csharp\r\npublic bool Equals(Weight other)\r\n{\r\n    return count.Equals(other.count) && unit.Equals(other.unit);\r\n}\r\n\r\npublic override bool Equals(object obj)\r\n{\r\n    return obj is Weight other && Equals(other);\r\n}\r\n\r\npublic override int GetHashCode()\r\n{\r\n    return HashCode.Combine(count, unit);\r\n}\r\n```\r\n\r\n## General\r\n\r\n- [structs][structs]: introduction to structs.\r\n- [class-or-struct][class-or-struct]: lists the guidelines for choosing between a struct and class.\r\n\r\n[structs-immutable]: https://stackoverflow.com/a/3753640/96167\r\n[date-time]: https://docs.microsoft.com/en-us/dotnet/api/system.datetime\r\n[operators]: https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/operators/operator-overloading\r\n[equality]: https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/statements-expressions-operators/how-to-define-value-equality-for-a-type\r\n[equality-performance]: https://medium.com/@semuserable/c-journey-into-struct-equality-comparison-deep-dive-9693f74562f1\r\n[structs]: https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/builtin-types/struct\r\n[class-or-struct]: https://docs.microsoft.com/en-us/dotnet/standard/design-guidelines/choosing-between-class-and-struct\r\n[int32]: https://docs.microsoft.com/en-us/dotnet/api/system.int32\r\n[time-span]: https://docs.microsoft.com/en-us/dotnet/api/system.timespan\r\n",
    "introduction": "# Introduction\r\n\r\nC# `struct`s are closely related to `class`es.\r\nThey have state and behavior.\r\nThey have constructors that take arguments, instances can be assigned, tested for equality and stored in collections.\r\n\r\n```csharp\r\nenum Unit\r\n{\r\n    Kg,\r\n    Lb\r\n}\r\nstruct Weight\r\n{\r\n    private double count;\r\n    private Unit unit;\r\n\r\n    public Weight(double count, Unit unit)\r\n    {\r\n        this.count = count;\r\n        this.unit = unit;\r\n    }\r\n\r\n    public override string ToString()\r\n    {\r\n        return count.ToString() + unit.ToString();\r\n    }\r\n}\r\n\r\nnew Weight(77.5, Unit.Kg).ToString();\r\n// => \"77.6Kg\"\r\n```\r\n"
  },
  "links": [
    {
      "url": "https://docs.microsoft.com/en-us/dotnet/standard/design-guidelines/choosing-between-class-and-struct",
      "description": "class-or-struct"
    },
    {
      "url": "https://stackoverflow.com/a/3753640/96167",
      "description": "structs-immutable"
    },
    {
      "url": "https://docs.microsoft.com/en-us/dotnet/api/system.int32?view=netcore-3.1",
      "description": "int32"
    },
    {
      "url": "https://docs.microsoft.com/en-us/dotnet/api/system.timespan?view=netcore-3.1",
      "description": "time-span"
    },
    {
      "url": "https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/statements-expressions-operators/how-to-define-value-equality-for-a-type",
      "description": "equality"
    },
    {
      "url": "https://medium.com/@semuserable/c-journey-into-struct-equality-comparison-deep-dive-9693f74562f1",
      "description": "equality-performance"
    },
    {
      "url": "https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/builtin-types/struct",
      "description": "structs"
    }
  ]
}