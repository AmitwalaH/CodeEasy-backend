{
  "language": "csharp",
  "slug": "integral-numbers",
  "title": "Integral Numbers",
  "docs": {
    "about": "# About\r\n\r\nC#, like many statically typed languages, provides a number of types that represent integers, each with its own [range of values][integral-numeric-types]. At the low end, the `sbyte` type has a minimum value of -128 and a maximum value of 127. Like all the integer types these values are available as `<type>.MinValue` and `<type>.MaxValue`. At the high end, the `long` type has a minimum value of -9,223,372,036,854,775,808 and a maximum value of 9,223,372,036,854,775,807. In between lie the `short` and `int` types.\r\n\r\nEach of the above types is paired with an unsigned equivalent: `sbyte`/`byte`, `short`/`ushort`, `int`/`uint` and `long`/`ulong`. In all cases the range of the values is from 0 to the negative signed maximum times 2 plus 1.\r\n\r\nValues of unsigned integral types are represented with a simple [base 2][wiki-binary] representation. Values of signed types use [2s complement][wiki-twos-complement] signed number representation.\r\n\r\nThe multiplicity of integer types reflects machine architectures, in the size of registers, the size of CPU instruction arguments and the treatment of sign within the CPU. A value of type `long` uses 64 bits whereas a value of type `sbyte` uses 8 bits. In some cases there will be implications on CPU performance, memory usage and even disk usage (where selection of a smaller integer type will generally be beneficial). Selection of integer `type` can also be a rough and ready wsy of communicating information to other developers about the expected range of values. The `int` type is widely used as the default type where nothing special has been identified about the particular usage. The `long` or `ulong` is widely used as a simple identifier. The size of the type in bytes determines the range of values.\r\n\r\nThe types discussed so far are _primitive_ types. Each is paired with a `struct` alias which implements fields (such as `MinValue`) and methods (such as `ToString()`) which are associated with the type.\r\n\r\n| Type     | Struct   | Width  | Minimum                    | Maximum                     |\r\n| -------- | -------- | ------ | -------------------------- | --------------------------- |\r\n| `sbyte`  | `SByte`  | 8 bit  | -128                       | +127                        |\r\n| `short`  | `Int16`  | 16 bit | -32_768                    | +32_767                     |\r\n| `int`    | `Int32`  | 32 bit | -2_147_483_648             | +2_147_483_647              |\r\n| `long`   | `Int64`  | 64 bit | -9_223_372_036_854_775_808 | +9_223_372_036_854_775_807  |\r\n| `byte`   | `Byte`   | 8 bit  | 0                          | +255                        |\r\n| `ushort` | `UInt16` | 16 bit | 0                          | +65_535                     |\r\n| `uint`   | `UInt32` | 32 bit | 0                          | +4_294_967_295              |\r\n| `ulong`  | `UInt64` | 64 bit | 0                          | +18_446_744_073_709_551_615 |\r\n\r\n## Casting\r\n\r\nA variable (or expression) of one type can easily be converted to another. For instance, in an assignment operation, if the type of the value being assigned (rhs) ensures that the value will fit within the range of the type being assigned to (lhs) then there is a simple assignment:\r\n\r\n```csharp\r\nulong ul;\r\nuint ui = uint.MaxValue;\r\nul = ui;    // no problem\r\n```\r\n\r\nOn the other hand if the range of type being assigned from is not a subset of the assignee's range of values then a cast, `()` operation is required even if the particular value is within the assignee's range:\r\n\r\n```csharp\r\nuint ui;\r\nshort s = 42;\r\nui = (uint)s;\r\n```\r\n\r\nIn the above example, if the value lay instead outside the range of the assignee then an overflow would occur. See [concept:csharp/overflow]().\r\n\r\nThe requirement for casting is determined by the two types involved rather than a particular value.\r\n\r\nThe following paragraphs discuss the casting of integral types. (see [concept:csharp/casting]()) provides a broader discussion of casting and type conversion. See that documentation for a discussion of conversion between integral types and floating-point numbers, `char` and `bool`.\r\n\r\n### Casting Primitive Types - Implicit\r\n\r\nC#'s type system is somewhat stricter than _C_'s or Javascript's and as a consequence, casting operations are more restricted. [Implicit casting][implicit-casts] takes place between two numeric types as long as the \"to\" type can preserve the scale and sign of the \"from\" type's value.\r\n\r\nAn implicit cast is not signified by any special syntax.\r\n\r\n### Casting Primitive Types - Explicit\r\n\r\nWhere numeric types cannot be cast implicitly you can generally use the explicit cast [operator][cast-operator].\r\n\r\nWhere the value being cast cannot be represented by the \"to\" type because it is insufficiently wide or there is a sign conflict then an overflow exception may be thrown.\r\n\r\n#### Casting Primitive Types - Examples\r\n\r\n```csharp\r\nint largeInt = Int32.MaxValue;\r\nint largeNegInt = Int32.MinValue;\r\nushort shortUnsignedInt = ushort.MaxValue;\r\n\r\n// implicit cast\r\nint from_ushort = shortUnsignedInt;          // 65535\r\nfloat from_int = largeInt;                   // -21474836E+09\r\n\r\n// explicit cast\r\nuint from_largeInt = (uint)largeInt;         // 2147483647\r\nuint from_neg = (uint) largeNegInt;          // 2147483648 or OverflowException is thrown (if checked)\r\n\r\n```\r\n\r\n#### Bit conversion\r\n\r\nThe `BitConverter` class provides a convenient way of converting integer types to and from arrays of bytes.\r\n\r\n#### Reference\r\n\r\n- [Integral numeric types][integral-numeric-types]: overview of the integral numeric types.\r\n- [Numeric conversions][numeric-conversions]: overview of implicit and explicit numeric conversions.\r\n\r\n[integral-numeric-types]: https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/builtin-types/integral-numeric-types\r\n[numeric-conversions]: https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/builtin-types/numeric-conversions\r\n[cast-operator]: https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/operators/type-testing-and-cast#cast-expression\r\n[implicit-casts]: https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/builtin-types/numeric-conversions\r\n[wiki-twos-complement]: https://en.wikipedia.org/wiki/Two%27s_complement\r\n[wiki-binary]: https://en.wikipedia.org/wiki/Binary_number\r\n[sbyte]: https://docs.microsoft.com/en-us/dotnet/api/system.sbyte\r\n",
    "introduction": "# Introduction\r\n\r\nC#, like many statically typed languages, provides a number of types that represent integers, each with its own range of values. At the low end, the `sbyte` type has a minimum value of -128 and a maximum value of 127. Like all the integer types these values are available as `<type>.MinValue` and `<type>.MaxValue`. At the high end, the `long` type has a minimum value of -9,223,372,036,854,775,808 and a maximum value of 9,223,372,036,854,775,807. In between lie the `short` and `int` types.\r\n\r\nThe ranges are determined by the storage width of the type as allocated by the system. For example, a `byte` uses 8 bits and a `long` uses 64 bits.\r\n\r\nEach of the above types is paired with an unsigned equivalent: `sbyte`/`byte`, `short`/`ushort`, `int`/`uint` and `long`/`ulong`. In all cases the range of the values is from 0 to the negative signed maximum times 2 plus 1.\r\n\r\n| Type   | Width  | Minimum                    | Maximum                     |\r\n| ------ | ------ | -------------------------- | --------------------------- |\r\n| sbyte  | 8 bit  | -128                       | +127                        |\r\n| short  | 16 bit | -32_768                    | +32_767                     |\r\n| int    | 32 bit | -2_147_483_648             | +2_147_483_647              |\r\n| long   | 64 bit | -9_223_372_036_854_775_808 | +9_223_372_036_854_775_807  |\r\n| byte   | 8 bit  | 0                          | +255                        |\r\n| ushort | 16 bit | 0                          | +65_535                     |\r\n| uint   | 32 bit | 0                          | +4_294_967_295              |\r\n| ulong  | 64 bit | 0                          | +18_446_744_073_709_551_615 |\r\n\r\nA variable (or expression) of one type can easily be converted to another. For instance, in an assignment operation, if the type of the value being assigned (lhs) ensures that the value will lie within the range of the type being assigned to (rhs) then there is a simple assignment:\r\n\r\n```csharp\r\nuint ui = uint.MaxValue;\r\nulong ul = ui;    // no problem\r\n```\r\n\r\nOn the other hand if the range of type being assigned from is not a subset of the assignee's range of values then a cast, `()` operation is required even if the particular value is within the assignee's range:\r\n\r\n```csharp\r\nshort s = 42;\r\nuint ui = (uint)s;\r\n```\r\n\r\n## Bit conversion\r\n\r\nThe `BitConverter` class provides a convenient way of converting integer types to and from arrays of bytes.\r\n"
  },
  "links": [
    {
      "url": "https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/builtin-types/integral-numeric-types",
      "description": "integral-numeric-types"
    },
    {
      "url": "https://en.wikipedia.org/wiki/Binary_number",
      "description": "wiki-binary"
    },
    {
      "url": "https://en.wikipedia.org/wiki/Two%27s_complement",
      "description": "wiki-twos-complement"
    },
    {
      "url": "https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/builtin-types/numeric-conversions",
      "description": "implicit-casts"
    },
    {
      "url": "https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/operators/type-testing-and-cast#cast-expression",
      "description": "cast-operator"
    },
    {
      "url": "https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/builtin-types/integral-numeric-types",
      "description": "integral-numeric-types"
    },
    {
      "url": "https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/builtin-types/numeric-conversions",
      "description": "numeric-conversions"
    }
  ]
}