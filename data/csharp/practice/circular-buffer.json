{
  "language": "csharp",
  "slug": "circular-buffer",
  "docs": {
    "instructions": "# Instructions\r\n\r\nA circular buffer, cyclic buffer or ring buffer is a data structure that uses a single, fixed-size buffer as if it were connected end-to-end.\r\n\r\nA circular buffer first starts empty and of some predefined length.\r\nFor example, this is a 7-element buffer:\r\n\r\n```text\r\n[ ][ ][ ][ ][ ][ ][ ]\r\n```\r\n\r\nAssume that a 1 is written into the middle of the buffer (exact starting location does not matter in a circular buffer):\r\n\r\n```text\r\n[ ][ ][ ][1][ ][ ][ ]\r\n```\r\n\r\nThen assume that two more elements are added — 2 & 3 — which get appended after the 1:\r\n\r\n```text\r\n[ ][ ][ ][1][2][3][ ]\r\n```\r\n\r\nIf two elements are then removed from the buffer, the oldest values inside the buffer are removed.\r\nThe two elements removed, in this case, are 1 & 2, leaving the buffer with just a 3:\r\n\r\n```text\r\n[ ][ ][ ][ ][ ][3][ ]\r\n```\r\n\r\nIf the buffer has 7 elements then it is completely full:\r\n\r\n```text\r\n[5][6][7][8][9][3][4]\r\n```\r\n\r\nWhen the buffer is full an error will be raised, alerting the client that further writes are blocked until a slot becomes free.\r\n\r\nWhen the buffer is full, the client can opt to overwrite the oldest data with a forced write.\r\nIn this case, two more elements — A & B — are added and they overwrite the 3 & 4:\r\n\r\n```text\r\n[5][6][7][8][9][A][B]\r\n```\r\n\r\n3 & 4 have been replaced by A & B making 5 now the oldest data in the buffer.\r\nFinally, if two elements are removed then what would be returned is 5 & 6 yielding the buffer:\r\n\r\n```text\r\n[ ][ ][7][8][9][A][B]\r\n```\r\n\r\nBecause there is space available, if the client again uses overwrite to store C & D then the space where 5 & 6 were stored previously will be used not the location of 7 & 8.\r\n7 is still the oldest element and the buffer is once again full.\r\n\r\n```text\r\n[C][D][7][8][9][A][B]\r\n```\r\n",
    "instructions_append": "",
    "hints": ""
  },
  "starter_code": {
    "CircularBuffer.cs": "public class CircularBuffer<T>\r\n{\r\n    public CircularBuffer(int capacity)\r\n    {\r\n        throw new NotImplementedException(\"You need to implement this method.\");\r\n    }\r\n\r\n    public T Read()\r\n    {\r\n        throw new NotImplementedException(\"You need to implement this method.\");\r\n    }\r\n\r\n    public void Write(T value)\r\n    {\r\n        throw new NotImplementedException(\"You need to implement this method.\");\r\n    }\r\n\r\n    public void Overwrite(T value)\r\n    {\r\n        throw new NotImplementedException(\"You need to implement this method.\");\r\n    }\r\n\r\n    public void Clear()\r\n    {\r\n        throw new NotImplementedException(\"You need to implement this method.\");\r\n    }\r\n}"
  },
  "tests": {
    "CircularBufferTests.cs": "public class CircularBufferTests\r\n{\r\n    [Fact]\r\n    public void Reading_empty_buffer_should_fail()\r\n    {\r\n        var buffer = new CircularBuffer<int>(capacity: 1);\r\n        Assert.Throws<InvalidOperationException>(() => buffer.Read());\r\n    }\r\n\r\n    [Fact(Skip = \"Remove this Skip property to run this test\")]\r\n    public void Can_read_an_item_just_written()\r\n    {\r\n        var buffer = new CircularBuffer<int>(capacity: 1);\r\n        buffer.Write(1);\r\n        Assert.Equal(1, buffer.Read());\r\n    }\r\n\r\n    [Fact(Skip = \"Remove this Skip property to run this test\")]\r\n    public void Each_item_may_only_be_read_once()\r\n    {\r\n        var buffer = new CircularBuffer<int>(capacity: 1);\r\n        buffer.Write(1);\r\n        Assert.Equal(1, buffer.Read());\r\n        Assert.Throws<InvalidOperationException>(() => buffer.Read());\r\n    }\r\n\r\n    [Fact(Skip = \"Remove this Skip property to run this test\")]\r\n    public void Items_are_read_in_the_order_they_are_written()\r\n    {\r\n        var buffer = new CircularBuffer<int>(capacity: 2);\r\n        buffer.Write(1);\r\n        buffer.Write(2);\r\n        Assert.Equal(1, buffer.Read());\r\n        Assert.Equal(2, buffer.Read());\r\n    }\r\n\r\n    [Fact(Skip = \"Remove this Skip property to run this test\")]\r\n    public void Full_buffer_can_t_be_written_to()\r\n    {\r\n        var buffer = new CircularBuffer<int>(capacity: 1);\r\n        buffer.Write(1);\r\n        Assert.Throws<InvalidOperationException>(() => buffer.Write(2));\r\n    }\r\n\r\n    [Fact(Skip = \"Remove this Skip property to run this test\")]\r\n    public void A_read_frees_up_capacity_for_another_write()\r\n    {\r\n        var buffer = new CircularBuffer<int>(capacity: 1);\r\n        buffer.Write(1);\r\n        Assert.Equal(1, buffer.Read());\r\n        buffer.Write(2);\r\n        Assert.Equal(2, buffer.Read());\r\n    }\r\n\r\n    [Fact(Skip = \"Remove this Skip property to run this test\")]\r\n    public void Read_position_is_maintained_even_across_multiple_writes()\r\n    {\r\n        var buffer = new CircularBuffer<int>(capacity: 3);\r\n        buffer.Write(1);\r\n        buffer.Write(2);\r\n        Assert.Equal(1, buffer.Read());\r\n        buffer.Write(3);\r\n        Assert.Equal(2, buffer.Read());\r\n        Assert.Equal(3, buffer.Read());\r\n    }\r\n\r\n    [Fact(Skip = \"Remove this Skip property to run this test\")]\r\n    public void Items_cleared_out_of_buffer_can_t_be_read()\r\n    {\r\n        var buffer = new CircularBuffer<int>(capacity: 1);\r\n        buffer.Write(1);\r\n        buffer.Clear();\r\n        Assert.Throws<InvalidOperationException>(() => buffer.Read());\r\n    }\r\n\r\n    [Fact(Skip = \"Remove this Skip property to run this test\")]\r\n    public void Clear_frees_up_capacity_for_another_write()\r\n    {\r\n        var buffer = new CircularBuffer<int>(capacity: 1);\r\n        buffer.Write(1);\r\n        buffer.Clear();\r\n        buffer.Write(2);\r\n        Assert.Equal(2, buffer.Read());\r\n    }\r\n\r\n    [Fact(Skip = \"Remove this Skip property to run this test\")]\r\n    public void Clear_does_nothing_on_empty_buffer()\r\n    {\r\n        var buffer = new CircularBuffer<int>(capacity: 1);\r\n        buffer.Clear();\r\n        buffer.Write(1);\r\n        Assert.Equal(1, buffer.Read());\r\n    }\r\n\r\n    [Fact(Skip = \"Remove this Skip property to run this test\")]\r\n    public void Overwrite_acts_like_write_on_non_full_buffer()\r\n    {\r\n        var buffer = new CircularBuffer<int>(capacity: 2);\r\n        buffer.Write(1);\r\n        buffer.Overwrite(2);\r\n        Assert.Equal(1, buffer.Read());\r\n        Assert.Equal(2, buffer.Read());\r\n    }\r\n\r\n    [Fact(Skip = \"Remove this Skip property to run this test\")]\r\n    public void Overwrite_replaces_the_oldest_item_on_full_buffer()\r\n    {\r\n        var buffer = new CircularBuffer<int>(capacity: 2);\r\n        buffer.Write(1);\r\n        buffer.Write(2);\r\n        buffer.Overwrite(3);\r\n        Assert.Equal(2, buffer.Read());\r\n        Assert.Equal(3, buffer.Read());\r\n    }\r\n\r\n    [Fact(Skip = \"Remove this Skip property to run this test\")]\r\n    public void Overwrite_replaces_the_oldest_item_remaining_in_buffer_following_a_read()\r\n    {\r\n        var buffer = new CircularBuffer<int>(capacity: 3);\r\n        buffer.Write(1);\r\n        buffer.Write(2);\r\n        buffer.Write(3);\r\n        Assert.Equal(1, buffer.Read());\r\n        buffer.Write(4);\r\n        buffer.Overwrite(5);\r\n        Assert.Equal(3, buffer.Read());\r\n        Assert.Equal(4, buffer.Read());\r\n        Assert.Equal(5, buffer.Read());\r\n    }\r\n\r\n    [Fact(Skip = \"Remove this Skip property to run this test\")]\r\n    public void Initial_clear_does_not_affect_wrapping_around()\r\n    {\r\n        var buffer = new CircularBuffer<int>(capacity: 2);\r\n        buffer.Clear();\r\n        buffer.Write(1);\r\n        buffer.Write(2);\r\n        buffer.Overwrite(3);\r\n        buffer.Overwrite(4);\r\n        Assert.Equal(3, buffer.Read());\r\n        Assert.Equal(4, buffer.Read());\r\n        Assert.Throws<InvalidOperationException>(() => buffer.Read());\r\n    }\r\n}\r\n"
  }
}