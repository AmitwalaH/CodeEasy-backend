{
  "language": "csharp",
  "slug": "go-counting",
  "docs": {
    "instructions": "# Instructions\r\n\r\nCount the scored points on a Go board.\r\n\r\nIn the game of go (also known as baduk, igo, cờ vây and wéiqí) points are gained by completely encircling empty intersections with your stones.\r\nThe encircled intersections of a player are known as its territory.\r\n\r\nCalculate the territory of each player.\r\nYou may assume that any stones that have been stranded in enemy territory have already been taken off the board.\r\n\r\nDetermine the territory which includes a specified coordinate.\r\n\r\nMultiple empty intersections may be encircled at once and for encircling only horizontal and vertical neighbors count.\r\nIn the following diagram the stones which matter are marked \"O\" and the stones that don't are marked \"I\" (ignored).\r\nEmpty spaces represent empty intersections.\r\n\r\n```text\r\n+----+\r\n|IOOI|\r\n|O  O|\r\n|O OI|\r\n|IOI |\r\n+----+\r\n```\r\n\r\nTo be more precise an empty intersection is part of a player's territory if all of its neighbors are either stones of that player or empty intersections that are part of that player's territory.\r\n\r\nFor more information see [Wikipedia][go-wikipedia] or [Sensei's Library][go-sensei].\r\n\r\n[go-wikipedia]: https://en.wikipedia.org/wiki/Go_%28game%29\r\n[go-sensei]: https://senseis.xmp.net/\r\n",
    "instructions_append": "",
    "hints": ""
  },
  "starter_code": {
    "GoCounting.cs": "public enum Owner\r\n{\r\n    None,\r\n    Black,\r\n    White\r\n}\r\n\r\npublic class GoCounting\r\n{\r\n    public GoCounting(string input)\r\n    {\r\n        throw new NotImplementedException(\"You need to implement this method.\");\r\n    }\r\n\r\n    public Tuple<Owner, HashSet<(int, int)>> Territory((int, int) coord)\r\n    {\r\n        throw new NotImplementedException(\"You need to implement this method.\");\r\n    }\r\n\r\n    public Dictionary<Owner, HashSet<(int, int)>> Territories()\r\n    {\r\n        throw new NotImplementedException(\"You need to implement this method.\");\r\n    }\r\n}\r\n"
  },
  "tests": {
    "GoCountingTests.cs": "public class GoCountingTests\r\n{\r\n    [Fact]\r\n    public void Black_corner_territory_on_5x5_board()\r\n    {\r\n        var board =\r\n            \"  B  \\n\" +\r\n            \" B B \\n\" +\r\n            \"B W B\\n\" +\r\n            \" W W \\n\" +\r\n            \"  W  \";\r\n        var sut = new GoCounting(board);\r\n        var coordinate = (0, 1);\r\n        var (territoryOwner, territoryCoordinates) = sut.Territory(coordinate);\r\n        var expectedOwner = Owner.Black;\r\n        var expectedCoordinates = new HashSet<(int, int)> { (0, 0), (0, 1), (1, 0) };\r\n        Assert.Equal(expectedOwner, territoryOwner);\r\n        Assert.Equal(expectedCoordinates, territoryCoordinates.ToHashSet());\r\n    }\r\n\r\n    [Fact(Skip = \"Remove this Skip property to run this test\")]\r\n    public void White_center_territory_on_5x5_board()\r\n    {\r\n        var board =\r\n            \"  B  \\n\" +\r\n            \" B B \\n\" +\r\n            \"B W B\\n\" +\r\n            \" W W \\n\" +\r\n            \"  W  \";\r\n        var sut = new GoCounting(board);\r\n        var coordinate = (2, 3);\r\n        var (territoryOwner, territoryCoordinates) = sut.Territory(coordinate);\r\n        var expectedOwner = Owner.White;\r\n        var expectedCoordinates = new HashSet<(int, int)> { (2, 3) };\r\n        Assert.Equal(expectedOwner, territoryOwner);\r\n        Assert.Equal(expectedCoordinates, territoryCoordinates.ToHashSet());\r\n    }\r\n\r\n    [Fact(Skip = \"Remove this Skip property to run this test\")]\r\n    public void Open_corner_territory_on_5x5_board()\r\n    {\r\n        var board =\r\n            \"  B  \\n\" +\r\n            \" B B \\n\" +\r\n            \"B W B\\n\" +\r\n            \" W W \\n\" +\r\n            \"  W  \";\r\n        var sut = new GoCounting(board);\r\n        var coordinate = (1, 4);\r\n        var (territoryOwner, territoryCoordinates) = sut.Territory(coordinate);\r\n        var expectedOwner = Owner.None;\r\n        var expectedCoordinates = new HashSet<(int, int)> { (0, 3), (0, 4), (1, 4) };\r\n        Assert.Equal(expectedOwner, territoryOwner);\r\n        Assert.Equal(expectedCoordinates, territoryCoordinates.ToHashSet());\r\n    }\r\n\r\n    [Fact(Skip = \"Remove this Skip property to run this test\")]\r\n    public void A_stone_and_not_a_territory_on_5x5_board()\r\n    {\r\n        var board =\r\n            \"  B  \\n\" +\r\n            \" B B \\n\" +\r\n            \"B W B\\n\" +\r\n            \" W W \\n\" +\r\n            \"  W  \";\r\n        var sut = new GoCounting(board);\r\n        var coordinate = (1, 1);\r\n        var (territoryOwner, territoryCoordinates) = sut.Territory(coordinate);\r\n        var expectedOwner = Owner.None;\r\n        var expectedCoordinates = new HashSet<(int, int)>();\r\n        Assert.Equal(expectedOwner, territoryOwner);\r\n        Assert.Equal(expectedCoordinates, territoryCoordinates.ToHashSet());\r\n    }\r\n\r\n    [Fact(Skip = \"Remove this Skip property to run this test\")]\r\n    public void Invalid_because_x_is_too_low_for_5x5_board()\r\n    {\r\n        var board =\r\n            \"  B  \\n\" +\r\n            \" B B \\n\" +\r\n            \"B W B\\n\" +\r\n            \" W W \\n\" +\r\n            \"  W  \";\r\n        var sut = new GoCounting(board);\r\n        var coordinate = (-1, 1);\r\n        Assert.Throws<ArgumentException>(() => sut.Territory(coordinate));\r\n    }\r\n\r\n    [Fact(Skip = \"Remove this Skip property to run this test\")]\r\n    public void Invalid_because_x_is_too_high_for_5x5_board()\r\n    {\r\n        var board =\r\n            \"  B  \\n\" +\r\n            \" B B \\n\" +\r\n            \"B W B\\n\" +\r\n            \" W W \\n\" +\r\n            \"  W  \";\r\n        var sut = new GoCounting(board);\r\n        var coordinate = (5, 1);\r\n        Assert.Throws<ArgumentException>(() => sut.Territory(coordinate));\r\n    }\r\n\r\n    [Fact(Skip = \"Remove this Skip property to run this test\")]\r\n    public void Invalid_because_y_is_too_low_for_5x5_board()\r\n    {\r\n        var board =\r\n            \"  B  \\n\" +\r\n            \" B B \\n\" +\r\n            \"B W B\\n\" +\r\n            \" W W \\n\" +\r\n            \"  W  \";\r\n        var sut = new GoCounting(board);\r\n        var coordinate = (1, -1);\r\n        Assert.Throws<ArgumentException>(() => sut.Territory(coordinate));\r\n    }\r\n\r\n    [Fact(Skip = \"Remove this Skip property to run this test\")]\r\n    public void Invalid_because_y_is_too_high_for_5x5_board()\r\n    {\r\n        var board =\r\n            \"  B  \\n\" +\r\n            \" B B \\n\" +\r\n            \"B W B\\n\" +\r\n            \" W W \\n\" +\r\n            \"  W  \";\r\n        var sut = new GoCounting(board);\r\n        var coordinate = (1, 5);\r\n        Assert.Throws<ArgumentException>(() => sut.Territory(coordinate));\r\n    }\r\n\r\n    [Fact(Skip = \"Remove this Skip property to run this test\")]\r\n    public void One_territory_is_the_whole_board()\r\n    {\r\n        var board =\r\n            \" \";\r\n        var sut = new GoCounting(board);\r\n        var actual = sut.Territories();\r\n        var expected = new Dictionary<Owner, HashSet<(int, int)>>\r\n        {\r\n            [Owner.Black] = new HashSet<(int, int)>() { },\r\n            [Owner.White] = new HashSet<(int, int)>() { },\r\n            [Owner.None] = new HashSet<(int, int)>() { (0, 0) }\r\n        };\r\n        Assert.Equal(expected[Owner.Black], actual[Owner.Black]);\r\n        Assert.Equal(expected[Owner.White], actual[Owner.White]);\r\n        Assert.Equal(expected[Owner.None], actual[Owner.None]);\r\n    }\r\n\r\n    [Fact(Skip = \"Remove this Skip property to run this test\")]\r\n    public void Two_territory_rectangular_board()\r\n    {\r\n        var board =\r\n            \" BW \\n\" +\r\n            \" BW \";\r\n        var sut = new GoCounting(board);\r\n        var actual = sut.Territories();\r\n        var expected = new Dictionary<Owner, HashSet<(int, int)>>\r\n        {\r\n            [Owner.Black] = new HashSet<(int, int)>() { (0, 0), (0, 1) },\r\n            [Owner.White] = new HashSet<(int, int)>() { (3, 0), (3, 1) },\r\n            [Owner.None] = new HashSet<(int, int)>() { }\r\n        };\r\n        Assert.Equal(expected[Owner.Black], actual[Owner.Black]);\r\n        Assert.Equal(expected[Owner.White], actual[Owner.White]);\r\n        Assert.Equal(expected[Owner.None], actual[Owner.None]);\r\n    }\r\n\r\n    [Fact(Skip = \"Remove this Skip property to run this test\")]\r\n    public void Two_region_rectangular_board()\r\n    {\r\n        var board =\r\n            \" B \";\r\n        var sut = new GoCounting(board);\r\n        var actual = sut.Territories();\r\n        var expected = new Dictionary<Owner, HashSet<(int, int)>>\r\n        {\r\n            [Owner.Black] = new HashSet<(int, int)>() { (0, 0), (2, 0) },\r\n            [Owner.White] = new HashSet<(int, int)>() { },\r\n            [Owner.None] = new HashSet<(int, int)>() { }\r\n        };\r\n        Assert.Equal(expected[Owner.Black], actual[Owner.Black]);\r\n        Assert.Equal(expected[Owner.White], actual[Owner.White]);\r\n        Assert.Equal(expected[Owner.None], actual[Owner.None]);\r\n    }\r\n}\r\n"
  }
}