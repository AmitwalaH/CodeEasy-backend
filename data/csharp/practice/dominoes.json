{
  "language": "csharp",
  "slug": "dominoes",
  "docs": {
    "instructions": "# Instructions\r\n\r\nMake a chain of dominoes.\r\n\r\nCompute a way to order a given set of domino stones so that they form a correct domino chain.\r\nIn the chain, the dots on one half of a stone must match the dots on the neighboring half of an adjacent stone.\r\nAdditionally, the dots on the halves of the stones without neighbors (the first and last stone) must match each other.\r\n\r\nFor example given the stones `[2|1]`, `[2|3]` and `[1|3]` you should compute something\r\nlike `[1|2] [2|3] [3|1]` or `[3|2] [2|1] [1|3]` or `[1|3] [3|2] [2|1]` etc, where the first and last numbers are the same.\r\n\r\nFor stones `[1|2]`, `[4|1]` and `[2|3]` the resulting chain is not valid: `[4|1] [1|2] [2|3]`'s first and last numbers are not the same.\r\n4 != 3\r\n\r\nSome test cases may use duplicate stones in a chain solution, assume that multiple Domino sets are being used.\r\n",
    "instructions_append": "",
    "hints": ""
  },
  "starter_code": {
    "Dominoes.cs": "public static class Dominoes\r\n{\r\n    public static bool CanChain(IEnumerable<(int, int)> dominoes)\r\n    {\r\n        throw new NotImplementedException(\"You need to implement this method.\");\r\n    }\r\n}"
  },
  "tests": {
    "DominoesTests.cs": "public class DominoesTests\r\n{\r\n    [Fact]\r\n    public void Empty_input_empty_output()\r\n    {\r\n        Assert.True(Dominoes.CanChain([]));\r\n    }\r\n\r\n    [Fact(Skip = \"Remove this Skip property to run this test\")]\r\n    public void Singleton_input_singleton_output()\r\n    {\r\n        Assert.True(Dominoes.CanChain([(1, 1)]));\r\n    }\r\n\r\n    [Fact(Skip = \"Remove this Skip property to run this test\")]\r\n    public void Singleton_that_can_t_be_chained()\r\n    {\r\n        Assert.False(Dominoes.CanChain([(1, 2)]));\r\n    }\r\n\r\n    [Fact(Skip = \"Remove this Skip property to run this test\")]\r\n    public void Three_elements()\r\n    {\r\n        Assert.True(Dominoes.CanChain([(1, 2), (3, 1), (2, 3)]));\r\n    }\r\n\r\n    [Fact(Skip = \"Remove this Skip property to run this test\")]\r\n    public void Can_reverse_dominoes()\r\n    {\r\n        Assert.True(Dominoes.CanChain([(1, 2), (1, 3), (2, 3)]));\r\n    }\r\n\r\n    [Fact(Skip = \"Remove this Skip property to run this test\")]\r\n    public void Can_t_be_chained()\r\n    {\r\n        Assert.False(Dominoes.CanChain([(1, 2), (4, 1), (2, 3)]));\r\n    }\r\n\r\n    [Fact(Skip = \"Remove this Skip property to run this test\")]\r\n    public void Disconnected_simple()\r\n    {\r\n        Assert.False(Dominoes.CanChain([(1, 1), (2, 2)]));\r\n    }\r\n\r\n    [Fact(Skip = \"Remove this Skip property to run this test\")]\r\n    public void Disconnected_double_loop()\r\n    {\r\n        Assert.False(Dominoes.CanChain([(1, 2), (2, 1), (3, 4), (4, 3)]));\r\n    }\r\n\r\n    [Fact(Skip = \"Remove this Skip property to run this test\")]\r\n    public void Disconnected_single_isolated()\r\n    {\r\n        Assert.False(Dominoes.CanChain([(1, 2), (2, 3), (3, 1), (4, 4)]));\r\n    }\r\n\r\n    [Fact(Skip = \"Remove this Skip property to run this test\")]\r\n    public void Need_backtrack()\r\n    {\r\n        Assert.True(Dominoes.CanChain([(1, 2), (2, 3), (3, 1), (2, 4), (2, 4)]));\r\n    }\r\n\r\n    [Fact(Skip = \"Remove this Skip property to run this test\")]\r\n    public void Separate_loops()\r\n    {\r\n        Assert.True(Dominoes.CanChain([(1, 2), (2, 3), (3, 1), (1, 1), (2, 2), (3, 3)]));\r\n    }\r\n\r\n    [Fact(Skip = \"Remove this Skip property to run this test\")]\r\n    public void Nine_elements()\r\n    {\r\n        Assert.True(Dominoes.CanChain([(1, 2), (5, 3), (3, 1), (1, 2), (2, 4), (1, 6), (2, 3), (3, 4), (5, 6)]));\r\n    }\r\n\r\n    [Fact(Skip = \"Remove this Skip property to run this test\")]\r\n    public void Separate_three_domino_loops()\r\n    {\r\n        Assert.False(Dominoes.CanChain([(1, 2), (2, 3), (3, 1), (4, 5), (5, 6), (6, 4)]));\r\n    }\r\n}\r\n"
  }
}