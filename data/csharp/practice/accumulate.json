{
  "language": "csharp",
  "slug": "accumulate",
  "docs": {
    "instructions": "# Instructions\r\n\r\nImplement the `accumulate` operation, which, given a collection and an operation to perform on each element of the collection, returns a new collection containing the result of applying that operation to each element of the input collection.\r\n\r\nGiven the collection of numbers:\r\n\r\n- 1, 2, 3, 4, 5\r\n\r\nAnd the operation:\r\n\r\n- square a number (`x => x * x`)\r\n\r\nYour code should be able to produce the collection of squares:\r\n\r\n- 1, 4, 9, 16, 25\r\n\r\nCheck out the test suite to see the expected function signature.\r\n\r\n## Restrictions\r\n\r\nKeep your hands off that collect/map/fmap/whatchamacallit functionality provided by your standard library!\r\nSolve this one yourself using other basic tools instead.\r\n",
    "instructions_append": "# Instructions append\r\n\r\nTo be more specific, you are not allowed to use any of the built-in [LINQ methods](https://docs.microsoft.com/en-us/dotnet/api/system.linq.enumerable).\r\n\r\n## Laziness test\r\n\r\nSince `accumulate` returns an `IEnumerable`, its execution is deferred until `ToList()` it is called on it, which is tested with the `Accumulate_is_lazy` method.\r\n\r\n## Hints\r\n\r\nThis exercise requires you to write an extension method. For more information, see [this page](https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/classes-and-structs/extension-methods).\r\n",
    "hints": ""
  },
  "starter_code": {
    "Accumulate.cs": "public static class AccumulateExtensions\r\n{\r\n    public static IEnumerable<U> Accumulate<T, U>(this IEnumerable<T> collection, Func<T, U> func)\r\n    {\r\n        throw new NotImplementedException(\"You need to implement this method.\");\r\n    }\r\n}"
  },
  "tests": {
    "AccumulateTests.cs": "public class AccumulateTests\r\n{\r\n    [Fact]\r\n    public void Accumulate_empty()\r\n    {\r\n        int[] input = [];\r\n        int[] expected = [];\r\n        Assert.Equal(expected, input.Accumulate((x) => x * x));\r\n    }\r\n\r\n    [Fact(Skip = \"Remove this Skip property to run this test\")]\r\n    public void Accumulate_squares()\r\n    {\r\n        int[] input = [1, 2, 3];\r\n        int[] expected = [1, 4, 9];\r\n        Assert.Equal(expected, input.Accumulate((x) => x * x));\r\n    }\r\n\r\n    [Fact(Skip = \"Remove this Skip property to run this test\")]\r\n    public void Accumulate_upcases()\r\n    {\r\n        string[] input = [\"Hello\", \"world\"];\r\n        string[] expected = [\"HELLO\", \"WORLD\"];\r\n        Assert.Equal(expected, input.Accumulate((x) => x.ToUpper()));\r\n    }\r\n\r\n    [Fact(Skip = \"Remove this Skip property to run this test\")]\r\n    public void Accumulate_reversed_strings()\r\n    {\r\n        string[] input = [\"the\", \"quick\", \"brown\", \"fox\", \"etc\"];\r\n        string[] expected = [\"eht\", \"kciuq\", \"nworb\", \"xof\", \"cte\"];\r\n        Assert.Equal(expected, input.Accumulate((x) => new string(x.Reverse().ToArray())));\r\n    }\r\n\r\n    [Fact(Skip = \"Remove this Skip property to run this test\")]\r\n    public void Accumulate_recursively()\r\n    {\r\n        string[] input = [\"a\", \"b\", \"c\"];\r\n        string[][] expected = [[\"a1\", \"a2\", \"a3\"], [\"b1\", \"b2\", \"b3\"], [\"c1\", \"c2\", \"c3\"]];\r\n        Assert.Equal(expected, input.Accumulate((x) => new[] { \"1\", \"2\", \"3\" }.Accumulate((y) => x + y)));\r\n    }\r\n\r\n    [Fact(Skip = \"Remove this Skip property to run this test\")]\r\n    public void Accumulate_is_lazy()\r\n    {\r\n        var counter = 0;\r\n        int[] input = [1, 2, 3];\r\n        var accumulation = input.Accumulate(x => x * counter++);\r\n        Assert.Equal(0, counter);\r\n        var _ = accumulation.ToList();\r\n        Assert.Equal(3, counter);\r\n    }\r\n}\r\n"
  }
}