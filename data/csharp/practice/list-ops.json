{
  "language": "csharp",
  "slug": "list-ops",
  "docs": {
    "instructions": "# Instructions\r\n\r\nImplement basic list operations.\r\n\r\nIn functional languages list operations like `length`, `map`, and `reduce` are very common.\r\nImplement a series of basic list operations, without using existing functions.\r\n\r\nThe precise number and names of the operations to be implemented will be track dependent to avoid conflicts with existing names, but the general operations you will implement include:\r\n\r\n- `append` (_given two lists, add all items in the second list to the end of the first list_);\r\n- `concatenate` (_given a series of lists, combine all items in all lists into one flattened list_);\r\n- `filter` (_given a predicate and a list, return the list of all items for which `predicate(item)` is True_);\r\n- `length` (_given a list, return the total number of items within it_);\r\n- `map` (_given a function and a list, return the list of the results of applying `function(item)` on all items_);\r\n- `foldl` (_given a function, a list, and initial accumulator, fold (reduce) each item into the accumulator from the left_);\r\n- `foldr` (_given a function, a list, and an initial accumulator, fold (reduce) each item into the accumulator from the right_);\r\n- `reverse` (_given a list, return a list with all the original items, but in reversed order_).\r\n\r\nNote, the ordering in which arguments are passed to the fold functions (`foldl`, `foldr`) is significant.\r\n",
    "instructions_append": "# Hints\r\n\r\nThe `Foldl` and `Foldr` methods are \"fold\" functions, which is a concept well-known in the functional programming world, but less so in the object-oriented one. If you'd like more background information, check out this [fold](<https://en.wikipedia.org/wiki/Fold_(higher-order_function)>) page.\r\n",
    "hints": ""
  },
  "starter_code": {
    "ListOps.cs": "public static class ListOps\r\n{\r\n    public static int Length<T>(List<T> input)\r\n    {\r\n        throw new NotImplementedException(\"You need to implement this method.\");\r\n    }\r\n\r\n    public static List<T> Reverse<T>(List<T> input)\r\n    {\r\n        throw new NotImplementedException(\"You need to implement this method.\");\r\n    }\r\n\r\n    public static List<TOut> Map<TIn, TOut>(List<TIn> input, Func<TIn, TOut> map)\r\n    {\r\n        throw new NotImplementedException(\"You need to implement this method.\");\r\n    }\r\n\r\n    public static List<T> Filter<T>(List<T> input, Func<T, bool> predicate)\r\n    {\r\n        throw new NotImplementedException(\"You need to implement this method.\");\r\n    }\r\n\r\n    public static TOut Foldl<TIn, TOut>(List<TIn> input, TOut start, Func<TOut, TIn, TOut> func)\r\n    {\r\n        throw new NotImplementedException(\"You need to implement this method.\");\r\n    }\r\n\r\n    public static TOut Foldr<TIn, TOut>(List<TIn> input, TOut start, Func<TIn, TOut, TOut> func)\r\n    {\r\n        throw new NotImplementedException(\"You need to implement this method.\");\r\n    }\r\n\r\n    public static List<T> Concat<T>(List<List<T>> input)\r\n    {\r\n        throw new NotImplementedException(\"You need to implement this method.\");\r\n    }\r\n\r\n    public static List<T> Append<T>(List<T> left, List<T> right)\r\n    {\r\n        throw new NotImplementedException(\"You need to implement this method.\");\r\n    }\r\n}"
  },
  "tests": {
    "ListOpsTests.cs": "public class ListOpsTests\r\n{\r\n    [Fact]\r\n    public void Append_entries_to_a_list_and_return_the_new_list_empty_lists()\r\n    {\r\n        List<int> list1 = [];\r\n        List<int> list2 = [];\r\n        Assert.Empty(ListOps.Append(list1, list2));\r\n    }\r\n\r\n    [Fact(Skip = \"Remove this Skip property to run this test\")]\r\n    public void Append_entries_to_a_list_and_return_the_new_list_list_to_empty_list()\r\n    {\r\n        List<int> list1 = [];\r\n        List<int> list2 = [1, 2, 3, 4];\r\n        List<int> expected = [1, 2, 3, 4];\r\n        Assert.Equal(expected, ListOps.Append(list1, list2));\r\n    }\r\n\r\n    [Fact(Skip = \"Remove this Skip property to run this test\")]\r\n    public void Append_entries_to_a_list_and_return_the_new_list_empty_list_to_list()\r\n    {\r\n        List<int> list1 = [1, 2, 3, 4];\r\n        List<int> list2 = [];\r\n        List<int> expected = [1, 2, 3, 4];\r\n        Assert.Equal(expected, ListOps.Append(list1, list2));\r\n    }\r\n\r\n    [Fact(Skip = \"Remove this Skip property to run this test\")]\r\n    public void Append_entries_to_a_list_and_return_the_new_list_non_empty_lists()\r\n    {\r\n        List<int> list1 = [1, 2];\r\n        List<int> list2 = [2, 3, 4, 5];\r\n        List<int> expected = [1, 2, 2, 3, 4, 5];\r\n        Assert.Equal(expected, ListOps.Append(list1, list2));\r\n    }\r\n\r\n    [Fact(Skip = \"Remove this Skip property to run this test\")]\r\n    public void Concatenate_a_list_of_lists_empty_list()\r\n    {\r\n        List<List<int>> lists = [];\r\n        Assert.Empty(ListOps.Concat(lists));\r\n    }\r\n\r\n    [Fact(Skip = \"Remove this Skip property to run this test\")]\r\n    public void Concatenate_a_list_of_lists_list_of_lists()\r\n    {\r\n        List<List<int>> lists = [[1, 2], [3], [], [4, 5, 6]];\r\n        List<int> expected = [1, 2, 3, 4, 5, 6];\r\n        Assert.Equal(expected, ListOps.Concat(lists));\r\n    }\r\n\r\n    [Fact(Skip = \"Remove this Skip property to run this test\")]\r\n    public void Concatenate_a_list_of_lists_list_of_nested_lists()\r\n    {\r\n        List<List<List<int>>> lists = [[[1], [2]], [[3]], [[]], [[4, 5, 6]]];\r\n        List<List<int>> expected = [[1], [2], [3], [], [4, 5, 6]];\r\n        Assert.Equal(expected, ListOps.Concat(lists));\r\n    }\r\n\r\n    [Fact(Skip = \"Remove this Skip property to run this test\")]\r\n    public void Filter_list_returning_only_values_that_satisfy_the_filter_function_empty_list()\r\n    {\r\n        List<int> list = [];\r\n        Func<int, bool> function = (x) => x % 2 == 1;\r\n        Assert.Empty(ListOps.Filter(list, function));\r\n    }\r\n\r\n    [Fact(Skip = \"Remove this Skip property to run this test\")]\r\n    public void Filter_list_returning_only_values_that_satisfy_the_filter_function_non_empty_list()\r\n    {\r\n        List<int> list = [1, 2, 3, 5];\r\n        Func<int, bool> function = (x) => x % 2 == 1;\r\n        List<int> expected = [1, 3, 5];\r\n        Assert.Equal(expected, ListOps.Filter(list, function));\r\n    }\r\n\r\n    [Fact(Skip = \"Remove this Skip property to run this test\")]\r\n    public void Returns_the_length_of_a_list_empty_list()\r\n    {\r\n        List<int> list = [];\r\n        Assert.Equal(0, ListOps.Length(list));\r\n    }\r\n\r\n    [Fact(Skip = \"Remove this Skip property to run this test\")]\r\n    public void Returns_the_length_of_a_list_non_empty_list()\r\n    {\r\n        List<int> list = [1, 2, 3, 4];\r\n        Assert.Equal(4, ListOps.Length(list));\r\n    }\r\n\r\n    [Fact(Skip = \"Remove this Skip property to run this test\")]\r\n    public void Return_a_list_of_elements_whose_values_equal_the_list_value_transformed_by_the_mapping_function_empty_list()\r\n    {\r\n        List<int> list = [];\r\n        Func<int, int> function = (x) => x + 1;\r\n        Assert.Empty(ListOps.Map(list, function));\r\n    }\r\n\r\n    [Fact(Skip = \"Remove this Skip property to run this test\")]\r\n    public void Return_a_list_of_elements_whose_values_equal_the_list_value_transformed_by_the_mapping_function_non_empty_list()\r\n    {\r\n        List<int> list = [1, 3, 5, 7];\r\n        Func<int, int> function = (x) => x + 1;\r\n        List<int> expected = [2, 4, 6, 8];\r\n        Assert.Equal(expected, ListOps.Map(list, function));\r\n    }\r\n\r\n    [Fact(Skip = \"Remove this Skip property to run this test\")]\r\n    public void Folds_reduces_the_given_list_from_the_left_with_a_function_direction_dependent_function_applied_to_non_empty_list()\r\n    {\r\n        List<int> list = [2, 5];\r\n        int initial = 5;\r\n        Func<int, int, int> function = (x, y) => x / y;\r\n        Assert.Equal(0, ListOps.Foldl(list, initial, function));\r\n    }\r\n\r\n    [Fact(Skip = \"Remove this Skip property to run this test\")]\r\n    public void Folds_reduces_the_given_list_from_the_left_with_a_function_empty_list()\r\n    {\r\n        List<int> list = [];\r\n        int initial = 2;\r\n        Func<int, int, int> function = (acc, el) => el * acc;\r\n        Assert.Equal(2, ListOps.Foldl(list, initial, function));\r\n    }\r\n\r\n    [Fact(Skip = \"Remove this Skip property to run this test\")]\r\n    public void Folds_reduces_the_given_list_from_the_left_with_a_function_direction_independent_function_applied_to_non_empty_list()\r\n    {\r\n        List<int> list = [1, 2, 3, 4];\r\n        int initial = 5;\r\n        Func<int, int, int> function = (acc, el) => el + acc;\r\n        Assert.Equal(15, ListOps.Foldl(list, initial, function));\r\n    }\r\n\r\n    [Fact(Skip = \"Remove this Skip property to run this test\")]\r\n    public void Folds_reduces_the_given_list_from_the_right_with_a_function_direction_dependent_function_applied_to_non_empty_list()\r\n    {\r\n        List<int> list = [2, 5];\r\n        int initial = 5;\r\n        Func<int, int, int> function = (x, y) => x / y;\r\n        Assert.Equal(2, ListOps.Foldr(list, initial, function));\r\n    }\r\n\r\n    [Fact(Skip = \"Remove this Skip property to run this test\")]\r\n    public void Folds_reduces_the_given_list_from_the_right_with_a_function_empty_list()\r\n    {\r\n        List<int> list = [];\r\n        int initial = 2;\r\n        Func<int, int, int> function = (acc, el) => el * acc;\r\n        Assert.Equal(2, ListOps.Foldr(list, initial, function));\r\n    }\r\n\r\n    [Fact(Skip = \"Remove this Skip property to run this test\")]\r\n    public void Folds_reduces_the_given_list_from_the_right_with_a_function_direction_independent_function_applied_to_non_empty_list()\r\n    {\r\n        List<int> list = [1, 2, 3, 4];\r\n        int initial = 5;\r\n        Func<int, int, int> function = (acc, el) => el + acc;\r\n        Assert.Equal(15, ListOps.Foldr(list, initial, function));\r\n    }\r\n\r\n    [Fact(Skip = \"Remove this Skip property to run this test\")]\r\n    public void Reverse_the_elements_of_the_list_empty_list()\r\n    {\r\n        List<int> list = [];\r\n        Assert.Empty(ListOps.Reverse(list));\r\n    }\r\n\r\n    [Fact(Skip = \"Remove this Skip property to run this test\")]\r\n    public void Reverse_the_elements_of_the_list_non_empty_list()\r\n    {\r\n        List<int> list = [1, 3, 5, 7];\r\n        List<int> expected = [7, 5, 3, 1];\r\n        Assert.Equal(expected, ListOps.Reverse(list));\r\n    }\r\n\r\n    [Fact(Skip = \"Remove this Skip property to run this test\")]\r\n    public void Reverse_the_elements_of_the_list_list_of_lists_is_not_flattened()\r\n    {\r\n        List<List<int>> list = [[1, 2], [3], [], [4, 5, 6]];\r\n        List<List<int>> expected = [[4, 5, 6], [], [3], [1, 2]];\r\n        Assert.Equal(expected, ListOps.Reverse(list));\r\n    }\r\n}\r\n"
  }
}