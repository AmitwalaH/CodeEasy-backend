{
  "language": "csharp",
  "slug": "react",
  "docs": {
    "instructions": "# Instructions\r\n\r\nImplement a basic reactive system.\r\n\r\nReactive programming is a programming paradigm that focuses on how values are computed in terms of each other to allow a change to one value to automatically propagate to other values, like in a spreadsheet.\r\n\r\nImplement a basic reactive system with cells with settable values (\"input\" cells) and cells with values computed in terms of other cells (\"compute\" cells).\r\nImplement updates so that when an input value is changed, values propagate to reach a new stable system state.\r\n\r\nIn addition, compute cells should allow for registering change notification callbacks.\r\nCall a cell’s callbacks when the cell’s value in a new stable state has changed from the previous stable state.\r\n",
    "instructions_append": "# Hints\r\n\r\nIn this exercise the following C# feature is used:\r\n\r\n- [Events](https://docs.microsoft.com/en-us/dotnet/standard/events/how-to-raise-and-consume-events).\r\n",
    "hints": ""
  },
  "starter_code": {
    "React.cs": "public class Reactor\r\n{\r\n    public InputCell CreateInputCell(int value)\r\n    {\r\n        throw new NotImplementedException(\"You need to implement this method.\");\r\n    }\r\n\r\n    public ComputeCell CreateComputeCell(IEnumerable<Cell> producers, Func<int[], int> compute)\r\n    {\r\n        throw new NotImplementedException(\"You need to implement this method.\");\r\n    }\r\n}\r\n\r\npublic abstract class Cell\r\n{\r\n}\r\n\r\npublic class InputCell : Cell\r\n{\r\n}\r\n\r\npublic class ComputeCell : Cell\r\n{\r\n\r\n}"
  },
  "tests": {
    "ReactTests.cs": "using FakeItEasy;\r\n\r\npublic class ReactTests\r\n{\r\n    [Fact]\r\n    public void Input_cells_have_a_value()\r\n    {\r\n        var sut = new Reactor();\r\n        var input = sut.CreateInputCell(10);\r\n        Assert.Equal(10, input.Value);\r\n    }\r\n\r\n    [Fact(Skip = \"Remove this Skip property to run this test\")]\r\n    public void An_input_cells_value_can_be_set()\r\n    {\r\n        var sut = new Reactor();\r\n        var input = sut.CreateInputCell(4);\r\n        input.Value = 20;\r\n        Assert.Equal(20, input.Value);\r\n    }\r\n\r\n    [Fact(Skip = \"Remove this Skip property to run this test\")]\r\n    public void Compute_cells_calculate_initial_value()\r\n    {\r\n        var sut = new Reactor();\r\n        var input = sut.CreateInputCell(1);\r\n        var output = sut.CreateComputeCell(new[] { input }, inputs => inputs[0] + 1);\r\n        Assert.Equal(2, output.Value);\r\n    }\r\n\r\n    [Fact(Skip = \"Remove this Skip property to run this test\")]\r\n    public void Compute_cells_take_inputs_in_the_right_order()\r\n    {\r\n        var sut = new Reactor();\r\n        var one = sut.CreateInputCell(1);\r\n        var two = sut.CreateInputCell(2);\r\n        var output = sut.CreateComputeCell(new[] { one, two }, inputs => inputs[0] + inputs[1] * 10);\r\n        Assert.Equal(21, output.Value);\r\n    }\r\n\r\n    [Fact(Skip = \"Remove this Skip property to run this test\")]\r\n    public void Compute_cells_update_value_when_dependencies_are_changed()\r\n    {\r\n        var sut = new Reactor();\r\n        var input = sut.CreateInputCell(1);\r\n        var output = sut.CreateComputeCell(new[] { input }, inputs => inputs[0] + 1);\r\n        input.Value = 3;\r\n        Assert.Equal(4, output.Value);\r\n    }\r\n\r\n    [Fact(Skip = \"Remove this Skip property to run this test\")]\r\n    public void Compute_cells_can_depend_on_other_compute_cells()\r\n    {\r\n        var sut = new Reactor();\r\n        var input = sut.CreateInputCell(1);\r\n        var timesTwo = sut.CreateComputeCell(new[] { input }, inputs => inputs[0] * 2);\r\n        var timesThirty = sut.CreateComputeCell(new[] { input }, inputs => inputs[0] * 30);\r\n        var output = sut.CreateComputeCell(new[] { timesTwo, timesThirty }, inputs => inputs[0] + inputs[1]);\r\n        Assert.Equal(32, output.Value);\r\n        input.Value = 3;\r\n        Assert.Equal(96, output.Value);\r\n    }\r\n\r\n    [Fact(Skip = \"Remove this Skip property to run this test\")]\r\n    public void Compute_cells_fire_callbacks()\r\n    {\r\n        var sut = new Reactor();\r\n        var input = sut.CreateInputCell(1);\r\n        var output = sut.CreateComputeCell(new[] { input }, inputs => inputs[0] + 1);\r\n        var callback1 = A.Fake<EventHandler<int>>();\r\n        output.Changed += callback1;\r\n        input.Value = 3;\r\n        A.CallTo(() => callback1.Invoke(A<object>._, 4)).MustHaveHappenedOnceExactly();\r\n        Fake.ClearRecordedCalls(callback1);\r\n    }\r\n\r\n    [Fact(Skip = \"Remove this Skip property to run this test\")]\r\n    public void Callback_cells_only_fire_on_change()\r\n    {\r\n        var sut = new Reactor();\r\n        var input = sut.CreateInputCell(1);\r\n        var output = sut.CreateComputeCell(new[] { input }, inputs => inputs[0] < 3 ? 111 : 222);\r\n        var callback1 = A.Fake<EventHandler<int>>();\r\n        output.Changed += callback1;\r\n        input.Value = 2;\r\n        A.CallTo(() => callback1.Invoke(A<object>._, A<int>._)).MustNotHaveHappened();\r\n        input.Value = 4;\r\n        A.CallTo(() => callback1.Invoke(A<object>._, 222)).MustHaveHappenedOnceExactly();\r\n        Fake.ClearRecordedCalls(callback1);\r\n    }\r\n\r\n    [Fact(Skip = \"Remove this Skip property to run this test\")]\r\n    public void Callbacks_do_not_report_already_reported_values()\r\n    {\r\n        var sut = new Reactor();\r\n        var input = sut.CreateInputCell(1);\r\n        var output = sut.CreateComputeCell(new[] { input }, inputs => inputs[0] + 1);\r\n        var callback1 = A.Fake<EventHandler<int>>();\r\n        output.Changed += callback1;\r\n        input.Value = 2;\r\n        A.CallTo(() => callback1.Invoke(A<object>._, 3)).MustHaveHappenedOnceExactly();\r\n        Fake.ClearRecordedCalls(callback1);\r\n        input.Value = 3;\r\n        A.CallTo(() => callback1.Invoke(A<object>._, 4)).MustHaveHappenedOnceExactly();\r\n        Fake.ClearRecordedCalls(callback1);\r\n    }\r\n\r\n    [Fact(Skip = \"Remove this Skip property to run this test\")]\r\n    public void Callbacks_can_fire_from_multiple_cells()\r\n    {\r\n        var sut = new Reactor();\r\n        var input = sut.CreateInputCell(1);\r\n        var plusOne = sut.CreateComputeCell(new[] { input }, inputs => inputs[0] + 1);\r\n        var minusOne = sut.CreateComputeCell(new[] { input }, inputs => inputs[0] - 1);\r\n        var callback1 = A.Fake<EventHandler<int>>();\r\n        plusOne.Changed += callback1;\r\n        var callback2 = A.Fake<EventHandler<int>>();\r\n        minusOne.Changed += callback2;\r\n        input.Value = 10;\r\n        A.CallTo(() => callback1.Invoke(A<object>._, 11)).MustHaveHappenedOnceExactly();\r\n        Fake.ClearRecordedCalls(callback1);\r\n        A.CallTo(() => callback2.Invoke(A<object>._, 9)).MustHaveHappenedOnceExactly();\r\n        Fake.ClearRecordedCalls(callback2);\r\n    }\r\n\r\n    [Fact(Skip = \"Remove this Skip property to run this test\")]\r\n    public void Callbacks_can_be_added_and_removed()\r\n    {\r\n        var sut = new Reactor();\r\n        var input = sut.CreateInputCell(11);\r\n        var output = sut.CreateComputeCell(new[] { input }, inputs => inputs[0] + 1);\r\n        var callback1 = A.Fake<EventHandler<int>>();\r\n        output.Changed += callback1;\r\n        var callback2 = A.Fake<EventHandler<int>>();\r\n        output.Changed += callback2;\r\n        input.Value = 31;\r\n        A.CallTo(() => callback1.Invoke(A<object>._, 32)).MustHaveHappenedOnceExactly();\r\n        Fake.ClearRecordedCalls(callback1);\r\n        A.CallTo(() => callback2.Invoke(A<object>._, 32)).MustHaveHappenedOnceExactly();\r\n        Fake.ClearRecordedCalls(callback2);\r\n        output.Changed -= callback1;\r\n        var callback3 = A.Fake<EventHandler<int>>();\r\n        output.Changed += callback3;\r\n        input.Value = 41;\r\n        A.CallTo(() => callback1.Invoke(A<object>._, A<int>._)).MustNotHaveHappened();\r\n    }\r\n\r\n    [Fact(Skip = \"Remove this Skip property to run this test\")]\r\n    public void Removing_a_callback_multiple_times_doesnt_interfere_with_other_callbacks()\r\n    {\r\n        var sut = new Reactor();\r\n        var input = sut.CreateInputCell(1);\r\n        var output = sut.CreateComputeCell(new[] { input }, inputs => inputs[0] + 1);\r\n        var callback1 = A.Fake<EventHandler<int>>();\r\n        output.Changed += callback1;\r\n        var callback2 = A.Fake<EventHandler<int>>();\r\n        output.Changed += callback2;\r\n        output.Changed -= callback1;\r\n        output.Changed -= callback1;\r\n        output.Changed -= callback1;\r\n        input.Value = 2;\r\n        A.CallTo(() => callback1.Invoke(A<object>._, A<int>._)).MustNotHaveHappened();\r\n    }\r\n\r\n    [Fact(Skip = \"Remove this Skip property to run this test\")]\r\n    public void Callbacks_should_only_be_called_once_even_if_multiple_dependencies_change()\r\n    {\r\n        var sut = new Reactor();\r\n        var input = sut.CreateInputCell(1);\r\n        var plusOne = sut.CreateComputeCell(new[] { input }, inputs => inputs[0] + 1);\r\n        var minusOne1 = sut.CreateComputeCell(new[] { input }, inputs => inputs[0] - 1);\r\n        var minusOne2 = sut.CreateComputeCell(new[] { minusOne1 }, inputs => inputs[0] - 1);\r\n        var output = sut.CreateComputeCell(new[] { plusOne, minusOne2 }, inputs => inputs[0] * inputs[1]);\r\n        var callback1 = A.Fake<EventHandler<int>>();\r\n        output.Changed += callback1;\r\n        input.Value = 4;\r\n        A.CallTo(() => callback1.Invoke(A<object>._, 10)).MustHaveHappenedOnceExactly();\r\n        Fake.ClearRecordedCalls(callback1);\r\n    }\r\n\r\n    [Fact(Skip = \"Remove this Skip property to run this test\")]\r\n    public void Callbacks_should_not_be_called_if_dependencies_change_but_output_value_doesnt_change()\r\n    {\r\n        var sut = new Reactor();\r\n        var input = sut.CreateInputCell(1);\r\n        var plusOne = sut.CreateComputeCell(new[] { input }, inputs => inputs[0] + 1);\r\n        var minusOne = sut.CreateComputeCell(new[] { input }, inputs => inputs[0] - 1);\r\n        var alwaysTwo = sut.CreateComputeCell(new[] { plusOne, minusOne }, inputs => inputs[0] - inputs[1]);\r\n        var callback1 = A.Fake<EventHandler<int>>();\r\n        alwaysTwo.Changed += callback1;\r\n        input.Value = 2;\r\n        A.CallTo(() => callback1.Invoke(A<object>._, A<int>._)).MustNotHaveHappened();\r\n        input.Value = 3;\r\n        A.CallTo(() => callback1.Invoke(A<object>._, A<int>._)).MustNotHaveHappened();\r\n        input.Value = 4;\r\n        A.CallTo(() => callback1.Invoke(A<object>._, A<int>._)).MustNotHaveHappened();\r\n        input.Value = 5;\r\n        A.CallTo(() => callback1.Invoke(A<object>._, A<int>._)).MustNotHaveHappened();\r\n    }\r\n}\r\n"
  }
}