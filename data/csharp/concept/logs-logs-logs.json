{
  "language": "csharp",
  "slug": "logs-logs-logs",
  "docs": {
    "introduction": "# Introduction\r\n\r\n## Enums\r\n\r\nThe C# `enum` type represents a fixed set of named constants (an enumeration). Its chief purpose is to provide a type-safe way of interacting with numeric constants, limiting the available values to a pre-defined set. A simple enum can be defined as follows:\r\n\r\n```csharp\r\nenum Season\r\n{\r\n    Spring,\r\n    Summer,\r\n    Autumn,\r\n    Winter\r\n}\r\n```\r\n\r\nIf not defined explicitly, enum members will automatically get assigned incrementing integer values, with the first value being zero. It is also possible to assign values explicitly:\r\n\r\n```csharp\r\nenum Answer\r\n{\r\n    Maybe = 1,\r\n    Yes = 3,\r\n    No = 5\r\n}\r\n```\r\n",
    "instructions": "# Instructions\r\n\r\nIn this exercise you'll be processing log-lines.\r\n\r\nEach log line is a string formatted as follows: `\"[<LVL>]: <MESSAGE>\"`.\r\n\r\nThese are the different log levels:\r\n\r\n- `TRC` (trace)\r\n- `DBG` (debug)\r\n- `INF` (info)\r\n- `WRN` (warning)\r\n- `ERR` (error)\r\n- `FTL` (fatal)\r\n\r\nYou have three tasks.\r\n\r\n## 1. Parse log level\r\n\r\nDefine a `LogLevel` enum that has six elements corresponding to the above log levels.\r\n\r\n- `Trace`\r\n- `Debug`\r\n- `Info`\r\n- `Warning`\r\n- `Error`\r\n- `Fatal`\r\n\r\nNext, implement the (_static_) `LogLine.ParseLogLevel()` method to parse the log level of a log line:\r\n\r\n```csharp\r\nLogLine.ParseLogLevel(\"[INF]: File deleted\")\r\n// => LogLevel.Info\r\n```\r\n\r\n## 2. Support unknown log level\r\n\r\nUnfortunately, occasionally some log lines have an unknown log level. To gracefully handle these log lines, add an `Unknown` element to the `LogLevel` enum which should be returned when parsing an unknown log level:\r\n\r\n```csharp\r\nLogLine.ParseLogLevel(\"[XYZ]: Overly specific, out of context message\")\r\n// => LogLevel.Unknown\r\n```\r\n\r\n## 3. Convert log line to short format\r\n\r\nThe log level of a log line is quite verbose. To reduce the disk space needed to store the log lines, a short format is developed: `\"[<ENCODED_LEVEL>]:<MESSAGE>\"`.\r\n\r\nThe encoded log level is a simple mapping of a log level to a number:\r\n\r\n- `Unknown` - `0`\r\n- `Trace` - `1`\r\n- `Debug` - `2`\r\n- `Info` - `4`\r\n- `Warning` - `5`\r\n- `Error` - `6`\r\n- `Fatal` - `42`\r\n\r\nImplement the (_static_) `LogLine.OutputForShortLog()` method that can output the shortened log line format:\r\n\r\n```csharp\r\nLogLine.OutputForShortLog(LogLevel.Error, \"Stack overflow\")\r\n// => \"6:Stack overflow\"\r\n```\r\n",
    "hints": "# Hints\r\n\r\n## General\r\n\r\n- [Tutorial on working with enums][docs.microsoft.com-enumeration-types].\r\n\r\n## 1. Parse log level\r\n\r\n- There is a [method to get a part of a string][docs.microsoft.com_system_string_substring].\r\n- You can use a [`switch` statement][docs.microsoft.com_keyword_switch] to elegantly handle the various log levels.\r\n\r\n## 2. Support unknown log level\r\n\r\n- There is a [special switch case][docs.microsoft.com_keyword_switch_default] that can be used to catch unspecified cases.\r\n\r\n## 3. Convert log line to short format\r\n\r\n- One can [assign specific values to enum members][docs.microsoft.com_creating-an-enumeration-type].\r\n- Converting an enum to a number can be done through [casting][docs.microsoft.com_enumeration-types-casting] or by using a [format string][docs.microsoft.com_system.enum.tostring].\r\n\r\n[docs.microsoft.com-enumeration-types]: https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/enumeration-types\r\n[docs.microsoft.com_system_string_substring]: https://docs.microsoft.com/en-us/dotnet/api/system.string.substring\r\n[docs.microsoft.com_keyword_switch]: https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/keywords/switch\r\n[docs.microsoft.com_keyword_switch_default]: https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/keywords/switch#the-default-case\r\n[docs.microsoft.com_enumeration-types-casting]: https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/enumeration-types#code-try-1\r\n[docs.microsoft.com_creating-an-enumeration-type]: https://docs.microsoft.com/en-us/dotnet/api/system.enum\r\n[docs.microsoft.com_system.enum.tostring]: https://docs.microsoft.com/en-us/dotnet/api/system.enum.tostring\r\n"
  },
  "starter_code": {
    "LogsLogsLogs.cs": "// TODO: define the 'LogLevel' enum\r\n\r\nstatic class LogLine\r\n{\r\n    public static LogLevel ParseLogLevel(string logLine)\r\n    {\r\n        throw new NotImplementedException(\"Please implement the (static) LogLine.ParseLogLevel() method\");\r\n    }\r\n\r\n    public static string OutputForShortLog(LogLevel logLevel, string message)\r\n    {\r\n        throw new NotImplementedException(\"Please implement the (static) LogLine.OutputForShortLog() method\");\r\n    }\r\n}\r\n"
  },
  "tests": {
    "LogsLogsLogsTests.cs": "using Exercism.Tests;\r\n\r\npublic class LogsLogsLogsTests\r\n{\r\n    [Fact]\r\n    [Task(1)]\r\n    public void Parse_trace()\r\n    {\r\n        Assert.Equal(LogLevel.Trace, LogLine.ParseLogLevel(\"[TRC]: Line 84 - Console.WriteLine('Hello World');\"));\r\n    }\r\n\r\n    [Fact]\r\n    [Task(1)]\r\n    public void Parse_debug()\r\n    {\r\n        Assert.Equal(LogLevel.Debug, LogLine.ParseLogLevel(\"[DBG]: ; expected\"));\r\n    }\r\n\r\n    [Fact]\r\n    [Task(1)]\r\n    public void Parse_info()\r\n    {\r\n        Assert.Equal(LogLevel.Info, LogLine.ParseLogLevel(\"[INF]: Timezone changed\"));\r\n    }\r\n\r\n    [Fact]\r\n    [Task(1)]\r\n    public void Parse_warning()\r\n    {\r\n        Assert.Equal(LogLevel.Warning, LogLine.ParseLogLevel(\"[WRN]: Timezone not set\"));\r\n    }\r\n\r\n    [Fact]\r\n    [Task(1)]\r\n    public void Parse_error()\r\n    {\r\n        Assert.Equal(LogLevel.Error, LogLine.ParseLogLevel(\"[ERR]: Disk full\"));\r\n    }\r\n\r\n    [Fact]\r\n    [Task(1)]\r\n    public void Parse_fatal()\r\n    {\r\n        Assert.Equal(LogLevel.Fatal, LogLine.ParseLogLevel(\"[FTL]: Not enough memory\"));\r\n    }\r\n\r\n    [Fact]\r\n    [Task(2)]\r\n    public void Parse_unknown()\r\n    {\r\n        Assert.Equal(LogLevel.Unknown, LogLine.ParseLogLevel(\"[XYZ]: Gibberish message.. beep boop..\"));\r\n    }\r\n\r\n    [Fact]\r\n    [Task(3)]\r\n    public void Output_for_short_log_for_trace()\r\n    {\r\n        Assert.Equal(\"1:Line 13 - int myNum = 42;\", LogLine.OutputForShortLog(LogLevel.Trace, \"Line 13 - int myNum = 42;\"));\r\n    }\r\n\r\n    [Fact]\r\n    [Task(3)]\r\n    public void Output_for_short_log_for_debug()\r\n    {\r\n        Assert.Equal(\"2:The name 'LogLevel' does not exist in the current context\", LogLine.OutputForShortLog(LogLevel.Debug, \"The name 'LogLevel' does not exist in the current context\"));\r\n    }\r\n\r\n    [Fact]\r\n    [Task(3)]\r\n    public void Output_for_short_log_for_info()\r\n    {\r\n        Assert.Equal(\"4:File moved\", LogLine.OutputForShortLog(LogLevel.Info, \"File moved\"));\r\n    }\r\n\r\n    [Fact]\r\n    [Task(3)]\r\n    public void Output_for_short_log_for_warning()\r\n    {\r\n        Assert.Equal(\"5:Unsafe password\", LogLine.OutputForShortLog(LogLevel.Warning, \"Unsafe password\"));\r\n    }\r\n\r\n    [Fact]\r\n    [Task(3)]\r\n    public void Output_for_short_log_for_error()\r\n    {\r\n        Assert.Equal(\"6:Stack overflow\", LogLine.OutputForShortLog(LogLevel.Error, \"Stack overflow\"));\r\n    }\r\n\r\n    [Fact]\r\n    [Task(3)]\r\n    public void Output_for_short_log_for_fatal()\r\n    {\r\n        Assert.Equal(\"42:Dumping all files\", LogLine.OutputForShortLog(LogLevel.Fatal, \"Dumping all files\"));\r\n    }\r\n\r\n    [Fact]\r\n    [Task(3)]\r\n    public void Output_for_short_log_for_unknown()\r\n    {\r\n        Assert.Equal(\"0:Something unknown happened\", LogLine.OutputForShortLog(LogLevel.Unknown, \"Something unknown happened\"));\r\n    }\r\n}\r\n"
  }
}