{
  "language": "csharp",
  "slug": "the-weather-in-deather",
  "docs": {
    "introduction": "# Introduction\r\n\r\n## Expression Bodied Members\r\n\r\nMany types of struct and class members (fields being the primary exception) can use the expression-bodied member syntax. Defining a member with an expression often produces more concise and readable code than traditional blocks/statements.\r\n\r\nMethods and read-only properties are amongst the members that can be defined with expression bodies.\r\n\r\n```csharp\r\npublic int Times3(int input) => input * 3;\r\n\r\npublic int Interesting => 1729;\r\n```\r\n\r\n## Switch Expressions\r\n\r\nA switch expression can match a value to one case in a set of patterns and return the associated value or take the associated action. The association is denoted by the `=>` symbol. In addition, each pattern can have an optional case guard introduced with the `when` keyword. The case guard expression must evaluate to true for that \"arm\" of the switch to be selected. The cases (also known as _switch arms_) are evaluated in text order and the process is cut short and the associated value is returned as soon as a match is found.\r\n\r\n```csharp\r\ndouble xx = 42d;\r\n\r\nstring interesting = xx switch\r\n{\r\n    0 => \"I suppose zero is interesting\",\r\n    3.14 when DateTime.Now.Day == 14 && DateTime.Now.Month == 3 => \"Mmm pie!\",\r\n    3.14 => \"π\",\r\n    42 => \"a bit of a cliché\",\r\n    1729 => \"only if you are a pure mathematician\",\r\n    _ => \"not interesting\"\r\n};\r\n\r\n// => interesting == \"a bit of a cliché\"\r\n```\r\n\r\n## Conditionals Ternary\r\n\r\nTernary operators allow if-conditions to be defined in expressions rather than statement blocks. This echoes functional programming approaches and can often make code more expressive and less error-prone.\r\n\r\nThe ternary operator combines 3 expressions: a condition followed by an expression to be evaluated and returned if the condition is true (the `if` part, introduced by `?`) and an expression to be evaluated and returned if the condition is false (the `else` part, introduced by `:`).\r\n\r\n```csharp\r\nint a = 3, b = 4;\r\nint max = a > b ? a : b;\r\n// => 4\r\n```\r\n\r\n## Throw Expressions\r\n\r\n`throw` expressions are an alternative to `throw` statements and in particular can add to the power of ternary and other compound expressions.\r\n\r\n```csharp\r\nstring trimmed = str == null ? throw new ArgumentException() : str.Trim();\r\n```\r\n",
    "instructions": "# Instructions\r\n\r\nYou have been asked to improve some legacy code relating to a weather station.\r\n\r\nThe weather station accepts readings, and outputs some indicators such as temperature and pressure.\r\n\r\n## 1. Improve the conciseness and readability of appropriate methods\r\n\r\nRefactor any appropriate methods of the `WeatherStation` class using expression bodied members. Use ternary operations and switch expressions where appropriate to improve expressiveness and potentially reduce errors.\r\n\r\nEnsure that all tests continue to pass.\r\n",
    "hints": "# General\r\n\r\n- Expression bodied members are discussed [here][expression-bodied-members].\r\n- Ternary operators are discussed [here][ternary-operators].\r\n- Switch expressions are discussed [here][switch-expressions].\r\n- Throw expressions are covered [here][throw-expressions].\r\n\r\n[expression-bodied-members]: https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/statements-expressions-operators/expression-bodied-members\r\n[ternary-operators]: https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/operators/conditional-operator\r\n[switch-expressions]: https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/operators/switch-expression\r\n[throw-expressions]: https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/keywords/throw#the-throw-expression\r\n"
  },
  "starter_code": {
    "TheWeatherInDeather.cs": "public class WeatherStation\r\n{\r\n    private Reading reading;\r\n    private List<DateTime> recordDates = new List<DateTime>();\r\n    private List<decimal> temperatures = new List<decimal>();\r\n\r\n    public void AcceptReading(Reading reading)\r\n    {\r\n        this.reading = reading;\r\n        recordDates.Add(DateTime.Now);\r\n        temperatures.Add(reading.Temperature);\r\n    }\r\n\r\n    public void ClearAll()\r\n    {\r\n        reading = new Reading();\r\n        recordDates.Clear();\r\n        temperatures.Clear();\r\n    }\r\n\r\n    public decimal LatestTemperature\r\n    {\r\n        get\r\n        {\r\n            return reading.Temperature;\r\n        }\r\n    }\r\n\r\n    public decimal LatestPressure\r\n    {\r\n        get\r\n        {\r\n            return reading.Pressure;\r\n        }\r\n    }\r\n\r\n    public decimal LatestRainfall\r\n    {\r\n        get\r\n        {\r\n            return reading.Rainfall;\r\n        }\r\n    }\r\n\r\n    public bool HasHistory\r\n    {\r\n        get\r\n        {\r\n            if (recordDates.Count > 1)\r\n            {\r\n                return true;\r\n            }\r\n            else\r\n            {\r\n                return false;\r\n            }\r\n        }\r\n    }\r\n\r\n    public Outlook ShortTermOutlook\r\n    {\r\n        get\r\n        {\r\n            if (reading.Equals(new Reading()))\r\n            {\r\n                throw new ArgumentException();\r\n            }\r\n            else\r\n            {\r\n                if (reading.Pressure < 10m && reading.Temperature < 30m)\r\n                {\r\n                    return Outlook.Cool;\r\n                }\r\n                else if (reading.Temperature > 50)\r\n                {\r\n                    return Outlook.Good;\r\n                }\r\n                else\r\n                {\r\n                    return Outlook.Warm;\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    public Outlook LongTermOutlook\r\n    {\r\n        get\r\n        {\r\n            if (reading.WindDirection == WindDirection.Southerly\r\n                || reading.WindDirection == WindDirection.Easterly\r\n                && reading.Temperature > 20)\r\n            {\r\n                return Outlook.Good;\r\n            }\r\n            if (reading.WindDirection == WindDirection.Northerly)\r\n            {\r\n                return Outlook.Cool;\r\n            }\r\n            if (reading.WindDirection == WindDirection.Easterly\r\n                && reading.Temperature <= 20)\r\n            {\r\n                return Outlook.Warm;\r\n            }\r\n            if (reading.WindDirection == WindDirection.Westerly)\r\n            {\r\n                return Outlook.Rainy;\r\n            }\r\n            throw new ArgumentException();\r\n        }\r\n    }\r\n\r\n    public State RunSelfTest()\r\n    {\r\n        if (reading.Equals(new Reading()))\r\n        {\r\n            return State.Bad;\r\n        }\r\n        else\r\n        {\r\n            return State.Good;\r\n        }\r\n    }\r\n}\r\n\r\n/*** Please do not modify this struct ***/\r\npublic struct Reading\r\n{\r\n    public decimal Temperature { get; }\r\n    public decimal Pressure { get; }\r\n    public decimal Rainfall { get; }\r\n    public WindDirection WindDirection { get; }\r\n\r\n    public Reading(decimal temperature, decimal pressure,\r\n        decimal rainfall, WindDirection windDirection)\r\n    {\r\n        Temperature = temperature;\r\n        Pressure = pressure;\r\n        Rainfall = rainfall;\r\n        WindDirection = windDirection;\r\n    }\r\n}\r\n\r\n/*** Please do not modify this enum ***/\r\npublic enum State\r\n{\r\n    Good,\r\n    Bad\r\n}\r\n\r\n/*** Please do not modify this enum ***/\r\npublic enum Outlook\r\n{\r\n    Cool,\r\n    Rainy,\r\n    Warm,\r\n    Good\r\n}\r\n\r\n/*** Please do not modify this enum ***/\r\npublic enum WindDirection\r\n{\r\n    Unknown, // default\r\n    Northerly,\r\n    Easterly,\r\n    Southerly,\r\n    Westerly\r\n}\r\n"
  },
  "tests": {
    "TheWeatherInDeatherTests.cs": "using Exercism.Tests;\r\n\r\npublic class TheWeatherInDeatherTests\r\n{\r\n    [Fact]\r\n    [Task(1)]\r\n    public void GetReading()\r\n    {\r\n        var ws = new WeatherStation();\r\n        ws.AcceptReading(new Reading(20m, 25m, 0.01m, WindDirection.Unknown));\r\n        decimal[] expected = { 20, 25, 0.01m };\r\n        decimal[] actual = { ws.LatestTemperature, ws.LatestPressure, ws.LatestRainfall };\r\n        Assert.Equal(expected, actual);\r\n    }\r\n\r\n    [Fact]\r\n    [Task(1)]\r\n    public void HasHistory_no()\r\n    {\r\n        var ws = new WeatherStation();\r\n        ws.AcceptReading(new Reading(20m, 25m, 0.01m, WindDirection.Unknown));\r\n        Assert.False(ws.HasHistory);\r\n    }\r\n\r\n    [Fact]\r\n    [Task(1)]\r\n    public void HasHistory_yes()\r\n    {\r\n        var ws = new WeatherStation();\r\n        ws.AcceptReading(new Reading(20m, 25m, 0.01m, WindDirection.Unknown));\r\n        ws.AcceptReading(new Reading(21m, 25m, 0.00m, WindDirection.Unknown));\r\n        Assert.True(ws.HasHistory);\r\n    }\r\n\r\n    [Fact]\r\n    [Task(1)]\r\n    public void ClearAll()\r\n    {\r\n        var ws = new WeatherStation();\r\n        ws.AcceptReading(new Reading(20m, 25m, 0.01m, WindDirection.Unknown));\r\n        ws.AcceptReading(new Reading(21m, 25m, 0.00m, WindDirection.Unknown));\r\n        ws.ClearAll();\r\n        object[] expected = { false, 0m };\r\n        object[] actual = { ws.HasHistory, ws.LatestTemperature };\r\n        Assert.Equal(expected, actual);\r\n    }\r\n\r\n    [Fact]\r\n    [Task(1)]\r\n    public void ShortTermOutlook_exception()\r\n    {\r\n        var ws = new WeatherStation();\r\n        Assert.Throws<ArgumentException>(() => ws.ShortTermOutlook);\r\n    }\r\n\r\n    [Fact]\r\n    [Task(1)]\r\n    public void ShortTermOutlook_cool()\r\n    {\r\n        var ws = new WeatherStation();\r\n        ws.AcceptReading(new Reading(7m, 7m, 0m, WindDirection.Unknown));\r\n        Assert.Equal(Outlook.Cool, ws.ShortTermOutlook);\r\n    }\r\n\r\n    [Fact]\r\n    [Task(1)]\r\n    public void ShortTermOutlook_good()\r\n    {\r\n        var ws = new WeatherStation();\r\n        ws.AcceptReading(new Reading(55m, 7m, 0m, WindDirection.Unknown));\r\n        Assert.Equal(Outlook.Good, ws.ShortTermOutlook);\r\n    }\r\n\r\n    [Fact]\r\n    [Task(1)]\r\n    public void ShortTermOutlook_warm()\r\n    {\r\n        var ws = new WeatherStation();\r\n        ws.AcceptReading(new Reading(40m, 7m, 0m, WindDirection.Unknown));\r\n        Assert.Equal(Outlook.Warm, ws.ShortTermOutlook);\r\n    }\r\n\r\n    [Fact]\r\n    [Task(1)]\r\n    public void RunSelfTest_good()\r\n    {\r\n        var ws = new WeatherStation();\r\n        ws.AcceptReading(new Reading(40m, 7m, 0m, WindDirection.Unknown));\r\n        Assert.Equal(State.Good, ws.RunSelfTest());\r\n    }\r\n\r\n    [Fact]\r\n    [Task(1)]\r\n    public void RunSelfTest_bad()\r\n    {\r\n        var ws = new WeatherStation();\r\n        Assert.Equal(State.Bad, ws.RunSelfTest());\r\n    }\r\n\r\n    [Fact]\r\n    [Task(1)]\r\n    public void LongTermOutlook_exception()\r\n    {\r\n        var ws = new WeatherStation();\r\n        Assert.Throws<ArgumentException>(() => ws.LongTermOutlook);\r\n    }\r\n\r\n    [Fact]\r\n    [Task(1)]\r\n    public void LongTermOutlook_cool()\r\n    {\r\n        var ws = new WeatherStation();\r\n        ws.AcceptReading(new Reading(7m, 7m, 0m, WindDirection.Northerly));\r\n        Assert.Equal(Outlook.Cool, ws.LongTermOutlook);\r\n    }\r\n\r\n    [Fact]\r\n    [Task(1)]\r\n    public void LongTermOutlook_good()\r\n    {\r\n        var ws = new WeatherStation();\r\n        ws.AcceptReading(new Reading(21m, 7m, 0m, WindDirection.Easterly));\r\n        Assert.Equal(Outlook.Good, ws.LongTermOutlook);\r\n    }\r\n\r\n    [Fact]\r\n    [Task(1)]\r\n    public void LongTermOutlook_good2()\r\n    {\r\n        var ws = new WeatherStation();\r\n        ws.AcceptReading(new Reading(7m, 7m, 0m, WindDirection.Southerly));\r\n        Assert.Equal(Outlook.Good, ws.LongTermOutlook);\r\n    }\r\n\r\n    [Fact]\r\n    [Task(1)]\r\n    public void LongTermOutlook_warm()\r\n    {\r\n        var ws = new WeatherStation();\r\n        ws.AcceptReading(new Reading(7m, 7m, 0m, WindDirection.Easterly));\r\n        Assert.Equal(Outlook.Warm, ws.LongTermOutlook);\r\n    }\r\n\r\n    [Fact]\r\n    [Task(1)]\r\n    public void LongTermOutlook_rainy()\r\n    {\r\n        var ws = new WeatherStation();\r\n        ws.AcceptReading(new Reading(21m, 7m, 0m, WindDirection.Westerly));\r\n        Assert.Equal(Outlook.Rainy, ws.LongTermOutlook);\r\n    }\r\n}\r\n"
  }
}