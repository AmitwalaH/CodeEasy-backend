{
  "language": "csharp",
  "slug": "red-vs-blue-darwin-style",
  "docs": {
    "introduction": "# Introduction\r\n\r\n## Namespaces\r\n\r\nNamespaces are a way to group related code and to avoid name clashes and are generally present in all but the most trivial code base.\r\n\r\nThe syntax is as follows:\r\n\r\n```csharp\r\nnamespace MyNameSpace\r\n{\r\n    public class MyClass {}\r\n\r\n    public class OtherClass {}\r\n}\r\n```\r\n\r\nTypes enclosed in namespaces are referred to outside the scope of the namespace by prefixing the type name with the dot syntax. Alternatively, and more usually, you can place a `using` directive at the top of the file (or within a namespace) and type can be used without the prefix. Within the same namespace there is no need to qualify type names.\r\n\r\n```csharp\r\nnamespace MySpace\r\n{\r\n    public class MyClass {}\r\n\r\n    public class Foo\r\n    {\r\n        public void Bar()\r\n        {\r\n            var baz = new MyClass();\r\n        }\r\n    }\r\n}\r\n\r\npublic class Qux\r\n{\r\n    public void Box()\r\n    {\r\n        var nux = new MySpace.MyClass();\r\n    }\r\n}\r\n\r\nnamespace OtherSpace\r\n{\r\n    using MySpace;\r\n\r\n    public class Tix\r\n    {\r\n        public void Jeg()\r\n        {\r\n            var lor = new MyClass();\r\n        }\r\n    }\r\n}\r\n```\r\n\r\nYou can alias a namespace with the syntax `using MyAlias = MySpace;` and then use the alias anywhere that the namespace could be used.\r\n",
    "instructions": "# Instructions\r\n\r\nManagement are starting to apply Darwinian principles to the Remote Control Car project [exercise:csharp/remote-control-competition](). The developers have been split into two teams, _Red_ and _Blue_, and are tasked with improving the design independently of each other. They don't need to concern themselves with design decisions of the other team.\r\n\r\nYou have been asked to take a look at the code and see how you can best combine the two efforts for testing purposes.\r\n\r\n## 1. Find a more appropriate way of isolating the code of the two teams\r\n\r\nPlease use `namespaces` to better express the intention of the code.\r\n\r\nCurrently, important types like `Motor` and `Telemetry`, not to mention `RemoteControlCar` itself, are nested within an enclosing static class, `<Color>RemoteControlCarTeam`. The only purpose of the enclosing class is to allow types with the same name to coexist in the program. That is better expressed by using a namespace. You will see in the next exercise that, for these purposes, a `namespace` has advantages over a `static class`.\r\n\r\n## 2. Simplify the naming system\r\n\r\nWhilst management are adamant that the teams should be called `RedRemoteControlCarTeam` and `BlueRemoteControlCarTeam` in the definitions, the names are rather cumbersome when referencing the teams. Find a way to use the shorter identifiers `Red` and `Blue` when building the cars.\r\n",
    "hints": "# Hints\r\n\r\n## General\r\n\r\n- [Namespaces][namespaces]: how to define and import namespaces.\r\n- [Accessibility levels][accessibility-levels]: use the `public/internal/private` access modifiers.\r\n\r\n## 1. Find a more appropriate way of isolating the code of the two teams\r\n\r\n- See this [article][namespaces] which discusses the syntax of namespaces.\r\n\r\n## 2. Simplify the naming system\r\n\r\n- See this [article][using] on the `using` directive.\r\n\r\n[namespaces]: https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/namespaces/\r\n[accessibility-levels]: https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/keywords/accessibility-levels\r\n[using]: https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/keywords/using-directive\r\n"
  },
  "starter_code": {
    "RedVsBlueDarwinStyle.cs": "public static class RedRemoteControlCarTeam\r\n{\r\n    public class RemoteControlCar\r\n    {\r\n        public RemoteControlCar(Motor motor, Chassis chassis, Telemetry telemetry, RunningGear runningGear)\r\n        {\r\n        }\r\n        // red members and API\r\n    }\r\n\r\n    public class RunningGear\r\n    {\r\n        // red members and API\r\n    }\r\n\r\n    public class Telemetry\r\n    {\r\n        // red members and API\r\n    }\r\n\r\n    public class Chassis\r\n    {\r\n        // red members and API\r\n    }\r\n\r\n    public class Motor\r\n    {\r\n        // red members and API\r\n    }\r\n}\r\n\r\npublic static class BlueRemoteControlCarTeam\r\n{\r\n    public class RemoteControlCar\r\n    {\r\n        public RemoteControlCar(Motor motor, Chassis chassis, Telemetry telemetry)\r\n        {\r\n        }\r\n        // blue members and API\r\n    }\r\n\r\n    public class Telemetry\r\n    {\r\n        // blue members and API\r\n    }\r\n\r\n    public class Chassis\r\n    {\r\n        // blue members and API\r\n    }\r\n\r\n    public class Motor\r\n    {\r\n        // blue members and API\r\n    }\r\n}\r\n\r\npublic static class CarBuilder\r\n{\r\n    public static RedRemoteControlCarTeam.RemoteControlCar BuildRed()\r\n    {\r\n        return new RedRemoteControlCarTeam.RemoteControlCar(\r\n            new RedRemoteControlCarTeam.Motor(),\r\n            new RedRemoteControlCarTeam.Chassis(),\r\n            new RedRemoteControlCarTeam.Telemetry(),\r\n            new RedRemoteControlCarTeam.RunningGear()\r\n        );\r\n    }\r\n\r\n    public static BlueRemoteControlCarTeam.RemoteControlCar BuildBlue()\r\n    {\r\n        return new BlueRemoteControlCarTeam.RemoteControlCar(\r\n            new BlueRemoteControlCarTeam.Motor(),\r\n            new BlueRemoteControlCarTeam.Chassis(),\r\n            new BlueRemoteControlCarTeam.Telemetry()\r\n        );\r\n    }\r\n}\r\n"
  },
  "tests": {
    "RedVsBlueDarwinStyleTests.cs": "using Exercism.Tests;\r\n\r\npublic class RedVsBlueDarwinStyleTests\r\n{\r\n    [Fact]\r\n    [Task(1)]\r\n    public void Namespace_for_CarBuilder_is_Combined()\r\n    {\r\n        var carBuilderType = Type.GetType(\"Combined.CarBuilder\");\r\n        Assert.NotNull(carBuilderType);\r\n    }\r\n\r\n    [Fact]\r\n    [Task(1)]\r\n    public void Namespace_for_CarBuilder_has_method_BuildBlue()\r\n    {\r\n        var carBuilderType = Type.GetType(\"Combined.CarBuilder\");\r\n        Assert.NotNull(carBuilderType?.GetMethod(\"BuildBlue\"));\r\n    }\r\n\r\n    [Fact]\r\n    [Task(1)]\r\n    public void Namespace_for_CarBuilder_has_method_BuildRed()\r\n    {\r\n        var carBuilderType = Type.GetType(\"Combined.CarBuilder\");\r\n        Assert.NotNull(carBuilderType?.GetMethod(\"BuildRed\"));\r\n    }\r\n\r\n    [Fact]\r\n    [Task(1)]\r\n    public void Namespace_for_CarBuilder_returns_Blue_Type()\r\n    {\r\n        var carBuilderType = Type.GetType(\"Combined.CarBuilder\");\r\n        var returnType = carBuilderType?.GetMethod(\"BuildBlue\")?.ReturnType;\r\n        Assert.Equal(\"BlueRemoteControlCarTeam.RemoteControlCar\", returnType?.FullName);\r\n    }\r\n\r\n    [Fact]\r\n    [Task(1)]\r\n    public void Namespace_for_CarBuilder_returns_Red_Type()\r\n    {\r\n        var carBuilderType = Type.GetType(\"Combined.CarBuilder\");\r\n        var returnType = carBuilderType?.GetMethod(\"BuildRed\")?.ReturnType;\r\n        Assert.Equal(\"RedRemoteControlCarTeam.RemoteControlCar\", returnType?.FullName);\r\n    }\r\n\r\n    [Fact]\r\n    [Task(1)]\r\n    public void Namespace_for_CarBuilder_can_BuildBlue_car()\r\n    {\r\n        var carBuilderType = Type.GetType(\"Combined.CarBuilder\");\r\n        var blueRemoteControlCar = carBuilderType?.GetMethod(\"BuildBlue\")?.Invoke(null, null);\r\n        Assert.NotNull(blueRemoteControlCar);\r\n    }\r\n\r\n    [Fact]\r\n    [Task(1)]\r\n    public void Namespace_for_CarBuilder_can_BuildRed_car()\r\n    {\r\n        var carBuilderType = Type.GetType(\"Combined.CarBuilder\");\r\n        var redRemoteControlCar = carBuilderType?.GetMethod(\"BuildRed\")?.Invoke(null, null);\r\n        Assert.NotNull(redRemoteControlCar);\r\n    }\r\n}\r\n"
  }
}