{
  "language": "csharp",
  "slug": "hyper-optimized-telemetry",
  "docs": {
    "introduction": "# Introduction\r\n\r\n## Integral Numbers\r\n\r\nC#, like many statically typed languages, provides a number of types that represent integers, each with its own range of values. At the low end, the `sbyte` type has a minimum value of -128 and a maximum value of 127. Like all the integer types these values are available as `<type>.MinValue` and `<type>.MaxValue`. At the high end, the `long` type has a minimum value of -9,223,372,036,854,775,808 and a maximum value of 9,223,372,036,854,775,807. In between lie the `short` and `int` types.\r\n\r\nThe ranges are determined by the storage width of the type as allocated by the system. For example, a `byte` uses 8 bits and a `long` uses 64 bits.\r\n\r\nEach of the above types is paired with an unsigned equivalent: `sbyte`/`byte`, `short`/`ushort`, `int`/`uint` and `long`/`ulong`. In all cases the range of the values is from 0 to the negative signed maximum times 2 plus 1.\r\n\r\n| Type   | Width  | Minimum                    | Maximum                     |\r\n| ------ | ------ | -------------------------- | --------------------------- |\r\n| sbyte  | 8 bit  | -128                       | +127                        |\r\n| short  | 16 bit | -32_768                    | +32_767                     |\r\n| int    | 32 bit | -2_147_483_648             | +2_147_483_647              |\r\n| long   | 64 bit | -9_223_372_036_854_775_808 | +9_223_372_036_854_775_807  |\r\n| byte   | 8 bit  | 0                          | +255                        |\r\n| ushort | 16 bit | 0                          | +65_535                     |\r\n| uint   | 32 bit | 0                          | +4_294_967_295              |\r\n| ulong  | 64 bit | 0                          | +18_446_744_073_709_551_615 |\r\n\r\nA variable (or expression) of one type can easily be converted to another. For instance, in an assignment operation, if the type of the value being assigned (lhs) ensures that the value will lie within the range of the type being assigned to (rhs) then there is a simple assignment:\r\n\r\n```csharp\r\nuint ui = uint.MaxValue;\r\nulong ul = ui;    // no problem\r\n```\r\n\r\nOn the other hand if the range of type being assigned from is not a subset of the assignee's range of values then a cast, `()` operation is required even if the particular value is within the assignee's range:\r\n\r\n```csharp\r\nshort s = 42;\r\nuint ui = (uint)s;\r\n```\r\n\r\n### Bit conversion\r\n\r\nThe `BitConverter` class provides a convenient way of converting integer types to and from arrays of bytes.\r\n",
    "instructions": "# Instructions\r\n\r\nWork continues on the remote control car project. Bandwidth in the telemetry system is at a premium and you have been asked to implement a message protocol for communicating telemetry data.\r\n\r\nData is transmitted in a buffer (byte array). When integers are sent, the size of the buffer is reduced by employing the protocol described below.\r\n\r\nEach value should be represented in the smallest possible integral type (types of `byte` and `sbyte` are not included as the saving would be trivial):\r\n\r\n| From                       | To                        | Type     |\r\n| -------------------------- | ------------------------- | -------- |\r\n| 4_294_967_296              | 9_223_372_036_854_775_807 | `long`   |\r\n| 2_147_483_648              | 4_294_967_295             | `uint`   |\r\n| 65_536                     | 2_147_483_647             | `int`    |\r\n| 0                          | 65_535                    | `ushort` |\r\n| -32_768                    | -1                        | `short`  |\r\n| -2_147_483_648             | -32_769                   | `int`    |\r\n| -9_223_372_036_854_775_808 | -2_147_483_649            | `long`   |\r\n\r\nThe value should be converted to the appropriate number of bytes for its assigned type. The complete buffer comprises a byte indicating the number of additional bytes in the buffer (_prefix byte_) followed by the bytes holding the integer (_payload bytes_).\r\n\r\nSome of the types use an identical number of bytes (e.g. the `uint` and `int` types). Normally, they would have the same _prefix byte_, but that would make decoding problematic. To counter this, the protocol introduces a little trick: for signed types, their _prefix byte_ value is `256` minus the number of additional bytes in the buffer.\r\n\r\nOnly the prefix byte and the number of following bytes indicated by the prefix will be sent in the communication. Internally a 9 byte buffer is used (with trailing zeroes, as necessary) both by sending and receiving routines.\r\n\r\n## 1. Encode an integral value ready to send\r\n\r\nPlease implement the static method `TelemetryBuffer.ToBuffer()` to encode a buffer taking the parameter passed to the method.\r\n\r\n```csharp\r\n// Type: ushort, bytes: 2, signed: no, prefix byte: 2\r\nTelemetryBuffer.ToBuffer(5)\r\n// => {0x2, 0x5, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0 };\r\n\r\n// Type: int, bytes: 4, signed: yes, prefix byte: 256 - 4\r\nTelemetryBuffer.ToBuffer(Int32.MaxValue)\r\n// => {0xfc, 0xff, 0xff, 0xff, 0x7f, 0x0, 0x0, 0x0, 0x0 };\r\n```\r\n\r\n## 2. Decode a received buffer\r\n\r\nPlease implement the static method `TelemetryBuffer.FromBuffer()` to decode the buffer received and return the value in the form of a `long`.\r\n\r\n```csharp\r\nTelemetryBuffer.FromBuffer(new byte[] {0xfc, 0xff, 0xff, 0xff, 0x7f, 0x0, 0x0, 0x0, 0x0 })\r\n// => 2147483647\r\n```\r\n\r\nIf the prefix byte is of unexpected value then `0` should be returned.\r\n",
    "hints": "# Hints\r\n\r\n## General\r\n\r\n- [Integral numeric types][integral-numeric-types]: overview of the integral numeric types.\r\n- [Numeric conversions][numeric-conversions]: overview of implicit and explicit numeric conversions.\r\n\r\n## 1. Encode an integral value ready to send\r\n\r\n- Conversion to a byte array is dealt with [here][bit-converter-get-bytes]\r\n\r\n## 2. Decode a received buffer\r\n\r\n- Converting from a byte array is discussed [here][bit-converter-to-type]\r\n\r\n[integral-numeric-types]: https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/builtin-types/integral-numeric-types\r\n[numeric-conversions]: https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/builtin-types/numeric-conversions\r\n[bit-converter-get-bytes]: https://docs.microsoft.com/en-us/dotnet/api/system.bitconverter.getbytes\r\n[bit-converter-to-type]: https://docs.microsoft.com/en-us/dotnet/api/system.bitconverter.toint16\r\n"
  },
  "starter_code": {
    "HyperOptimizedTelemetry.cs": "public static class TelemetryBuffer\r\n{\r\n    public static byte[] ToBuffer(long reading)\r\n    {\r\n        throw new NotImplementedException(\"Please implement the static TelemetryBuffer.ToBuffer() method\");\r\n    }\r\n\r\n    public static long FromBuffer(byte[] buffer)\r\n    {\r\n        throw new NotImplementedException(\"Please implement the static TelemetryBuffer.FromBuffer() method\");\r\n    }\r\n}\r\n"
  },
  "tests": {
    "HyperOptimizedTelemetryTests.cs": "using Exercism.Tests;\r\n\r\npublic class HyperOptimizedTelemetryTests\r\n{\r\n    [Fact]\r\n    [Task(1)]\r\n    public void ToBuffer_upper_long()\r\n    {\r\n        var bytes = TelemetryBuffer.ToBuffer(Int64.MaxValue);\r\n        Assert.Equal(new byte[] { 0xf8, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x7f }, bytes);\r\n    }\r\n\r\n    [Fact]\r\n    [Task(1)]\r\n    public void ToBuffer_lower_long()\r\n    {\r\n        var bytes = TelemetryBuffer.ToBuffer((long)UInt32.MaxValue + 1);\r\n        Assert.Equal(new byte[] { 0xf8, 0x0, 0x0, 0x0, 0x0, 0x1, 0x0, 0x0, 0x0 }, bytes);\r\n    }\r\n\r\n    [Fact]\r\n    [Task(1)]\r\n    public void ToBuffer_upper_uint()\r\n    {\r\n        var bytes = TelemetryBuffer.ToBuffer(UInt32.MaxValue);\r\n        Assert.Equal(new byte[] { 0x4, 0xff, 0xff, 0xff, 0xff, 0x0, 0x0, 0x0, 0x0 }, bytes);\r\n    }\r\n\r\n    [Fact]\r\n    [Task(1)]\r\n    public void ToBuffer_lower_uint()\r\n    {\r\n        var bytes = TelemetryBuffer.ToBuffer((long)Int32.MaxValue + 1);\r\n        Assert.Equal(new byte[] { 0x4, 0x0, 0x0, 0x0, 0x80, 0x0, 0x0, 0x0, 0x0 }, bytes);\r\n    }\r\n\r\n    [Fact]\r\n    [Task(1)]\r\n    public void ToBuffer_upper_int()\r\n    {\r\n        var bytes = TelemetryBuffer.ToBuffer(Int32.MaxValue);\r\n        Assert.Equal(new byte[] { 0xfc, 0xff, 0xff, 0xff, 0x7f, 0x0, 0x0, 0x0, 0x0 }, bytes);\r\n    }\r\n\r\n    [Fact]\r\n    [Task(1)]\r\n    public void ToBuffer_lower_int()\r\n    {\r\n        var bytes = TelemetryBuffer.ToBuffer((long)UInt16.MaxValue + 1);\r\n        Assert.Equal(new byte[] { 0xfc, 0x0, 0x0, 0x1, 0x0, 0x0, 0x0, 0x0, 0x0 }, bytes);\r\n    }\r\n\r\n    [Fact]\r\n    [Task(1)]\r\n    public void ToBuffer_upper_ushort()\r\n    {\r\n        var bytes = TelemetryBuffer.ToBuffer(UInt16.MaxValue);\r\n        Assert.Equal(new byte[] { 0x2, 0xff, 0xff, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0 }, bytes);\r\n    }\r\n\r\n    [Fact]\r\n    [Task(1)]\r\n    public void ToBuffer_lower_ushort()\r\n    {\r\n        var bytes = TelemetryBuffer.ToBuffer((long)Int16.MaxValue + 1);\r\n        Assert.Equal(new byte[] { 0x2, 0x0, 0x80, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0 }, bytes);\r\n    }\r\n\r\n    [Fact]\r\n    [Task(1)]\r\n    public void ToBuffer_upper_short()\r\n    {\r\n        var bytes = TelemetryBuffer.ToBuffer(Int16.MaxValue);\r\n        Assert.Equal(new byte[] { 0x2, 0xff, 0x7f, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0 }, bytes);\r\n    }\r\n\r\n    [Fact]\r\n    [Task(1)]\r\n    public void ToBuffer_Zero()\r\n    {\r\n        var bytes = TelemetryBuffer.ToBuffer(0);\r\n        Assert.Equal(new byte[] { 0x2, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0 }, bytes);\r\n    }\r\n\r\n    [Fact]\r\n    [Task(1)]\r\n    public void ToBuffer_upper_neg_short()\r\n    {\r\n        var bytes = TelemetryBuffer.ToBuffer(-1);\r\n        Assert.Equal(new byte[] { 0xfe, 0xff, 0xff, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0 }, bytes);\r\n    }\r\n\r\n    [Fact]\r\n    [Task(1)]\r\n    public void ToBuffer_lower_neg_short()\r\n    {\r\n        var bytes = TelemetryBuffer.ToBuffer(Int16.MinValue);\r\n        Assert.Equal(new byte[] { 0xfe, 0x0, 0x80, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0 }, bytes);\r\n    }\r\n\r\n    [Fact]\r\n    [Task(1)]\r\n    public void ToBuffer_upper_neg_int()\r\n    {\r\n        int n = Int16.MinValue - 1;\r\n        var bytes = TelemetryBuffer.ToBuffer(n);\r\n        Assert.Equal(new byte[] { 0xfc, 0xff, 0x7f, 0xff, 0xff, 0x0, 0x0, 0x0, 0x0 }, bytes);\r\n    }\r\n\r\n    [Fact]\r\n    [Task(1)]\r\n    public void ToBuffer_lower_neg_int()\r\n    {\r\n        var bytes = TelemetryBuffer.ToBuffer(Int32.MinValue);\r\n        Assert.Equal(new byte[] { 0xfc, 0x0, 0x0, 0x0, 0x80, 0x0, 0x0, 0x0, 0x0 }, bytes);\r\n    }\r\n\r\n    [Fact]\r\n    [Task(1)]\r\n    public void ToBuffer_upper_neg_long()\r\n    {\r\n        var bytes = TelemetryBuffer.ToBuffer((long)Int32.MinValue - 1);\r\n        Assert.Equal(new byte[] { 0xf8, 0xff, 0xff, 0xff, 0x7f, 0xff, 0xff, 0xff, 0xff }, bytes);\r\n    }\r\n\r\n    [Fact]\r\n    [Task(1)]\r\n    public void ToBuffer_lower_neg_long()\r\n    {\r\n        var bytes = TelemetryBuffer.ToBuffer(Int64.MinValue);\r\n        Assert.Equal(new byte[] { 0xf8, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x80 }, bytes);\r\n    }\r\n\r\n    [Fact]\r\n    [Task(2)]\r\n    public void FromBuffer_Invalid()\r\n    {\r\n        Assert.Equal(0,\r\n            TelemetryBuffer.FromBuffer(new byte[] { 22, 0xff, 0xff, 0xff, 0x7f, 0, 0, 0, 0 }));\r\n    }\r\n\r\n    [Fact]\r\n    [Task(2)]\r\n    public void FromBuffer_upper_long()\r\n    {\r\n        Assert.Equal(Int64.MaxValue,\r\n            TelemetryBuffer.FromBuffer(new byte[] { 0xf8, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x7f }));\r\n    }\r\n\r\n    [Fact]\r\n    [Task(2)]\r\n    public void FromBuffer_lower_long()\r\n    {\r\n        Assert.Equal((long)UInt32.MaxValue + 1,\r\n            TelemetryBuffer.FromBuffer(new byte[] { 0xf8, 0x0, 0x0, 0x0, 0x0, 0x1, 0x0, 0x0, 0x0 }));\r\n    }\r\n\r\n    [Fact]\r\n    [Task(2)]\r\n    public void FromBuffer_upper_uint()\r\n    {\r\n        Assert.Equal(UInt32.MaxValue,\r\n            TelemetryBuffer.FromBuffer(new byte[] { 0x4, 0xff, 0xff, 0xff, 0xff, 0x0, 0x0, 0x0, 0x0 }));\r\n    }\r\n\r\n    [Fact]\r\n    [Task(2)]\r\n    public void FromBuffer_lower_uint()\r\n    {\r\n        Assert.Equal((long)Int32.MaxValue + 1,\r\n            TelemetryBuffer.FromBuffer(new byte[] { 0x4, 0x0, 0x0, 0x0, 0x80, 0x0, 0x0, 0x0, 0x0 }));\r\n    }\r\n\r\n    [Fact]\r\n    [Task(2)]\r\n    public void FromBuffer_upper_int()\r\n    {\r\n        Assert.Equal(Int32.MaxValue,\r\n            TelemetryBuffer.FromBuffer(new byte[] { 0xfc, 0xff, 0xff, 0xff, 0x7f, 0x0, 0x0, 0x0, 0x0 }));\r\n    }\r\n\r\n    [Fact]\r\n    [Task(2)]\r\n    public void FromBuffer_lower_int()\r\n    {\r\n        Assert.Equal(UInt16.MaxValue + 1,\r\n            TelemetryBuffer.FromBuffer(new byte[] { 0xfc, 0x0, 0x0, 0x1, 0x0, 0x0, 0x0, 0x0, 0x0 }));\r\n    }\r\n\r\n    [Fact]\r\n    [Task(2)]\r\n    public void FromBuffer_upper_ushort()\r\n    {\r\n        Assert.Equal(UInt16.MaxValue,\r\n            TelemetryBuffer.FromBuffer(new byte[] { 0x2, 0xff, 0xff, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0 }));\r\n    }\r\n\r\n    [Fact]\r\n    [Task(2)]\r\n    public void FromBuffer_lower_ushort()\r\n    {\r\n        Assert.Equal(Int16.MaxValue + 1,\r\n            TelemetryBuffer.FromBuffer(new byte[] { 0x2, 0x0, 0x80, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0 }));\r\n    }\r\n\r\n    [Fact]\r\n    [Task(2)]\r\n    public void FromBuffer_upper_short()\r\n    {\r\n        Assert.Equal(Int16.MaxValue,\r\n            TelemetryBuffer.FromBuffer(new byte[] { 0xfe, 0xff, 0x7f, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0 }));\r\n    }\r\n\r\n    [Fact]\r\n    [Task(2)]\r\n    public void FromBuffer_Zero()\r\n    {\r\n        Assert.Equal(0,\r\n            TelemetryBuffer.FromBuffer(new byte[] { 0xfe, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0 }));\r\n    }\r\n\r\n    [Fact]\r\n    [Task(2)]\r\n    public void FromBuffer_upper_neg_short()\r\n    {\r\n        Assert.Equal(-1,\r\n            TelemetryBuffer.FromBuffer(new byte[] { 0xfe, 0xff, 0xff, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0 }));\r\n    }\r\n\r\n    [Fact]\r\n    [Task(2)]\r\n    public void FromBuffer_lower_neg_short()\r\n    {\r\n        Assert.Equal(Int16.MinValue,\r\n            TelemetryBuffer.FromBuffer(new byte[] { 0xfe, 0x0, 0x80, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0 }));\r\n    }\r\n\r\n    [Fact]\r\n    [Task(2)]\r\n    public void FromBuffer_upper_neg_int()\r\n    {\r\n        Assert.Equal(Int16.MinValue - 1,\r\n            TelemetryBuffer.FromBuffer(new byte[] { 0xfc, 0xff, 0x7f, 0xff, 0xff, 0x0, 0x0, 0x0, 0x0 }));\r\n    }\r\n\r\n    [Fact]\r\n    [Task(2)]\r\n    public void FromBuffer_lower_neg_int()\r\n    {\r\n        Assert.Equal(Int32.MinValue,\r\n            TelemetryBuffer.FromBuffer(new byte[] { 0xfc, 0x0, 0x0, 0x0, 0x80, 0x0, 0x0, 0x0, 0x0 }));\r\n    }\r\n\r\n    [Fact]\r\n    [Task(2)]\r\n    public void FromBuffer_upper_neg_long()\r\n    {\r\n        Assert.Equal((long)Int32.MinValue - 1,\r\n            TelemetryBuffer.FromBuffer(new byte[] { 0xf8, 0xff, 0xff, 0xff, 0x7f, 0xff, 0xff, 0xff, 0xff }));\r\n    }\r\n\r\n    [Fact]\r\n    [Task(2)]\r\n    public void FromBuffer_lower_neg_long()\r\n    {\r\n        Assert.Equal(Int64.MinValue,\r\n            TelemetryBuffer.FromBuffer(new byte[] { 0xf8, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x80 }));\r\n    }\r\n}"
  }
}