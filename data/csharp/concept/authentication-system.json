{
  "language": "csharp",
  "slug": "authentication-system",
  "docs": {
    "introduction": "# Introduction\r\n\r\n## Constants\r\n\r\nThe `const` modifier can be (and generally should be) applied to any field where its value is known at compile time and will not change during the lifetime of the program.\r\n\r\n```csharp\r\nprivate const int num = 1729;\r\npublic const string title = \"Grand\" + \" Master\";\r\n```\r\n\r\nThe `readonly` modifier can be (and generally should be) applied to any field that cannot be made `const` where its value will not change during the lifetime of the program and is either set by an inline initializer or during instantiation (by the constructor or a method called by the constructor).\r\n\r\n```csharp\r\nprivate readonly int num;\r\nprivate readonly System.Random rand = new System.Random();\r\n\r\npublic MyClass(int num)\r\n{\r\n    this.num = num;\r\n}\r\n```\r\n\r\n## Defensive Copying\r\n\r\nIn security sensitive situations (or even simply on a large code-base where developers have different priorities and agendas) you should avoid allowing a class's public API to be circumvented by accepting and storing a method's mutable parameters or by exposing a mutable member of a class through a return value or as an `out` parameter.\r\n\r\n## Readonly Collections\r\n\r\nWhile the `readonly` modifier prevents the value or reference in a field from being overwritten, it offers no protection for the members of a reference type.\r\n\r\n```csharp\r\nreadonly List<int> ints = new List<int>();\r\n\r\nvoid Foo()\r\n{\r\n    ints.Add(1);    // ok\r\n    ints = new List<int>(); // fails to compile\r\n}\r\n```\r\n\r\nTo ensure that all members of a reference type are protected the fields can be made `readonly` and automatic properties can be defined without a `set` accessor.\r\n\r\nThe Base Class Library (BCL) provides some readonly versions of collections where there is a requirement to stop members of a collections being updated. These come in the form of wrappers:\r\n\r\n- `ReadOnlyDictionary<T>` exposes a `Dictionary<T>` as read-only.\r\n- `ReadOnlyCollection<T>` exposes a `List<T>` as read-only.\r\n",
    "instructions": "# Instructions\r\n\r\nThe authentication system that you last saw in [exercise:csharp/developer-privileges]() is in need of some attention. You have been tasked with cleaning up the code. Such a cleanup project will not only make life easy for future maintainers but will expose and fix some security vulnerabilities.\r\n\r\n## 1. Set appropriate fields and properties to const\r\n\r\nThis is a refactoring task. Add the `const` modifier to any members of `Authenticator` or `Identity` that you think appropriate.\r\n\r\n## 2. Set appropriate fields to readonly\r\n\r\nThis is a refactoring task. Add the `readonly` modifier to any fields of the `Authenticator` class or the `Identity` struct that you think appropriate.\r\n\r\n## 3. Ensure that the class cannot be changed once it has been created\r\n\r\nRemove the `set` accessor or make it `private` for any appropriate property on the `Authenticator` class or `Identity` struct.\r\n\r\n## 4. Ensure that the admin cannot be tampered with\r\n\r\nAt present the admin identity field is returned by a call to `Admin`. This is not ideal as the caller can modify the field. Find a way to prevent the caller from modifying the details of admin on the `Authenticator` object.\r\n\r\n## 5. Ensure that the developers cannot be tampered with\r\n\r\nAt present the dictionary containing the hard coded privileged developer identities is returned by a call to `GetDevelopers()`. This is not ideal as the caller can modify the dictionary. Find a way to prevent the caller from modifying the details of developers on the `Authenticator` object.\r\n",
    "hints": "# Hints\r\n\r\n## General\r\n\r\n- [Readonly fields][readonly-fields]: how to define a readonly field.\r\n- [Constants][constants]: how to define constants.\r\n\r\n## 1. Set appropriate fields and properties to const\r\n\r\n- Constants in C# are discussed [here][constants].\r\n\r\n## 2. Set appropriate fields to readonly\r\n\r\n- Read-only fields are discussed [here][readonly-fields].\r\n\r\n## 3. Remove set accessor or make it private for any appropriate field\r\n\r\n- This [article][properties] discusses C# properties.\r\n\r\n## 4. Ensure that the admin cannot be tampered with\r\n\r\n- See [this][defensive-copying] discussion on the pattern and purpose of defensive copying.\r\n\r\n## 5. Ensure that the developers cannot be tampered with\r\n\r\n- Read-only dictionaries are discussed [here][readonly-dictionaries].\r\n\r\n[readonly-fields]: https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/keywords/readonly#readonly-field-example\r\n[constants]: https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/classes-and-structs/constants\r\n[properties]: https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/classes-and-structs/properties\r\n[defensive-copying]: https://www.informit.com/articles/article.aspx?p=31551&seqNum=2\r\n[readonly-dictionaries]: https://docs.microsoft.com/en-us/dotnet/api/system.collections.objectmodel.readonlydictionary-2\r\n"
  },
  "starter_code": {
    "AuthenticationSystem.cs": "public class Authenticator\r\n{\r\n    private class EyeColor\r\n    {\r\n        public string Blue = \"blue\";\r\n        public string Green = \"green\";\r\n        public string Brown = \"brown\";\r\n        public string Hazel = \"hazel\";\r\n        public string Grey = \"grey\";\r\n    }\r\n\r\n    public Authenticator(Identity admin)\r\n    {\r\n        this.admin = admin;\r\n    }\r\n\r\n    private Identity admin;\r\n\r\n    private IDictionary<string, Identity> developers\r\n        = new Dictionary<string, Identity>\r\n        {\r\n            [\"Bertrand\"] = new Identity\r\n            {\r\n                Email = \"bert@ex.ism\",\r\n                EyeColor = \"blue\"\r\n            },\r\n\r\n            [\"Anders\"] = new Identity\r\n            {\r\n                Email = \"anders@ex.ism\",\r\n                EyeColor = \"brown\"\r\n            }\r\n        };\r\n\r\n    public Identity Admin\r\n    {\r\n        get { return admin; }\r\n        set { admin = value; }\r\n    }\r\n\r\n    public IDictionary<string, Identity> GetDevelopers()\r\n    {\r\n        return developers;\r\n    }\r\n}\r\n\r\npublic struct Identity\r\n{\r\n    public string Email { get; set; }\r\n\r\n    public string EyeColor { get; set; }\r\n}\r\n"
  },
  "tests": {
    "AuthenticationSystemTests.cs": "using Exercism.Tests;\r\n\r\npublic class AuthenticationSystemTests\r\n{\r\n    [Fact]\r\n    [Task(4)]\r\n    public void GetAdmin()\r\n    {\r\n        var admin = new Identity { EyeColor = \"green\", Email = \"admin@ex.ism\" };\r\n        var authenticator = new Authenticator(admin);\r\n        Assert.Equal(admin, authenticator.Admin);\r\n    }\r\n\r\n    [Fact]\r\n    [Task(4)]\r\n    public void CheckAdminCannotBeTampered()\r\n    {\r\n        var adminEmail = \"admin@ex.ism\";\r\n        var admin = new Identity { EyeColor = \"green\", Email = adminEmail };\r\n        var authenticator = new Authenticator(admin);\r\n        var tamperedAdmin = authenticator.Admin;\r\n        tamperedAdmin.Email = \"admin@hack.ed\";\r\n        Assert.Equal(adminEmail, authenticator.Admin.Email);\r\n    }\r\n\r\n    [Fact]\r\n    [Task(5)]\r\n    public void GetDevelopers()\r\n    {\r\n        var authenticator = new Authenticator(new Identity { EyeColor = \"green\", Email = \"admin@ex.ism\" });\r\n        var devs = authenticator.GetDevelopers() as IDictionary<string, Identity>;\r\n        bool?[] actual = { devs != null, devs?.Count == 2, devs?[\"Anders\"].EyeColor == \"brown\" };\r\n        bool?[] expected = { true, true, true };\r\n        Assert.Equal(expected, actual);\r\n    }\r\n\r\n    [Fact]\r\n    [Task(5)]\r\n    public void CheckDevelopersCannotBeTampered()\r\n    {\r\n        var authenticator = new Authenticator(new Identity { EyeColor = \"green\", Email = \"admin@ex.ism\" });\r\n        IDictionary<string, Identity> devs = authenticator.GetDevelopers();\r\n\r\n        Identity tamperedDev = new Identity { EyeColor = \"grey\", Email = \"anders@hack.ed\" };\r\n        Assert.Throws<NotSupportedException>(() => devs[\"Anders\"] = tamperedDev);\r\n    }\r\n}\r\n"
  }
}