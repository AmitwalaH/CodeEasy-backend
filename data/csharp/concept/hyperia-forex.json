{
  "language": "csharp",
  "slug": "hyperia-forex",
  "docs": {
    "introduction": "# Introduction\r\n\r\n## Operator Overloading\r\n\r\nThe principal arithmetic and comparison operators can be adapted for use by your own classes and structs. This is known as _operator overloading_.\r\n\r\nMost operators have the form:\r\n\r\n```csharp\r\nstatic <return type> operator <operator symbols>(<parameters>);\r\n```\r\n\r\nCast operators have the form:\r\n\r\n```csharp\r\nstatic (explicit|implicit) operator <cast-to-type>(<cast-from-type> <parameter name>);\r\n```\r\n\r\nOperators behave in the same way as static methods. An operator symbol takes the place of a method identifier, and they have parameters and a return type. The type rules for parameters and return type follow your intuition and you can rely on the compiler to provide detailed guidance.\r\n",
    "instructions": "# Instructions\r\n\r\nYou've been tempted back to Hyperia (with the high inflation) for an eye watering daily rate.\r\n\r\nThe Central Bank is contemplating introducing the US Dollar as a second currency so all the accounting systems have to be adapted to handle multiple currencies.\r\n\r\nYou have been asked to implement the currency amount object.\r\n\r\n## 1. Enable the currency amount to be tested for equality\r\n\r\nPlease modify the `CurrencyAmount` struct to handle equality. If the two currency amount structs do not have the same currency (\"USD\" or \"HD\") then an instance of `ArgumentException` should be thrown.\r\n\r\n```csharp\r\nCurrencyAmount amountA = new CurrencyAmount(55, \"HD\");\r\nCurrencyAmount amountB = new CurrencyAmount(55, \"HD\");\r\nCurrencyAmount amountC = new CurrencyAmount(55, \"USD\");\r\namountA == amountB\r\n// => true\r\namountA != amountB\r\n// => false\r\namountA == amountC\r\n// => ArgumentException\r\namountA != amountC\r\n// => ArgumentException\r\n```\r\n\r\n## 2. Compare currency amounts\r\n\r\nPlease modify the `CurrencyAmount` struct to handle comparisons (`>` and `<`, only). If the two currency amount structs do not have the same currency (\"USD\" or \"HD\") then an instance of `ArgumentException` should be thrown.\r\n\r\n```csharp\r\nCurrencyAmount amountA = new CurrencyAmount(55, \"HD\");\r\namountA > new CurrencyAmount(50, \"HD\")\r\n// => true\r\namountA < new CurrencyAmount(50, \"HD\")\r\n// => false\r\namountA > new CurrencyAmount(50, \"USD\")\r\n// => ArgumentException\r\n```\r\n\r\n## 3. Add and subtract currency amounts\r\n\r\nPlease modify the `CurrencyAmount` struct to handle arithmetic addition and subtraction (`+` and `-`, only). If the two currency amount structs do not have the same currency (\"USD\" or \"HD\") then an instance of `ArgumentException` should be thrown.\r\n\r\n```csharp\r\nCurrencyAmount amountA = new CurrencyAmount(55, \"HD\");\r\nCurrencyAmount amountB = new CurrencyAmount(100, \"HD\");\r\nCurrencyAmount amountC = new CurrencyAmount(55, \"USD\");\r\namountA + amountB\r\n// => {155, HD}\r\namountB - amountA\r\n// => {45, HD}\r\namountA + amountC\r\n// => ArgumentException\r\n```\r\n\r\n## 4. Multiply and divide currency amounts\r\n\r\nPlease modify the `CurrencyAmount` struct to handle arithmetic multiplication and division (`*` and `/`, only).\r\n\r\n```csharp\r\nCurrencyAmount amountA = new CurrencyAmount(10, \"HD\");\r\namountA * 2m\r\n// => {20, HD}\r\namountA / 2m\r\n// => {5, HD}\r\n```\r\n\r\n## 5. Convert the currency amount to a double\r\n\r\nPlease modify the `CurrencyAmount` struct so that an instance can be explicitly cast to a `double`.\r\n\r\n```csharp\r\nCurrencyAmount amountA = new CurrencyAmount(55.5m, \"HD\");\r\n(double)amountA\r\n// => 55.5d\r\n```\r\n\r\n## 6. Convert the currency amount to a decimal\r\n\r\nPlease modify the `CurrencyAmount` struct so that an instance can be implicitly converted to a `decimal`.\r\n\r\n```csharp\r\nCurrencyAmount amountA = new CurrencyAmount(55.5m, \"HD\");\r\ndecimal d = amountA;\r\n// => d == 55.5m\r\n```\r\n",
    "hints": "# Hints\r\n\r\n## General\r\n\r\n- This documentation of [operator overloading][operator-overloading] details the syntax.\r\n\r\n## 1. Enable the currency amount to be tested for equality\r\n\r\n- See [this][operator-overloading] for equality operators.\r\n\r\n## 2. Compare currency amounts\r\n\r\n- See [this][operator-overloading] for comparison operators.\r\n\r\n## 3. Add and subtract currency amounts\r\n\r\n- See [this][operator-overloading] for sum and difference operators.\r\n\r\n## 4. Multiply and divide currency amounts\r\n\r\n- See [this][operator-overloading] for product and division operators.\r\n\r\n## 5. Convert the currency amount to a double\r\n\r\n- See [this][ud-conversion-operators] for conversion operators.\r\n\r\n## 5. Convert the currency amount to a decimal\r\n\r\n- See [this][ud-conversion-operators] for conversion operators.\r\n\r\n[operator-overloading]: https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/operators/operator-overloading\r\n[ud-conversion-operators]: https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/operators/user-defined-conversion-operators\r\n"
  },
  "starter_code": {
    "HyperiaForex.cs": "public struct CurrencyAmount\r\n{\r\n    private decimal amount;\r\n    private string currency;\r\n\r\n    public CurrencyAmount(decimal amount, string currency)\r\n    {\r\n        this.amount = amount;\r\n        this.currency = currency;\r\n    }\r\n\r\n    // TODO: implement equality operators\r\n\r\n    // TODO: implement comparison operators\r\n\r\n    // TODO: implement arithmetic operators\r\n\r\n    // TODO: implement type conversion operators\r\n}\r\n"
  },
  "tests": {
    "HyperiaForexTests.cs": "using FsCheck;\r\n\r\nusing Exercism.Tests;\r\n\r\nusing FsCheck.Fluent;\r\n\r\npublic class HyperiaForexTests\r\n{\r\n    [Fact]\r\n    [Task(1)]\r\n    public void Equality_with_same_currency()\r\n    {\r\n        Prop.ForAll<decimal>(value =>\r\n        {\r\n            var amount1 = new CurrencyAmount(value, \"HD\");\r\n            var amount2 = new CurrencyAmount(value, \"HD\");\r\n\r\n            Assert.True(amount1 == amount2);\r\n        }).QuickCheckThrowOnFailure();\r\n    }\r\n\r\n    [Fact]\r\n    [Task(1)]\r\n    public void Equality_with_different_currency()\r\n    {\r\n        Prop.ForAll<decimal>(value =>\r\n        {\r\n            var amount1 = new CurrencyAmount(value, \"HD\");\r\n            var amount2 = new CurrencyAmount(value, \"USD\");\r\n\r\n            Assert.Throws<ArgumentException>(() => amount1 == amount2);\r\n        }).QuickCheckThrowOnFailure();\r\n    }\r\n\r\n    [Fact]\r\n    [Task(1)]\r\n    public void Inequality_with_same_currency()\r\n    {\r\n        Prop.ForAll<(decimal, decimal)>(values =>\r\n        {\r\n            var amount1 = new CurrencyAmount(values.Item1, \"HD\");\r\n            var amount2 = new CurrencyAmount(values.Item2, \"HD\");\r\n\r\n            return Prop.When(values.Item1 != values.Item2, () => Assert.True(amount1 != amount2));\r\n        }).QuickCheckThrowOnFailure();\r\n    }\r\n\r\n    [Fact]\r\n    [Task(1)]\r\n    public void Inequality_with_different_currency()\r\n    {\r\n        Prop.ForAll<(decimal, decimal)>(values =>\r\n        {\r\n            var amount1 = new CurrencyAmount(values.Item1, \"HD\");\r\n            var amount2 = new CurrencyAmount(values.Item2, \"USD\");\r\n\r\n            Assert.Throws<ArgumentException>(() => amount1 != amount2);\r\n        }).QuickCheckThrowOnFailure();\r\n    }\r\n\r\n    [Fact]\r\n    [Task(2)]\r\n    public void LessThan_with_same_currency()\r\n    {\r\n        Prop.ForAll<(decimal, decimal)>(values =>\r\n        {\r\n            var amount1 = new CurrencyAmount(values.Item1, \"HD\");\r\n            var amount2 = new CurrencyAmount(values.Item2, \"HD\");\r\n\r\n            return Prop.When(values.Item1 < values.Item2, () => Assert.True(amount1 < amount2));\r\n        }).QuickCheckThrowOnFailure();\r\n    }\r\n\r\n    [Fact]\r\n    [Task(2)]\r\n    public void LessThan_with_different_currency()\r\n    {\r\n        Prop.ForAll<(decimal, decimal)>(values =>\r\n        {\r\n            var amount1 = new CurrencyAmount(values.Item1, \"HD\");\r\n            var amount2 = new CurrencyAmount(values.Item2, \"USD\");\r\n\r\n            Assert.Throws<ArgumentException>(() => amount1 < amount2);\r\n        }).QuickCheckThrowOnFailure();\r\n    }\r\n\r\n    [Fact]\r\n    [Task(2)]\r\n    public void GreaterThan_with_same_currency()\r\n    {\r\n        Prop.ForAll<(decimal, decimal)>(values =>\r\n        {\r\n            var amount1 = new CurrencyAmount(values.Item1, \"HD\");\r\n            var amount2 = new CurrencyAmount(values.Item2, \"HD\");\r\n\r\n            return Prop.When(values.Item1 > values.Item2, () => Assert.True(amount1 > amount2));\r\n        }).QuickCheckThrowOnFailure();\r\n    }\r\n\r\n    [Fact]\r\n    [Task(2)]\r\n    public void GreaterThan_with_different_currency()\r\n    {\r\n        Prop.ForAll<(decimal, decimal)>(values =>\r\n        {\r\n            var amount1 = new CurrencyAmount(values.Item1, \"HD\");\r\n            var amount2 = new CurrencyAmount(values.Item2, \"USD\");\r\n\r\n            Assert.Throws<ArgumentException>(() => amount1 > amount2);\r\n        }).QuickCheckThrowOnFailure();\r\n    }\r\n\r\n    [Fact]\r\n    [Task(3)]\r\n    public void Addition_with_same_currency()\r\n    {\r\n        Prop.ForAll<(decimal, decimal)>(values =>\r\n        {\r\n            var amount1 = new CurrencyAmount(values.Item1, \"HD\");\r\n            var amount2 = new CurrencyAmount(values.Item2, \"HD\");\r\n            var expected = new CurrencyAmount(values.Item1 + values.Item2, \"HD\");\r\n\r\n            Assert.Equal(expected, amount1 + amount2);\r\n        }).QuickCheckThrowOnFailure();\r\n    }\r\n\r\n    [Fact]\r\n    [Task(3)]\r\n    public void Addition_is_commutative()\r\n    {\r\n        Prop.ForAll<(decimal, decimal)>(values =>\r\n        {\r\n            var amount1 = new CurrencyAmount(values.Item1, \"HD\");\r\n            var amount2 = new CurrencyAmount(values.Item2, \"HD\");\r\n\r\n            Assert.Equal(amount1 + amount2, amount2 + amount1);\r\n        }).QuickCheckThrowOnFailure();\r\n    }\r\n\r\n    [Fact]\r\n    [Task(3)]\r\n    public void Addition_with_different_currency()\r\n    {\r\n        Prop.ForAll<(decimal, decimal)>(values =>\r\n        {\r\n            var amount1 = new CurrencyAmount(values.Item1, \"HD\");\r\n            var amount2 = new CurrencyAmount(values.Item2, \"USD\");\r\n\r\n            Assert.Throws<ArgumentException>(() => amount1 + amount2);\r\n        }).QuickCheckThrowOnFailure();\r\n    }\r\n\r\n    [Fact]\r\n    [Task(3)]\r\n    public void Subtraction_with_same_currency()\r\n    {\r\n        Prop.ForAll<(decimal, decimal)>(values =>\r\n        {\r\n            var amount1 = new CurrencyAmount(values.Item1, \"HD\");\r\n            var amount2 = new CurrencyAmount(values.Item2, \"HD\");\r\n            var expected = new CurrencyAmount(values.Item1 - values.Item2, \"HD\");\r\n\r\n            Assert.Equal(expected, amount1 - amount2);\r\n        }).QuickCheckThrowOnFailure();\r\n    }\r\n\r\n    [Fact]\r\n    [Task(3)]\r\n    public void Subtraction_with_different_currency()\r\n    {\r\n        Prop.ForAll<(decimal, decimal)>(values =>\r\n        {\r\n            var amount1 = new CurrencyAmount(values.Item1, \"HD\");\r\n            var amount2 = new CurrencyAmount(values.Item2, \"USD\");\r\n\r\n            Assert.Throws<ArgumentException>(() => amount1 - amount2);\r\n        }).QuickCheckThrowOnFailure();\r\n    }\r\n\r\n    [Fact]\r\n    [Task(4)]\r\n    public void Multiplication()\r\n    {\r\n        Prop.ForAll<(decimal, decimal)>(values =>\r\n        {\r\n            var (value, factor) = values;\r\n            Assert.Equal(new CurrencyAmount(factor * value, \"HD\"),\r\n                factor * new CurrencyAmount(value, \"HD\"));\r\n        }).QuickCheckThrowOnFailure();\r\n    }\r\n\r\n    [Fact]\r\n    [Task(4)]\r\n    public void Multiplication_is_commutative()\r\n    {\r\n        Prop.ForAll<(decimal, decimal)>(values =>\r\n        {\r\n            var (value, factor) = values;\r\n            var amount = new CurrencyAmount(value, \"HD\");\r\n\r\n            Assert.Equal(amount * factor, factor * amount);\r\n        }).QuickCheckThrowOnFailure();\r\n    }\r\n\r\n    [Fact]\r\n    [Task(4)]\r\n    public void Division()\r\n    {\r\n        Prop.ForAll<(decimal, decimal)>(values =>\r\n        {\r\n            var (value, divisor) = values;\r\n            return Prop.When(\r\n                divisor != 0,\r\n                () => Assert.True(new CurrencyAmount(value, \"HD\") / divisor ==\r\n                                  new CurrencyAmount(value / divisor, \"HD\")));\r\n        }).QuickCheckThrowOnFailure();\r\n    }\r\n\r\n    [Fact]\r\n    [Task(5)]\r\n    public void Cast_to_double()\r\n    {\r\n        Prop.ForAll<decimal>(value =>\r\n        {\r\n            Assert.Equal(Convert.ToDouble(value), (double)new CurrencyAmount(value, \"HD\"));\r\n        }).QuickCheckThrowOnFailure();\r\n    }\r\n\r\n    [Fact]\r\n    [Task(6)]\r\n    public void Cast_to_decimal()\r\n    {\r\n        Prop.ForAll<decimal>(value =>\r\n        {\r\n            decimal actual = new CurrencyAmount(value, \"HD\");\r\n            Assert.Equal(value, actual);\r\n        }).QuickCheckThrowOnFailure();\r\n    }\r\n}"
  }
}