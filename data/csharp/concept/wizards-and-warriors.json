{
  "language": "csharp",
  "slug": "wizards-and-warriors",
  "docs": {
    "introduction": "# Introduction\r\n\r\n## Inheritance\r\n\r\nIn C#, a _class_ hierarchy can be defined using _inheritance_, which allows a derived class (`Car`) to inherit the behavior and data of its parent class (`Vehicle`). If no parent is specified, the class inherits from the `object` class.\r\n\r\nParent classes can provide functionality to derived classes in three ways:\r\n\r\n- Define a regular method.\r\n- Define a `virtual` method, which is like a regular method but one that derived classes _can_ change.\r\n- Define an `abstract` method, which is a method without an implementation that derived classes _must_ implement. A class with `abstract` methods must be marked as `abstract` too. Abstract classes cannot be instantiated.\r\n\r\nThe `protected` access modifier allows a parent class member to be accessed in a derived class, but blocks access from other classes.\r\n\r\nDerived classes can access parent class members through the `base` keyword.\r\n\r\n```csharp\r\n// Inherits from the 'object' class\r\nabstract class Vehicle\r\n{\r\n    // Can be overridden\r\n    public virtual void Drive()\r\n    {\r\n    }\r\n\r\n    // Must be overridden\r\n    protected abstract int Speed();\r\n}\r\n\r\nclass Car : Vehicle\r\n{\r\n    public override void Drive()\r\n    {\r\n        // Override virtual method\r\n\r\n        // Call parent implementation\r\n        base.Drive();\r\n    }\r\n\r\n    protected override int Speed()\r\n    {\r\n        // Implement abstract method\r\n    }\r\n}\r\n```\r\n\r\nThe constructor of a derived class will automatically call its parent's constructor _before_ executing its own constructor's logic. Arguments can be passed to a parent class' constructor using the `base` keyword:\r\n\r\n```csharp\r\nabstract class Vehicle\r\n{\r\n    protected Vehicle(int wheels)\r\n    {\r\n        Console.WriteLine(\"Called first\");\r\n    }\r\n}\r\n\r\nclass Car : Vehicle\r\n{\r\n    public Car() : base(4)\r\n    {\r\n        Console.WriteLine(\"Called second\");\r\n    }\r\n}\r\n```\r\n\r\nWhere more than one class is derived from a base class the two (or more) classes will often implement different versions of a base class method. This is a very important principle called polymorphism. For instance in a variation on the above example we show how code using `Vehicle` can change its behavior depending on what type of vehicle has been instantiated.\r\n\r\n```csharp\r\nabstract class Vehicle\r\n{\r\n   public abstract string GetDescription();\r\n}\r\n\r\nclass Car : Vehicle\r\n{\r\n   public Car()\r\n   {\r\n   }\r\n\r\n   public override string GetDescription()\r\n   {\r\n      return \"Runabout\";\r\n   }\r\n}\r\n\r\nclass Rig : Vehicle\r\n{\r\n   public Rig()\r\n   {\r\n   }\r\n\r\n   public override string GetDescription()\r\n   {\r\n      return \"Big Rig\";\r\n   }\r\n}\r\n\r\nVehicle v1 = new Car();\r\nVehicle v2 = new Rig();\r\n\r\nv1.GetDescription();\r\n// => Runabout\r\nv2.GetDescription();\r\n// => Big Rig\r\n```\r\n",
    "instructions": "# Instructions\r\n\r\nIn this exercise you're playing a role-playing game named \"Wizard and Warriors,\" which allows you to play as either a Wizard or a Warrior.\r\n\r\nThere are different rules for Warriors and Wizards to determine how much damage points they deal.\r\n\r\nFor a Warrior, these are the rules:\r\n\r\n- Deal 6 points of damage if the character they are attacking is not vulnerable\r\n- Deal 10 points of damage if the character they are attacking is vulnerable\r\n\r\nFor a Wizard, these are the rules:\r\n\r\n- Deal 12 points of damage if the Wizard prepared a spell in advance\r\n- Deal 3 points of damage if the Wizard did not prepare a spell in advance\r\n\r\nIn general, characters are never vulnerable. However, Wizards _are_ vulnerable if they haven't prepared a spell.\r\n\r\nYou have six tasks that work with Warriors and Wizard characters.\r\n\r\n## 1. Describe a character\r\n\r\nOverride the `ToString()` method on the `Character` class to return a description of the character, formatted as `\"Character is a <CHARACTER_TYPE>\"`.\r\n\r\n```csharp\r\nvar warrior = new Warrior();\r\nwarrior.ToString();\r\n// => \"Character is a Warrior\"\r\n```\r\n\r\n## 2. Make characters not vulnerable by default\r\n\r\nEnsure that the `Character.Vulnerable()` method always returns `false`.\r\n\r\n```csharp\r\nvar warrior = new Warrior();\r\nwarrior.Vulnerable();\r\n// => false\r\n```\r\n\r\n## 3. Allow Wizards to prepare a spell\r\n\r\nImplement the `Wizard.PrepareSpell()` method to allow a Wizard to prepare a spell in advance.\r\n\r\n```csharp\r\nvar wizard = new Wizard();\r\nwizard.PrepareSpell();\r\n```\r\n\r\n## 4. Make Wizards vulnerable when not having prepared a spell\r\n\r\nEnsure that the `Vulnerable()` method returns `true` if the wizard did not prepare a spell; otherwise, return `false`.\r\n\r\n```csharp\r\nvar wizard = new Wizard();\r\nwizard.Vulnerable();\r\n// => true\r\n```\r\n\r\n## 5. Calculate the damage points for a Wizard\r\n\r\nImplement the `Wizard.DamagePoints()` method to return the damage points dealt: 12 damage points when a spell has been prepared, 3 damage points when not.\r\n\r\n```csharp\r\nvar wizard = new Wizard();\r\nvar warrior = new Warrior();\r\n\r\nwizard.PrepareSpell();\r\nwizard.DamagePoints(warrior);\r\n// => 12\r\n```\r\n\r\n## 6. Calculate the damage points for a Warrior\r\n\r\nImplement the `Warrior.DamagePoints()` method to return the damage points dealt: 10 damage points when the target is vulnerable, 6 damage points when not.\r\n\r\n```csharp\r\nvar warrior = new Warrior();\r\nvar wizard = new Wizard();\r\n\r\nwarrior.DamagePoints(wizard);\r\n// => 10\r\n```\r\n",
    "hints": "# Hints\r\n\r\n## 1. Describe a character\r\n\r\n- Modify the [constructors][constructor-syntax] of the `Wizard` and `Warrior` classes to pass their character type to the [base class' constructor][instance-constructors].\r\n- Store the character type as a [field][fields] on the `Character` class.\r\n- The `Character` class implicitly inherits from the `object` class, which [`ToString()` method you can override][override-tostring].\r\n\r\n## 2. Make characters not vulnerable by default\r\n\r\n- Implement the `Vulnerable()` method in the `Character` class to always return `false`.\r\n\r\n## 3. Allow Wizards to prepare a spell\r\n\r\n- Add a field to the `Wizard` class to store if a spell was prepared and update this in the `PrepareSpell()` method.\r\n- The spell should start out as not being prepared.\r\n\r\n## 4. Make Wizards vulnerable when not having prepared a spell\r\n\r\n- Override the `Vulnerable()` method in the `Wizard` class to make Wizards vulnerable if they haven't prepared a spell.\r\n\r\n## 5. Calculate the damage points for a Wizard\r\n\r\n- Use a [conditional statement][if-else] to return the damage points, taking into account the value of the prepare spell field.\r\n\r\n## 6. Calculate the damage points for a Warrior\r\n\r\n- You can call a method on the passed `Character` instance to determine its vulnerability.\r\n- Use a [conditional statement][if-else] to return the damage points, taking into account the vulnerability of the target.\r\n\r\n[constructor-syntax]: https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/classes-and-structs/constructors#constructor-syntax\r\n[instance-constructors]: https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/classes-and-structs/instance-constructors\r\n[fields]: https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/classes-and-structs/fields\r\n[override-tostring]: https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/classes-and-structs/how-to-override-the-tostring-method\r\n[if-else]: https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/keywords/if-else\r\n"
  },
  "starter_code": {
    "WizardsAndWarriors.cs": "abstract class Character\r\n{\r\n    protected Character(string characterType)\r\n    {\r\n        throw new NotImplementedException(\"Please implement the Character() constructor\");\r\n    }\r\n\r\n    public abstract int DamagePoints(Character target);\r\n\r\n    public virtual bool Vulnerable()\r\n    {\r\n        throw new NotImplementedException(\"Please implement the Character.Vulnerable() method\");\r\n    }\r\n\r\n    public override string ToString()\r\n    {\r\n        throw new NotImplementedException(\"Please implement the Character.ToString() method\");\r\n    }\r\n}\r\n\r\nclass Warrior : Character\r\n{\r\n    public Warrior() : base(\"TODO\")\r\n    {\r\n    }\r\n\r\n    public override int DamagePoints(Character target)\r\n    {\r\n        throw new NotImplementedException(\"Please implement the Warrior.DamagePoints() method\");\r\n    }\r\n}\r\n\r\nclass Wizard : Character\r\n{\r\n    public Wizard() : base(\"TODO\")\r\n    {\r\n    }\r\n\r\n    public override int DamagePoints(Character target)\r\n    {\r\n        throw new NotImplementedException(\"Please implement the Wizard.DamagePoints() method\");\r\n    }\r\n\r\n    public void PrepareSpell()\r\n    {\r\n        throw new NotImplementedException(\"Please implement the Wizard.PrepareSpell() method\");\r\n    }\r\n}\r\n"
  },
  "tests": {
    "WizardsAndWarriorsTests.cs": "using Exercism.Tests;\r\n\r\npublic class WizardsAndWarriorsTests\r\n{\r\n    [Fact]\r\n    [Task(1)]\r\n    public void Describe_wizard()\r\n    {\r\n        var wizard = new Wizard();\r\n        Assert.Equal(\"Character is a Wizard\", wizard.ToString());\r\n    }\r\n\r\n    [Fact]\r\n    [Task(1)]\r\n    public void Describe_warrior()\r\n    {\r\n        var warrior = new Warrior();\r\n        Assert.Equal(\"Character is a Warrior\", warrior.ToString());\r\n    }\r\n\r\n    [Fact]\r\n    [Task(2)]\r\n    public void Warrior_is_not_vulnerable()\r\n    {\r\n        var warrior = new Warrior();\r\n        Assert.False(warrior.Vulnerable());\r\n    }\r\n\r\n    [Fact]\r\n    [Task(4)]\r\n    public void Wizard_is_vulnerable()\r\n    {\r\n        var wizard = new Wizard();\r\n        Assert.True(wizard.Vulnerable());\r\n    }\r\n\r\n    [Fact]\r\n    [Task(4)]\r\n    public void Wizard_with_prepared_spell_is_not_vulnerable()\r\n    {\r\n        var wizard = new Wizard();\r\n        wizard.PrepareSpell();\r\n        Assert.False(wizard.Vulnerable());\r\n    }\r\n\r\n    [Fact]\r\n    [Task(4)]\r\n    public void Wizard_with_no_prepared_spell_is_vulnerable()\r\n    {\r\n        var wizard = new Wizard();\r\n        Assert.True(wizard.Vulnerable());\r\n    }\r\n\r\n    [Fact]\r\n    [Task(5)]\r\n    public void Attack_points_for_wizard_with_prepared_spell()\r\n    {\r\n        var wizard = new Wizard();\r\n        var warrior = new Warrior();\r\n\r\n        wizard.PrepareSpell();\r\n\r\n        Assert.Equal(12, wizard.DamagePoints(warrior));\r\n    }\r\n\r\n    [Fact]\r\n    [Task(5)]\r\n    public void Attack_points_for_wizard_with_no_prepared_spell()\r\n    {\r\n        var wizard = new Wizard();\r\n        var otherWizard = new Wizard();\r\n\r\n        Assert.Equal(3, wizard.DamagePoints(otherWizard));\r\n    }\r\n\r\n    [Fact]\r\n    [Task(6)]\r\n    public void Attack_points_for_warrior_with_vulnerable_target()\r\n    {\r\n        var warrior = new Warrior();\r\n        var wizard = new Wizard();\r\n\r\n        Assert.Equal(10, warrior.DamagePoints(wizard));\r\n    }\r\n\r\n    [Fact]\r\n    [Task(6)]\r\n    public void Attack_points_for_warrior_with_non_vulnerable_target()\r\n    {\r\n        var warrior = new Warrior();\r\n        var wizard = new Wizard();\r\n        wizard.PrepareSpell();\r\n\r\n        Assert.Equal(6, warrior.DamagePoints(wizard));\r\n    }\r\n}\r\n"
  }
}