{
  "language": "c",
  "slug": "palindrome-products",
  "docs": {
    "introduction": "",
    "instructions": "# Instructions\r\n\r\nDetect palindrome products in a given range.\r\n\r\nA palindromic number is a number that remains the same when its digits are reversed.\r\nFor example, `121` is a palindromic number but `112` is not.\r\n\r\nGiven a range of numbers, find the largest and smallest palindromes which\r\nare products of two numbers within that range.\r\n\r\nYour solution should return the largest and smallest palindromes, along with the factors of each within the range.\r\nIf the largest or smallest palindrome has more than one pair of factors within the range, then return all the pairs.\r\n\r\n## Example 1\r\n\r\nGiven the range `[1, 9]` (both inclusive)...\r\n\r\nAnd given the list of all possible products within this range:\r\n`[1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 12, 14, 16, 18, 15, 21, 24, 27, 20, 28, 32, 36, 25, 30, 35, 40, 45, 42, 48, 54, 49, 56, 63, 64, 72, 81]`\r\n\r\nThe palindrome products are all single digit numbers (in this case):\r\n`[1, 2, 3, 4, 5, 6, 7, 8, 9]`\r\n\r\nThe smallest palindrome product is `1`.\r\nIts factors are `(1, 1)`.\r\nThe largest palindrome product is `9`.\r\nIts factors are `(1, 9)` and `(3, 3)`.\r\n\r\n## Example 2\r\n\r\nGiven the range `[10, 99]` (both inclusive)...\r\n\r\nThe smallest palindrome product is `121`.\r\nIts factors are `(11, 11)`.\r\nThe largest palindrome product is `9009`.\r\nIts factors are `(91, 99)`.\r\n",
    "hints": ""
  },
  "starter_code": {
    "palindrome_products.c": "#include \"palindrome_products.h\"\r\n",
    "palindrome_products.h": "#ifndef PALINDROME_PRODUCTS_H\r\n#define PALINDROME_PRODUCTS_H\r\n\r\n#define MAXERR 100\r\n\r\ntypedef struct factors {\r\n   int factor_a;\r\n   int factor_b;\r\n   struct factors *next;\r\n} factor_t;\r\n\r\nstruct product {\r\n   int smallest;\r\n   int largest;\r\n   factor_t *factors_sm;\r\n   factor_t *factors_lg;\r\n   char error[MAXERR];\r\n};\r\n\r\ntypedef struct product product_t;\r\n\r\nproduct_t *get_palindrome_product(int from, int to);\r\nvoid free_product(product_t *p);\r\n\r\n#endif\r\n"
  },
  "tests": {
    "test_palindrome_products.c": "#include \"test-framework/unity.h\"\r\n#include \"palindrome_products.h\"\r\n\r\n#include <stdbool.h>\r\n#include <stddef.h>\r\n\r\nvoid setUp(void)\r\n{\r\n}\r\n\r\nvoid tearDown(void)\r\n{\r\n}\r\n\r\n/* factor_t_are_equal compares the values of the factors\r\n * that are stored in the passed f1, f2 factor_t structs\r\n * regardless of their order in the said structs. Returns\r\n * true if the values are equal, false otherwise.\r\n *\r\n *\r\n * Examples:\r\n *\r\n * factor_t_are_equal(&{1, 9}, &{1, 9}) returns true\r\n * factor_t_are_equal(&{1, 9}, &{9, 1}) returns true\r\n * factor_t_are_equal(&{1, 9}, &{1, 8}) returns false\r\n * */\r\nstatic bool factor_t_are_equal(const factor_t *const f1,\r\n                               const factor_t *const f2)\r\n{\r\n   return ((f1->factor_a == f2->factor_a) && (f1->factor_b == f2->factor_b)) ||\r\n          ((f1->factor_a == f2->factor_b) && (f1->factor_b == f2->factor_a));\r\n}\r\n\r\n/* contains_factor checks if the `factor` variable is stored\r\n * in the `factors` linked-list. The function traverses the\r\n * `factors` list, until it finds the desired element, in which case\r\n * it returns true. If the function gets to the end of the list or\r\n * exceeds the number of checked elements (passed as the `depth` variable),\r\n * it returns false.\r\n * */\r\nstatic bool contains_factor(factor_t *factors, const factor_t *const factor,\r\n                            const size_t depth)\r\n{\r\n   size_t current_depth = 0;\r\n   factor_t *current_factor = factors;\r\n   while ((current_factor != NULL) && (current_depth != depth)) {\r\n      if (factor_t_are_equal(current_factor, factor)) {\r\n         return true;\r\n      }\r\n      current_factor = current_factor->next;\r\n      current_depth += 1;\r\n   }\r\n   return false;\r\n}\r\n\r\n/* check_factors checks if all the factor_t elements that are\r\n * passed in the `expected` variable are present in the `actual`\r\n * variable that contains a linked list of factor_t elements from\r\n * the student's solution. For every element of `expected` found in\r\n * `actual` the `found_count` variable is incremented. In the end\r\n * `found_count` is compared with the expected number of the found\r\n * elements passed in the `depth` variable.\r\n * */\r\nstatic void check_factors(factor_t *actual, size_t depth, factor_t expected[])\r\n{\r\n   if (depth == 0) {\r\n      TEST_ASSERT_EQUAL_PTR(NULL, actual);\r\n      return;\r\n   }\r\n   int found_count = 0;\r\n   for (size_t i = 0; i < depth; ++i) {\r\n      if (!contains_factor(actual, &expected[i], depth)) {\r\n         break;\r\n      }\r\n      found_count += 1;\r\n   }\r\n   TEST_ASSERT_EQUAL_INT_MESSAGE(\r\n       depth, found_count,\r\n       \"Not every expected factor found in the actual result.\");\r\n}\r\n\r\nstatic void test_smallest_palindrome_from_single_digit_factors(void)\r\n{\r\n   product_t *product = get_palindrome_product(1, 9);\r\n   TEST_ASSERT_NOT_NULL(product);\r\n   TEST_ASSERT_EQUAL_INT(1, product->smallest);\r\n\r\n   factor_t expected_sm[] = { { 1, 1, NULL } };\r\n   check_factors(product->factors_sm, 1, expected_sm);\r\n\r\n   free_product(product);\r\n}\r\n\r\nstatic void test_largest_palindrome_from_single_digit_factors(void)\r\n{\r\n   TEST_IGNORE();   // delete this line to run test\r\n   product_t *product = get_palindrome_product(1, 9);\r\n   TEST_ASSERT_NOT_NULL(product);\r\n   TEST_ASSERT_EQUAL_INT(9, product->largest);\r\n\r\n   factor_t expected_lg[] = { { 3, 3, NULL }, { 1, 9, NULL } };\r\n   check_factors(product->factors_lg, 2, expected_lg);\r\n\r\n   free_product(product);\r\n}\r\n\r\nstatic void test_smallest_palindrome_from_double_digit_factors(void)\r\n{\r\n   TEST_IGNORE();   // delete this line to run test\r\n   product_t *product = get_palindrome_product(10, 99);\r\n   TEST_ASSERT_NOT_NULL(product);\r\n   TEST_ASSERT_EQUAL_INT(121, product->smallest);\r\n\r\n   factor_t expected_sm[] = { { 11, 11, NULL } };\r\n   check_factors(product->factors_sm, 1, expected_sm);\r\n\r\n   free_product(product);\r\n}\r\n\r\nstatic void test_largest_palindrome_from_double_digit_factors(void)\r\n{\r\n   TEST_IGNORE();   // delete this line to run test\r\n   product_t *product = get_palindrome_product(10, 99);\r\n   TEST_ASSERT_NOT_NULL(product);\r\n   TEST_ASSERT_EQUAL_INT(9009, product->largest);\r\n\r\n   factor_t expected_lg[] = { { 91, 99, NULL } };\r\n   check_factors(product->factors_lg, 1, expected_lg);\r\n\r\n   free_product(product);\r\n}\r\n\r\nstatic void test_smallest_palindrome_from_triple_digit_factors(void)\r\n{\r\n   TEST_IGNORE();   // delete this line to run test\r\n   product_t *product = get_palindrome_product(100, 999);\r\n   TEST_ASSERT_NOT_NULL(product);\r\n   TEST_ASSERT_EQUAL_INT(10201, product->smallest);\r\n\r\n   factor_t expected_sm[] = { { 101, 101, NULL } };\r\n   check_factors(product->factors_sm, 1, expected_sm);\r\n\r\n   free_product(product);\r\n}\r\n\r\nstatic void test_largest_palindrome_from_triple_digit_factors(void)\r\n{\r\n   TEST_IGNORE();   // delete this line to run test\r\n   product_t *product = get_palindrome_product(100, 999);\r\n   TEST_ASSERT_NOT_NULL(product);\r\n   TEST_ASSERT_EQUAL_INT(906609, product->largest);\r\n\r\n   factor_t expected_lg[] = { { 913, 993, NULL } };\r\n   check_factors(product->factors_lg, 1, expected_lg);\r\n\r\n   free_product(product);\r\n}\r\n\r\nstatic void test_smallest_palindrome_from_four_digit_factors(void)\r\n{\r\n   TEST_IGNORE();   // delete this line to run test\r\n   product_t *product = get_palindrome_product(1000, 9999);\r\n   TEST_ASSERT_NOT_NULL(product);\r\n   TEST_ASSERT_EQUAL_INT(1002001, product->smallest);\r\n\r\n   factor_t expected_sm[] = { { 1001, 1001, NULL } };\r\n   check_factors(product->factors_sm, 1, expected_sm);\r\n\r\n   free_product(product);\r\n}\r\n\r\nstatic void test_largest_palindrome_from_four_digit_factors(void)\r\n{\r\n   TEST_IGNORE();   // delete this line to run test\r\n   product_t *product = get_palindrome_product(1000, 9999);\r\n   TEST_ASSERT_NOT_NULL(product);\r\n   TEST_ASSERT_EQUAL_INT(99000099, product->largest);\r\n\r\n   factor_t expected_lg[] = { { 9901, 9999, NULL } };\r\n   check_factors(product->factors_lg, 1, expected_lg);\r\n\r\n   free_product(product);\r\n}\r\n\r\nstatic void test_empty_result_for_smallest_if_no_palindrome_in_the_range(void)\r\n{\r\n   TEST_IGNORE();   // delete this line to run test\r\n   product_t *product = get_palindrome_product(1002, 1003);\r\n   TEST_ASSERT_NOT_NULL(product);\r\n   const char *expected =\r\n       \"no palindrome with factors in the range 1002 to 1003\";\r\n   TEST_ASSERT_EQUAL_STRING(expected, product->error);\r\n\r\n   free_product(product);\r\n}\r\n\r\nstatic void test_empty_result_for_largest_if_no_palindrome_in_the_range(void)\r\n{\r\n   TEST_IGNORE();   // delete this line to run test\r\n   product_t *product = get_palindrome_product(15, 15);\r\n   TEST_ASSERT_NOT_NULL(product);\r\n   const char *expected = \"no palindrome with factors in the range 15 to 15\";\r\n   TEST_ASSERT_EQUAL_STRING(expected, product->error);\r\n\r\n   free_product(product);\r\n}\r\n\r\nstatic void test_error_result_for_smallest_if_min_is_more_than_max(void)\r\n{\r\n   TEST_IGNORE();   // delete this line to run test\r\n   product_t *product = get_palindrome_product(10000, 1);\r\n   TEST_ASSERT_NOT_NULL(product);\r\n   const char *expected = \"invalid input: min is 10000 and max is 1\";\r\n   TEST_ASSERT_EQUAL_STRING(expected, product->error);\r\n\r\n   free_product(product);\r\n}\r\n\r\nstatic void test_error_result_for_largest_if_min_is_more_than_max(void)\r\n{\r\n   TEST_IGNORE();   // delete this line to run test\r\n   product_t *product = get_palindrome_product(2, 1);\r\n   TEST_ASSERT_NOT_NULL(product);\r\n   const char *expected = \"invalid input: min is 2 and max is 1\";\r\n   TEST_ASSERT_EQUAL_STRING(expected, product->error);\r\n\r\n   free_product(product);\r\n}\r\n\r\nstatic void test_smallest_product_not_using_smallest_factor(void)\r\n{\r\n   TEST_IGNORE();   // delete this line to run test\r\n   product_t *product = get_palindrome_product(3215, 4000);\r\n   TEST_ASSERT_NOT_NULL(product);\r\n   TEST_ASSERT_EQUAL_INT(10988901, product->smallest);\r\n\r\n   factor_t expected_lg[] = { { 3297, 3333, NULL } };\r\n   check_factors(product->factors_sm, 1, expected_lg);\r\n\r\n   free_product(product);\r\n}\r\n\r\nint main(void)\r\n{\r\n   UNITY_BEGIN();\r\n\r\n   RUN_TEST(test_smallest_palindrome_from_single_digit_factors);\r\n   RUN_TEST(test_largest_palindrome_from_single_digit_factors);\r\n\r\n   RUN_TEST(test_smallest_palindrome_from_double_digit_factors);\r\n   RUN_TEST(test_largest_palindrome_from_double_digit_factors);\r\n\r\n   RUN_TEST(test_smallest_palindrome_from_triple_digit_factors);\r\n   RUN_TEST(test_largest_palindrome_from_triple_digit_factors);\r\n\r\n   RUN_TEST(test_smallest_palindrome_from_four_digit_factors);\r\n   RUN_TEST(test_largest_palindrome_from_four_digit_factors);\r\n\r\n   RUN_TEST(test_empty_result_for_smallest_if_no_palindrome_in_the_range);\r\n   RUN_TEST(test_empty_result_for_largest_if_no_palindrome_in_the_range);\r\n\r\n   RUN_TEST(test_error_result_for_smallest_if_min_is_more_than_max);\r\n   RUN_TEST(test_error_result_for_largest_if_min_is_more_than_max);\r\n\r\n   RUN_TEST(test_smallest_product_not_using_smallest_factor);\r\n\r\n   return UNITY_END();\r\n}\r\n"
  }
}