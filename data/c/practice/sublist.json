{
  "language": "c",
  "slug": "sublist",
  "docs": {
    "introduction": "",
    "instructions": "# Instructions\r\n\r\nGiven any two lists `A` and `B`, determine if:\r\n\r\n- List `A` is equal to list `B`; or\r\n- List `A` contains list `B` (`A` is a superlist of `B`); or\r\n- List `A` is contained by list `B` (`A` is a sublist of `B`); or\r\n- None of the above is true, thus lists `A` and `B` are unequal\r\n\r\nSpecifically, list `A` is equal to list `B` if both lists have the same values in the same order.\r\nList `A` is a superlist of `B` if `A` contains a contiguous sub-sequence of values equal to `B`.\r\nList `A` is a sublist of `B` if `B` contains a contiguous sub-sequence of values equal to `A`.\r\n\r\nExamples:\r\n\r\n- If `A = []` and `B = []` (both lists are empty), then `A` and `B` are equal\r\n- If `A = [1, 2, 3]` and `B = []`, then `A` is a superlist of `B`\r\n- If `A = []` and `B = [1, 2, 3]`, then `A` is a sublist of `B`\r\n- If `A = [1, 2, 3]` and `B = [1, 2, 3, 4, 5]`, then `A` is a sublist of `B`\r\n- If `A = [3, 4, 5]` and `B = [1, 2, 3, 4, 5]`, then `A` is a sublist of `B`\r\n- If `A = [3, 4]` and `B = [1, 2, 3, 4, 5]`, then `A` is a sublist of `B`\r\n- If `A = [1, 2, 3]` and `B = [1, 2, 3]`, then `A` and `B` are equal\r\n- If `A = [1, 2, 3, 4, 5]` and `B = [2, 3, 4]`, then `A` is a superlist of `B`\r\n- If `A = [1, 2, 4]` and `B = [1, 2, 3, 4, 5]`, then `A` and `B` are unequal\r\n- If `A = [1, 2, 3]` and `B = [1, 3, 2]`, then `A` and `B` are unequal\r\n",
    "hints": ""
  },
  "starter_code": {
    "sublist.c": "#include \"sublist.h\"\r\n",
    "sublist.h": "#ifndef SUBLIST_H\r\n#define SUBLIST_H\r\n\r\n#include <stddef.h>\r\n\r\ntypedef enum { EQUAL, UNEQUAL, SUBLIST, SUPERLIST } comparison_result_t;\r\n\r\ncomparison_result_t check_lists(int *list_to_compare, int *base_list,\r\n                                size_t list_to_compare_element_count,\r\n                                size_t base_list_element_count);\r\n\r\n#endif\r\n"
  },
  "tests": {
    "test_sublist.c": "#include \"test-framework/unity.h\"\r\n#include \"sublist.h\"\r\n\r\n#define ELEMENT_COUNT(array) (sizeof(array) / sizeof(array[0]))\r\n\r\nvoid setUp(void)\r\n{\r\n}\r\n\r\nvoid tearDown(void)\r\n{\r\n}\r\n\r\nstatic void test_empty_lists(void)\r\n{\r\n   TEST_ASSERT_EQUAL(EQUAL, check_lists(NULL, NULL, 0, 0));\r\n}\r\n\r\nstatic void test_empty_list_within_non_empty_list(void)\r\n{\r\n   TEST_IGNORE();   // delete this line to run test\r\n   int base_list[] = { 1, 2, 3 };\r\n\r\n   TEST_ASSERT_EQUAL(SUBLIST,\r\n                     check_lists(NULL, base_list, 0, ELEMENT_COUNT(base_list)));\r\n}\r\n\r\nstatic void test_non_empty_list_contains_empty_list(void)\r\n{\r\n   TEST_IGNORE();\r\n   int list_to_compare[] = { 1, 2, 3 };\r\n\r\n   TEST_ASSERT_EQUAL(SUPERLIST, check_lists(list_to_compare, NULL,\r\n                                            ELEMENT_COUNT(list_to_compare), 0));\r\n}\r\n\r\nstatic void test_list_equals_itself(void)\r\n{\r\n   TEST_IGNORE();\r\n   int list_to_compare[] = { 1, 2, 3 };\r\n   int base_list[] = { 1, 2, 3 };\r\n\r\n   TEST_ASSERT_EQUAL(EQUAL, check_lists(list_to_compare, base_list,\r\n                                        ELEMENT_COUNT(list_to_compare),\r\n                                        ELEMENT_COUNT(base_list)));\r\n}\r\n\r\nstatic void test_different_lists(void)\r\n{\r\n   TEST_IGNORE();\r\n   int list_to_compare[] = { 1, 2, 3 };\r\n   int base_list[] = { 2, 3, 4 };\r\n\r\n   TEST_ASSERT_EQUAL(UNEQUAL, check_lists(list_to_compare, base_list,\r\n                                          ELEMENT_COUNT(list_to_compare),\r\n                                          ELEMENT_COUNT(base_list)));\r\n}\r\n\r\nstatic void test_false_start(void)\r\n{\r\n   TEST_IGNORE();\r\n   int list_to_compare[] = { 1, 2, 5 };\r\n   int base_list[] = { 0, 1, 2, 3, 1, 2, 5, 6 };\r\n\r\n   TEST_ASSERT_EQUAL(SUBLIST, check_lists(list_to_compare, base_list,\r\n                                          ELEMENT_COUNT(list_to_compare),\r\n                                          ELEMENT_COUNT(base_list)));\r\n}\r\n\r\nstatic void test_consecutive(void)\r\n{\r\n   TEST_IGNORE();\r\n   int list_to_compare[] = { 1, 1, 2 };\r\n   int base_list[] = { 0, 1, 1, 1, 2, 1, 2 };\r\n\r\n   TEST_ASSERT_EQUAL(SUBLIST, check_lists(list_to_compare, base_list,\r\n                                          ELEMENT_COUNT(list_to_compare),\r\n                                          ELEMENT_COUNT(base_list)));\r\n}\r\n\r\nstatic void test_sublist_at_start(void)\r\n{\r\n   TEST_IGNORE();\r\n   int list_to_compare[] = { 0, 1, 2 };\r\n   int base_list[] = { 0, 1, 2, 3, 4, 5 };\r\n\r\n   TEST_ASSERT_EQUAL(SUBLIST, check_lists(list_to_compare, base_list,\r\n                                          ELEMENT_COUNT(list_to_compare),\r\n                                          ELEMENT_COUNT(base_list)));\r\n}\r\n\r\nstatic void test_sublist_at_middle(void)\r\n{\r\n   TEST_IGNORE();\r\n   int list_to_compare[] = { 2, 3, 4 };\r\n   int base_list[] = { 0, 1, 2, 3, 4, 5 };\r\n\r\n   TEST_ASSERT_EQUAL(SUBLIST, check_lists(list_to_compare, base_list,\r\n                                          ELEMENT_COUNT(list_to_compare),\r\n                                          ELEMENT_COUNT(base_list)));\r\n}\r\n\r\nstatic void test_sublist_at_end(void)\r\n{\r\n   TEST_IGNORE();\r\n   int list_to_compare[] = { 3, 4, 5 };\r\n   int base_list[] = { 0, 1, 2, 3, 4, 5 };\r\n\r\n   TEST_ASSERT_EQUAL(SUBLIST, check_lists(list_to_compare, base_list,\r\n                                          ELEMENT_COUNT(list_to_compare),\r\n                                          ELEMENT_COUNT(base_list)));\r\n}\r\n\r\nstatic void test_at_start_of_superlist(void)\r\n{\r\n   TEST_IGNORE();\r\n   int list_to_compare[] = { 0, 1, 2, 3, 4, 5 };\r\n   int base_list[] = { 0, 1, 2 };\r\n\r\n   TEST_ASSERT_EQUAL(SUPERLIST, check_lists(list_to_compare, base_list,\r\n                                            ELEMENT_COUNT(list_to_compare),\r\n                                            ELEMENT_COUNT(base_list)));\r\n}\r\n\r\nstatic void test_in_middle_of_superlist(void)\r\n{\r\n   TEST_IGNORE();\r\n   int list_to_compare[] = { 0, 1, 2, 3, 4, 5 };\r\n   int base_list[] = { 2, 3 };\r\n\r\n   TEST_ASSERT_EQUAL(SUPERLIST, check_lists(list_to_compare, base_list,\r\n                                            ELEMENT_COUNT(list_to_compare),\r\n                                            ELEMENT_COUNT(base_list)));\r\n}\r\n\r\nstatic void test_at_end_of_superlist(void)\r\n{\r\n   TEST_IGNORE();\r\n   int list_to_compare[] = { 0, 1, 2, 3, 4, 5 };\r\n   int base_list[] = { 3, 4, 5 };\r\n\r\n   TEST_ASSERT_EQUAL(SUPERLIST, check_lists(list_to_compare, base_list,\r\n                                            ELEMENT_COUNT(list_to_compare),\r\n                                            ELEMENT_COUNT(base_list)));\r\n}\r\n\r\nstatic void test_first_list_missing_element_from_second_list(void)\r\n{\r\n   TEST_IGNORE();\r\n   int list_to_compare[] = { 1, 3 };\r\n   int base_list[] = { 1, 2, 3 };\r\n\r\n   TEST_ASSERT_EQUAL(UNEQUAL, check_lists(list_to_compare, base_list,\r\n                                          ELEMENT_COUNT(list_to_compare),\r\n                                          ELEMENT_COUNT(base_list)));\r\n}\r\n\r\nstatic void test_second_list_missing_element_from_first_list(void)\r\n{\r\n   TEST_IGNORE();\r\n   int list_to_compare[] = { 1, 2, 3 };\r\n   int base_list[] = { 1, 3 };\r\n\r\n   TEST_ASSERT_EQUAL(UNEQUAL, check_lists(list_to_compare, base_list,\r\n                                          ELEMENT_COUNT(list_to_compare),\r\n                                          ELEMENT_COUNT(base_list)));\r\n}\r\n\r\nstatic void test_first_list_missing_additional_digits_from_second_list(void)\r\n{\r\n   TEST_IGNORE();\r\n   int list_to_compare[] = { 1, 2 };\r\n   int base_list[] = { 1, 22 };\r\n\r\n   TEST_ASSERT_EQUAL(UNEQUAL, check_lists(list_to_compare, base_list,\r\n                                          ELEMENT_COUNT(list_to_compare),\r\n                                          ELEMENT_COUNT(base_list)));\r\n}\r\n\r\nstatic void test_order_matters_to_a_list(void)\r\n{\r\n   TEST_IGNORE();\r\n   int list_to_compare[] = { 1, 2, 3 };\r\n   int base_list[] = { 3, 2, 1 };\r\n\r\n   TEST_ASSERT_EQUAL(UNEQUAL, check_lists(list_to_compare, base_list,\r\n                                          ELEMENT_COUNT(list_to_compare),\r\n                                          ELEMENT_COUNT(base_list)));\r\n}\r\n\r\nstatic void test_same_digits_but_different_numbers(void)\r\n{\r\n   TEST_IGNORE();\r\n   int list_to_compare[] = { 1, 0, 1 };\r\n   int base_list[] = { 10, 1 };\r\n\r\n   TEST_ASSERT_EQUAL(UNEQUAL, check_lists(list_to_compare, base_list,\r\n                                          ELEMENT_COUNT(list_to_compare),\r\n                                          ELEMENT_COUNT(base_list)));\r\n}\r\n\r\nstatic void test_different_signs(void)\r\n{\r\n   TEST_IGNORE();\r\n   int list_to_compare[] = { 1, 2, 3 };\r\n   int base_list[] = { 1, -2, 3 };\r\n\r\n   TEST_ASSERT_EQUAL(UNEQUAL, check_lists(list_to_compare, base_list,\r\n                                          ELEMENT_COUNT(list_to_compare),\r\n                                          ELEMENT_COUNT(base_list)));\r\n}\r\n\r\nint main(void)\r\n{\r\n   UNITY_BEGIN();\r\n\r\n   RUN_TEST(test_empty_lists);\r\n   RUN_TEST(test_empty_list_within_non_empty_list);\r\n   RUN_TEST(test_non_empty_list_contains_empty_list);\r\n   RUN_TEST(test_list_equals_itself);\r\n   RUN_TEST(test_different_lists);\r\n   RUN_TEST(test_false_start);\r\n   RUN_TEST(test_consecutive);\r\n   RUN_TEST(test_sublist_at_start);\r\n   RUN_TEST(test_sublist_at_middle);\r\n   RUN_TEST(test_sublist_at_end);\r\n   RUN_TEST(test_at_start_of_superlist);\r\n   RUN_TEST(test_in_middle_of_superlist);\r\n   RUN_TEST(test_at_end_of_superlist);\r\n   RUN_TEST(test_first_list_missing_element_from_second_list);\r\n   RUN_TEST(test_second_list_missing_element_from_first_list);\r\n   RUN_TEST(test_first_list_missing_additional_digits_from_second_list);\r\n   RUN_TEST(test_order_matters_to_a_list);\r\n   RUN_TEST(test_same_digits_but_different_numbers);\r\n   RUN_TEST(test_different_signs);\r\n\r\n   return UNITY_END();\r\n}\r\n"
  }
}