{
  "language": "c",
  "slug": "collatz-conjecture",
  "docs": {
    "introduction": "# Introduction\r\n\r\nOne evening, you stumbled upon an old notebook filled with cryptic scribbles, as though someone had been obsessively chasing an idea.\r\nOn one page, a single question stood out: **Can every number find its way to 1?**\r\nIt was tied to something called the **Collatz Conjecture**, a puzzle that has baffled thinkers for decades.\r\n\r\nThe rules were deceptively simple.\r\nPick any positive integer.\r\n\r\n- If it's even, divide it by 2.\r\n- If it's odd, multiply it by 3 and add 1.\r\n\r\nThen, repeat these steps with the result, continuing indefinitely.\r\n\r\nCurious, you picked number 12 to test and began the journey:\r\n\r\n12 ➜ 6 ➜ 3 ➜ 10 ➜ 5 ➜ 16 ➜ 8 ➜ 4 ➜ 2 ➜ 1\r\n\r\nCounting from the second number (6), it took 9 steps to reach 1, and each time the rules repeated, the number kept changing.\r\nAt first, the sequence seemed unpredictable — jumping up, down, and all over.\r\nYet, the conjecture claims that no matter the starting number, we'll always end at 1.\r\n\r\nIt was fascinating, but also puzzling.\r\nWhy does this always seem to work?\r\nCould there be a number where the process breaks down, looping forever or escaping into infinity?\r\nThe notebook suggested solving this could reveal something profound — and with it, fame, [fortune][collatz-prize], and a place in history awaits whoever could unlock its secrets.\r\n\r\n[collatz-prize]: https://mathprize.net/posts/collatz-conjecture/\r\n",
    "instructions": "# Instructions\r\n\r\nGiven a positive integer, return the number of steps it takes to reach 1 according to the rules of the Collatz Conjecture.\r\n",
    "hints": ""
  },
  "starter_code": {
    "collatz_conjecture.c": "#include \"collatz_conjecture.h\"\r\n",
    "collatz_conjecture.h": "#ifndef COLLATZ_CONJECTURE_H\r\n#define COLLATZ_CONJECTURE_H\r\n\r\n#define ERROR_VALUE -1\r\n\r\nint steps(int start);\r\n\r\n#endif\r\n"
  },
  "tests": {
    "test_collatz_conjecture.c": "#include \"test-framework/unity.h\"\r\n#include \"collatz_conjecture.h\"\r\n\r\nvoid setUp(void)\r\n{\r\n}\r\n\r\nvoid tearDown(void)\r\n{\r\n}\r\n\r\nstatic void test_zero_steps_for_one(void)\r\n{\r\n   TEST_ASSERT_EQUAL(0, steps(1));\r\n}\r\n\r\nstatic void test_divide_if_even(void)\r\n{\r\n   TEST_ASSERT_EQUAL(4, steps(16));\r\n}\r\n\r\nstatic void test_even_and_odd_steps(void)\r\n{\r\n   TEST_ASSERT_EQUAL(9, steps(12));\r\n}\r\n\r\nstatic void test_large_number_of_even_and_odd_steps(void)\r\n{\r\n   TEST_ASSERT_EQUAL(152, steps(1000000));\r\n}\r\n\r\nstatic void test_zero_is_an_error(void)\r\n{\r\n   TEST_ASSERT_EQUAL(ERROR_VALUE, steps(0));\r\n}\r\n\r\nstatic void test_negative_value_is_an_error(void)\r\n{\r\n   TEST_ASSERT_EQUAL(ERROR_VALUE, steps(-15));\r\n}\r\n\r\nint main(void)\r\n{\r\n   UNITY_BEGIN();\r\n\r\n   RUN_TEST(test_zero_steps_for_one);\r\n   RUN_TEST(test_divide_if_even);\r\n   RUN_TEST(test_even_and_odd_steps);\r\n   RUN_TEST(test_large_number_of_even_and_odd_steps);\r\n   RUN_TEST(test_zero_is_an_error);\r\n   RUN_TEST(test_negative_value_is_an_error);\r\n\r\n   return UNITY_END();\r\n}\r\n"
  }
}