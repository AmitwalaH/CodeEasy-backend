{
  "language": "c",
  "slug": "complex-numbers",
  "docs": {
    "introduction": "",
    "instructions": "# Instructions\r\n\r\nA **complex number** is expressed in the form `z = a + b * i`, where:\r\n\r\n- `a` is the **real part** (a real number),\r\n\r\n- `b` is the **imaginary part** (also a real number), and\r\n\r\n- `i` is the **imaginary unit** satisfying `i^2 = -1`.\r\n\r\n## Operations on Complex Numbers\r\n\r\n### Conjugate\r\n\r\nThe conjugate of the complex number `z = a + b * i` is given by:\r\n\r\n```text\r\nzc = a - b * i\r\n```\r\n\r\n### Absolute Value\r\n\r\nThe absolute value (or modulus) of `z` is defined as:\r\n\r\n```text\r\n|z| = sqrt(a^2 + b^2)\r\n```\r\n\r\nThe square of the absolute value is computed as the product of `z` and its conjugate `zc`:\r\n\r\n```text\r\n|z|^2 = z * zc = a^2 + b^2\r\n```\r\n\r\n### Addition\r\n\r\nThe sum of two complex numbers `z1 = a + b * i` and `z2 = c + d * i` is computed by adding their real and imaginary parts separately:\r\n\r\n```text\r\nz1 + z2 = (a + b * i) + (c + d * i)\r\n        = (a + c) + (b + d) * i\r\n```\r\n\r\n### Subtraction\r\n\r\nThe difference of two complex numbers is obtained by subtracting their respective parts:\r\n\r\n```text\r\nz1 - z2 = (a + b * i) - (c + d * i)\r\n        = (a - c) + (b - d) * i\r\n```\r\n\r\n### Multiplication\r\n\r\nThe product of two complex numbers is defined as:\r\n\r\n```text\r\nz1 * z2 = (a + b * i) * (c + d * i)\r\n        = (a * c - b * d) + (b * c + a * d) * i\r\n```\r\n\r\n### Reciprocal\r\n\r\nThe reciprocal of a non-zero complex number is given by:\r\n\r\n```text\r\n1 / z = 1 / (a + b * i)\r\n      = a / (a^2 + b^2) - b / (a^2 + b^2) * i\r\n```\r\n\r\n### Division\r\n\r\nThe division of one complex number by another is given by:\r\n\r\n```text\r\nz1 / z2 = z1 * (1 / z2)\r\n        = (a + b * i) / (c + d * i)\r\n        = (a * c + b * d) / (c^2 + d^2) + (b * c - a * d) / (c^2 + d^2) * i\r\n```\r\n\r\n### Exponentiation\r\n\r\nRaising _e_ (the base of the natural logarithm) to a complex exponent can be expressed using Euler's formula:\r\n\r\n```text\r\ne^(a + b * i) = e^a * e^(b * i)\r\n              = e^a * (cos(b) + i * sin(b))\r\n```\r\n\r\n## Implementation Requirements\r\n\r\nGiven that you should not use built-in support for complex numbers, implement the following operations:\r\n\r\n- **addition** of two complex numbers\r\n- **subtraction** of two complex numbers\r\n- **multiplication** of two complex numbers\r\n- **division** of two complex numbers\r\n- **conjugate** of a complex number\r\n- **absolute value** of a complex number\r\n- **exponentiation** of _e_ (the base of the natural logarithm) to a complex number\r\n",
    "hints": ""
  },
  "starter_code": {
    "complex_numbers.c": "#include \"complex_numbers.h\"\r\n\r\ncomplex_t c_add(complex_t a, complex_t b)\r\n{\r\n   // TODO: implement\r\n}\r\n\r\ncomplex_t c_sub(complex_t a, complex_t b)\r\n{\r\n   // TODO: implement\r\n}\r\n\r\ncomplex_t c_mul(complex_t a, complex_t b)\r\n{\r\n   // TODO: implement\r\n}\r\n\r\ncomplex_t c_div(complex_t a, complex_t b)\r\n{\r\n   // TODO: implement\r\n}\r\n\r\ndouble c_abs(complex_t x)\r\n{\r\n   // TODO: implement\r\n}\r\n\r\ncomplex_t c_conjugate(complex_t x)\r\n{\r\n   // TODO: implement\r\n}\r\n\r\ndouble c_real(complex_t x)\r\n{\r\n   // TODO: implement\r\n}\r\n\r\ndouble c_imag(complex_t x)\r\n{\r\n   // TODO: implement\r\n}\r\n\r\ncomplex_t c_exp(complex_t x)\r\n{\r\n   // TODO: implement\r\n}\r\n",
    "complex_numbers.h": "#ifndef COMPLEX_NUMBERS_H\r\n#define COMPLEX_NUMBERS_H\r\n\r\ntypedef struct {\r\n   double real;\r\n   double imag;\r\n} complex_t;\r\n\r\ncomplex_t c_add(complex_t a, complex_t b);\r\ncomplex_t c_sub(complex_t a, complex_t b);\r\ncomplex_t c_mul(complex_t a, complex_t b);\r\ncomplex_t c_div(complex_t a, complex_t b);\r\ndouble c_abs(complex_t x);\r\ncomplex_t c_conjugate(complex_t x);\r\ndouble c_real(complex_t x);\r\ndouble c_imag(complex_t x);\r\ncomplex_t c_exp(complex_t x);\r\n\r\n#endif\r\n"
  },
  "tests": {
    "test_complex_numbers.c": "#include <math.h>\r\n#include \"test-framework/unity.h\"\r\n#include \"complex_numbers.h\"\r\n\r\n#define PI acos(-1)\r\n#define E exp(1)\r\n\r\nvoid setUp(void)\r\n{\r\n}\r\n\r\nvoid tearDown(void)\r\n{\r\n}\r\n\r\nstatic void compare_complex(complex_t expected, complex_t actual)\r\n{\r\n   double double_delta = 0.000000001;\r\n   TEST_ASSERT_DOUBLE_WITHIN(double_delta, expected.real, actual.real);\r\n   TEST_ASSERT_DOUBLE_WITHIN(double_delta, expected.imag, actual.imag);\r\n}\r\n\r\nstatic void test_real_part_of_a_purely_real_number(void)\r\n{\r\n   TEST_IGNORE();\r\n   complex_t z = { .real = 1.0, .imag = 0.0 };\r\n\r\n   double expected = 1.0;\r\n   double actual = c_real(z);\r\n\r\n   TEST_ASSERT_EQUAL_FLOAT(expected, actual);\r\n}\r\n\r\nstatic void test_real_part_of_a_purely_imaginary_number(void)\r\n{\r\n   TEST_IGNORE();\r\n   complex_t z = { .real = 0.0, .imag = 1.0 };\r\n\r\n   double expected = 0.0;\r\n   double actual = c_real(z);\r\n\r\n   TEST_ASSERT_EQUAL_FLOAT(expected, actual);\r\n}\r\n\r\nstatic void test_real_part_of_a_number_with_real_and_imaginary_part(void)\r\n{\r\n   TEST_IGNORE();\r\n   complex_t z = { .real = 1.0, .imag = 2.0 };\r\n\r\n   double expected = 1.0;\r\n   double actual = c_real(z);\r\n\r\n   TEST_ASSERT_EQUAL_FLOAT(expected, actual);\r\n}\r\n\r\nstatic void test_imaginary_part_of_a_purely_real_number(void)\r\n{\r\n   TEST_IGNORE();\r\n   complex_t z = { .real = 1.0, .imag = 0.0 };\r\n\r\n   double expected = 0.0;\r\n   double actual = c_imag(z);\r\n\r\n   TEST_ASSERT_EQUAL_FLOAT(expected, actual);\r\n}\r\n\r\nstatic void test_imaginary_part_of_a_purely_imaginary_number(void)\r\n{\r\n   TEST_IGNORE();\r\n   complex_t z = { .real = 0.0, .imag = 1.0 };\r\n\r\n   double expected = 1.0;\r\n   double actual = c_imag(z);\r\n\r\n   TEST_ASSERT_EQUAL_FLOAT(expected, actual);\r\n}\r\n\r\nstatic void test_imaginary_part_of_a_number_with_real_and_imaginary_part(void)\r\n{\r\n   TEST_IGNORE();\r\n   complex_t z = { .real = 1.0, .imag = 2.0 };\r\n\r\n   double expected = 2.0;\r\n   double actual = c_imag(z);\r\n\r\n   TEST_ASSERT_EQUAL_FLOAT(expected, actual);\r\n}\r\n\r\nstatic void test_imaginary_unit(void)\r\n{\r\n   complex_t z = { .real = 0.0, .imag = 1.0 };\r\n\r\n   complex_t expected = { .real = -1.0, .imag = 0.0 };\r\n   complex_t actual = c_mul(z, z);\r\n\r\n   compare_complex(expected, actual);\r\n}\r\n\r\nstatic void test_add_purely_real_numbers(void)\r\n{\r\n   TEST_IGNORE();\r\n   complex_t z1 = { .real = 1.0, .imag = 0.0 };\r\n   complex_t z2 = { .real = 2.0, .imag = 0.0 };\r\n\r\n   complex_t expected = { .real = 3.0, .imag = 0.0 };\r\n   complex_t actual = c_add(z1, z2);\r\n\r\n   compare_complex(expected, actual);\r\n}\r\n\r\nstatic void test_add_purely_imaginary_numbers(void)\r\n{\r\n   TEST_IGNORE();\r\n   complex_t z1 = { .real = 0.0, .imag = 1.0 };\r\n   complex_t z2 = { .real = 0.0, .imag = 2.0 };\r\n\r\n   complex_t expected = { .real = 0.0, .imag = 3.0 };\r\n   complex_t actual = c_add(z1, z2);\r\n\r\n   compare_complex(expected, actual);\r\n}\r\n\r\nstatic void test_add_numbers_with_real_and_imaginary_part(void)\r\n{\r\n   TEST_IGNORE();\r\n   complex_t z1 = { .real = 1.0, .imag = 2.0 };\r\n   complex_t z2 = { .real = 3.0, .imag = 4.0 };\r\n\r\n   complex_t expected = { .real = 4.0, .imag = 6.0 };\r\n   complex_t actual = c_add(z1, z2);\r\n\r\n   compare_complex(expected, actual);\r\n}\r\n\r\nstatic void test_subtract_purely_real_numbers(void)\r\n{\r\n   TEST_IGNORE();\r\n   complex_t z1 = { .real = 1.0, .imag = 0.0 };\r\n   complex_t z2 = { .real = 2.0, .imag = 0.0 };\r\n\r\n   complex_t expected = { .real = -1.0, .imag = 0.0 };\r\n   complex_t actual = c_sub(z1, z2);\r\n\r\n   compare_complex(expected, actual);\r\n}\r\n\r\nstatic void test_subtract_purely_imaginary_numbers(void)\r\n{\r\n   TEST_IGNORE();\r\n   complex_t z1 = { .real = 0.0, .imag = 1.0 };\r\n   complex_t z2 = { .real = 0.0, .imag = 2.0 };\r\n\r\n   complex_t expected = { .real = 0.0, .imag = -1.0 };\r\n   complex_t actual = c_sub(z1, z2);\r\n\r\n   compare_complex(expected, actual);\r\n}\r\n\r\nstatic void test_subtract_numbers_with_real_and_imaginary_part(void)\r\n{\r\n   TEST_IGNORE();\r\n   complex_t z1 = { .real = 1.0, .imag = 2.0 };\r\n   complex_t z2 = { .real = 3.0, .imag = 4.0 };\r\n\r\n   complex_t expected = { .real = -2.0, .imag = -2.0 };\r\n   complex_t actual = c_sub(z1, z2);\r\n\r\n   compare_complex(expected, actual);\r\n}\r\n\r\nstatic void test_multiply_purely_real_numbers(void)\r\n{\r\n   TEST_IGNORE();\r\n   complex_t z1 = { .real = 1.0, .imag = 0.0 };\r\n   complex_t z2 = { .real = 2.0, .imag = 0.0 };\r\n\r\n   complex_t expected = { .real = 2.0, .imag = 0.0 };\r\n   complex_t actual = c_mul(z1, z2);\r\n\r\n   compare_complex(expected, actual);\r\n}\r\n\r\nstatic void test_multiply_purely_imaginary_numbers(void)\r\n{\r\n   TEST_IGNORE();\r\n   complex_t z1 = { .real = 0.0, .imag = 1.0 };\r\n   complex_t z2 = { .real = 0.0, .imag = 2.0 };\r\n\r\n   complex_t expected = { .real = -2.0, .imag = 0.0 };\r\n   complex_t actual = c_mul(z1, z2);\r\n\r\n   compare_complex(expected, actual);\r\n}\r\n\r\nstatic void test_multiply_numbers_with_real_and_imaginary_part(void)\r\n{\r\n   TEST_IGNORE();\r\n   complex_t z1 = { .real = 1.0, .imag = 2.0 };\r\n   complex_t z2 = { .real = 3.0, .imag = 4.0 };\r\n\r\n   complex_t expected = { .real = -5.0, .imag = 10.0 };\r\n   complex_t actual = c_mul(z1, z2);\r\n\r\n   compare_complex(expected, actual);\r\n}\r\n\r\nstatic void test_divide_purely_real_numbers(void)\r\n{\r\n   TEST_IGNORE();\r\n   complex_t z1 = { .real = 1.0, .imag = 0.0 };\r\n   complex_t z2 = { .real = 2.0, .imag = 0.0 };\r\n\r\n   complex_t expected = { .real = 0.5, .imag = 0.0 };\r\n   complex_t actual = c_div(z1, z2);\r\n\r\n   compare_complex(expected, actual);\r\n}\r\n\r\nstatic void test_divide_purely_imaginary_numbers(void)\r\n{\r\n   TEST_IGNORE();\r\n   complex_t z1 = { .real = 0.0, .imag = 1.0 };\r\n   complex_t z2 = { .real = 0.0, .imag = 2.0 };\r\n\r\n   complex_t expected = { .real = 0.5, .imag = 0.0 };\r\n   complex_t actual = c_div(z1, z2);\r\n\r\n   compare_complex(expected, actual);\r\n}\r\n\r\nstatic void test_divide_numbers_with_real_and_imaginary_part(void)\r\n{\r\n   TEST_IGNORE();\r\n   complex_t z1 = { .real = 1.0, .imag = 2.0 };\r\n   complex_t z2 = { .real = 3.0, .imag = 4.0 };\r\n\r\n   complex_t expected = { .real = 0.44, .imag = 0.08 };\r\n   complex_t actual = c_div(z1, z2);\r\n\r\n   compare_complex(expected, actual);\r\n}\r\n\r\nstatic void test_absolute_value_of_a_positive_purely_real_number(void)\r\n{\r\n   TEST_IGNORE();\r\n   complex_t z = { .real = 5.0, .imag = 0.0 };\r\n\r\n   double expected = 5.0;\r\n   double actual = c_abs(z);\r\n\r\n   TEST_ASSERT_EQUAL_FLOAT(expected, actual);\r\n}\r\n\r\nstatic void test_absolute_value_of_a_negative_purely_real_number(void)\r\n{\r\n   TEST_IGNORE();\r\n   complex_t z = { .real = -5.0, .imag = 0.0 };\r\n\r\n   double expected = 5.0;\r\n   double actual = c_abs(z);\r\n\r\n   TEST_ASSERT_EQUAL_FLOAT(expected, actual);\r\n}\r\n\r\nstatic void\r\ntest_absolute_value_of_a_purely_imaginary_number_with_positive_imaginary_part(\r\n    void)\r\n{\r\n   TEST_IGNORE();\r\n   complex_t z = { .real = 0.0, .imag = 5.0 };\r\n\r\n   double expected = 5.0;\r\n   double actual = c_abs(z);\r\n\r\n   TEST_ASSERT_EQUAL_FLOAT(expected, actual);\r\n}\r\n\r\nstatic void\r\ntest_absolute_value_of_a_purely_imaginary_number_with_negative_imaginary_part(\r\n    void)\r\n{\r\n   TEST_IGNORE();\r\n   complex_t z = { .real = 0.0, .imag = -5.0 };\r\n\r\n   double expected = 5.0;\r\n   double actual = c_abs(z);\r\n\r\n   TEST_ASSERT_EQUAL_FLOAT(expected, actual);\r\n}\r\n\r\nstatic void test_absolute_value_of_a_number_with_real_and_imaginary_part(void)\r\n{\r\n   TEST_IGNORE();\r\n   complex_t z = { .real = 3.0, .imag = 4.0 };\r\n\r\n   double expected = 5.0;\r\n   double actual = c_abs(z);\r\n\r\n   TEST_ASSERT_EQUAL_FLOAT(expected, actual);\r\n}\r\n\r\nstatic void test_complex_conjugate_of_a_purely_real_number(void)\r\n{\r\n   TEST_IGNORE();\r\n   complex_t z = { .real = 5.0, .imag = 0.0 };\r\n\r\n   complex_t expected = { .real = 5.0, .imag = 0.0 };\r\n   complex_t actual = c_conjugate(z);\r\n\r\n   compare_complex(expected, actual);\r\n}\r\n\r\nstatic void test_complex_conjugate_of_a_purely_imaginary_number(void)\r\n{\r\n   TEST_IGNORE();\r\n   complex_t z = { .real = 0.0, .imag = 5.0 };\r\n\r\n   complex_t expected = { .real = 0.0, .imag = -5.0 };\r\n   complex_t actual = c_conjugate(z);\r\n\r\n   compare_complex(expected, actual);\r\n}\r\n\r\nstatic void\r\ntest_complex_conjugate_of_a_number_with_real_and_imaginary_part(void)\r\n{\r\n   TEST_IGNORE();\r\n   complex_t z = { .real = 1.0, .imag = 1.0 };\r\n\r\n   complex_t expected = { .real = 1.0, .imag = -1.0 };\r\n   complex_t actual = c_conjugate(z);\r\n\r\n   compare_complex(expected, actual);\r\n}\r\n\r\nstatic void test_eulers_identity(void)\r\n{\r\n   TEST_IGNORE();\r\n   complex_t z = { .real = 0.0, .imag = PI };\r\n\r\n   complex_t expected = { .real = -1.0, .imag = 0.0 };\r\n   complex_t actual = c_exp(z);\r\n\r\n   TEST_ASSERT_FLOAT_WITHIN(1e-10, expected.real, actual.real);\r\n   TEST_ASSERT_FLOAT_WITHIN(1e-10, expected.imag, actual.imag);\r\n}\r\n\r\nstatic void test_exponential_of_zero(void)\r\n{\r\n   TEST_IGNORE();\r\n   complex_t zero = { .real = 0.0, .imag = 0.0 };\r\n\r\n   complex_t expected = { .real = 1.0, .imag = 0.0 };\r\n   complex_t actual = c_exp(zero);\r\n\r\n   compare_complex(expected, actual);\r\n}\r\n\r\nstatic void test_exponential_of_a_purely_real_number(void)\r\n{\r\n   TEST_IGNORE();\r\n   complex_t z = { .real = 1.0, .imag = 0.0 };\r\n\r\n   complex_t expected = { .real = E, .imag = 0.0 };\r\n   complex_t actual = c_exp(z);\r\n\r\n   compare_complex(expected, actual);\r\n}\r\n\r\nstatic void test_exponential_of_a_number_with_real_and_imaginary_part(void)\r\n{\r\n   TEST_IGNORE();\r\n   // In math.h the log() function computes log to the base e, which\r\n   // is the natural logarithm, often written in mathematics as ln\r\n   complex_t z = { .real = log(2.0), .imag = PI };\r\n\r\n   complex_t expected = { .real = -2.0, .imag = 0 };\r\n   complex_t actual = c_exp(z);\r\n\r\n   compare_complex(expected, actual);\r\n}\r\n\r\nstatic void\r\ntest_exponential_resulting_in_number_with_real_and_imaginary_part(void)\r\n{\r\n   TEST_IGNORE();\r\n   complex_t z = { .real = log(2.0) / 2.0, .imag = PI / 4.0 };\r\n\r\n   complex_t expected = { .real = 1.0, .imag = 1.0 };\r\n   complex_t actual = c_exp(z);\r\n\r\n   compare_complex(expected, actual);\r\n}\r\n\r\nstatic void test_add_real_number_to_complex_number(void)\r\n{\r\n   TEST_IGNORE();\r\n   complex_t z1 = { .real = 1.0, .imag = 2.0 };\r\n   complex_t z2 = { .real = 5.0, .imag = 0.0 };\r\n\r\n   complex_t expected = { .real = 6.0, .imag = 2.0 };\r\n   complex_t actual = c_add(z1, z2);\r\n\r\n   compare_complex(expected, actual);\r\n}\r\n\r\nstatic void test_add_complex_number_to_real_number(void)\r\n{\r\n   TEST_IGNORE();\r\n   complex_t z1 = { .real = 5.0, .imag = 0.0 };\r\n   complex_t z2 = { .real = 1.0, .imag = 2.0 };\r\n\r\n   complex_t expected = { .real = 6.0, .imag = 2.0 };\r\n   complex_t actual = c_add(z1, z2);\r\n\r\n   compare_complex(expected, actual);\r\n}\r\n\r\nstatic void test_subtract_real_number_from_complex_number(void)\r\n{\r\n   TEST_IGNORE();\r\n   complex_t z1 = { .real = 5.0, .imag = 7.0 };\r\n   complex_t z2 = { .real = 4.0, .imag = 0.0 };\r\n\r\n   complex_t expected = { .real = 1.0, .imag = 7.0 };\r\n   complex_t actual = c_sub(z1, z2);\r\n\r\n   compare_complex(expected, actual);\r\n}\r\n\r\nstatic void test_subtract_complex_number_from_real_number(void)\r\n{\r\n   TEST_IGNORE();\r\n   complex_t z1 = { .real = 4.0, .imag = 0.0 };\r\n   complex_t z2 = { .real = 5.0, .imag = 7.0 };\r\n\r\n   complex_t expected = { .real = -1.0, .imag = -7.0 };\r\n   complex_t actual = c_sub(z1, z2);\r\n\r\n   compare_complex(expected, actual);\r\n}\r\n\r\nstatic void test_multiply_complex_number_by_real_number(void)\r\n{\r\n   TEST_IGNORE();\r\n   complex_t z1 = { .real = 2.0, .imag = 5.0 };\r\n   complex_t z2 = { .real = 5.0, .imag = 0.0 };\r\n\r\n   complex_t expected = { .real = 10.0, .imag = 25.0 };\r\n   complex_t actual = c_mul(z1, z2);\r\n\r\n   compare_complex(expected, actual);\r\n}\r\n\r\nstatic void test_multiply_real_number_by_complex_number(void)\r\n{\r\n   TEST_IGNORE();\r\n   complex_t z1 = { .real = 5.0, .imag = 0.0 };\r\n   complex_t z2 = { .real = 2.0, .imag = 5.0 };\r\n\r\n   complex_t expected = { .real = 10.0, .imag = 25.0 };\r\n   complex_t actual = c_mul(z1, z2);\r\n\r\n   compare_complex(expected, actual);\r\n}\r\n\r\nstatic void test_divide_complex_number_by_real_number(void)\r\n{\r\n   TEST_IGNORE();\r\n   complex_t z1 = { .real = 10.0, .imag = 100.0 };\r\n   complex_t z2 = { .real = 10.0, .imag = 0.0 };\r\n\r\n   complex_t expected = { .real = 1.0, .imag = 10.0 };\r\n   complex_t actual = c_div(z1, z2);\r\n\r\n   compare_complex(expected, actual);\r\n}\r\n\r\nstatic void test_divide_real_number_by_complex_number(void)\r\n{\r\n   TEST_IGNORE();\r\n   complex_t z1 = { .real = 5.0, .imag = 0.0 };\r\n   complex_t z2 = { .real = 1.0, .imag = 1.0 };\r\n\r\n   complex_t expected = { .real = 2.5, .imag = -2.5 };\r\n   complex_t actual = c_div(z1, z2);\r\n\r\n   compare_complex(expected, actual);\r\n}\r\n\r\nint main(void)\r\n{\r\n   UNITY_BEGIN();\r\n\r\n   RUN_TEST(test_real_part_of_a_purely_real_number);\r\n   RUN_TEST(test_real_part_of_a_purely_imaginary_number);\r\n   RUN_TEST(test_real_part_of_a_number_with_real_and_imaginary_part);\r\n   RUN_TEST(test_imaginary_part_of_a_purely_real_number);\r\n   RUN_TEST(test_imaginary_part_of_a_purely_imaginary_number);\r\n   RUN_TEST(test_imaginary_part_of_a_number_with_real_and_imaginary_part);\r\n\r\n   RUN_TEST(test_imaginary_unit);\r\n\r\n   RUN_TEST(test_add_purely_real_numbers);\r\n   RUN_TEST(test_add_purely_imaginary_numbers);\r\n   RUN_TEST(test_add_numbers_with_real_and_imaginary_part);\r\n\r\n   RUN_TEST(test_subtract_purely_real_numbers);\r\n   RUN_TEST(test_subtract_purely_imaginary_numbers);\r\n   RUN_TEST(test_subtract_numbers_with_real_and_imaginary_part);\r\n\r\n   RUN_TEST(test_multiply_purely_real_numbers);\r\n   RUN_TEST(test_multiply_purely_imaginary_numbers);\r\n   RUN_TEST(test_multiply_numbers_with_real_and_imaginary_part);\r\n\r\n   RUN_TEST(test_divide_purely_real_numbers);\r\n   RUN_TEST(test_divide_purely_imaginary_numbers);\r\n   RUN_TEST(test_divide_numbers_with_real_and_imaginary_part);\r\n\r\n   RUN_TEST(test_absolute_value_of_a_positive_purely_real_number);\r\n   RUN_TEST(test_absolute_value_of_a_negative_purely_real_number);\r\n   RUN_TEST(\r\n       test_absolute_value_of_a_purely_imaginary_number_with_positive_imaginary_part);\r\n   RUN_TEST(\r\n       test_absolute_value_of_a_purely_imaginary_number_with_negative_imaginary_part);\r\n   RUN_TEST(test_absolute_value_of_a_number_with_real_and_imaginary_part);\r\n\r\n   RUN_TEST(test_complex_conjugate_of_a_purely_real_number);\r\n   RUN_TEST(test_complex_conjugate_of_a_purely_imaginary_number);\r\n   RUN_TEST(test_complex_conjugate_of_a_number_with_real_and_imaginary_part);\r\n\r\n   RUN_TEST(test_eulers_identity);\r\n   RUN_TEST(test_exponential_of_zero);\r\n   RUN_TEST(test_exponential_of_a_purely_real_number);\r\n   RUN_TEST(test_exponential_of_a_number_with_real_and_imaginary_part);\r\n   RUN_TEST(test_exponential_resulting_in_number_with_real_and_imaginary_part);\r\n\r\n   RUN_TEST(test_add_real_number_to_complex_number);\r\n   RUN_TEST(test_add_complex_number_to_real_number);\r\n   RUN_TEST(test_subtract_real_number_from_complex_number);\r\n   RUN_TEST(test_subtract_complex_number_from_real_number);\r\n   RUN_TEST(test_multiply_complex_number_by_real_number);\r\n   RUN_TEST(test_multiply_real_number_by_complex_number);\r\n   RUN_TEST(test_divide_complex_number_by_real_number);\r\n   RUN_TEST(test_divide_real_number_by_complex_number);\r\n\r\n   return UNITY_END();\r\n}\r\n"
  }
}