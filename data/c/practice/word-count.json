{
  "language": "c",
  "slug": "word-count",
  "docs": {
    "introduction": "# Introduction\r\n\r\nYou teach English as a foreign language to high school students.\r\n\r\nYou've decided to base your entire curriculum on TV shows.\r\nYou need to analyze which words are used, and how often they're repeated.\r\n\r\nThis will let you choose the simplest shows to start with, and to gradually increase the difficulty as time passes.\r\n",
    "instructions": "# Instructions\r\n\r\nYour task is to count how many times each word occurs in a subtitle of a drama.\r\n\r\nThe subtitles from these dramas use only ASCII characters.\r\n\r\nThe characters often speak in casual English, using contractions like _they're_ or _it's_.\r\nThough these contractions come from two words (e.g. _we are_), the contraction (_we're_) is considered a single word.\r\n\r\nWords can be separated by any form of punctuation (e.g. \":\", \"!\", or \"?\") or whitespace (e.g. \"\\t\", \"\\n\", or \" \").\r\nThe only punctuation that does not separate words is the apostrophe in contractions.\r\n\r\nNumbers are considered words.\r\nIf the subtitles say _It costs 100 dollars._ then _100_ will be its own word.\r\n\r\nWords are case insensitive.\r\nFor example, the word _you_ occurs three times in the following sentence:\r\n\r\n> You come back, you hear me? DO YOU HEAR ME?\r\n\r\nThe ordering of the word counts in the results doesn't matter.\r\n\r\nHere's an example that incorporates several of the elements discussed above:\r\n\r\n- simple words\r\n- contractions\r\n- numbers\r\n- case insensitive words\r\n- punctuation (including apostrophes) to separate words\r\n- different forms of whitespace to separate words\r\n\r\n`\"That's the password: 'PASSWORD 123'!\", cried the Special Agent.\\nSo I fled.`\r\n\r\nThe mapping for this subtitle would be:\r\n\r\n```text\r\n123: 1\r\nagent: 1\r\ncried: 1\r\nfled: 1\r\ni: 1\r\npassword: 2\r\nso: 1\r\nspecial: 1\r\nthat's: 1\r\nthe: 2\r\n```\r\n",
    "hints": ""
  },
  "starter_code": {
    "word_count.c": "#include \"word_count.h\"\r\n",
    "word_count.h": "#ifndef WORD_COUNT_H\r\n#define WORD_COUNT_H\r\n\r\n#define MAX_WORDS                                                              \\\r\n   20   // at most MAX_WORDS can be found in the test input string\r\n#define MAX_WORD_LENGTH 50   // no individual word can exceed this length\r\n\r\n// results structure\r\ntypedef struct word_count_word {\r\n   char text[MAX_WORD_LENGTH +\r\n             1];   // allow for the string to be null-terminated\r\n   int count;\r\n} word_count_word_t;\r\n\r\n#define EXCESSIVE_LENGTH_WORD -1\r\n#define EXCESSIVE_NUMBER_OF_WORDS -2\r\n\r\n// count_words - routine to classify the unique words and their frequency in a\r\n// sentence inputs:\r\n//    sentence =  a null-terminated string containing that is analyzed\r\n//\r\n// outputs:\r\n//    words = allocated structure to record the words found and their frequency\r\n//    uniqueWords - number of words in the words structure\r\n//           returns a negative number if an error.\r\n//           words will contain the results up to that point.\r\nint count_words(const char *sentence, word_count_word_t *words);\r\n\r\n#endif\r\n"
  },
  "tests": {
    "test_word_count.c": "#include <stddef.h>\r\n#include <stdlib.h>\r\n#include <string.h>\r\n#include \"test-framework/unity.h\"\r\n#include \"word_count.h\"\r\n\r\n#define STRING_SIZE (MAX_WORD_LENGTH + 1)\r\n\r\nword_count_word_t actual_solution[MAX_WORDS];\r\nword_count_word_t expected_solution[MAX_WORDS + 1];\r\n\r\nvoid setUp(void)\r\n{\r\n}\r\n\r\nvoid tearDown(void)\r\n{\r\n}\r\n\r\nstatic int compare_word(const void *a, const void *b)\r\n{\r\n   word_count_word_t *w1 = (word_count_word_t *)a;\r\n   word_count_word_t *w2 = (word_count_word_t *)b;\r\n   return strcmp(w1->text, w2->text);\r\n}\r\n\r\nstatic void check_solution(word_count_word_t *expected_solution,\r\n                           int expected_word_count,\r\n                           word_count_word_t *actual_solution,\r\n                           int actual_word_count)\r\n{\r\n   // All words counted?\r\n   TEST_ASSERT_EQUAL(expected_word_count, actual_word_count);\r\n\r\n   // Sort the words before comparing\r\n   qsort(expected_solution, expected_word_count, sizeof(word_count_word_t),\r\n         compare_word);\r\n   qsort(actual_solution, actual_word_count, sizeof(word_count_word_t),\r\n         compare_word);\r\n\r\n   // now test the word count for the words...\r\n   for (int index = 0; index < MAX_WORDS; index++) {\r\n      TEST_ASSERT_EQUAL(expected_solution[index].count,\r\n                        actual_solution[index].count);\r\n      TEST_ASSERT_EQUAL_STRING_LEN(expected_solution[index].text,\r\n                                   actual_solution[index].text,\r\n                                   strlen(expected_solution[index].text) + 1);\r\n   }\r\n}\r\n\r\n// Tests Start here\r\nstatic void test_count_one_word(void)\r\n{\r\n   int index = 0;\r\n   int actual_word_count;\r\n   char *input_text = \"word\";\r\n   const int expected_word_count = 1;\r\n\r\n   // build the expected solution\r\n   memset(expected_solution, 0,\r\n          sizeof(expected_solution));   // clear to start with a known value\r\n   memset(actual_solution, 0, sizeof(actual_solution));\r\n\r\n   // fill in the expected words\r\n   expected_solution[index].count = 1;\r\n   strncpy(expected_solution[index++].text, \"word\", STRING_SIZE);\r\n\r\n   actual_word_count = count_words(input_text, actual_solution);\r\n\r\n   check_solution(expected_solution, expected_word_count, actual_solution,\r\n                  actual_word_count);\r\n}\r\n\r\nstatic void test_count_one_of_each_word(void)\r\n{\r\n   TEST_IGNORE();   // delete this line to run test\r\n   int index = 0;\r\n   int actual_word_count;\r\n   char *input_text = \"one of each\";\r\n   const int expected_word_count = 3;\r\n\r\n   // build the expected solution\r\n   memset(expected_solution, 0,\r\n          sizeof(expected_solution));   // clear to start with a known value\r\n   memset(actual_solution, 0, sizeof(actual_solution));\r\n\r\n   // fill in the expected words\r\n   expected_solution[index].count = 1;\r\n   strncpy(expected_solution[index++].text, \"one\", STRING_SIZE);\r\n\r\n   expected_solution[index].count = 1;\r\n   strncpy(expected_solution[index++].text, \"of\", STRING_SIZE);\r\n\r\n   expected_solution[index].count = 1;\r\n   strncpy(expected_solution[index++].text, \"each\", STRING_SIZE);\r\n\r\n   actual_word_count = count_words(input_text, actual_solution);\r\n\r\n   check_solution(expected_solution, expected_word_count, actual_solution,\r\n                  actual_word_count);\r\n}\r\n\r\nstatic void test_multiple_occurrences_of_a_word(void)\r\n{\r\n   TEST_IGNORE();\r\n   int index = 0;\r\n   int actual_word_count;\r\n   char *input_text = \"one fish two fish red fish blue fish\";\r\n   const int expected_word_count = 5;\r\n\r\n   // build the expected solution\r\n   memset(expected_solution, 0,\r\n          sizeof(expected_solution));   // clear to start with a known value\r\n   memset(actual_solution, 0, sizeof(actual_solution));\r\n\r\n   expected_solution[index].count = 1;\r\n   strncpy(expected_solution[index++].text, \"one\", STRING_SIZE);\r\n\r\n   expected_solution[index].count = 4;\r\n   strncpy(expected_solution[index++].text, \"fish\", STRING_SIZE);\r\n\r\n   expected_solution[index].count = 1;\r\n   strncpy(expected_solution[index++].text, \"two\", STRING_SIZE);\r\n\r\n   expected_solution[index].count = 1;\r\n   strncpy(expected_solution[index++].text, \"red\", STRING_SIZE);\r\n\r\n   expected_solution[index].count = 1;\r\n   strncpy(expected_solution[index++].text, \"blue\", STRING_SIZE);\r\n\r\n   actual_word_count = count_words(input_text, actual_solution);\r\n\r\n   check_solution(expected_solution, expected_word_count, actual_solution,\r\n                  actual_word_count);\r\n}\r\n\r\nstatic void test_handles_cramped_lists(void)\r\n{\r\n   TEST_IGNORE();\r\n   int index = 0;\r\n   int actual_word_count;\r\n   char *input_text = \"one,two,three\";\r\n   const int expected_word_count = 3;\r\n\r\n   // build the expected solution\r\n   memset(expected_solution, 0,\r\n          sizeof(expected_solution));   // clear to start with a known value\r\n   memset(actual_solution, 0, sizeof(actual_solution));\r\n\r\n   expected_solution[index].count = 1;\r\n   strncpy(expected_solution[index++].text, \"one\", STRING_SIZE);\r\n\r\n   expected_solution[index].count = 1;\r\n   strncpy(expected_solution[index++].text, \"two\", STRING_SIZE);\r\n\r\n   expected_solution[index].count = 1;\r\n   strncpy(expected_solution[index++].text, \"three\", STRING_SIZE);\r\n\r\n   actual_word_count = count_words(input_text, actual_solution);\r\n\r\n   check_solution(expected_solution, expected_word_count, actual_solution,\r\n                  actual_word_count);\r\n}\r\n\r\nstatic void test_handles_expanded_lists(void)\r\n{\r\n   TEST_IGNORE();\r\n   int index = 0;\r\n   int actual_word_count;\r\n   char *input_text = \"one,\\ntwo,\\nthree\";\r\n   const int expected_word_count = 3;\r\n\r\n   // build the expected solution\r\n   memset(expected_solution, 0,\r\n          sizeof(expected_solution));   // clear to start with a known value\r\n   memset(actual_solution, 0, sizeof(actual_solution));\r\n\r\n   expected_solution[index].count = 1;\r\n   strncpy(expected_solution[index++].text, \"one\", STRING_SIZE);\r\n\r\n   expected_solution[index].count = 1;\r\n   strncpy(expected_solution[index++].text, \"two\", STRING_SIZE);\r\n\r\n   expected_solution[index].count = 1;\r\n   strncpy(expected_solution[index++].text, \"three\", STRING_SIZE);\r\n\r\n   actual_word_count = count_words(input_text, actual_solution);\r\n\r\n   check_solution(expected_solution, expected_word_count, actual_solution,\r\n                  actual_word_count);\r\n}\r\n\r\nstatic void test_ignore_punctuation(void)\r\n{\r\n   TEST_IGNORE();\r\n   int index = 0;\r\n   int actual_word_count;\r\n   char *input_text = \"car: carpet as java: javascript!!&@$%^&\";\r\n   const int expected_word_count = 5;\r\n\r\n   // build the expected solution\r\n   memset(expected_solution, 0,\r\n          sizeof(expected_solution));   // clear to start with a known value\r\n   memset(actual_solution, 0, sizeof(actual_solution));\r\n\r\n   expected_solution[index].count = 1;\r\n   strncpy(expected_solution[index++].text, \"car\", STRING_SIZE);\r\n\r\n   expected_solution[index].count = 1;\r\n   strncpy(expected_solution[index++].text, \"carpet\", STRING_SIZE);\r\n\r\n   expected_solution[index].count = 1;\r\n   strncpy(expected_solution[index++].text, \"as\", STRING_SIZE);\r\n\r\n   expected_solution[index].count = 1;\r\n   strncpy(expected_solution[index++].text, \"java\", STRING_SIZE);\r\n\r\n   expected_solution[index].count = 1;\r\n   strncpy(expected_solution[index++].text, \"javascript\", STRING_SIZE);\r\n\r\n   actual_word_count = count_words(input_text, actual_solution);\r\n\r\n   check_solution(expected_solution, expected_word_count, actual_solution,\r\n                  actual_word_count);\r\n}\r\n\r\nstatic void test_include_numbers(void)\r\n{\r\n   TEST_IGNORE();\r\n   int index = 0;\r\n   int actual_word_count;\r\n   char *input_text = \"testing, 1, 2 testing\";\r\n   const int expected_word_count = 3;\r\n\r\n   // build the expected solution\r\n   memset(expected_solution, 0,\r\n          sizeof(expected_solution));   // clear to start with a known value\r\n   memset(actual_solution, 0, sizeof(actual_solution));\r\n\r\n   expected_solution[index].count = 2;\r\n   strncpy(expected_solution[index++].text, \"testing\", STRING_SIZE);\r\n\r\n   expected_solution[index].count = 1;\r\n   strncpy(expected_solution[index++].text, \"1\", STRING_SIZE);\r\n\r\n   expected_solution[index].count = 1;\r\n   strncpy(expected_solution[index++].text, \"2\", STRING_SIZE);\r\n\r\n   actual_word_count = count_words(input_text, actual_solution);\r\n\r\n   check_solution(expected_solution, expected_word_count, actual_solution,\r\n                  actual_word_count);\r\n}\r\n\r\nstatic void test_normalize_case(void)\r\n{\r\n   TEST_IGNORE();\r\n   int index = 0;\r\n   int actual_word_count;\r\n   char *input_text = \"go Go GO Stop stop\";\r\n   const int expected_word_count = 2;\r\n\r\n   // build the expected solution\r\n   memset(expected_solution, 0,\r\n          sizeof(expected_solution));   // clear to start with a known value\r\n   memset(actual_solution, 0, sizeof(actual_solution));\r\n\r\n   expected_solution[index].count = 3;\r\n   strncpy(expected_solution[index++].text, \"go\", STRING_SIZE);\r\n\r\n   expected_solution[index].count = 2;\r\n   strncpy(expected_solution[index++].text, \"stop\", STRING_SIZE);\r\n\r\n   actual_word_count = count_words(input_text, actual_solution);\r\n\r\n   check_solution(expected_solution, expected_word_count, actual_solution,\r\n                  actual_word_count);\r\n}\r\n\r\nstatic void test_with_apostrophes(void)\r\n{\r\n   TEST_IGNORE();\r\n   int index = 0;\r\n   int actual_word_count;\r\n   char *input_text = \"First: don't laugh. Then: don't cry. You're getting it.\";\r\n   const int expected_word_count = 8;\r\n\r\n   // build the expected solution\r\n   memset(expected_solution, 0,\r\n          sizeof(expected_solution));   // clear to start with a known value\r\n   memset(actual_solution, 0, sizeof(actual_solution));\r\n\r\n   expected_solution[index].count = 1;\r\n   strncpy(expected_solution[index++].text, \"first\", STRING_SIZE);\r\n\r\n   expected_solution[index].count = 2;\r\n   strncpy(expected_solution[index++].text, \"don't\", STRING_SIZE);\r\n\r\n   expected_solution[index].count = 1;\r\n   strncpy(expected_solution[index++].text, \"laugh\", STRING_SIZE);\r\n\r\n   expected_solution[index].count = 1;\r\n   strncpy(expected_solution[index++].text, \"then\", STRING_SIZE);\r\n\r\n   expected_solution[index].count = 1;\r\n   strncpy(expected_solution[index++].text, \"cry\", STRING_SIZE);\r\n\r\n   expected_solution[index].count = 1;\r\n   strncpy(expected_solution[index++].text, \"you're\", STRING_SIZE);\r\n\r\n   expected_solution[index].count = 1;\r\n   strncpy(expected_solution[index++].text, \"getting\", STRING_SIZE);\r\n\r\n   expected_solution[index].count = 1;\r\n   strncpy(expected_solution[index++].text, \"it\", STRING_SIZE);\r\n\r\n   actual_word_count = count_words(input_text, actual_solution);\r\n\r\n   check_solution(expected_solution, expected_word_count, actual_solution,\r\n                  actual_word_count);\r\n}\r\n\r\nstatic void test_with_quotations(void)\r\n{\r\n   TEST_IGNORE();\r\n   int index = 0;\r\n   int actual_word_count;\r\n   char *input_text = \"Joe can't tell between 'large' and large.\";\r\n   const int expected_word_count = 6;\r\n\r\n   // build the expected solution\r\n   memset(expected_solution, 0,\r\n          sizeof(expected_solution));   // clear to start with a known value\r\n   memset(actual_solution, 0, sizeof(actual_solution));\r\n\r\n   expected_solution[index].count = 1;\r\n   strncpy(expected_solution[index++].text, \"joe\", STRING_SIZE);\r\n\r\n   expected_solution[index].count = 1;\r\n   strncpy(expected_solution[index++].text, \"can't\", STRING_SIZE);\r\n\r\n   expected_solution[index].count = 1;\r\n   strncpy(expected_solution[index++].text, \"tell\", STRING_SIZE);\r\n\r\n   expected_solution[index].count = 1;\r\n   strncpy(expected_solution[index++].text, \"between\", STRING_SIZE);\r\n\r\n   expected_solution[index].count = 2;\r\n   strncpy(expected_solution[index++].text, \"large\", STRING_SIZE);\r\n\r\n   expected_solution[index].count = 1;\r\n   strncpy(expected_solution[index++].text, \"and\", STRING_SIZE);\r\n\r\n   actual_word_count = count_words(input_text, actual_solution);\r\n\r\n   check_solution(expected_solution, expected_word_count, actual_solution,\r\n                  actual_word_count);\r\n}\r\n\r\nstatic void test_substrings_from_the_beginning(void)\r\n{\r\n   TEST_IGNORE();\r\n   int index = 0;\r\n   int actual_word_count;\r\n   char *input_text = \"Joe can't tell between app, apple and a.\";\r\n   const int expected_word_count = 8;\r\n\r\n   // build the expected solution\r\n   memset(expected_solution, 0,\r\n          sizeof(expected_solution));   // clear to start with a known value\r\n   memset(actual_solution, 0, sizeof(actual_solution));\r\n\r\n   expected_solution[index].count = 1;\r\n   strncpy(expected_solution[index++].text, \"joe\", STRING_SIZE);\r\n\r\n   expected_solution[index].count = 1;\r\n   strncpy(expected_solution[index++].text, \"can't\", STRING_SIZE);\r\n\r\n   expected_solution[index].count = 1;\r\n   strncpy(expected_solution[index++].text, \"tell\", STRING_SIZE);\r\n\r\n   expected_solution[index].count = 1;\r\n   strncpy(expected_solution[index++].text, \"between\", STRING_SIZE);\r\n\r\n   expected_solution[index].count = 1;\r\n   strncpy(expected_solution[index++].text, \"app\", STRING_SIZE);\r\n\r\n   expected_solution[index].count = 1;\r\n   strncpy(expected_solution[index++].text, \"apple\", STRING_SIZE);\r\n\r\n   expected_solution[index].count = 1;\r\n   strncpy(expected_solution[index++].text, \"and\", STRING_SIZE);\r\n\r\n   expected_solution[index].count = 1;\r\n   strncpy(expected_solution[index++].text, \"a\", STRING_SIZE);\r\n\r\n   actual_word_count = count_words(input_text, actual_solution);\r\n\r\n   check_solution(expected_solution, expected_word_count, actual_solution,\r\n                  actual_word_count);\r\n}\r\n\r\nstatic void test_multiple_spaces_not_detected_as_a_word(void)\r\n{\r\n   TEST_IGNORE();\r\n   int actual_word_count;\r\n   int index = 0;\r\n   char *input_text = \" multiple   whitespaces\";\r\n\r\n   const int expected_word_count = 2;\r\n\r\n   // build the expected solution\r\n   memset(expected_solution, 0,\r\n          sizeof(expected_solution));   // clear to start with a known value\r\n   memset(actual_solution, 0, sizeof(actual_solution));\r\n\r\n   expected_solution[index].count = 1;\r\n   strncpy(expected_solution[index++].text, \"multiple\", STRING_SIZE);\r\n\r\n   expected_solution[index].count = 1;\r\n   strncpy(expected_solution[index++].text, \"whitespaces\", STRING_SIZE);\r\n\r\n   actual_word_count = count_words(input_text, actual_solution);\r\n\r\n   check_solution(expected_solution, expected_word_count, actual_solution,\r\n                  actual_word_count);\r\n}\r\n\r\nstatic void test_alternating_word_separators_not_detected_as_a_word(void)\r\n{\r\n   TEST_IGNORE();\r\n   int actual_word_count;\r\n   int index = 0;\r\n   char *input_text = \",\\n,one,\\n ,two \\n 'three'\";\r\n\r\n   const int expected_word_count = 3;\r\n\r\n   // build the expected solution\r\n   memset(expected_solution, 0,\r\n          sizeof(expected_solution));   // clear to start with a known value\r\n   memset(actual_solution, 0, sizeof(actual_solution));\r\n\r\n   expected_solution[index].count = 1;\r\n   strncpy(expected_solution[index++].text, \"one\", STRING_SIZE);\r\n\r\n   expected_solution[index].count = 1;\r\n   strncpy(expected_solution[index++].text, \"two\", STRING_SIZE);\r\n\r\n   expected_solution[index].count = 1;\r\n   strncpy(expected_solution[index++].text, \"three\", STRING_SIZE);\r\n\r\n   actual_word_count = count_words(input_text, actual_solution);\r\n\r\n   check_solution(expected_solution, expected_word_count, actual_solution,\r\n                  actual_word_count);\r\n}\r\n\r\nstatic void test_quotation_for_word_with_apostrophe(void)\r\n{\r\n   TEST_IGNORE();\r\n   int actual_word_count;\r\n   int index = 0;\r\n   char *input_text = \"can, can't, 'can't'\";\r\n\r\n   const int expected_word_count = 2;\r\n\r\n   // build the expected solution\r\n   memset(expected_solution, 0,\r\n          sizeof(expected_solution));   // clear to start with a known value\r\n   memset(actual_solution, 0, sizeof(actual_solution));\r\n\r\n   expected_solution[index].count = 1;\r\n   strncpy(expected_solution[index++].text, \"can\", STRING_SIZE);\r\n\r\n   expected_solution[index].count = 2;\r\n   strncpy(expected_solution[index++].text, \"can't\", STRING_SIZE);\r\n\r\n   actual_word_count = count_words(input_text, actual_solution);\r\n\r\n   check_solution(expected_solution, expected_word_count, actual_solution,\r\n                  actual_word_count);\r\n}\r\n\r\nint main(void)\r\n{\r\n   UNITY_BEGIN();\r\n\r\n   RUN_TEST(test_count_one_word);\r\n   RUN_TEST(test_count_one_of_each_word);\r\n   RUN_TEST(test_multiple_occurrences_of_a_word);\r\n   RUN_TEST(test_handles_cramped_lists);\r\n   RUN_TEST(test_handles_expanded_lists);\r\n   RUN_TEST(test_ignore_punctuation);\r\n   RUN_TEST(test_include_numbers);\r\n   RUN_TEST(test_normalize_case);\r\n   RUN_TEST(test_with_apostrophes);\r\n   RUN_TEST(test_with_quotations);\r\n   RUN_TEST(test_substrings_from_the_beginning);\r\n   RUN_TEST(test_multiple_spaces_not_detected_as_a_word);\r\n   RUN_TEST(test_alternating_word_separators_not_detected_as_a_word);\r\n   RUN_TEST(test_quotation_for_word_with_apostrophe);\r\n\r\n   return UNITY_END();\r\n}\r\n"
  }
}