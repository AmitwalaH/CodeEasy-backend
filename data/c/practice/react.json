{
  "language": "c",
  "slug": "react",
  "docs": {
    "introduction": "",
    "instructions": "# Instructions\r\n\r\nImplement a basic reactive system.\r\n\r\nReactive programming is a programming paradigm that focuses on how values are computed in terms of each other to allow a change to one value to automatically propagate to other values, like in a spreadsheet.\r\n\r\nImplement a basic reactive system with cells with settable values (\"input\" cells) and cells with values computed in terms of other cells (\"compute\" cells).\r\nImplement updates so that when an input value is changed, values propagate to reach a new stable system state.\r\n\r\nIn addition, compute cells should allow for registering change notification callbacks.\r\nCall a cell’s callbacks when the cell’s value in a new stable state has changed from the previous stable state.\r\n",
    "hints": ""
  },
  "starter_code": {
    "react.c": "#include \"react.h\"\r\n",
    "react.h": "#ifndef REACT_H\r\n#define REACT_H\r\n\r\nstruct reactor;\r\nstruct cell;\r\n\r\ntypedef int (*compute1)(int);\r\ntypedef int (*compute2)(int, int);\r\n\r\nstruct reactor *create_reactor(void);\r\n// destroy_reactor should free all cells created under that reactor.\r\nvoid destroy_reactor(struct reactor *);\r\n\r\nstruct cell *create_input_cell(struct reactor *, int initial_value);\r\nstruct cell *create_compute1_cell(struct reactor *, struct cell *, compute1);\r\nstruct cell *create_compute2_cell(struct reactor *, struct cell *,\r\n                                  struct cell *, compute2);\r\n\r\nint get_cell_value(struct cell *);\r\nvoid set_cell_value(struct cell *, int new_value);\r\n\r\ntypedef void (*callback)(void *, int);\r\ntypedef int callback_id;\r\n\r\n// The callback should be called with the same void * given in add_callback.\r\ncallback_id add_callback(struct cell *, void *, callback);\r\nvoid remove_callback(struct cell *, callback_id);\r\n\r\n#endif\r\n"
  },
  "tests": {
    "test_react.c": "#include <stddef.h>\r\n#include <stdio.h>\r\n#include \"test-framework/unity.h\"\r\n#include \"react.h\"\r\n\r\nvoid setUp(void)\r\n{\r\n}\r\n\r\nvoid tearDown(void)\r\n{\r\n}\r\n\r\nstatic int plus(int x, int y)\r\n{\r\n   return x + y;\r\n}\r\n\r\nstatic int plus1(int x)\r\n{\r\n   return x + 1;\r\n}\r\n\r\nstatic int minus(int x, int y)\r\n{\r\n   return x - y;\r\n}\r\n\r\nstatic int minus1(int x)\r\n{\r\n   return x - 1;\r\n}\r\n\r\nstatic int concat_digits(int a, int b)\r\n{\r\n   return b * 10 + a;\r\n}\r\n\r\nstatic int times(int x, int y)\r\n{\r\n   return x * y;\r\n}\r\n\r\nstatic int times2(int x)\r\n{\r\n   return x * 2;\r\n}\r\n\r\nstatic int times30(int x)\r\n{\r\n   return x * 30;\r\n}\r\n\r\nstruct cbinfo {\r\n   int last_value;\r\n   int times_called;\r\n};\r\n\r\nstatic void cb_spy(void *obj, int v)\r\n{\r\n   struct cbinfo *cbinfo = (struct cbinfo *)obj;\r\n   cbinfo->last_value = v;\r\n   ++cbinfo->times_called;\r\n}\r\n\r\nstatic int big_if_three(int x)\r\n{\r\n   return x < 3 ? 111 : 222;\r\n}\r\n\r\nstatic void test_input_cells_have_value(void)\r\n{\r\n   struct reactor *r = create_reactor();\r\n   struct cell *input = create_input_cell(r, 10);\r\n\r\n   TEST_ASSERT_EQUAL_INT(10, get_cell_value(input));\r\n\r\n   destroy_reactor(r);\r\n}\r\n\r\nstatic void test_input_cells_value_can_be_set(void)\r\n{\r\n   TEST_IGNORE();   // delete this line to run test\r\n   struct reactor *r = create_reactor();\r\n   struct cell *input = create_input_cell(r, 4);\r\n\r\n   set_cell_value(input, 20);\r\n   TEST_ASSERT_EQUAL_INT(20, get_cell_value(input));\r\n\r\n   destroy_reactor(r);\r\n}\r\n\r\nstatic void test_compute_cells_calculate_initial_value(void)\r\n{\r\n   TEST_IGNORE();\r\n   struct reactor *r = create_reactor();\r\n   struct cell *input = create_input_cell(r, 1);\r\n   struct cell *output = create_compute1_cell(r, input, plus1);\r\n\r\n   TEST_ASSERT_EQUAL_INT(2, get_cell_value(output));\r\n\r\n   destroy_reactor(r);\r\n}\r\n\r\nstatic void test_compute_cells_take_inputs_in_the_right_order(void)\r\n{\r\n   TEST_IGNORE();\r\n   struct reactor *r = create_reactor();\r\n   struct cell *one = create_input_cell(r, 1);\r\n   struct cell *two = create_input_cell(r, 2);\r\n   struct cell *output = create_compute2_cell(r, one, two, concat_digits);\r\n\r\n   TEST_ASSERT_EQUAL_INT(21, get_cell_value(output));\r\n\r\n   destroy_reactor(r);\r\n}\r\n\r\nstatic void test_compute_cells_update_value_when_dependencies_are_changed(void)\r\n{\r\n   TEST_IGNORE();\r\n   struct reactor *r = create_reactor();\r\n   struct cell *input = create_input_cell(r, 1);\r\n   struct cell *output = create_compute1_cell(r, input, plus1);\r\n\r\n   set_cell_value(input, 3);\r\n   TEST_ASSERT_EQUAL_INT(4, get_cell_value(output));\r\n\r\n   destroy_reactor(r);\r\n}\r\n\r\nstatic void test_compute_cells_can_depend_on_other_compute_cells(void)\r\n{\r\n   TEST_IGNORE();\r\n   struct reactor *r = create_reactor();\r\n   struct cell *input = create_input_cell(r, 1);\r\n   struct cell *times_two = create_compute1_cell(r, input, times2);\r\n   struct cell *times_thirty = create_compute1_cell(r, input, times30);\r\n   struct cell *output = create_compute2_cell(r, times_two, times_thirty, plus);\r\n\r\n   TEST_ASSERT_EQUAL_INT(32, get_cell_value(output));\r\n   set_cell_value(input, 3);\r\n   TEST_ASSERT_EQUAL_INT(96, get_cell_value(output));\r\n\r\n   destroy_reactor(r);\r\n}\r\n\r\nstatic void test_compute_cells_fire_callbacks(void)\r\n{\r\n   TEST_IGNORE();\r\n   struct reactor *r = create_reactor();\r\n   struct cell *input = create_input_cell(r, 1);\r\n   struct cell *output = create_compute1_cell(r, input, plus1);\r\n\r\n   struct cbinfo cbinfo = { -1, 0 };\r\n   add_callback(output, &cbinfo, cb_spy);\r\n\r\n   set_cell_value(input, 3);\r\n   TEST_ASSERT_EQUAL_INT(1, cbinfo.times_called);\r\n   TEST_ASSERT_EQUAL_INT(4, cbinfo.last_value);\r\n\r\n   destroy_reactor(r);\r\n}\r\n\r\nstatic void test_callbacks_only_fire_on_change(void)\r\n{\r\n   TEST_IGNORE();\r\n   struct reactor *r = create_reactor();\r\n   struct cell *input = create_input_cell(r, 1);\r\n   struct cell *output = create_compute1_cell(r, input, big_if_three);\r\n\r\n   struct cbinfo cbinfo = { -1, 0 };\r\n   add_callback(output, &cbinfo, cb_spy);\r\n\r\n   set_cell_value(input, 2);\r\n   TEST_ASSERT_EQUAL_INT(0, cbinfo.times_called);\r\n\r\n   set_cell_value(input, 4);\r\n   TEST_ASSERT_EQUAL_INT(1, cbinfo.times_called);\r\n   TEST_ASSERT_EQUAL_INT(222, cbinfo.last_value);\r\n\r\n   destroy_reactor(r);\r\n}\r\n\r\nstatic void test_callbacks_do_not_report_already_reported_values(void)\r\n{\r\n   TEST_IGNORE();\r\n   struct reactor *r = create_reactor();\r\n   struct cell *input = create_input_cell(r, 1);\r\n   struct cell *output = create_compute1_cell(r, input, plus1);\r\n\r\n   struct cbinfo cbinfo = { -1, 0 };\r\n   add_callback(output, &cbinfo, cb_spy);\r\n\r\n   set_cell_value(input, 2);\r\n   TEST_ASSERT_EQUAL_INT(3, cbinfo.last_value);\r\n\r\n   set_cell_value(input, 3);\r\n   TEST_ASSERT_EQUAL_INT(4, cbinfo.last_value);\r\n\r\n   destroy_reactor(r);\r\n}\r\n\r\nstatic void test_callbacks_can_fire_from_multiple_cells(void)\r\n{\r\n   TEST_IGNORE();\r\n   struct reactor *r = create_reactor();\r\n   struct cell *input = create_input_cell(r, 1);\r\n   struct cell *plus_one = create_compute1_cell(r, input, plus1);\r\n   struct cell *minus_one = create_compute1_cell(r, input, minus1);\r\n\r\n   struct cbinfo cbinfo1 = { -1, 0 };\r\n   add_callback(plus_one, &cbinfo1, cb_spy);\r\n   struct cbinfo cbinfo2 = { -1, 0 };\r\n   add_callback(minus_one, &cbinfo2, cb_spy);\r\n\r\n   set_cell_value(input, 10);\r\n\r\n   TEST_ASSERT_EQUAL_INT(11, cbinfo1.last_value);\r\n   TEST_ASSERT_EQUAL_INT(9, cbinfo2.last_value);\r\n\r\n   destroy_reactor(r);\r\n}\r\n\r\nstatic void test_callbacks_can_be_added_and_removed(void)\r\n{\r\n   TEST_IGNORE();\r\n   struct reactor *r = create_reactor();\r\n   struct cell *input = create_input_cell(r, 11);\r\n   struct cell *output = create_compute1_cell(r, input, plus1);\r\n\r\n   struct cbinfo cbinfo1 = { -1, 0 };\r\n   callback_id cb1 = add_callback(output, &cbinfo1, cb_spy);\r\n   struct cbinfo cbinfo2 = { -1, 0 };\r\n   add_callback(output, &cbinfo2, cb_spy);\r\n\r\n   set_cell_value(input, 31);\r\n\r\n   TEST_ASSERT_EQUAL_INT(32, cbinfo1.last_value);\r\n   TEST_ASSERT_EQUAL_INT(32, cbinfo2.last_value);\r\n   TEST_ASSERT_EQUAL_INT(1, cbinfo1.times_called);\r\n\r\n   remove_callback(output, cb1);\r\n   struct cbinfo cbinfo3 = { -1, 0 };\r\n   add_callback(output, &cbinfo3, cb_spy);\r\n\r\n   set_cell_value(input, 41);\r\n\r\n   TEST_ASSERT_EQUAL_INT(42, cbinfo2.last_value);\r\n   TEST_ASSERT_EQUAL_INT(42, cbinfo3.last_value);\r\n   TEST_ASSERT_EQUAL_INT(1, cbinfo1.times_called);\r\n\r\n   destroy_reactor(r);\r\n}\r\n\r\nstatic void\r\ntest_removing_a_callback_multiple_times_doesnt_interfere_with_other_callbacks(\r\n    void)\r\n{\r\n   TEST_IGNORE();\r\n   struct reactor *r = create_reactor();\r\n   struct cell *input = create_input_cell(r, 1);\r\n   struct cell *output = create_compute1_cell(r, input, plus1);\r\n\r\n   struct cbinfo cbinfo1 = { -1, 0 };\r\n   callback_id cb1 = add_callback(output, &cbinfo1, cb_spy);\r\n   struct cbinfo cbinfo2 = { -1, 0 };\r\n   add_callback(output, &cbinfo2, cb_spy);\r\n   for (int i = 0; i < 10; ++i) {\r\n      remove_callback(output, cb1);\r\n   }\r\n\r\n   set_cell_value(input, 2);\r\n\r\n   TEST_ASSERT_EQUAL_INT(0, cbinfo1.times_called);\r\n   TEST_ASSERT_EQUAL_INT(1, cbinfo2.times_called);\r\n   TEST_ASSERT_EQUAL_INT(3, cbinfo2.last_value);\r\n\r\n   destroy_reactor(r);\r\n}\r\n\r\nstatic void\r\ntest_callbacks_only_called_once_even_if_multiple_dependencies_change(void)\r\n{\r\n   TEST_IGNORE();\r\n   struct reactor *r = create_reactor();\r\n   struct cell *input = create_input_cell(r, 1);\r\n   struct cell *plus_one = create_compute1_cell(r, input, plus1);\r\n   struct cell *minus_one1 = create_compute1_cell(r, input, minus1);\r\n   struct cell *minus_one2 = create_compute1_cell(r, minus_one1, minus1);\r\n   struct cell *output = create_compute2_cell(r, plus_one, minus_one2, times);\r\n\r\n   struct cbinfo cbinfo = { -1, 0 };\r\n   add_callback(output, &cbinfo, cb_spy);\r\n\r\n   set_cell_value(input, 4);\r\n\r\n   TEST_ASSERT_EQUAL_INT(1, cbinfo.times_called);\r\n   TEST_ASSERT_EQUAL_INT(10, cbinfo.last_value);\r\n\r\n   destroy_reactor(r);\r\n}\r\n\r\nstatic void\r\ntest_callbacks_not_called_if_dependencies_change_but_output_value_doesnt_change(\r\n    void)\r\n{\r\n   TEST_IGNORE();\r\n   struct reactor *r = create_reactor();\r\n   struct cell *input = create_input_cell(r, 1);\r\n   struct cell *plus_one = create_compute1_cell(r, input, plus1);\r\n   struct cell *minus_one = create_compute1_cell(r, input, minus1);\r\n   struct cell *always_two =\r\n       create_compute2_cell(r, plus_one, minus_one, minus);\r\n\r\n   struct cbinfo cbinfo = { -1, 0 };\r\n   add_callback(always_two, &cbinfo, cb_spy);\r\n\r\n   for (int i = 2; i <= 5; ++i) {\r\n      set_cell_value(input, i);\r\n   }\r\n\r\n   TEST_ASSERT_EQUAL_INT(0, cbinfo.times_called);\r\n\r\n   destroy_reactor(r);\r\n}\r\n\r\nint main(void)\r\n{\r\n   UNITY_BEGIN();\r\n\r\n   RUN_TEST(test_input_cells_have_value);\r\n   RUN_TEST(test_input_cells_value_can_be_set);\r\n   RUN_TEST(test_compute_cells_calculate_initial_value);\r\n   RUN_TEST(test_compute_cells_take_inputs_in_the_right_order);\r\n   RUN_TEST(test_compute_cells_update_value_when_dependencies_are_changed);\r\n   RUN_TEST(test_compute_cells_can_depend_on_other_compute_cells);\r\n   RUN_TEST(test_compute_cells_fire_callbacks);\r\n   RUN_TEST(test_callbacks_only_fire_on_change);\r\n   RUN_TEST(test_callbacks_do_not_report_already_reported_values);\r\n   RUN_TEST(test_callbacks_can_fire_from_multiple_cells);\r\n   RUN_TEST(test_callbacks_can_be_added_and_removed);\r\n   RUN_TEST(\r\n       test_removing_a_callback_multiple_times_doesnt_interfere_with_other_callbacks);\r\n   RUN_TEST(\r\n       test_callbacks_only_called_once_even_if_multiple_dependencies_change);\r\n   RUN_TEST(\r\n       test_callbacks_not_called_if_dependencies_change_but_output_value_doesnt_change);\r\n\r\n   return UNITY_END();\r\n}\r\n"
  }
}