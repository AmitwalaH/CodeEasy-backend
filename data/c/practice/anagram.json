{
  "language": "c",
  "slug": "anagram",
  "docs": {
    "introduction": "# Introduction\r\n\r\nAt a garage sale, you find a lovely vintage typewriter at a bargain price!\r\nExcitedly, you rush home, insert a sheet of paper, and start typing away.\r\nHowever, your excitement wanes when you examine the output: all words are garbled!\r\nFor example, it prints \"stop\" instead of \"post\" and \"least\" instead of \"stale.\"\r\nCarefully, you try again, but now it prints \"spot\" and \"slate.\"\r\nAfter some experimentation, you find there is a random delay before each letter is printed, which messes up the order.\r\nYou now understand why they sold it for so little money!\r\n\r\nYou realize this quirk allows you to generate anagrams, which are words formed by rearranging the letters of another word.\r\nPleased with your finding, you spend the rest of the day generating hundreds of anagrams.\r\n",
    "instructions": "# Instructions\r\n\r\nGiven a target word and one or more candidate words, your task is to find the candidates that are anagrams of the target.\r\n\r\nAn anagram is a rearrangement of letters to form a new word: for example `\"owns\"` is an anagram of `\"snow\"`.\r\nA word is _not_ its own anagram: for example, `\"stop\"` is not an anagram of `\"stop\"`.\r\n\r\nThe target word and candidate words are made up of one or more ASCII alphabetic characters (`A`-`Z` and `a`-`z`).\r\nLowercase and uppercase characters are equivalent: for example, `\"PoTS\"` is an anagram of `\"sTOp\"`, but `\"StoP\"` is not an anagram of `\"sTOp\"`.\r\nThe words you need to find should be taken from the candidate words, using the same letter case.\r\n\r\nGiven the target `\"stone\"` and the candidate words `\"stone\"`, `\"tones\"`, `\"banana\"`, `\"tons\"`, `\"notes\"`, and `\"Seton\"`, the anagram words you need to find are `\"tones\"`, `\"notes\"`, and `\"Seton\"`.\r\n",
    "hints": ""
  },
  "starter_code": {
    "anagram.c": "#include \"anagram.h\"\r\n",
    "anagram.h": "#ifndef ANAGRAM_H\r\n#define ANAGRAM_H\r\n\r\n#include <stddef.h>\r\n\r\n#define MAX_STR_LEN 20\r\n\r\nenum anagram_status { UNCHECKED = -1, NOT_ANAGRAM, IS_ANAGRAM };\r\n\r\nstruct candidate {\r\n   enum anagram_status is_anagram;\r\n   const char *word;\r\n};\r\n\r\nstruct candidates {\r\n   struct candidate *candidate;\r\n   size_t count;\r\n};\r\n\r\n/**\r\n * @description - determines if any of the words in candidate are anagrams\r\n *                for subject. Contents of candidate structures may be modified.\r\n */\r\nvoid find_anagrams(const char *subject, struct candidates *candidates);\r\n\r\n#endif\r\n"
  },
  "tests": {
    "test_anagram.c": "#include <stdlib.h>\r\n#include <string.h>\r\n\r\n#include \"test-framework/unity.h\"\r\n#include \"anagram.h\"\r\n\r\n#define MAX_STR_LEN 20\r\n\r\nstruct candidates candidates;\r\n\r\nvoid setUp(void)\r\n{\r\n}\r\n\r\nvoid tearDown(void)\r\n{\r\n   free(candidates.candidate);\r\n   candidates.candidate = NULL;\r\n}\r\n\r\nstatic struct candidates build_candidates(char *inputs, size_t count)\r\n{\r\n   struct candidates result;\r\n   result.count = count;\r\n   result.candidate = malloc(sizeof(struct candidate) * count);\r\n   for (int i = 0; i < (int)count; i++) {\r\n      result.candidate[i].word = &inputs[i * MAX_STR_LEN];\r\n      result.candidate[i].is_anagram = UNCHECKED;\r\n   }\r\n\r\n   return result;\r\n}\r\n\r\nstatic void assert_correct_anagrams(struct candidates *candidates,\r\n                                    enum anagram_status expected[])\r\n{\r\n   for (int i = 0; i < (int)candidates->count; i++) {\r\n      TEST_ASSERT_EQUAL(expected[i], candidates->candidate[i].is_anagram);\r\n   }\r\n}\r\n\r\nstatic void test_no_matches(void)\r\n{\r\n   char inputs[][MAX_STR_LEN] = { \"hello\", \"world\", \"zombies\", \"pants\" };\r\n\r\n   char subject[] = { \"diaper\" };\r\n\r\n   candidates = build_candidates(*inputs, sizeof(inputs) / MAX_STR_LEN);\r\n   enum anagram_status expected[] = { NOT_ANAGRAM, NOT_ANAGRAM, NOT_ANAGRAM,\r\n                                      NOT_ANAGRAM };\r\n\r\n   find_anagrams(subject, &candidates);\r\n   assert_correct_anagrams(&candidates, expected);\r\n}\r\n\r\nstatic void test_detect_two_anagrams(void)\r\n{\r\n   TEST_IGNORE();   // delete this line to run test\r\n   char inputs[][MAX_STR_LEN] = { \"lemons\", \"cherry\", \"melons\" };\r\n\r\n   char subject[] = { \"solemn\" };\r\n\r\n   candidates = build_candidates(*inputs, sizeof(inputs) / MAX_STR_LEN);\r\n   enum anagram_status expected[] = { IS_ANAGRAM, NOT_ANAGRAM, IS_ANAGRAM };\r\n\r\n   find_anagrams(subject, &candidates);\r\n   assert_correct_anagrams(&candidates, expected);\r\n}\r\n\r\nstatic void test_does_not_detect_anagram_subsets(void)\r\n{\r\n   TEST_IGNORE();\r\n   char inputs[][MAX_STR_LEN] = { \"dog\", \"goody\" };\r\n\r\n   char subject[] = { \"good\" };\r\n\r\n   candidates = build_candidates(*inputs, sizeof(inputs) / MAX_STR_LEN);\r\n   enum anagram_status expected[] = { NOT_ANAGRAM, NOT_ANAGRAM };\r\n\r\n   find_anagrams(subject, &candidates);\r\n   assert_correct_anagrams(&candidates, expected);\r\n}\r\n\r\nstatic void test_detects_anagram(void)\r\n{\r\n   TEST_IGNORE();\r\n   char inputs[][MAX_STR_LEN] = { \"enlists\", \"google\", \"inlets\", \"banana\" };\r\n\r\n   char subject[] = { \"listen\" };\r\n\r\n   candidates = build_candidates(*inputs, sizeof(inputs) / MAX_STR_LEN);\r\n   enum anagram_status expected[] = { NOT_ANAGRAM, NOT_ANAGRAM, IS_ANAGRAM,\r\n                                      NOT_ANAGRAM };\r\n\r\n   find_anagrams(subject, &candidates);\r\n   assert_correct_anagrams(&candidates, expected);\r\n}\r\n\r\nstatic void test_three_anagrams(void)\r\n{\r\n   TEST_IGNORE();\r\n   char inputs[][MAX_STR_LEN] = { \"gallery\", \"ballerina\", \"regally\",\r\n                                  \"clergy\",  \"largely\",   \"leading\" };\r\n\r\n   char subject[] = { \"allergy\" };\r\n\r\n   candidates = build_candidates(*inputs, sizeof(inputs) / MAX_STR_LEN);\r\n   enum anagram_status expected[] = { IS_ANAGRAM,  NOT_ANAGRAM, IS_ANAGRAM,\r\n                                      NOT_ANAGRAM, IS_ANAGRAM,  NOT_ANAGRAM };\r\n\r\n   find_anagrams(subject, &candidates);\r\n   assert_correct_anagrams(&candidates, expected);\r\n}\r\n\r\nstatic void test_detects_multiple_anagrams_with_different_case(void)\r\n{\r\n   TEST_IGNORE();\r\n   char inputs[][MAX_STR_LEN] = { \"Eons\", \"ONES\" };\r\n\r\n   char subject[] = { \"nose\" };\r\n\r\n   candidates = build_candidates(*inputs, sizeof(inputs) / MAX_STR_LEN);\r\n   enum anagram_status expected[] = { IS_ANAGRAM, IS_ANAGRAM };\r\n\r\n   find_anagrams(subject, &candidates);\r\n   assert_correct_anagrams(&candidates, expected);\r\n}\r\n\r\nstatic void test_does_not_detect_non_anagrams_with_identical_checksum(void)\r\n{\r\n   TEST_IGNORE();\r\n   char inputs[][MAX_STR_LEN] = { \"last\" };\r\n\r\n   char subject[] = { \"mass\" };\r\n\r\n   candidates = build_candidates(*inputs, sizeof(inputs) / MAX_STR_LEN);\r\n   enum anagram_status expected[] = { NOT_ANAGRAM };\r\n\r\n   find_anagrams(subject, &candidates);\r\n   assert_correct_anagrams(&candidates, expected);\r\n}\r\n\r\nstatic void test_detects_anagrams_case_insensitively(void)\r\n{\r\n   TEST_IGNORE();\r\n   char inputs[][MAX_STR_LEN] = { \"cashregister\", \"Carthorse\", \"radishes\" };\r\n\r\n   char subject[] = { \"Orchestra\" };\r\n\r\n   candidates = build_candidates(*inputs, sizeof(inputs) / MAX_STR_LEN);\r\n   enum anagram_status expected[] = { NOT_ANAGRAM, IS_ANAGRAM, NOT_ANAGRAM };\r\n\r\n   find_anagrams(subject, &candidates);\r\n   assert_correct_anagrams(&candidates, expected);\r\n}\r\n\r\nstatic void test_detects_anagram_using_case_insensitive_subject(void)\r\n{\r\n   TEST_IGNORE();\r\n   char inputs[][MAX_STR_LEN] = { \"cashregister\", \"carthorse\", \"radishes\" };\r\n\r\n   char subject[] = { \"Orchestra\" };\r\n\r\n   candidates = build_candidates(*inputs, sizeof(inputs) / MAX_STR_LEN);\r\n   enum anagram_status expected[] = { NOT_ANAGRAM, IS_ANAGRAM, NOT_ANAGRAM };\r\n\r\n   find_anagrams(subject, &candidates);\r\n   assert_correct_anagrams(&candidates, expected);\r\n}\r\n\r\nstatic void test_detects_anagrams_using_case_insensitive_possible_matches(void)\r\n{\r\n   TEST_IGNORE();\r\n   char inputs[][MAX_STR_LEN] = { \"cashregister\", \"Carthorse\", \"radishes\" };\r\n\r\n   char subject[] = { \"orchestra\" };\r\n\r\n   candidates = build_candidates(*inputs, sizeof(inputs) / MAX_STR_LEN);\r\n   enum anagram_status expected[] = { NOT_ANAGRAM, IS_ANAGRAM, NOT_ANAGRAM };\r\n\r\n   find_anagrams(subject, &candidates);\r\n   assert_correct_anagrams(&candidates, expected);\r\n}\r\n\r\nstatic void\r\ntest_does_not_detect_an_anagram_if_the_original_word_is_repeated(void)\r\n{\r\n   TEST_IGNORE();\r\n   char inputs[][MAX_STR_LEN] = { \"goGoGO\" };\r\n\r\n   char subject[] = { \"go\" };\r\n\r\n   candidates = build_candidates(*inputs, sizeof(inputs) / MAX_STR_LEN);\r\n   enum anagram_status expected[] = { NOT_ANAGRAM };\r\n\r\n   find_anagrams(subject, &candidates);\r\n   assert_correct_anagrams(&candidates, expected);\r\n}\r\n\r\nstatic void test_anagrams_must_use_all_letters_exactly_once(void)\r\n{\r\n   TEST_IGNORE();\r\n   char inputs[][MAX_STR_LEN] = { \"patter\" };\r\n\r\n   char subject[] = { \"tapper\" };\r\n\r\n   candidates = build_candidates(*inputs, sizeof(inputs) / MAX_STR_LEN);\r\n   enum anagram_status expected[] = { NOT_ANAGRAM };\r\n\r\n   find_anagrams(subject, &candidates);\r\n   assert_correct_anagrams(&candidates, expected);\r\n}\r\n\r\nstatic void test_words_are_not_anagrams_of_themselves(void)\r\n{\r\n   TEST_IGNORE();\r\n   char inputs[][MAX_STR_LEN] = { \"BANANA\" };\r\n\r\n   char subject[] = { \"BANANA\" };\r\n\r\n   candidates = build_candidates(*inputs, sizeof(inputs) / MAX_STR_LEN);\r\n   enum anagram_status expected[] = { NOT_ANAGRAM };\r\n\r\n   find_anagrams(subject, &candidates);\r\n   assert_correct_anagrams(&candidates, expected);\r\n}\r\n\r\nstatic void\r\ntest_words_are_not_anagrams_of_themselves_even_if_letter_case_is_partially_different(\r\n    void)\r\n{\r\n   TEST_IGNORE();\r\n   char inputs[][MAX_STR_LEN] = { \"Banana\" };\r\n\r\n   char subject[] = { \"BANANA\" };\r\n\r\n   candidates = build_candidates(*inputs, sizeof(inputs) / MAX_STR_LEN);\r\n   enum anagram_status expected[] = { NOT_ANAGRAM };\r\n\r\n   find_anagrams(subject, &candidates);\r\n   assert_correct_anagrams(&candidates, expected);\r\n}\r\n\r\nstatic void\r\ntest_words_are_not_anagrams_of_themselves_even_if_letter_case_is_completely_different(\r\n    void)\r\n{\r\n   TEST_IGNORE();\r\n   char inputs[][MAX_STR_LEN] = { \"banana\" };\r\n\r\n   char subject[] = { \"BANANA\" };\r\n\r\n   candidates = build_candidates(*inputs, sizeof(inputs) / MAX_STR_LEN);\r\n   enum anagram_status expected[] = { NOT_ANAGRAM };\r\n\r\n   find_anagrams(subject, &candidates);\r\n   assert_correct_anagrams(&candidates, expected);\r\n}\r\n\r\nstatic void test_words_other_than_themselves_can_be_anagrams(void)\r\n{\r\n   TEST_IGNORE();\r\n   char inputs[][MAX_STR_LEN] = { \"Listen\", \"Silent\" };\r\n\r\n   char subject[] = { \"LISTEN\" };\r\n\r\n   candidates = build_candidates(*inputs, sizeof(inputs) / MAX_STR_LEN);\r\n   enum anagram_status expected[] = { NOT_ANAGRAM, IS_ANAGRAM };\r\n\r\n   find_anagrams(subject, &candidates);\r\n   assert_correct_anagrams(&candidates, expected);\r\n}\r\n\r\nint main(void)\r\n{\r\n   UNITY_BEGIN();\r\n\r\n   RUN_TEST(test_no_matches);\r\n   RUN_TEST(test_detect_two_anagrams);\r\n   RUN_TEST(test_does_not_detect_anagram_subsets);\r\n   RUN_TEST(test_detects_anagram);\r\n   RUN_TEST(test_three_anagrams);\r\n   RUN_TEST(test_detects_multiple_anagrams_with_different_case);\r\n   RUN_TEST(test_does_not_detect_non_anagrams_with_identical_checksum);\r\n   RUN_TEST(test_detects_anagrams_case_insensitively);\r\n   RUN_TEST(test_detects_anagram_using_case_insensitive_subject);\r\n   RUN_TEST(test_detects_anagrams_using_case_insensitive_possible_matches);\r\n   RUN_TEST(test_does_not_detect_an_anagram_if_the_original_word_is_repeated);\r\n   RUN_TEST(test_anagrams_must_use_all_letters_exactly_once);\r\n   RUN_TEST(test_words_are_not_anagrams_of_themselves);\r\n   RUN_TEST(\r\n       test_words_are_not_anagrams_of_themselves_even_if_letter_case_is_partially_different);\r\n   RUN_TEST(\r\n       test_words_are_not_anagrams_of_themselves_even_if_letter_case_is_completely_different);\r\n   RUN_TEST(test_words_other_than_themselves_can_be_anagrams);\r\n\r\n   return UNITY_END();\r\n}\r\n"
  }
}