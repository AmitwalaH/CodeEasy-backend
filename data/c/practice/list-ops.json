{
  "language": "c",
  "slug": "list-ops",
  "docs": {
    "introduction": "",
    "instructions": "# Instructions\r\n\r\nImplement basic list operations.\r\n\r\nIn functional languages list operations like `length`, `map`, and `reduce` are very common.\r\nImplement a series of basic list operations, without using existing functions.\r\n\r\nThe precise number and names of the operations to be implemented will be track dependent to avoid conflicts with existing names, but the general operations you will implement include:\r\n\r\n- `append` (_given two lists, add all items in the second list to the end of the first list_);\r\n- `concatenate` (_given a series of lists, combine all items in all lists into one flattened list_);\r\n- `filter` (_given a predicate and a list, return the list of all items for which `predicate(item)` is True_);\r\n- `length` (_given a list, return the total number of items within it_);\r\n- `map` (_given a function and a list, return the list of the results of applying `function(item)` on all items_);\r\n- `foldl` (_given a function, a list, and initial accumulator, fold (reduce) each item into the accumulator from the left_);\r\n- `foldr` (_given a function, a list, and an initial accumulator, fold (reduce) each item into the accumulator from the right_);\r\n- `reverse` (_given a list, return a list with all the original items, but in reversed order_).\r\n\r\nNote, the ordering in which arguments are passed to the fold functions (`foldl`, `foldr`) is significant.\r\n",
    "hints": ""
  },
  "starter_code": {
    "list_ops.c": "#include \"list_ops.h\"\r\n",
    "list_ops.h": "#ifndef LIST_OPS_H\r\n#define LIST_OPS_H\r\n\r\n#include <stdlib.h>\r\n#include <stdbool.h>\r\n\r\ntypedef int list_element_t;\r\n\r\ntypedef struct {\r\n   size_t length;\r\n   list_element_t elements[];\r\n} list_t;\r\n\r\n// constructs a new list\r\nlist_t *new_list(size_t length, list_element_t elements[]);\r\n\r\n// append entries to a list and return the new list\r\nlist_t *append_list(list_t *list1, list_t *list2);\r\n\r\n// filter list returning only values that satisfy the filter function\r\nlist_t *filter_list(list_t *list, bool (*filter)(list_element_t));\r\n\r\n// returns the length of the list\r\nsize_t length_list(list_t *list);\r\n\r\n// return a list of elements whose values equal the list value transformed by\r\n// the mapping function\r\nlist_t *map_list(list_t *list, list_element_t (*map)(list_element_t));\r\n\r\n// folds (reduces) the given list from the left with a function\r\nlist_element_t foldl_list(list_t *list, list_element_t initial,\r\n                          list_element_t (*foldl)(list_element_t,\r\n                                                  list_element_t));\r\n\r\n// folds (reduces) the given list from the right with a function\r\nlist_element_t foldr_list(list_t *list, list_element_t initial,\r\n                          list_element_t (*foldr)(list_element_t,\r\n                                                  list_element_t));\r\n\r\n// reverse the elements of the list\r\nlist_t *reverse_list(list_t *list);\r\n\r\n// destroy the entire list\r\n// list will be a dangling pointer after calling this method on it\r\nvoid delete_list(list_t *list);\r\n\r\n#endif\r\n"
  },
  "tests": {
    "test_list_ops.c": "#include <stdarg.h>\r\n#include \"list_ops.h\"\r\n#include \"test-framework/unity.h\"\r\n\r\nstatic const int MAX_STRING_LEN = 100;\r\nstatic list_t *list = NULL;\r\nstatic list_t *list2 = NULL;\r\nstatic list_t *actual = NULL;\r\nstatic char *error_message = NULL;\r\n\r\nvoid setUp(void)\r\n{\r\n}\r\n\r\nstatic void release_lists(int count, ...)\r\n{\r\n   va_list ptr;\r\n   va_start(ptr, count);\r\n   for (int i = 0; i < count; ++i) {\r\n      list_t **list = va_arg(ptr, list_t **);\r\n      if (*list) {\r\n         free(*list);\r\n         *list = NULL;\r\n      }\r\n   }\r\n   va_end(ptr);\r\n}\r\n\r\nvoid tearDown(void)\r\n{\r\n   release_lists(3, &list, &list2, &actual);\r\n   if (error_message) {\r\n      free(error_message);\r\n      error_message = NULL;\r\n   }\r\n}\r\n\r\nstatic char *print_elements(size_t length, list_element_t list_elements[])\r\n{\r\n   char *array = malloc(MAX_STRING_LEN * sizeof(char));\r\n   char *ptr = array;\r\n   for (size_t i = 0; i < length; i++) {\r\n      int printed = snprintf(ptr, MAX_STRING_LEN - (ptr - array), \" %d \",\r\n                             (list_elements[i]));\r\n      ptr += printed;\r\n      if (ptr - array > MAX_STRING_LEN) {\r\n         break;\r\n      }\r\n   }\r\n   return array;\r\n}\r\n\r\nstatic char *create_error_message(size_t length,\r\n                                  list_element_t expected_elements[],\r\n                                  list_element_t actual_elements[])\r\n{\r\n   char *message = malloc(MAX_STRING_LEN * sizeof(char));\r\n   char *expected_string = print_elements(length, expected_elements);\r\n   char *actual_string = print_elements(length, actual_elements);\r\n   snprintf(message, MAX_STRING_LEN, \"[%s] != [%s]\", expected_string,\r\n            actual_string);\r\n   free(expected_string);\r\n   free(actual_string);\r\n   return message;\r\n}\r\n\r\nstatic void check_lists_match(size_t expected_length,\r\n                              list_element_t expected_elements[],\r\n                              list_t *actual)\r\n{\r\n   // check actual list is a valid list\r\n   TEST_ASSERT_NOT_NULL(actual);\r\n\r\n   // check lengths match\r\n   TEST_ASSERT_EQUAL_MESSAGE(expected_length, actual->length,\r\n                             \"List lengths differ\");\r\n\r\n   // check elements match in non-zero length list\r\n   if (expected_length) {\r\n      error_message = create_error_message(expected_length, expected_elements,\r\n                                           actual->elements);\r\n      TEST_ASSERT_EQUAL_MEMORY_ARRAY_MESSAGE(\r\n          expected_elements, actual->elements, sizeof(list_element_t),\r\n          expected_length, error_message);\r\n      free(error_message);\r\n      error_message = NULL;\r\n   }\r\n}\r\n\r\nstatic bool filter_modulo(list_element_t element)\r\n{\r\n   return (element % 2 == 1);\r\n}\r\n\r\nstatic list_element_t map_increment(list_element_t element)\r\n{\r\n   return element + 1;\r\n}\r\n\r\nstatic list_element_t fold_multiply(list_element_t element,\r\n                                    list_element_t accumulator)\r\n{\r\n   return element * accumulator;\r\n}\r\n\r\nstatic list_element_t fold_add(list_element_t element,\r\n                               list_element_t accumulator)\r\n{\r\n   return element + accumulator;\r\n}\r\n\r\nstatic list_element_t fold_divide(list_element_t element,\r\n                                  list_element_t accumulator)\r\n{\r\n   return (accumulator == 0) ? 0 : element / accumulator;\r\n}\r\n\r\nstatic void call_delete_list(list_t **list)\r\n{\r\n   delete_list(*list);\r\n   *list = NULL;\r\n}\r\n\r\nstatic void test_append_empty_lists(void)\r\n{\r\n   list = new_list(0, NULL);\r\n   list2 = new_list(0, NULL);\r\n\r\n   actual = append_list(list, list2);\r\n   check_lists_match(0, NULL, actual);\r\n\r\n   call_delete_list(&list);\r\n   call_delete_list(&list2);\r\n   call_delete_list(&actual);\r\n}\r\n\r\nstatic void test_append_list_to_empty_list(void)\r\n{\r\n   TEST_IGNORE();   // delete this line to run test\r\n   list = new_list(0, NULL);\r\n   list2 = new_list(3, (list_element_t[]){ 1, 3, 4 });\r\n   size_t expected_length = 3;\r\n   list_element_t expected_elements[] = { 1, 3, 4 };\r\n\r\n   actual = append_list(list, list2);\r\n   check_lists_match(expected_length, expected_elements, actual);\r\n\r\n   call_delete_list(&list);\r\n   call_delete_list(&list2);\r\n   call_delete_list(&actual);\r\n}\r\n\r\nstatic void test_append_empty_list_to_list(void)\r\n{\r\n   TEST_IGNORE();\r\n   list = new_list(4, (list_element_t[]){ 1, 2, 3, 4 });\r\n   list2 = new_list(0, NULL);\r\n   size_t expected_length = 4;\r\n   list_element_t expected_elements[] = { 1, 2, 3, 4 };\r\n\r\n   actual = append_list(list, list2);\r\n   check_lists_match(expected_length, expected_elements, actual);\r\n\r\n   call_delete_list(&list);\r\n   call_delete_list(&list2);\r\n   call_delete_list(&actual);\r\n}\r\n\r\nstatic void test_append_non_empty_lists(void)\r\n{\r\n   TEST_IGNORE();\r\n   list = new_list(2, (list_element_t[]){ 1, 2 });\r\n   list2 = new_list(4, (list_element_t[]){ 2, 3, 4, 5 });\r\n   size_t expected_length = 6;\r\n   list_element_t expected_elements[] = { 1, 2, 2, 3, 4, 5 };\r\n\r\n   actual = append_list(list, list2);\r\n   check_lists_match(expected_length, expected_elements, actual);\r\n\r\n   call_delete_list(&list);\r\n   call_delete_list(&list2);\r\n   call_delete_list(&actual);\r\n}\r\n\r\nstatic void test_filter_empty_list(void)\r\n{\r\n   TEST_IGNORE();\r\n   list = new_list(0, NULL);\r\n\r\n   actual = filter_list(list, filter_modulo);\r\n   check_lists_match(0, NULL, actual);\r\n\r\n   call_delete_list(&list);\r\n   call_delete_list(&actual);\r\n}\r\n\r\nstatic void test_filter_non_empty_list(void)\r\n{\r\n   TEST_IGNORE();\r\n   list = new_list(5, (list_element_t[]){ 1, 2, 3, 4, 5 });\r\n   size_t expected_length = 3;\r\n   list_element_t expected_elements[] = { 1, 3, 5 };\r\n\r\n   actual = filter_list(list, filter_modulo);\r\n   check_lists_match(expected_length, expected_elements, actual);\r\n\r\n   call_delete_list(&list);\r\n   call_delete_list(&actual);\r\n}\r\n\r\nstatic void test_length_empty_list(void)\r\n{\r\n   TEST_IGNORE();\r\n   list = new_list(0, NULL);\r\n   size_t expected = 0;\r\n\r\n   size_t actual = length_list(list);\r\n   TEST_ASSERT_EQUAL(expected, actual);\r\n\r\n   call_delete_list(&list);\r\n}\r\n\r\nstatic void test_length_non_empty_list(void)\r\n{\r\n   TEST_IGNORE();\r\n   list = new_list(4, (list_element_t[]){ 1, 2, 3, 4 });\r\n   size_t expected = 4;\r\n\r\n   size_t actual = length_list(list);\r\n   TEST_ASSERT_EQUAL(expected, actual);\r\n\r\n   call_delete_list(&list);\r\n}\r\n\r\nstatic void test_map_empty_list(void)\r\n{\r\n   TEST_IGNORE();\r\n   list = new_list(0, NULL);\r\n\r\n   actual = map_list(list, map_increment);\r\n   check_lists_match(0, NULL, actual);\r\n\r\n   call_delete_list(&list);\r\n   call_delete_list(&actual);\r\n}\r\n\r\nstatic void test_map_non_empty_list(void)\r\n{\r\n\r\n   TEST_IGNORE();\r\n   list = new_list(4, (list_element_t[]){ 1, 3, 5, 7 });\r\n   size_t expected_length = 4;\r\n   list_element_t expected_elements[] = { 2, 4, 6, 8 };\r\n\r\n   actual = map_list(list, map_increment);\r\n   check_lists_match(expected_length, expected_elements, actual);\r\n\r\n   call_delete_list(&list);\r\n   call_delete_list(&actual);\r\n}\r\n\r\nstatic void test_foldl_empty_list(void)\r\n{\r\n   TEST_IGNORE();\r\n   list = new_list(0, NULL);\r\n   list_element_t initial = 2;\r\n   list_element_t expected = 2;\r\n\r\n   list_element_t actual = foldl_list(list, initial, fold_divide);\r\n   TEST_ASSERT_EQUAL(expected, actual);\r\n\r\n   call_delete_list(&list);\r\n}\r\n\r\nstatic void\r\ntest_foldl_direction_independent_function_applied_to_non_empty_list(void)\r\n{\r\n   TEST_IGNORE();\r\n   list = new_list(4, (list_element_t[]){ 1, 2, 3, 4 });\r\n   list_element_t initial = 5;\r\n   list_element_t expected = 15;\r\n\r\n   list_element_t actual = foldl_list(list, initial, fold_add);\r\n   TEST_ASSERT_EQUAL(expected, actual);\r\n\r\n   call_delete_list(&list);\r\n}\r\n\r\nstatic void\r\ntest_foldl_direction_dependent_function_applied_to_non_empty_list(void)\r\n{\r\n   TEST_IGNORE();\r\n   list = new_list(2, (list_element_t[]){ 2, 5 });\r\n   list_element_t initial = 5;\r\n   list_element_t expected = 0;\r\n\r\n   list_element_t actual = foldl_list(list, initial, fold_divide);\r\n   TEST_ASSERT_EQUAL(expected, actual);\r\n\r\n   call_delete_list(&list);\r\n}\r\n\r\nstatic void test_foldr_empty_list(void)\r\n{\r\n   TEST_IGNORE();\r\n   list = new_list(0, NULL);\r\n   list_element_t initial = 2;\r\n   list_element_t expected = 2;\r\n\r\n   list_element_t actual = foldr_list(list, initial, fold_multiply);\r\n   TEST_ASSERT_EQUAL(expected, actual);\r\n\r\n   call_delete_list(&list);\r\n}\r\n\r\nstatic void\r\ntest_foldr_direction_independent_function_applied_to_non_empty_list(void)\r\n{\r\n   TEST_IGNORE();\r\n   list = new_list(4, (list_element_t[]){ 1, 2, 3, 4 });\r\n   list_element_t initial = 5;\r\n   list_element_t expected = 15;\r\n\r\n   list_element_t actual = foldr_list(list, initial, fold_add);\r\n   TEST_ASSERT_EQUAL(expected, actual);\r\n\r\n   call_delete_list(&list);\r\n}\r\n\r\nstatic void\r\ntest_foldr_direction_dependent_function_applied_to_non_empty_list(void)\r\n{\r\n   TEST_IGNORE();\r\n   list = new_list(2, (list_element_t[]){ 2, 5 });\r\n   list_element_t initial = 5;\r\n   list_element_t expected = 2;\r\n\r\n   list_element_t actual = foldr_list(list, initial, fold_divide);\r\n   TEST_ASSERT_EQUAL(expected, actual);\r\n\r\n   call_delete_list(&list);\r\n}\r\n\r\nstatic void test_reverse_empty_list(void)\r\n{\r\n   TEST_IGNORE();\r\n   list = new_list(0, NULL);\r\n\r\n   actual = reverse_list(list);\r\n   check_lists_match(0, NULL, actual);\r\n\r\n   call_delete_list(&list);\r\n   call_delete_list(&actual);\r\n}\r\n\r\nstatic void test_reverse_non_empty_list(void)\r\n{\r\n   TEST_IGNORE();\r\n   list = new_list(4, (list_element_t[]){ 1, 3, 5, 7 });\r\n   size_t expected_length = 4;\r\n   list_element_t expected_elements[] = { 7, 5, 3, 1 };\r\n\r\n   actual = reverse_list(list);\r\n   check_lists_match(expected_length, expected_elements, actual);\r\n\r\n   call_delete_list(&list);\r\n   call_delete_list(&actual);\r\n}\r\n\r\nint main(void)\r\n{\r\n   UNITY_BEGIN();\r\n\r\n   RUN_TEST(test_append_empty_lists);\r\n   RUN_TEST(test_append_list_to_empty_list);\r\n   RUN_TEST(test_append_empty_list_to_list);\r\n   RUN_TEST(test_append_non_empty_lists);\r\n   RUN_TEST(test_filter_empty_list);\r\n   RUN_TEST(test_filter_non_empty_list);\r\n   RUN_TEST(test_length_empty_list);\r\n   RUN_TEST(test_length_non_empty_list);\r\n   RUN_TEST(test_map_empty_list);\r\n   RUN_TEST(test_map_non_empty_list);\r\n   RUN_TEST(test_foldl_empty_list);\r\n   RUN_TEST(\r\n       test_foldl_direction_independent_function_applied_to_non_empty_list);\r\n   RUN_TEST(test_foldl_direction_dependent_function_applied_to_non_empty_list);\r\n   RUN_TEST(test_foldr_empty_list);\r\n   RUN_TEST(\r\n       test_foldr_direction_independent_function_applied_to_non_empty_list);\r\n   RUN_TEST(test_foldr_direction_dependent_function_applied_to_non_empty_list);\r\n   RUN_TEST(test_reverse_empty_list);\r\n   RUN_TEST(test_reverse_non_empty_list);\r\n\r\n   return UNITY_END();\r\n}\r\n"
  }
}