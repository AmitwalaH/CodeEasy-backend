{
  "language": "c",
  "slug": "all-your-base",
  "docs": {
    "introduction": "# Introduction\r\n\r\nYou've just been hired as professor of mathematics.\r\nYour first week went well, but something is off in your second week.\r\nThe problem is that every answer given by your students is wrong!\r\nLuckily, your math skills have allowed you to identify the problem: the student answers _are_ correct, but they're all in base 2 (binary)!\r\nAmazingly, it turns out that each week, the students use a different base.\r\nTo help you quickly verify the student answers, you'll be building a tool to translate between bases.\r\n",
    "instructions": "# Instructions\r\n\r\nConvert a sequence of digits in one base, representing a number, into a sequence of digits in another base, representing the same number.\r\n\r\n~~~~exercism/note\r\nTry to implement the conversion yourself.\r\nDo not use something else to perform the conversion for you.\r\n~~~~\r\n\r\n## About [Positional Notation][positional-notation]\r\n\r\nIn positional notation, a number in base **b** can be understood as a linear combination of powers of **b**.\r\n\r\nThe number 42, _in base 10_, means:\r\n\r\n`(4 × 10¹) + (2 × 10⁰)`\r\n\r\nThe number 101010, _in base 2_, means:\r\n\r\n`(1 × 2⁵) + (0 × 2⁴) + (1 × 2³) + (0 × 2²) + (1 × 2¹) + (0 × 2⁰)`\r\n\r\nThe number 1120, _in base 3_, means:\r\n\r\n`(1 × 3³) + (1 × 3²) + (2 × 3¹) + (0 × 3⁰)`\r\n\r\n_Yes. Those three numbers above are exactly the same. Congratulations!_\r\n\r\n[positional-notation]: https://en.wikipedia.org/wiki/Positional_notation\r\n",
    "hints": ""
  },
  "starter_code": {
    "all_your_base.c": "#include \"all_your_base.h\"\r\n",
    "all_your_base.h": "#ifndef ALL_YOUR_BASE_H\r\n#define ALL_YOUR_BASE_H\r\n\r\n#define DIGITS_ARRAY_SIZE 64\r\n\r\n#endif\r\n"
  },
  "tests": {
    "test_all_your_base.c": "#include \"test-framework/unity.h\"\r\n#include <stddef.h>\r\n#include <stdint.h>\r\n#include \"all_your_base.h\"\r\n\r\n#include <stdio.h>\r\n\r\n#define LENGTH(A) (sizeof(A) / sizeof(A[0]))\r\n\r\nvoid setUp(void)\r\n{\r\n}\r\n\r\nvoid tearDown(void)\r\n{\r\n}\r\n\r\nstatic void copy_array(int8_t src[], int8_t dest[DIGITS_ARRAY_SIZE], size_t n)\r\n{\r\n   if (n > DIGITS_ARRAY_SIZE)\r\n      return;\r\n   for (size_t i = 0; i < n; ++i)\r\n      dest[i] = src[i];\r\n}\r\n\r\nstatic void check_rebase(int16_t input_base, int8_t input_digits[],\r\n                         size_t input_length, int16_t output_base,\r\n                         int8_t expected_digits[], size_t expected_length)\r\n{\r\n   int8_t digits[DIGITS_ARRAY_SIZE] = { 0 };\r\n\r\n   copy_array(input_digits, digits, input_length);\r\n\r\n   size_t actual_length = rebase(digits, input_base, output_base, input_length);\r\n\r\n   TEST_ASSERT_EQUAL_INT32(expected_length, actual_length);\r\n\r\n   if (expected_length > 0)\r\n      TEST_ASSERT_EQUAL_INT8_ARRAY(expected_digits, digits, expected_length);\r\n}\r\n\r\nstatic void test_single_bit_to_decimal(void)\r\n{\r\n   int8_t input[] = { 1 };\r\n   int8_t expected[] = { 1 };\r\n   check_rebase(2, input, LENGTH(input), 10, expected, LENGTH(expected));\r\n}\r\n\r\nstatic void test_binary_to_single_decimal(void)\r\n{\r\n   TEST_IGNORE();   // delete this line to run test\r\n   int8_t input[] = { 1, 0, 1 };\r\n   int8_t expected[] = { 5 };\r\n   check_rebase(2, input, LENGTH(input), 10, expected, LENGTH(expected));\r\n}\r\n\r\nstatic void test_single_decimal_to_binary(void)\r\n{\r\n   TEST_IGNORE();\r\n   int8_t input[] = { 5 };\r\n   int8_t expected[] = { 1, 0, 1 };\r\n   check_rebase(10, input, LENGTH(input), 2, expected, LENGTH(expected));\r\n}\r\n\r\nstatic void test_binary_to_multiple_decimal(void)\r\n{\r\n   TEST_IGNORE();\r\n   int8_t input[] = { 1, 0, 1, 0, 1, 0 };\r\n   int8_t expected[] = { 4, 2 };\r\n   check_rebase(2, input, LENGTH(input), 10, expected, LENGTH(expected));\r\n}\r\n\r\nstatic void test_decimal_to_binary(void)\r\n{\r\n   TEST_IGNORE();\r\n   int8_t input[] = { 4, 2 };\r\n   int8_t expected[] = { 1, 0, 1, 0, 1, 0 };\r\n   check_rebase(10, input, LENGTH(input), 2, expected, LENGTH(expected));\r\n}\r\n\r\nstatic void test_trinary_to_hexadecimal(void)\r\n{\r\n   TEST_IGNORE();\r\n   int8_t input[] = { 1, 1, 2, 0 };\r\n   int8_t expected[] = { 2, 10 };\r\n   check_rebase(3, input, LENGTH(input), 16, expected, LENGTH(expected));\r\n}\r\n\r\nstatic void test_hexadecimal_to_trinary(void)\r\n{\r\n   TEST_IGNORE();\r\n   int8_t input[] = { 2, 10 };\r\n   int8_t expected[] = { 1, 1, 2, 0 };\r\n   check_rebase(16, input, LENGTH(input), 3, expected, LENGTH(expected));\r\n}\r\n\r\nstatic void test_15_bit_integer(void)\r\n{\r\n   TEST_IGNORE();\r\n   int8_t input[] = { 3, 46, 60 };\r\n   int8_t expected[] = { 6, 10, 45 };\r\n   check_rebase(97, input, LENGTH(input), 73, expected, LENGTH(expected));\r\n}\r\n\r\nstatic void test_empty_list(void)\r\n{\r\n   TEST_IGNORE();\r\n   int8_t input[DIGITS_ARRAY_SIZE] = { 0 };\r\n   TEST_ASSERT_EQUAL_size_t(0, rebase(input, 2, 10, 0));\r\n}\r\n\r\nstatic void test_single_zero(void)\r\n{\r\n   TEST_IGNORE();\r\n   int8_t input[] = { 0 };\r\n   int8_t expected[] = { 0 };\r\n   check_rebase(2, input, LENGTH(input), 10, expected, LENGTH(expected));\r\n}\r\n\r\nstatic void test_multiple_zeros(void)\r\n{\r\n   TEST_IGNORE();\r\n   int8_t input[] = { 0, 0, 0 };\r\n   int8_t expected[] = { 0 };\r\n   check_rebase(10, input, LENGTH(input), 2, expected, LENGTH(expected));\r\n}\r\n\r\nstatic void test_leading_zeros(void)\r\n{\r\n   TEST_IGNORE();\r\n   int8_t input[] = { 0, 6, 0 };\r\n   int8_t expected[] = { 4, 2 };\r\n   check_rebase(7, input, LENGTH(input), 10, expected, LENGTH(expected));\r\n}\r\n\r\nstatic void test_input_base_is_one(void)\r\n{\r\n   TEST_IGNORE();\r\n   int8_t input[] = { 0 };\r\n   int8_t expected[] = { 0 };\r\n   check_rebase(1, input, LENGTH(input), 10, expected, 0);\r\n}\r\n\r\nstatic void test_input_base_is_zero(void)\r\n{\r\n   TEST_IGNORE();\r\n   int8_t input[] = { 0 };\r\n   int8_t expected[] = { 0 };\r\n   check_rebase(0, input, LENGTH(input), 10, expected, 0);\r\n}\r\n\r\nstatic void test_input_base_is_negative(void)\r\n{\r\n   TEST_IGNORE();\r\n   int8_t input[] = { 1 };\r\n   int8_t expected[] = { 0 };\r\n   check_rebase(-2, input, LENGTH(input), 10, expected, 0);\r\n}\r\n\r\nstatic void test_negative_digit(void)\r\n{\r\n   TEST_IGNORE();\r\n   int8_t input[] = { 1, -1, 1, 0, 1, 0 };\r\n   int8_t expected[] = { 0 };\r\n   check_rebase(2, input, LENGTH(input), 10, expected, 0);\r\n}\r\n\r\nstatic void test_invalid_positive_digit(void)\r\n{\r\n   TEST_IGNORE();\r\n   int8_t input[] = { 1, 2, 1, 0, 1, 0 };\r\n   int8_t expected[] = { 0 };\r\n   check_rebase(2, input, LENGTH(input), 10, expected, 0);\r\n}\r\n\r\nstatic void test_output_base_is_one(void)\r\n{\r\n   TEST_IGNORE();\r\n   int8_t input[] = { 1, 0, 1, 0, 1, 0 };\r\n   int8_t expected[] = { 0 };\r\n   check_rebase(2, input, LENGTH(input), 1, expected, 0);\r\n}\r\n\r\nstatic void test_output_base_is_zero(void)\r\n{\r\n   TEST_IGNORE();\r\n   int8_t input[] = { 7 };\r\n   int8_t expected[] = { 0 };\r\n   check_rebase(10, input, LENGTH(input), 0, expected, 0);\r\n}\r\n\r\nstatic void test_output_base_is_negative(void)\r\n{\r\n   TEST_IGNORE();\r\n   int8_t input[] = { 1 };\r\n   int8_t expected[] = { 0 };\r\n   check_rebase(2, input, LENGTH(input), -7, expected, 0);\r\n}\r\n\r\nstatic void test_both_bases_are_negative(void)\r\n{\r\n   TEST_IGNORE();\r\n   int8_t input[] = { 1 };\r\n   int8_t expected[] = { 0 };\r\n   check_rebase(-2, input, LENGTH(input), -7, expected, 0);\r\n}\r\n\r\nint main(void)\r\n{\r\n   UNITY_BEGIN();\r\n\r\n   RUN_TEST(test_single_bit_to_decimal);\r\n   RUN_TEST(test_binary_to_single_decimal);\r\n   RUN_TEST(test_single_decimal_to_binary);\r\n   RUN_TEST(test_binary_to_multiple_decimal);\r\n   RUN_TEST(test_decimal_to_binary);\r\n   RUN_TEST(test_trinary_to_hexadecimal);\r\n   RUN_TEST(test_hexadecimal_to_trinary);\r\n   RUN_TEST(test_15_bit_integer);\r\n   RUN_TEST(test_empty_list);\r\n   RUN_TEST(test_single_zero);\r\n   RUN_TEST(test_multiple_zeros);\r\n   RUN_TEST(test_leading_zeros);\r\n   RUN_TEST(test_input_base_is_one);\r\n   RUN_TEST(test_input_base_is_zero);\r\n   RUN_TEST(test_input_base_is_negative);\r\n   RUN_TEST(test_negative_digit);\r\n   RUN_TEST(test_invalid_positive_digit);\r\n   RUN_TEST(test_output_base_is_one);\r\n   RUN_TEST(test_output_base_is_zero);\r\n   RUN_TEST(test_output_base_is_negative);\r\n   RUN_TEST(test_both_bases_are_negative);\r\n\r\n   return UNITY_END();\r\n}\r\n"
  }
}