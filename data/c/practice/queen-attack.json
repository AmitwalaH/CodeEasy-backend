{
  "language": "c",
  "slug": "queen-attack",
  "docs": {
    "introduction": "",
    "instructions": "# Instructions\r\n\r\nGiven the position of two queens on a chess board, indicate whether or not they are positioned so that they can attack each other.\r\n\r\nIn the game of chess, a queen can attack pieces which are on the same row, column, or diagonal.\r\n\r\nA chessboard can be represented by an 8 by 8 array.\r\n\r\nSo if you are told the white queen is at `c5` (zero-indexed at column 2, row 3) and the black queen at `f2` (zero-indexed at column 5, row 6), then you know that the set-up is like so:\r\n\r\n![A chess board with two queens. Arrows emanating from the queen at c5 indicate possible directions of capture along file, rank and diagonal.](https://assets.exercism.org/images/exercises/queen-attack/queen-capture.svg)\r\n\r\nYou are also able to answer whether the queens can attack each other.\r\nIn this case, that answer would be yes, they can, because both pieces share a diagonal.\r\n\r\n## Credit\r\n\r\nThe chessboard image was made by [habere-et-dispertire][habere-et-dispertire] using LaTeX and the [chessboard package][chessboard-package] by Ulrike Fischer.\r\n\r\n[habere-et-dispertire]: https://exercism.org/profiles/habere-et-dispertire\r\n[chessboard-package]: https://github.com/u-fischer/chessboard\r\n",
    "hints": ""
  },
  "starter_code": {
    "queen_attack.c": "#include \"queen_attack.h\"\r\n",
    "queen_attack.h": "#ifndef QUEEN_ATTACK_H\r\n#define QUEEN_ATTACK_H\r\n\r\n#include <stdint.h>\r\n\r\ntypedef enum { CAN_NOT_ATTACK, CAN_ATTACK, INVALID_POSITION } attack_status_t;\r\n\r\ntypedef struct {\r\n   uint8_t row;\r\n   uint8_t column;\r\n} position_t;\r\n\r\nattack_status_t can_attack(position_t queen_1, position_t queen_2);\r\n\r\n#endif\r\n"
  },
  "tests": {
    "test_queen_attack.c": "#include \"test-framework/unity.h\"\r\n#include \"queen_attack.h\"\r\n\r\nvoid setUp(void)\r\n{\r\n}\r\n\r\nvoid tearDown(void)\r\n{\r\n}\r\n\r\nstatic void test_invalid_if_on_same_position(void)\r\n{\r\n   position_t white_queen;\r\n   position_t black_queen;\r\n\r\n   white_queen.column = 2;\r\n   white_queen.row = 5;\r\n   black_queen.column = white_queen.column;\r\n   black_queen.row = white_queen.row;\r\n\r\n   TEST_ASSERT_EQUAL(INVALID_POSITION, can_attack(white_queen, black_queen));\r\n}\r\n\r\nstatic void test_white_queen_must_have_row_on_board(void)\r\n{\r\n   TEST_IGNORE();   // delete this line to run test\r\n   position_t white_queen;\r\n   position_t black_queen;\r\n\r\n   white_queen.column = 2;\r\n   white_queen.row = 8;\r\n   black_queen.column = 0;\r\n   black_queen.row = 0;\r\n\r\n   TEST_ASSERT_EQUAL(INVALID_POSITION, can_attack(white_queen, black_queen));\r\n}\r\n\r\nstatic void test_white_queen_must_have_column_on_board(void)\r\n{\r\n   TEST_IGNORE();\r\n   position_t white_queen;\r\n   position_t black_queen;\r\n\r\n   white_queen.column = 8;\r\n   white_queen.row = 2;\r\n   black_queen.column = 0;\r\n   black_queen.row = 0;\r\n\r\n   TEST_ASSERT_EQUAL(INVALID_POSITION, can_attack(white_queen, black_queen));\r\n}\r\n\r\nstatic void test_black_queen_must_have_row_on_board(void)\r\n{\r\n   TEST_IGNORE();\r\n   position_t white_queen;\r\n   position_t black_queen;\r\n\r\n   white_queen.column = 0;\r\n   white_queen.row = 0;\r\n   black_queen.column = 2;\r\n   black_queen.row = 10;\r\n\r\n   TEST_ASSERT_EQUAL(INVALID_POSITION, can_attack(white_queen, black_queen));\r\n}\r\n\r\nstatic void test_black_queen_must_have_column_on_board(void)\r\n{\r\n   TEST_IGNORE();\r\n   position_t white_queen;\r\n   position_t black_queen;\r\n\r\n   white_queen.column = 0;\r\n   white_queen.row = 0;\r\n   black_queen.column = 9;\r\n   black_queen.row = 4;\r\n\r\n   TEST_ASSERT_EQUAL(INVALID_POSITION, can_attack(white_queen, black_queen));\r\n}\r\n\r\nstatic void test_can_not_attack(void)\r\n{\r\n   TEST_IGNORE();\r\n   position_t white_queen;\r\n   position_t black_queen;\r\n\r\n   white_queen.column = 4;\r\n   white_queen.row = 2;\r\n   black_queen.column = 6;\r\n   black_queen.row = 6;\r\n\r\n   TEST_ASSERT_EQUAL(CAN_NOT_ATTACK, can_attack(white_queen, black_queen));\r\n}\r\n\r\nstatic void test_can_attack_on_same_row(void)\r\n{\r\n   TEST_IGNORE();\r\n   position_t white_queen;\r\n   position_t black_queen;\r\n\r\n   white_queen.column = 4;\r\n   white_queen.row = 2;\r\n   black_queen.column = 6;\r\n   black_queen.row = 2;\r\n\r\n   TEST_ASSERT_EQUAL(CAN_ATTACK, can_attack(white_queen, black_queen));\r\n}\r\n\r\nstatic void test_can_attack_on_same_column(void)\r\n{\r\n   TEST_IGNORE();\r\n   position_t white_queen;\r\n   position_t black_queen;\r\n\r\n   white_queen.column = 5;\r\n   white_queen.row = 4;\r\n   black_queen.column = 5;\r\n   black_queen.row = 2;\r\n\r\n   TEST_ASSERT_EQUAL(CAN_ATTACK, can_attack(white_queen, black_queen));\r\n}\r\n\r\nstatic void test_can_attack_on_first_diagonal(void)\r\n{\r\n   TEST_IGNORE();\r\n   position_t white_queen;\r\n   position_t black_queen;\r\n\r\n   white_queen.column = 2;\r\n   white_queen.row = 2;\r\n   black_queen.column = 4;\r\n   black_queen.row = 0;\r\n\r\n   TEST_ASSERT_EQUAL(CAN_ATTACK, can_attack(white_queen, black_queen));\r\n}\r\n\r\nstatic void test_can_attack_on_second_diagonal(void)\r\n{\r\n   TEST_IGNORE();\r\n   position_t white_queen;\r\n   position_t black_queen;\r\n\r\n   white_queen.column = 2;\r\n   white_queen.row = 2;\r\n   black_queen.column = 1;\r\n   black_queen.row = 3;\r\n\r\n   TEST_ASSERT_EQUAL(CAN_ATTACK, can_attack(white_queen, black_queen));\r\n}\r\n\r\nstatic void test_can_attack_on_third_diagonal(void)\r\n{\r\n   TEST_IGNORE();\r\n   position_t white_queen;\r\n   position_t black_queen;\r\n\r\n   white_queen.column = 2;\r\n   white_queen.row = 2;\r\n   black_queen.column = 1;\r\n   black_queen.row = 1;\r\n\r\n   TEST_ASSERT_EQUAL(CAN_ATTACK, can_attack(white_queen, black_queen));\r\n}\r\n\r\nstatic void test_can_attack_on_fourth_diagonal(void)\r\n{\r\n   TEST_IGNORE();\r\n   position_t white_queen;\r\n   position_t black_queen;\r\n\r\n   white_queen.column = 7;\r\n   white_queen.row = 1;\r\n   black_queen.column = 6;\r\n   black_queen.row = 0;\r\n\r\n   TEST_ASSERT_EQUAL(CAN_ATTACK, can_attack(white_queen, black_queen));\r\n}\r\n\r\nstatic void\r\ntest_cannot_attack_if_falling_diagonals_only_same_when_reflected_across_longest_falling_diagonal(\r\n    void)\r\n{\r\n   TEST_IGNORE();\r\n   position_t white_queen;\r\n   position_t black_queen;\r\n\r\n   white_queen.column = 1;\r\n   white_queen.row = 4;\r\n   black_queen.column = 5;\r\n   black_queen.row = 2;\r\n\r\n   TEST_ASSERT_EQUAL(CAN_NOT_ATTACK, can_attack(white_queen, black_queen));\r\n}\r\n\r\nint main(void)\r\n{\r\n   UNITY_BEGIN();\r\n\r\n   RUN_TEST(test_invalid_if_on_same_position);\r\n   RUN_TEST(test_white_queen_must_have_row_on_board);\r\n   RUN_TEST(test_white_queen_must_have_column_on_board);\r\n   RUN_TEST(test_black_queen_must_have_row_on_board);\r\n   RUN_TEST(test_black_queen_must_have_column_on_board);\r\n   RUN_TEST(test_can_not_attack);\r\n   RUN_TEST(test_can_attack_on_same_row);\r\n   RUN_TEST(test_can_attack_on_same_column);\r\n   RUN_TEST(test_can_attack_on_first_diagonal);\r\n   RUN_TEST(test_can_attack_on_second_diagonal);\r\n   RUN_TEST(test_can_attack_on_third_diagonal);\r\n   RUN_TEST(test_can_attack_on_fourth_diagonal);\r\n   RUN_TEST(\r\n       test_cannot_attack_if_falling_diagonals_only_same_when_reflected_across_longest_falling_diagonal);\r\n\r\n   return UNITY_END();\r\n}\r\n"
  }
}