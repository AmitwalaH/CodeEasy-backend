{
  "language": "c",
  "slug": "sieve",
  "docs": {
    "introduction": "# Introduction\r\n\r\nYou bought a big box of random computer parts at a garage sale.\r\nYou've started putting the parts together to build custom computers.\r\n\r\nYou want to test the performance of different combinations of parts, and decide to create your own benchmarking program to see how your computers compare.\r\nYou choose the famous \"Sieve of Eratosthenes\" algorithm, an ancient algorithm, but one that should push your computers to the limits.\r\n",
    "instructions": "# Instructions\r\n\r\nYour task is to create a program that implements the Sieve of Eratosthenes algorithm to find all prime numbers less than or equal to a given number.\r\n\r\nA prime number is a number larger than 1 that is only divisible by 1 and itself.\r\nFor example, 2, 3, 5, 7, 11, and 13 are prime numbers.\r\nBy contrast, 6 is _not_ a prime number as it not only divisible by 1 and itself, but also by 2 and 3.\r\n\r\nTo use the Sieve of Eratosthenes, first, write out all the numbers from 2 up to and including your given number.\r\nThen, follow these steps:\r\n\r\n1. Find the next unmarked number (skipping over marked numbers).\r\n   This is a prime number.\r\n2. Mark all the multiples of that prime number as **not** prime.\r\n\r\nRepeat the steps until you've gone through every number.\r\nAt the end, all the unmarked numbers are prime.\r\n\r\n~~~~exercism/note\r\nThe Sieve of Eratosthenes marks off multiples of each prime using addition (repeatedly adding the prime) or multiplication (directly computing its multiples), rather than checking each number for divisibility.\r\n\r\nThe tests don't check that you've implemented the algorithm, only that you've come up with the correct primes.\r\n~~~~\r\n\r\n## Example\r\n\r\nLet's say you're finding the primes less than or equal to 10.\r\n\r\n- Write out 2, 3, 4, 5, 6, 7, 8, 9, 10, leaving them all unmarked.\r\n\r\n  ```text\r\n  2 3 4 5 6 7 8 9 10\r\n  ```\r\n\r\n- 2 is unmarked and is therefore a prime.\r\n  Mark 4, 6, 8 and 10 as \"not prime\".\r\n\r\n  ```text\r\n  2 3 [4] 5 [6] 7 [8] 9 [10]\r\n  ↑\r\n  ```\r\n\r\n- 3 is unmarked and is therefore a prime.\r\n  Mark 6 and 9 as not prime _(marking 6 is optional - as it's already been marked)_.\r\n\r\n  ```text\r\n  2 3 [4] 5 [6] 7 [8] [9] [10]\r\n    ↑\r\n  ```\r\n\r\n- 4 is marked as \"not prime\", so we skip over it.\r\n\r\n  ```text\r\n  2 3 [4] 5 [6] 7 [8] [9] [10]\r\n       ↑\r\n  ```\r\n\r\n- 5 is unmarked and is therefore a prime.\r\n  Mark 10 as not prime _(optional - as it's already been marked)_.\r\n\r\n  ```text\r\n  2 3 [4] 5 [6] 7 [8] [9] [10]\r\n          ↑\r\n  ```\r\n\r\n- 6 is marked as \"not prime\", so we skip over it.\r\n\r\n  ```text\r\n  2 3 [4] 5 [6] 7 [8] [9] [10]\r\n             ↑\r\n  ```\r\n\r\n- 7 is unmarked and is therefore a prime.\r\n\r\n  ```text\r\n  2 3 [4] 5 [6] 7 [8] [9] [10]\r\n                ↑\r\n  ```\r\n\r\n- 8 is marked as \"not prime\", so we skip over it.\r\n\r\n  ```text\r\n  2 3 [4] 5 [6] 7 [8] [9] [10]\r\n                   ↑\r\n  ```\r\n\r\n- 9 is marked as \"not prime\", so we skip over it.\r\n\r\n  ```text\r\n  2 3 [4] 5 [6] 7 [8] [9] [10]\r\n                       ↑\r\n  ```\r\n\r\n- 10 is marked as \"not prime\", so we stop as there are no more numbers to check.\r\n\r\n  ```text\r\n  2 3 [4] 5 [6] 7 [8] [9] [10]\r\n                           ↑\r\n  ```\r\n\r\nYou've examined all the numbers and found that 2, 3, 5, and 7 are still unmarked, meaning they're the primes less than or equal to 10.\r\n",
    "hints": ""
  },
  "starter_code": {
    "sieve.c": "#include \"sieve.h\"\r\n",
    "sieve.h": "#ifndef SIEVE_H\r\n#define SIEVE_H\r\n\r\n#include <stdint.h>\r\n#include <stddef.h>\r\n\r\n/// Calculate at most `max_primes` prime numbers in the interval [2,limit]\r\n/// using the Sieve of Eratosthenes and store the prime numbers in `primes`\r\n/// in increasing order.\r\n/// The function returns the number of calculated primes.\r\nuint32_t sieve(uint32_t limit, uint32_t *primes, size_t max_primes);\r\n\r\n#endif\r\n"
  },
  "tests": {
    "test_sieve.c": "#include <string.h>\r\n#include \"test-framework/unity.h\"\r\n#include \"sieve.h\"\r\n\r\n#define RESULT_ARRAY_LEN (1000)\r\nstatic uint32_t result_array[RESULT_ARRAY_LEN];\r\n\r\nvoid setUp(void)\r\n{\r\n}\r\n\r\nvoid tearDown(void)\r\n{\r\n}\r\n\r\nstatic void test_no_primes_under_two(void)\r\n{\r\n   const uint32_t limit = 1;\r\n   const uint32_t expected_prime_count = 0;\r\n   const uint32_t result_prime_count =\r\n       sieve(limit, result_array, RESULT_ARRAY_LEN);\r\n   TEST_ASSERT_EQUAL(expected_prime_count, result_prime_count);\r\n}\r\n\r\nstatic void test_find_first_prime(void)\r\n{\r\n   TEST_IGNORE();\r\n   const uint32_t limit = 2;\r\n   const uint32_t expected_prime_array[] = { 2 };\r\n   const uint32_t expected_prime_count = 1;\r\n\r\n   const uint32_t result_prime_count =\r\n       sieve(limit, result_array, RESULT_ARRAY_LEN);\r\n\r\n   TEST_ASSERT_EQUAL(expected_prime_count, result_prime_count);\r\n   TEST_ASSERT_EQUAL_UINT_ARRAY(expected_prime_array, result_array,\r\n                                expected_prime_count);\r\n}\r\n\r\nstatic void test_find_primes_up_to_10(void)\r\n{\r\n   TEST_IGNORE();\r\n   const uint32_t limit = 10;\r\n   const uint32_t expected_prime_array[] = { 2, 3, 5, 7 };\r\n   const uint32_t expected_prime_count = 4;\r\n\r\n   const uint32_t result_prime_count =\r\n       sieve(limit, result_array, RESULT_ARRAY_LEN);\r\n\r\n   TEST_ASSERT_EQUAL(expected_prime_count, result_prime_count);\r\n   TEST_ASSERT_EQUAL_UINT_ARRAY(expected_prime_array, result_array,\r\n                                expected_prime_count);\r\n}\r\n\r\nstatic void test_limit_is_prime(void)\r\n{\r\n   TEST_IGNORE();\r\n   const uint32_t limit = 13;\r\n   const uint32_t expected_prime_array[] = { 2, 3, 5, 7, 11, 13 };\r\n   const uint32_t expected_prime_count = 6;\r\n\r\n   const uint32_t result_prime_count =\r\n       sieve(limit, result_array, RESULT_ARRAY_LEN);\r\n\r\n   TEST_ASSERT_EQUAL(expected_prime_count, result_prime_count);\r\n   TEST_ASSERT_EQUAL_UINT_ARRAY(expected_prime_array, result_array,\r\n                                expected_prime_count);\r\n}\r\n\r\nstatic void test_limit_is_prime_and_small_max_primes(void)\r\n{\r\n   TEST_IGNORE();\r\n   const uint32_t limit = 13;\r\n   const uint32_t expected_prime_array[] = { 2, 3, 5, 7, 11, 13 };\r\n   const uint32_t expected_prime_count = 4;\r\n\r\n   const uint32_t result_prime_count = sieve(limit, result_array, 4);\r\n\r\n   TEST_ASSERT_EQUAL(expected_prime_count, result_prime_count);\r\n   TEST_ASSERT_EQUAL_UINT_ARRAY(expected_prime_array, result_array,\r\n                                expected_prime_count);\r\n}\r\n\r\nstatic void test_find_primes_up_to_1000(void)\r\n{\r\n   TEST_IGNORE();\r\n   const uint32_t limit = 1000;\r\n   const uint32_t expected_prime_array[] = {\r\n      2,   3,   5,   7,   11,  13,  17,  19,  23,  29,  31,  37,  41,  43,\r\n      47,  53,  59,  61,  67,  71,  73,  79,  83,  89,  97,  101, 103, 107,\r\n      109, 113, 127, 131, 137, 139, 149, 151, 157, 163, 167, 173, 179, 181,\r\n      191, 193, 197, 199, 211, 223, 227, 229, 233, 239, 241, 251, 257, 263,\r\n      269, 271, 277, 281, 283, 293, 307, 311, 313, 317, 331, 337, 347, 349,\r\n      353, 359, 367, 373, 379, 383, 389, 397, 401, 409, 419, 421, 431, 433,\r\n      439, 443, 449, 457, 461, 463, 467, 479, 487, 491, 499, 503, 509, 521,\r\n      523, 541, 547, 557, 563, 569, 571, 577, 587, 593, 599, 601, 607, 613,\r\n      617, 619, 631, 641, 643, 647, 653, 659, 661, 673, 677, 683, 691, 701,\r\n      709, 719, 727, 733, 739, 743, 751, 757, 761, 769, 773, 787, 797, 809,\r\n      811, 821, 823, 827, 829, 839, 853, 857, 859, 863, 877, 881, 883, 887,\r\n      907, 911, 919, 929, 937, 941, 947, 953, 967, 971, 977, 983, 991, 997\r\n   };\r\n   const uint32_t expected_prime_count = 168;\r\n\r\n   const uint32_t result_prime_count =\r\n       sieve(limit, result_array, RESULT_ARRAY_LEN);\r\n\r\n   TEST_ASSERT_EQUAL(expected_prime_count, result_prime_count);\r\n   TEST_ASSERT_EQUAL_UINT_ARRAY(expected_prime_array, result_array,\r\n                                expected_prime_count);\r\n}\r\n\r\nint main(void)\r\n{\r\n   UNITY_BEGIN();\r\n\r\n   RUN_TEST(test_no_primes_under_two);\r\n   RUN_TEST(test_find_first_prime);\r\n   RUN_TEST(test_find_primes_up_to_10);\r\n   RUN_TEST(test_limit_is_prime);\r\n   RUN_TEST(test_limit_is_prime_and_small_max_primes);\r\n   RUN_TEST(test_find_primes_up_to_1000);\r\n\r\n   return UNITY_END();\r\n}\r\n"
  }
}