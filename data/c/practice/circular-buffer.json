{
  "language": "c",
  "slug": "circular-buffer",
  "docs": {
    "introduction": "",
    "instructions": "# Instructions\r\n\r\nA circular buffer, cyclic buffer or ring buffer is a data structure that uses a single, fixed-size buffer as if it were connected end-to-end.\r\n\r\nA circular buffer first starts empty and of some predefined length.\r\nFor example, this is a 7-element buffer:\r\n\r\n```text\r\n[ ][ ][ ][ ][ ][ ][ ]\r\n```\r\n\r\nAssume that a 1 is written into the middle of the buffer (exact starting location does not matter in a circular buffer):\r\n\r\n```text\r\n[ ][ ][ ][1][ ][ ][ ]\r\n```\r\n\r\nThen assume that two more elements are added — 2 & 3 — which get appended after the 1:\r\n\r\n```text\r\n[ ][ ][ ][1][2][3][ ]\r\n```\r\n\r\nIf two elements are then removed from the buffer, the oldest values inside the buffer are removed.\r\nThe two elements removed, in this case, are 1 & 2, leaving the buffer with just a 3:\r\n\r\n```text\r\n[ ][ ][ ][ ][ ][3][ ]\r\n```\r\n\r\nIf the buffer has 7 elements then it is completely full:\r\n\r\n```text\r\n[5][6][7][8][9][3][4]\r\n```\r\n\r\nWhen the buffer is full an error will be raised, alerting the client that further writes are blocked until a slot becomes free.\r\n\r\nWhen the buffer is full, the client can opt to overwrite the oldest data with a forced write.\r\nIn this case, two more elements — A & B — are added and they overwrite the 3 & 4:\r\n\r\n```text\r\n[5][6][7][8][9][A][B]\r\n```\r\n\r\n3 & 4 have been replaced by A & B making 5 now the oldest data in the buffer.\r\nFinally, if two elements are removed then what would be returned is 5 & 6 yielding the buffer:\r\n\r\n```text\r\n[ ][ ][7][8][9][A][B]\r\n```\r\n\r\nBecause there is space available, if the client again uses overwrite to store C & D then the space where 5 & 6 were stored previously will be used not the location of 7 & 8.\r\n7 is still the oldest element and the buffer is once again full.\r\n\r\n```text\r\n[C][D][7][8][9][A][B]\r\n```\r\n",
    "hints": ""
  },
  "starter_code": {
    "circular_buffer.c": "#include \"circular_buffer.h\"\r\n",
    "circular_buffer.h": "#ifndef CIRCULAR_BUFFER_H\r\n#define CIRCULAR_BUFFER_H\r\n\r\n#endif\r\n"
  },
  "tests": {
    "test_circular_buffer.c": "#include \"test-framework/unity.h\"\r\n#include \"circular_buffer.h\"\r\n#include <stdlib.h>\r\n#include <stdbool.h>\r\n#include <errno.h>\r\n\r\n#define MAX_ERROR_MSG_LEN 100\r\n#define ARRAY_LENGTH(A) (sizeof(A) / sizeof(A[0]))\r\n\r\nvoid setUp(void)\r\n{\r\n}\r\n\r\nvoid tearDown(void)\r\n{\r\n}\r\n\r\nstatic void write_values_to_buffer(size_t length, buffer_value_t values[],\r\n                                   bool writeover, circular_buffer_t *buffer)\r\n{\r\n   for (size_t i = 0; i < length; ++i) {\r\n      int16_t status = 0;\r\n      if (!writeover)\r\n         status = write(buffer, values[i]);\r\n      else\r\n         status = overwrite(buffer, values[i]);\r\n\r\n      char error_message[MAX_ERROR_MSG_LEN] = { 0 };\r\n      snprintf(error_message, MAX_ERROR_MSG_LEN,\r\n               \"Writing %d at %zu resulted in errno %d\", values[i], i, errno);\r\n      TEST_ASSERT_EQUAL_INT16_MESSAGE(EXIT_SUCCESS, status, error_message);\r\n   }\r\n}\r\n\r\nstatic void read_values_from_buffer(size_t length, buffer_value_t values[],\r\n                                    circular_buffer_t *buffer)\r\n{\r\n   for (size_t i = 0; i < length; ++i) {\r\n      buffer_value_t read_value = 0;\r\n      int16_t status = read(buffer, &read_value);\r\n\r\n      char error_message[MAX_ERROR_MSG_LEN] = { 0 };\r\n      snprintf(error_message, MAX_ERROR_MSG_LEN,\r\n               \"Reading at %zu resulted in errno %d, expected to read %d\", i,\r\n               errno, values[i]);\r\n      TEST_ASSERT_EQUAL_INT16_MESSAGE(EXIT_SUCCESS, status, error_message);\r\n\r\n      snprintf(error_message, MAX_ERROR_MSG_LEN,\r\n               \"Read %d at %zu where %d was expected\", read_value, i,\r\n               values[i]);\r\n      TEST_ASSERT_EQUAL_INT16_MESSAGE(values[i], read_value, error_message);\r\n   }\r\n}\r\n\r\nstatic void test_reading_empty_buffer_fails(void)\r\n{\r\n   size_t capacity = 1;\r\n   buffer_value_t read_value = 0;\r\n\r\n   circular_buffer_t *buffer = new_circular_buffer(capacity);\r\n   int16_t status = read(buffer, &read_value);\r\n   TEST_ASSERT_EQUAL_INT16(EXIT_FAILURE, status);\r\n   TEST_ASSERT_EQUAL_INT16(ENODATA, errno);\r\n\r\n   delete_buffer(buffer);\r\n}\r\n\r\nstatic void test_can_read_item_just_written(void)\r\n{\r\n   TEST_IGNORE();   // delete this line to run test\r\n   size_t capacity = 1;\r\n   buffer_value_t values[] = { 1 };\r\n   size_t values_length = ARRAY_LENGTH(values);\r\n   circular_buffer_t *buffer = new_circular_buffer(capacity);\r\n\r\n   write_values_to_buffer(values_length, values, false, buffer);\r\n   read_values_from_buffer(values_length, values, buffer);\r\n\r\n   delete_buffer(buffer);\r\n}\r\n\r\nstatic void test_each_item_may_only_be_read_once(void)\r\n{\r\n   TEST_IGNORE();\r\n   size_t capacity = 1;\r\n   buffer_value_t values[] = { 1 };\r\n   size_t values_length = ARRAY_LENGTH(values);\r\n   buffer_value_t read_value = 0;\r\n\r\n   circular_buffer_t *buffer = new_circular_buffer(capacity);\r\n   write_values_to_buffer(values_length, values, false, buffer);\r\n   read_values_from_buffer(values_length, values, buffer);\r\n\r\n   int16_t status = read(buffer, &read_value);\r\n   TEST_ASSERT_EQUAL_INT16(EXIT_FAILURE, status);\r\n   TEST_ASSERT_EQUAL_INT16(ENODATA, errno);\r\n\r\n   delete_buffer(buffer);\r\n}\r\n\r\nstatic void test_items_are_read_in_order_written(void)\r\n{\r\n   TEST_IGNORE();\r\n   size_t capacity = 2;\r\n   buffer_value_t values[] = { 1, 2 };\r\n   size_t values_length = ARRAY_LENGTH(values);\r\n\r\n   circular_buffer_t *buffer = new_circular_buffer(capacity);\r\n   write_values_to_buffer(values_length, values, false, buffer);\r\n   read_values_from_buffer(values_length, values, buffer);\r\n\r\n   delete_buffer(buffer);\r\n}\r\n\r\nstatic void test_full_buffer_cannot_be_written_to(void)\r\n{\r\n   TEST_IGNORE();\r\n   size_t capacity = 1;\r\n\r\n   circular_buffer_t *buffer = new_circular_buffer(capacity);\r\n   write_values_to_buffer(1, (buffer_value_t[]){ 1 }, false, buffer);\r\n\r\n   int16_t status = write(buffer, 2);\r\n   TEST_ASSERT_EQUAL_INT16(EXIT_FAILURE, status);\r\n   TEST_ASSERT_EQUAL_INT16(ENOBUFS, errno);\r\n\r\n   delete_buffer(buffer);\r\n}\r\n\r\nstatic void test_read_frees_capacity_for_another_write(void)\r\n{\r\n   TEST_IGNORE();\r\n   size_t capacity = 1;\r\n\r\n   circular_buffer_t *buffer = new_circular_buffer(capacity);\r\n   write_values_to_buffer(1, (buffer_value_t[]){ 1 }, false, buffer);\r\n   read_values_from_buffer(1, (buffer_value_t[]){ 1 }, buffer);\r\n   write_values_to_buffer(1, (buffer_value_t[]){ 2 }, false, buffer);\r\n   read_values_from_buffer(1, (buffer_value_t[]){ 2 }, buffer);\r\n\r\n   delete_buffer(buffer);\r\n}\r\n\r\nstatic void test_read_position_maintained_across_multiple_writes(void)\r\n{\r\n   TEST_IGNORE();\r\n   size_t capacity = 3;\r\n\r\n   circular_buffer_t *buffer = new_circular_buffer(capacity);\r\n   write_values_to_buffer(2, (buffer_value_t[]){ 1, 2 }, false, buffer);\r\n   read_values_from_buffer(1, (buffer_value_t[]){ 1 }, buffer);\r\n   write_values_to_buffer(1, (buffer_value_t[]){ 3 }, false, buffer);\r\n   read_values_from_buffer(2, (buffer_value_t[]){ 2, 3 }, buffer);\r\n\r\n   delete_buffer(buffer);\r\n}\r\n\r\nstatic void test_cleared_buffer_cannot_be_read(void)\r\n{\r\n   TEST_IGNORE();\r\n   size_t capacity = 1;\r\n   buffer_value_t read_value = 0;\r\n\r\n   circular_buffer_t *buffer = new_circular_buffer(capacity);\r\n   write_values_to_buffer(1, (buffer_value_t[]){ 1 }, false, buffer);\r\n   clear_buffer(buffer);\r\n   int16_t status = read(buffer, &read_value);\r\n   TEST_ASSERT_EQUAL_INT16(EXIT_FAILURE, status);\r\n   TEST_ASSERT_EQUAL_INT16(ENODATA, errno);\r\n\r\n   delete_buffer(buffer);\r\n}\r\n\r\nstatic void test_clear_frees_capacity_for_another_write(void)\r\n{\r\n   TEST_IGNORE();\r\n   size_t capacity = 1;\r\n\r\n   circular_buffer_t *buffer = new_circular_buffer(capacity);\r\n   write_values_to_buffer(1, (buffer_value_t[]){ 1 }, false, buffer);\r\n   clear_buffer(buffer);\r\n   write_values_to_buffer(1, (buffer_value_t[]){ 2 }, false, buffer);\r\n   read_values_from_buffer(1, (buffer_value_t[]){ 2 }, buffer);\r\n\r\n   delete_buffer(buffer);\r\n}\r\n\r\nstatic void test_clear_does_nothing_on_an_empty_buffer(void)\r\n{\r\n   TEST_IGNORE();\r\n   size_t capacity = 1;\r\n   buffer_value_t values[] = { 1 };\r\n   size_t values_length = ARRAY_LENGTH(values);\r\n\r\n   circular_buffer_t *buffer = new_circular_buffer(capacity);\r\n   clear_buffer(buffer);\r\n   write_values_to_buffer(values_length, values, false, buffer);\r\n\r\n   delete_buffer(buffer);\r\n}\r\n\r\nstatic void test_overwrite_acts_like_write_on_non_full_buffer(void)\r\n{\r\n   TEST_IGNORE();\r\n   size_t capacity = 2;\r\n\r\n   circular_buffer_t *buffer = new_circular_buffer(capacity);\r\n   write_values_to_buffer(1, (buffer_value_t[]){ 1 }, false, buffer);\r\n   write_values_to_buffer(1, (buffer_value_t[]){ 2 }, true, buffer);\r\n   read_values_from_buffer(2, (buffer_value_t[]){ 1, 2 }, buffer);\r\n\r\n   delete_buffer(buffer);\r\n}\r\n\r\nstatic void test_overwrite_replaces_oldest_item_on_full_buffer(void)\r\n{\r\n   TEST_IGNORE();\r\n   size_t capacity = 2;\r\n\r\n   circular_buffer_t *buffer = new_circular_buffer(capacity);\r\n   write_values_to_buffer(2, (buffer_value_t[]){ 1, 2 }, false, buffer);\r\n   write_values_to_buffer(1, (buffer_value_t[]){ 3 }, true, buffer);\r\n   read_values_from_buffer(2, (buffer_value_t[]){ 2, 3 }, buffer);\r\n\r\n   delete_buffer(buffer);\r\n}\r\n\r\nstatic void test_overwrite_replaces_oldest_item_remaining_following_read(void)\r\n{\r\n   TEST_IGNORE();\r\n   size_t capacity = 3;\r\n\r\n   circular_buffer_t *buffer = new_circular_buffer(capacity);\r\n   write_values_to_buffer(3, (buffer_value_t[]){ 1, 2, 3 }, false, buffer);\r\n   read_values_from_buffer(1, (buffer_value_t[]){ 1 }, buffer);\r\n   write_values_to_buffer(1, (buffer_value_t[]){ 4 }, false, buffer);\r\n   write_values_to_buffer(1, (buffer_value_t[]){ 5 }, true, buffer);\r\n   read_values_from_buffer(3, (buffer_value_t[]){ 3, 4, 5 }, buffer);\r\n\r\n   delete_buffer(buffer);\r\n}\r\n\r\nstatic void test_initial_clear_does_not_affect_wrapping(void)\r\n{\r\n   TEST_IGNORE();\r\n   size_t capacity = 2;\r\n   buffer_value_t read_value = 0;\r\n\r\n   circular_buffer_t *buffer = new_circular_buffer(capacity);\r\n   clear_buffer(buffer);\r\n   write_values_to_buffer(2, (buffer_value_t[]){ 1, 2 }, false, buffer);\r\n   write_values_to_buffer(2, (buffer_value_t[]){ 3, 4 }, true, buffer);\r\n   read_values_from_buffer(2, (buffer_value_t[]){ 3, 4 }, buffer);\r\n\r\n   int16_t status = read(buffer, &read_value);\r\n   TEST_ASSERT_EQUAL_INT16(EXIT_FAILURE, status);\r\n   TEST_ASSERT_EQUAL_INT16(ENODATA, errno);\r\n\r\n   delete_buffer(buffer);\r\n}\r\n\r\nint main(void)\r\n{\r\n   UNITY_BEGIN();\r\n\r\n   RUN_TEST(test_reading_empty_buffer_fails);\r\n   RUN_TEST(test_can_read_item_just_written);\r\n   RUN_TEST(test_each_item_may_only_be_read_once);\r\n   RUN_TEST(test_items_are_read_in_order_written);\r\n   RUN_TEST(test_full_buffer_cannot_be_written_to);\r\n   RUN_TEST(test_read_frees_capacity_for_another_write);\r\n   RUN_TEST(test_read_position_maintained_across_multiple_writes);\r\n   RUN_TEST(test_cleared_buffer_cannot_be_read);\r\n   RUN_TEST(test_clear_frees_capacity_for_another_write);\r\n   RUN_TEST(test_clear_does_nothing_on_an_empty_buffer);\r\n   RUN_TEST(test_overwrite_acts_like_write_on_non_full_buffer);\r\n   RUN_TEST(test_overwrite_replaces_oldest_item_on_full_buffer);\r\n   RUN_TEST(test_overwrite_replaces_oldest_item_remaining_following_read);\r\n   RUN_TEST(test_initial_clear_does_not_affect_wrapping);\r\n\r\n   return UNITY_END();\r\n}\r\n"
  }
}