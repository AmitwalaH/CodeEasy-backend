{
  "language": "c",
  "slug": "binary-search-tree",
  "docs": {
    "introduction": "",
    "instructions": "# Instructions\r\n\r\nInsert and search for numbers in a binary tree.\r\n\r\nWhen we need to represent sorted data, an array does not make a good data structure.\r\n\r\nSay we have the array `[1, 3, 4, 5]`, and we add 2 to it so it becomes `[1, 3, 4, 5, 2]`.\r\nNow we must sort the entire array again!\r\nWe can improve on this by realizing that we only need to make space for the new item `[1, nil, 3, 4, 5]`, and then adding the item in the space we added.\r\nBut this still requires us to shift many elements down by one.\r\n\r\nBinary Search Trees, however, can operate on sorted data much more efficiently.\r\n\r\nA binary search tree consists of a series of connected nodes.\r\nEach node contains a piece of data (e.g. the number 3), a variable named `left`, and a variable named `right`.\r\nThe `left` and `right` variables point at `nil`, or other nodes.\r\nSince these other nodes in turn have other nodes beneath them, we say that the left and right variables are pointing at subtrees.\r\nAll data in the left subtree is less than or equal to the current node's data, and all data in the right subtree is greater than the current node's data.\r\n\r\nFor example, if we had a node containing the data 4, and we added the data 2, our tree would look like this:\r\n\r\n![A graph with root node 4 and a single child node 2.](https://assets.exercism.org/images/exercises/binary-search-tree/tree-4-2.svg)\r\n\r\n```text\r\n      4\r\n     /\r\n    2\r\n```\r\n\r\nIf we then added 6, it would look like this:\r\n\r\n![A graph with root node 4 and two child nodes 2 and 6.](https://assets.exercism.org/images/exercises/binary-search-tree/tree-4-2-6.svg)\r\n\r\n```text\r\n      4\r\n     / \\\r\n    2   6\r\n```\r\n\r\nIf we then added 3, it would look like this\r\n\r\n![A graph with root node 4, two child nodes 2 and 6, and a grandchild node 3.](https://assets.exercism.org/images/exercises/binary-search-tree/tree-4-2-6-3.svg)\r\n\r\n```text\r\n       4\r\n     /   \\\r\n    2     6\r\n     \\\r\n      3\r\n```\r\n\r\nAnd if we then added 1, 5, and 7, it would look like this\r\n\r\n![A graph with root node 4, two child nodes 2 and 6, and four grandchild nodes 1, 3, 5 and 7.](https://assets.exercism.org/images/exercises/binary-search-tree/tree-4-2-6-1-3-5-7.svg)\r\n\r\n```text\r\n          4\r\n        /   \\\r\n       /     \\\r\n      2       6\r\n     / \\     / \\\r\n    1   3   5   7\r\n```\r\n\r\n## Credit\r\n\r\nThe images were created by [habere-et-dispertire][habere-et-dispertire] using [PGF/TikZ][pgf-tikz] by Till Tantau.\r\n\r\n[habere-et-dispertire]: https://exercism.org/profiles/habere-et-dispertire\r\n[pgf-tikz]: https://en.wikipedia.org/wiki/PGF/TikZ\r\n",
    "hints": ""
  },
  "starter_code": {
    "binary_search_tree.c": "#include \"binary_search_tree.h\"\r\n",
    "binary_search_tree.h": "#ifndef BINARY_SEARCH_TREE_H\r\n#define BINARY_SEARCH_TREE_H\r\n#include <stddef.h>\r\n\r\ntypedef struct node node_t;\r\n\r\nstruct node {\r\n   node_t *right;\r\n   node_t *left;\r\n   int data;\r\n};\r\n\r\nnode_t *build_tree(int *tree_data, size_t tree_data_len);\r\nvoid free_tree(node_t *tree);\r\nint *sorted_data(node_t *tree);\r\n\r\n#endif\r\n"
  },
  "tests": {
    "test_binary_search_tree.c": "#include \"test-framework/unity.h\"\r\n#include \"binary_search_tree.h\"\r\n#include <stdlib.h>\r\n#include <stdbool.h>\r\n\r\n#define ARRAY_SIZE(arr) (sizeof(arr) / sizeof(arr[0]))\r\n\r\nvoid setUp(void)\r\n{\r\n}\r\n\r\nvoid tearDown(void)\r\n{\r\n}\r\n\r\nstatic void test_data_data_is_retained(void)\r\n{\r\n   int tree_data[] = { 4 };\r\n   node_t *tree = build_tree(tree_data, ARRAY_SIZE(tree_data));\r\n\r\n   TEST_ASSERT_NOT_NULL(tree);\r\n   TEST_ASSERT_EQUAL_INT(4, tree->data);\r\n   TEST_ASSERT_NULL(tree->left);\r\n   TEST_ASSERT_NULL(tree->right);\r\n\r\n   free_tree(tree);\r\n}\r\n\r\nstatic void test_data_smaller_number_at_left_node(void)\r\n{\r\n   TEST_IGNORE();   // delete this line to run test\r\n   int tree_data[] = { 4, 2 };\r\n   node_t *tree = build_tree(tree_data, ARRAY_SIZE(tree_data));\r\n\r\n   TEST_ASSERT_NOT_NULL(tree);\r\n   TEST_ASSERT_EQUAL_INT(4, tree->data);\r\n   TEST_ASSERT_NOT_NULL(tree->left);\r\n   TEST_ASSERT_NULL(tree->right);\r\n\r\n   TEST_ASSERT_EQUAL_INT(2, tree->left->data);\r\n   TEST_ASSERT_NULL(tree->left->left);\r\n   TEST_ASSERT_NULL(tree->left->right);\r\n\r\n   free_tree(tree);\r\n}\r\n\r\nstatic void test_data_same_number_at_left_node(void)\r\n{\r\n   TEST_IGNORE();\r\n   int tree_data[] = { 4, 4 };\r\n   node_t *tree = build_tree(tree_data, ARRAY_SIZE(tree_data));\r\n\r\n   TEST_ASSERT_NOT_NULL(tree);\r\n   TEST_ASSERT_EQUAL_INT(4, tree->data);\r\n   TEST_ASSERT_NOT_NULL(tree->left);\r\n   TEST_ASSERT_NULL(tree->right);\r\n\r\n   TEST_ASSERT_EQUAL_INT(4, tree->left->data);\r\n   TEST_ASSERT_NULL(tree->left->left);\r\n   TEST_ASSERT_NULL(tree->left->right);\r\n\r\n   free_tree(tree);\r\n}\r\n\r\nstatic void test_data_greater_number_at_right_node(void)\r\n{\r\n   TEST_IGNORE();\r\n   int tree_data[] = { 4, 5 };\r\n   node_t *tree = build_tree(tree_data, ARRAY_SIZE(tree_data));\r\n\r\n   TEST_ASSERT_NOT_NULL(tree);\r\n   TEST_ASSERT_EQUAL_INT(4, tree->data);\r\n   TEST_ASSERT_NULL(tree->left);\r\n   TEST_ASSERT_NOT_NULL(tree->right);\r\n\r\n   TEST_ASSERT_EQUAL_INT(5, tree->right->data);\r\n   TEST_ASSERT_NULL(tree->right->left);\r\n   TEST_ASSERT_NULL(tree->right->right);\r\n\r\n   free_tree(tree);\r\n}\r\n\r\nstatic void test_data_can_create_complex_tree(void)\r\n{\r\n   TEST_IGNORE();\r\n   int tree_data[] = { 4, 2, 6, 1, 3, 5, 7 };\r\n   node_t *tree = build_tree(tree_data, ARRAY_SIZE(tree_data));\r\n\r\n   TEST_ASSERT_NOT_NULL(tree);\r\n   TEST_ASSERT_EQUAL_INT(4, tree->data);\r\n   TEST_ASSERT_NOT_NULL(tree->left);\r\n   TEST_ASSERT_NOT_NULL(tree->right);\r\n\r\n   TEST_ASSERT_EQUAL_INT(2, tree->left->data);\r\n   TEST_ASSERT_NOT_NULL(tree->left->left);\r\n   TEST_ASSERT_NOT_NULL(tree->left->right);\r\n\r\n   TEST_ASSERT_EQUAL_INT(6, tree->right->data);\r\n   TEST_ASSERT_NOT_NULL(tree->right->left);\r\n   TEST_ASSERT_NOT_NULL(tree->right->right);\r\n\r\n   TEST_ASSERT_EQUAL_INT(1, tree->left->left->data);\r\n   TEST_ASSERT_NULL(tree->left->left->left);\r\n   TEST_ASSERT_NULL(tree->left->left->right);\r\n\r\n   TEST_ASSERT_EQUAL_INT(3, tree->left->right->data);\r\n   TEST_ASSERT_NULL(tree->left->right->left);\r\n   TEST_ASSERT_NULL(tree->left->right->right);\r\n\r\n   TEST_ASSERT_EQUAL_INT(5, tree->right->left->data);\r\n   TEST_ASSERT_NULL(tree->right->left->left);\r\n   TEST_ASSERT_NULL(tree->right->left->right);\r\n\r\n   TEST_ASSERT_EQUAL_INT(7, tree->right->right->data);\r\n   TEST_ASSERT_NULL(tree->right->right->left);\r\n   TEST_ASSERT_NULL(tree->right->right->right);\r\n\r\n   free_tree(tree);\r\n}\r\n\r\nstatic void test_sorted_data_can_sort_single_number(void)\r\n{\r\n   TEST_IGNORE();\r\n   int tree_data[] = { 2 };\r\n   node_t *tree = build_tree(tree_data, ARRAY_SIZE(tree_data));\r\n\r\n   int expected[] = { 2 };\r\n   int *actual = sorted_data(tree);\r\n   TEST_ASSERT_EQUAL_INT_ARRAY(expected, actual, ARRAY_SIZE(expected));\r\n\r\n   free_tree(tree);\r\n   free(actual);\r\n}\r\n\r\nstatic void\r\ntest_sorted_data_can_sort_if_second_number_is_smaller_than_first(void)\r\n{\r\n   TEST_IGNORE();\r\n   int tree_data[] = { 2, 1 };\r\n   node_t *tree = build_tree(tree_data, ARRAY_SIZE(tree_data));\r\n\r\n   int expected[] = { 1, 2 };\r\n   int *actual = sorted_data(tree);\r\n   TEST_ASSERT_EQUAL_INT_ARRAY(expected, actual, ARRAY_SIZE(expected));\r\n\r\n   free_tree(tree);\r\n   free(actual);\r\n}\r\n\r\nstatic void test_sorted_data_can_sort_if_second_number_is_same_as_first(void)\r\n{\r\n   TEST_IGNORE();\r\n   int tree_data[] = { 2, 2 };\r\n   node_t *tree = build_tree(tree_data, ARRAY_SIZE(tree_data));\r\n\r\n   int expected[] = { 2, 2 };\r\n   int *actual = sorted_data(tree);\r\n   TEST_ASSERT_EQUAL_INT_ARRAY(expected, actual, ARRAY_SIZE(expected));\r\n\r\n   free_tree(tree);\r\n   free(actual);\r\n}\r\n\r\nstatic void\r\ntest_sorted_data_can_sort_if_second_number_is_greater_than_first(void)\r\n{\r\n   TEST_IGNORE();\r\n   int tree_data[] = { 2, 3 };\r\n   node_t *tree = build_tree(tree_data, ARRAY_SIZE(tree_data));\r\n\r\n   int expected[] = { 2, 3 };\r\n   int *actual = sorted_data(tree);\r\n   TEST_ASSERT_EQUAL_INT_ARRAY(expected, actual, ARRAY_SIZE(expected));\r\n\r\n   free_tree(tree);\r\n   free(actual);\r\n}\r\n\r\nstatic void test_sorted_data_can_sort_complex_tree(void)\r\n{\r\n   TEST_IGNORE();\r\n   int tree_data[] = { 2, 1, 3, 6, 7, 5 };\r\n   node_t *tree = build_tree(tree_data, ARRAY_SIZE(tree_data));\r\n\r\n   int expected[] = { 1, 2, 3, 5, 6, 7 };\r\n   int *actual = sorted_data(tree);\r\n   TEST_ASSERT_EQUAL_INT_ARRAY(expected, actual, ARRAY_SIZE(expected));\r\n\r\n   free_tree(tree);\r\n   free(actual);\r\n}\r\n\r\nint main(void)\r\n{\r\n   UNITY_BEGIN();\r\n\r\n   RUN_TEST(test_data_data_is_retained);\r\n   RUN_TEST(test_data_smaller_number_at_left_node);\r\n   RUN_TEST(test_data_same_number_at_left_node);\r\n   RUN_TEST(test_data_greater_number_at_right_node);\r\n   RUN_TEST(test_data_can_create_complex_tree);\r\n   RUN_TEST(test_sorted_data_can_sort_single_number);\r\n   RUN_TEST(test_sorted_data_can_sort_if_second_number_is_smaller_than_first);\r\n   RUN_TEST(test_sorted_data_can_sort_if_second_number_is_same_as_first);\r\n   RUN_TEST(test_sorted_data_can_sort_if_second_number_is_greater_than_first);\r\n   RUN_TEST(test_sorted_data_can_sort_complex_tree);\r\n\r\n   return UNITY_END();\r\n}\r\n"
  }
}