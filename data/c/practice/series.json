{
  "language": "c",
  "slug": "series",
  "docs": {
    "introduction": "",
    "instructions": "# Instructions\r\n\r\nGiven a string of digits, output all the contiguous substrings of length `n` in that string in the order that they appear.\r\n\r\nFor example, the string \"49142\" has the following 3-digit series:\r\n\r\n- \"491\"\r\n- \"914\"\r\n- \"142\"\r\n\r\nAnd the following 4-digit series:\r\n\r\n- \"4914\"\r\n- \"9142\"\r\n\r\nAnd if you ask for a 6-digit series from a 5-digit string, you deserve whatever you get.\r\n\r\nNote that these series are only required to occupy _adjacent positions_ in the input;\r\nthe digits need not be _numerically consecutive_.\r\n",
    "hints": ""
  },
  "starter_code": {
    "series.c": "#include \"series.h\"\r\n",
    "series.h": "#ifndef SERIES_H\r\n#define SERIES_H\r\n\r\n#define MAX_INPUT_TEXT_LENGTH (8)\r\n#define MAX_SERIES_RESULTS (MAX_INPUT_TEXT_LENGTH)\r\n#define MAX_SERIES_LENGTH (5)\r\n\r\n// results structure\r\ntypedef struct slices {\r\n   unsigned int substring_count;\r\n   char **substring;   // array of pointers of dimension substring_count\r\n} slices_t;\r\n\r\n// slices - routine to slice up input text into consecutive substrings of text\r\n// of a given substring_length\r\n//\r\n// inputs:\r\n//    input_text - bounded to MAX_INPUT_TEXT_LENGTH\r\n//    substring_length - the desired length of substrings that are returned\r\n//    bounded to MAX_SERIES_LENGTH\r\n//\r\n// outputs:\r\n//    slices_t results - structure containing count of the substrings and an\r\n//    array of\r\n//       pointers to the substrings.\r\n//\r\n//       Calling routine will free memory associated with each of the substrings\r\n//       and the pointers to the substrings.\r\nslices_t slices(char *input_text, unsigned int substring_length);\r\n\r\n#endif\r\n"
  },
  "tests": {
    "test_series.c": "#include <stdlib.h>\r\n#include \"test-framework/unity.h\"\r\n#include \"series.h\"\r\n\r\nvoid setUp(void)\r\n{\r\n}\r\n\r\nvoid tearDown(void)\r\n{\r\n}\r\n\r\n// helper routines to validate test results\r\nstatic void test_solution(slices_t *expected_solution,\r\n                          slices_t *actual_solution)\r\n{\r\n   // result count correct\r\n   TEST_ASSERT_EQUAL(expected_solution->substring_count,\r\n                     actual_solution->substring_count);\r\n\r\n   // test each substring...\r\n   for (unsigned int index = 0; index < expected_solution->substring_count;\r\n        index++) {\r\n      TEST_ASSERT_EQUAL_STRING(expected_solution->substring[index],\r\n                               actual_solution->substring[index]);\r\n      free(actual_solution->substring[index]);\r\n   }\r\n   if (actual_solution->substring_count) {\r\n      free(actual_solution->substring);\r\n   }\r\n}\r\n\r\n// Test cases\r\nstatic void test_slices_of_one_from_one(void)\r\n{\r\n   char *substrings[] = { \"1\" };\r\n   slices_t expected = { 1, &substrings[0] };\r\n   slices_t actual = slices(\"1\", 1);\r\n\r\n   test_solution(&expected, &actual);\r\n}\r\n\r\nstatic void test_slices_of_one_from_two(void)\r\n{\r\n   TEST_IGNORE();   // delete this line to run test\r\n   char *substrings[] = { \"1\", \"2\" };\r\n   slices_t expected = { 2, &substrings[0] };\r\n   slices_t actual = slices(\"12\", 1);\r\n\r\n   test_solution(&expected, &actual);\r\n}\r\n\r\nstatic void test_slices_of_two(void)\r\n{\r\n   TEST_IGNORE();\r\n   char *substrings[] = { \"35\" };\r\n   slices_t expected = { 1, &substrings[0] };\r\n   slices_t actual = slices(\"35\", 2);\r\n\r\n   test_solution(&expected, &actual);\r\n}\r\n\r\nstatic void test_slices_of_two_overlap(void)\r\n{\r\n   TEST_IGNORE();\r\n   char *substrings[] = { \"91\", \"14\", \"42\" };\r\n   slices_t expected = { 3, &substrings[0] };\r\n   slices_t actual = slices(\"9142\", 2);\r\n\r\n   test_solution(&expected, &actual);\r\n}\r\n\r\nstatic void test_slices_can_include_duplicates(void)\r\n{\r\n   TEST_IGNORE();\r\n   char *substrings[] = { \"777\", \"777\", \"777\", \"777\" };\r\n   slices_t expected = { 4, &substrings[0] };\r\n   slices_t actual = slices(\"777777\", 3);\r\n\r\n   test_solution(&expected, &actual);\r\n}\r\n\r\nstatic void test_slices_of_a_long_series(void)\r\n{\r\n   TEST_IGNORE();\r\n   char *substrings[] = { \"91849\", \"18493\", \"84939\", \"49390\",\r\n                          \"93904\", \"39042\", \"90424\", \"04243\" };\r\n   slices_t expected = { 8, &substrings[0] };\r\n   slices_t actual = slices(\"918493904243\", 5);\r\n\r\n   test_solution(&expected, &actual);\r\n}\r\n\r\nstatic void test_slice_length_is_too_large(void)\r\n{\r\n   TEST_IGNORE();\r\n   char *substrings[] = { \"\" };\r\n   slices_t expected = { 0, &substrings[0] };\r\n   slices_t actual = slices(\"12345\", 6);\r\n\r\n   test_solution(&expected, &actual);\r\n}\r\n\r\nstatic void test_slice_length_is_way_too_large(void)\r\n{\r\n   TEST_IGNORE();\r\n   char *substrings[] = { \"\" };\r\n   slices_t expected = { 0, &substrings[0] };\r\n   slices_t actual = slices(\"12345\", 42);\r\n\r\n   test_solution(&expected, &actual);\r\n}\r\n\r\nstatic void test_slice_length_cannot_be_zero(void)\r\n{\r\n   TEST_IGNORE();\r\n   char *substrings[] = { \"\" };\r\n   slices_t expected = { 0, &substrings[0] };\r\n   slices_t actual = slices(\"12345\", 0);\r\n\r\n   test_solution(&expected, &actual);\r\n}\r\n\r\nstatic void test_empty_series_is_invalid(void)\r\n{\r\n   TEST_IGNORE();\r\n   char *substrings[] = { \"\" };\r\n   slices_t expected = { 0, &substrings[0] };\r\n   slices_t actual = slices(\"\", 1);\r\n\r\n   test_solution(&expected, &actual);\r\n}\r\n\r\nint main(void)\r\n{\r\n   UNITY_BEGIN();\r\n\r\n   RUN_TEST(test_slices_of_one_from_one);\r\n   RUN_TEST(test_slices_of_one_from_two);\r\n   RUN_TEST(test_slices_of_two);\r\n   RUN_TEST(test_slices_of_two_overlap);\r\n   RUN_TEST(test_slices_can_include_duplicates);\r\n   RUN_TEST(test_slices_of_a_long_series);\r\n   RUN_TEST(test_slice_length_is_too_large);\r\n   RUN_TEST(test_slice_length_is_way_too_large);\r\n   RUN_TEST(test_slice_length_cannot_be_zero);\r\n   RUN_TEST(test_empty_series_is_invalid);\r\n\r\n   return UNITY_END();\r\n}\r\n"
  }
}