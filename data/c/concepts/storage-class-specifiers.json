{
  "language": "c",
  "slug": "storage-class-specifiers",
  "title": "Storage Class Specifiers",
  "docs": {
    "about": "# About\r\n\r\nStorage-class specifiers relate to how variables are stored in memory.\r\nThey are closely related to the storage duration (also referred to as the lifetime) of a value.\r\n\r\n## auto: the default storage class for function or block scope variables\r\n\r\nSince variables defined within a block or function are `auto` by default, it is not common to explicitly use the term.\r\nAnother reason that `auto` is often avoided is because it has a different meaning in C++.\r\nCodebases that combine C and C++ may be less confusing by avoiding the `auto` storage specifier.\r\nAn `auto` variable's lifetime begins when its block is entered and ends when its block is exited.\r\nAn `auto` variable has memory allocated for it, _but with no default value_, when its block is entered.\r\nAn exception is for variable length arrays (VLAs.)\r\nA VLA's allocation happens where it is declared or defined in its block and ends when its block is exited.\r\nAn `auto` variable can be initialized by any valid expression.\r\n\r\n## static: the storage specifier not to be confused with the static linkage type\r\n\r\nA variable defined outside of a block or function has file scope and always has static storage duration.\r\nFile scope means it can be accessed anywhere in the file.\r\nStatic storage means it exists from the beginning of the programs execution until the end.\r\nUnless explicitly initialized, a `static` variable is initialized with its default zero value.\r\nIf a file scope variable is marked with `static`, the `static` refers to its linkage.\r\nA file scope variable marked `static` has internal linkage, meaning it can only be accessed within the file.\r\nIf a variable is defined within a function or in a block within a function and is marked `static`, it has `static` storage duration.\r\nThe `static` variable's value persists between calls to the function or block.\r\n\r\nIn the following example we see two `static` variables at work.\r\nThe first `count` variable is defined within the `print_stuff` function and retains its value between calls to the function.\r\nThe second `count` variable is defined within an arbitrary block and hides (or shadows) the first `count` variable within its block.\r\nThe second `count` variable independently retains its value between entries into the block.\r\n\r\n```c\r\n#include <stdio.h>\r\n\r\nvoid print_stuff(void) {\r\n    // static variable is initialized to 0\r\n    static int count;\r\n    count++;\r\n    printf(\"function count is %d\\n\", count);\r\n    {\r\n        // static variable is initialized to 0\r\n        static int count;\r\n        count++;\r\n        printf(\"block count is %d\\n\", count);\r\n    }\r\n}\r\n\r\nint main() {\r\n    // prints\r\n    // function count is 1\r\n    // block count is 1\r\n    print_stuff();\r\n    // prints\r\n    // function count is 2\r\n    // block count is 2    \r\n    print_stuff();\r\n}\r\n```\r\n\r\nIf a `static` variable is explicitly initialized, it must be done so with a constant expression.\r\nA constant expression is one which can be evaluated at compile time.\r\n\r\n## extern: how to access a variable in another translation unit\r\n\r\nA translation unit consists of a source file and any other file it `#include`s.\r\nAlthough a variable with file scope can be declared and initialized as `extern`, the `extern` keyword is usually used to refer to an existing variable, not to define a new one.\r\nThe variable referred to by `extern` must have file scope.\r\nA variable in file scope always has `static` storage.\r\nA variable in an included file must have external linkage to be accessed by the file including it.\r\n\r\nIn the following example we use the variable `val` declared as `extern` so that it will refer to `val` defined in its file scope.\r\nBoth uses of `extern` are called referencing declarations, since they reference a variable defined elsewhere.\r\n\r\n```c\r\n#include <stdio.h>\r\n\r\nvoid set_val() {\r\n    // this declares val which is defined elsewhere\r\n    extern int val;\r\n    val += 42;\r\n    // prints val is 42\r\n    printf(\"val is %d\\n\", val);\r\n}\r\n\r\nint main() {\r\n    set_val();\r\n    // this declares val which is defined elsewhere\r\n    extern int val;\r\n    val += 42;\r\n    // prints val is 84\r\n    printf(\"val is %d\\n\", val);\r\n}\r\n// this value could be defined in another source file.\r\n// as a variable with static storage, it is initialized to zero\r\nint val;\r\n```\r\n\r\nIf both `extern` keywords were removed the program might print something like\r\n\r\n```\r\nval is 22038\r\nval is 42\r\n```\r\n\r\nSuch an output demonstrates that each declaration of `val` without `extern` is a defining declaration and is independent of the other declarations of `val`.\r\nEntirely removing the declarations of `val` from `set_val` and `main` would result in a compile error that `val` is undeclared in `set_val` and `main`.\r\n\r\nIf a variable referred to as `extern` is in the same file, it can have either internal or external linkage.\r\nDefining `val` as `static int val;` would have no effect on the use of `val` in `set_val` or `main`, except that the definition would need to be moved above them to compile.\r\nBut if `val` were defined above the functions they would not need to declare `val` as `extern`.\r\n\r\nThe following would work\r\n\r\n```c\r\n#include <stdio.h>\r\n\r\n// val defining declaration before the function definitions\r\nstatic int val;\r\n\r\nvoid set_val() {\r\n    val += 42;\r\n    // prints val is 42\r\n    printf(\"val is %d\\n\", val);\r\n}\r\n\r\nint main() {\r\n    set_val();\r\n    val += 42;\r\n    // prints val is 84\r\n    printf(\"val is %d\\n\", val);\r\n}\r\n```\r\n\r\nThe `static` could be removed from `static int val;`, giving `val` external linkage,  and `val` would still work the same in `set_val` and `main`.\r\nIf another source file included this file, it could only use `val` if `val` had external linkage (not declared as `static`) and the other file declared `extern int val;`.\r\n\r\nA variable referred to by `extern` must not only have `static` storage, but must also have file scope.\r\nThe following example will most likely not compile, because `val`, though `static`, does not have file scope.\r\n\r\n```c\r\n#include <stdio.h>\r\n\r\nvoid set_val() {\r\n    // defined with static storage, but not in file scope\r\n    static int val;\r\n    val += 42;\r\n    printf(\"val is %d\\n\", val);\r\n}\r\n\r\nint main() {\r\n    set_val();\r\n    extern int val;\r\n    printf(\"val is %d\\n\", val);\r\n}\r\n```\r\n\r\n## register: how to possibly speed access to a variable\r\n\r\nA variable marked as `register` expresses the programmer's desire to have the value placed in a register for quick access.\r\nA `register` variable is like an `auto` variable in that it must be in function or block scope.\r\nSince the value is intended to be placed in a register instead of memory, accessing the address of the variable should be disallowed by the compiler, since the address of a register can't be taken.\r\nHowever, a memory address itself can be placed in a register.\r\nThe following example demonstrates that\r\n\r\n```c\r\n#include <stdio.h>\r\n\r\nint main() {\r\n    int i = 42;\r\n    register int *i_ptr = &i;\r\n    // prints i is 42, i_ptr is 0x7ffd0c2055c4 (or some other address)\r\n    printf(\"i is %d, i_ptr is %p\", i, i_ptr);\r\n}\r\n```\r\n\r\nregister` is essentially a hint, since compilers are free to chose if they follow this specifier or not, so the value may or may not be actually placed in a register.\r\n\r\n## typedef: the storage class specifier that isn't really\r\n\r\n`typedef` is described as a storage class specifier for syntactic reasons only.\r\nThis is because a storage class specifier can't be used with another storage class specifer.\r\nSo, `typedef auto int i = 42;` is just as illegal as `static auto int i = 42;`.\r\n",
    "introduction": "# Introduction\r\n\r\nStorage-class specifiers relate to how variables are stored in memory.\r\nThey are closely related to the storage duration (also referred to as the lifetime) of a value.\r\n\r\n## auto: the default storage class for function or block scope variables\r\n\r\nSince variables defined within a block or function are `auto` by default, it is not common to explicitly use the term.\r\nAn `auto` variable's lifetime begins when its block is entered and ends when its block is exited.\r\nAn `auto` variable has memory allocated for it, _but with no default value_, when its block is entered.\r\n\r\n## static: the storage specifier not to be confused with the static linkage type\r\n\r\nIf a variable is defined outside of a block or function and is marked with `static`, the `static` refers to its linkage, meaning it can only be accessed within the file.\r\nIf a variable is defined within a function or in a block within a function and is marked `static`, it has `static` storage duration.\r\nThe `static` variable's value persists between calls to the function or block.\r\n\r\n## extern: how to access a variable in another translation unit\r\n\r\nA translation unit consists of a source file and any other file it `#include`s.\r\nAlthough a variable with file scope can be declared and initialized as `extern`, the `extern` keyword is usually used to refer to an existing variable, not to define a new one.\r\nThe variable referred to by `extern` must have file scope.\r\nA variable in file scope always has `static` storage.\r\nA variable in an included file must have external linkage to be accessed by the file including it.\r\n\r\n## register: how to possibly speed access to a variable\r\n\r\nA variable marked as `register` expresses the programmer's desire to have the value placed in a register for quick access.\r\nA `register` variable is like an `auto` variable in that it must be in function or block scope.\r\nSince the value is intended to be placed in a register instead of memory, accessing the address of the variable should be disallowed by the compiler, since the adress of a register can't be taken.\r\nHowever, a memory address itself can be placed in a register.\r\n`register` is essentially a hint, since the value may or may not be actually placed in a register.\r\n\r\n## typedef: the storage class specifier that isn't really\r\n\r\n`typedef` is described as a storage class specifier for syntactic reasons only.\r\nThis is because a storage class specifier can't be used with another storage class specifer.\r\nSo, `typedef auto int i = 42;` is just as illegal as `static auto int i = 42;`.\r\n"
  },
  "meta": {},
  "links": []
}