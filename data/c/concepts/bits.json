{
  "language": "c",
  "slug": "bits",
  "title": "Bits",
  "docs": {
    "about": "# About\r\n\r\nA `bit` is the most granular value in computing.\r\nThe word `bit` stands for \"binary digit\".\r\nIt is a unit of data storage in the execution environment large enough to hold an object that may have one of two values.\r\nAs such, it has a binary value of either `1` or `0`.\r\nAll other data types consist of multiple `bits`.\r\nFor example, a `byte` commonly consists of eight `bits`.\r\n\r\n## How to write bit values\r\n\r\n`Bits` make up a base 2 number system.\r\nEvery multiple of `2` is put into what we think of as the tens/hundreds/thousands/etc. place, except that \"tens\" would be \"two\", \"hundreds\" would be \"four\", \"thousands\" would be \"eight\", and so on.\r\nSo, the decimal value `2` would be the binary value `10`, `4` would be `100`, and `8` would be `1000`.\r\nLike decimal numbers, the values become higher as they go from right to left.\r\nWe can think of the decimal value `5` being represented by `101` in binary, with a `1` in the \"ones\" place and a `1` in the \"four\" place.\r\nHowever, binary literals are not part of the C language standard.\r\nThe only binary values supported by the C language standard are a single `1` or `0`.\r\nBinary literals _are_ supported by some non-standard compiler extensions, such as the gnu compiler, by prefacing the literal with `0b`.\r\n\r\n```c\r\n#include <stdio.h>\r\n\r\nint main() {\r\n    int binary_five = 0b101;\r\n    printf(\"%d\", binary_five);\r\n    return 0;\r\n}\r\n```\r\n\r\nIt is important to remember that such a notation is not supported by all compilers and could be a barrier to code portability between different compilers.\r\n\r\nA common way to code binary values is to use hexadecimal notation, which is a base 16 number system.\r\nC language hexadecimal notation prefaces the literal with `0x` or `0X`.\r\nSince the decimal value `16` is represented as `1` in the tens place, the decimal value `10` is represented as `0xA` in hexadecimal, `11` as `0xB`, `12` as `0xC`, `13` as `0xD`, `14` as `0xE` and `15` as `0xF`.\r\nSo, for example, the decimal value `42` would be written as `0x2A`: `2` times `16` (= `32`) plus `10` (= `42`).\r\n\r\nIn binary, we can think of `42` as `00101010`: `32` plus `8` plus `2`.\r\nWe would say that the second, fourth, and sixth bits from the right are \"set\", meaning that they are `1` instead of `0`.\r\nThe second bit is `2`, the fourth bit is `8`, and the sixth bit is `32`.\r\nSetting those three bits defines a value of `42`.\r\n\r\n## Bit Masks\r\n\r\nA bit mask can be any value that is used for setting individual bits.\r\nFor instance, there are twenty-six letters in the English alphabet.\r\nA value of at least twenty-six bits, such as an unsigned 32-bit integer, could be used as a bit mask to set a `true` or `false` condition for every English letter.\r\nAny value with enough bits to handle a required set of `true` or `false` conditions can serve as a bit mask.\r\nSetting and reading the individual bits is done through the use of bitwise operators.\r\n\r\n## Bitwise Operators\r\n\r\nLet's say we want to keep track of which letters occur in a `string`.\r\nFor our example, we will use only the twenty-six letters in the English alphabet.\r\nOur bit mask will be an unsigned 32-bit integer.\r\nA `0` will represent that the letter does not occur.\r\nA `1` will represent that the letter occurs one or more times.\r\nAt the beginning, the bit representation of our bit mask will be 32 `0s` in a row: `00000000000000000000000000000000`.\r\nThe rightmost position will be for `A`.\r\nSecond from the left will be for `B`, and so on.\r\nSay that we are processing all of the letters in the string in a loop, so we want one line of code that will work for setting any letter.\r\n\r\n### Bitwise shift left operator: a way to position a bit\r\n\r\n`<<` is the bitwise operator for shifting left.\r\n\r\nIf our letter is `A` we don't want to shift left, but if our letter is `B` we want to shift left one position, and if our letter is `C` we want to shift left two positions, and so on.\r\nAlthough we can perceive `chars` as letters like `A` or `B`,  a `char` is implemented as an integer type in memory, so we can do simple math with a `char`.\r\nGiven a variable named `letter` which represents the `char` we are processing, we can shift left the required number of positions by shifting `1` to the left by the difference between `letter` and the `A` `char`, like so: `1 << letter - 'A'`.\r\n`A` - `A` is `0`, so it would shift left `0` positions if `letter` is `A`.\r\n`B` - `A` is `1`, so it would shift left `1` position if `letter` is `B`, and so on.\r\n\r\n### Bitwise inclusive OR operator: a way to set a bit\r\n\r\nOnce we know _where_ we want to set a bit, we can actually set it by using the bitwise inclusive OR operator, which is `|`.\r\nThe result of the `|` operator will be `1` in each position where either the left or right operand has a bit set.\r\nSo, the result of `0010 | 0001` would be `0011`.\r\n(It's important to remember that the value is `11` in binary, but is `3` in decimal.)\r\nTo assign the result to a value, the `|` operator can be combined with the assignment operator to set the bits like so: `|=`.\r\nTo keep it simple, the following example does not use a loop, but it demonstrates how we could process the letters `ABA` in a bit mask.\r\n\r\n```c\r\n#include <stdio.h>\r\n#include <stdint.h>\r\n\r\nint main() {\r\n    // it's important to initialize the mask to 0 so we don't get garbage values\r\n    uint32_t mask = 0;\r\n    char letter_A = 'A';\r\n    char letter_B = 'B';\r\n    char letter_A_again = 'A';\r\n    mask |= 1 << letter_A - 'A';\r\n    mask |= 1 << letter_B - 'A';\r\n    mask |= 1 << letter_A_again - 'A';\r\n    // prints 3\r\n    printf(\"%d\", mask);\r\n}\r\n```\r\n\r\nWe set the rightmost part of our mask to `0001` for `A`, and then set the mask to `0011` for `B`.\r\nSetting another `A` results in no change to the existing mask.\r\nWe could have avoided setting the bit again by looking to see if `A` had already been set.\r\n\r\n### Bitwise AND operator: a way to read a bit\r\n\r\n`&` is the bitwise AND operator.\r\nThe result of the `&` operator will be `1` in each position where both the left and right operand has a bit set.\r\nSo, the result of `0011 & 0001` would be `0001`.\r\nWe can see this in action in the following example.\r\n\r\n```c\r\n#include <stdio.h>\r\n#include <stdint.h>\r\n\r\nint main() {\r\n    uint32_t mask = 0;\r\n    char letter_A = 'A';\r\n    char letter_B = 'B';\r\n    char letter_A_again = 'A';\r\n    mask |= 1 << letter_A - 'A';\r\n    mask |= 1 << letter_B - 'A';\r\n    // prints A already set\r\n    if (mask & 1 << letter_A_again - 'A')\r\n        printf(\"A already set\\n\");\r\n    else\r\n        mask |= 1 << letter_A_again - 'A';\r\n    printf(\"%d\", mask);\r\n}\r\n```\r\n\r\n### Bitwise exclusive OR operator: a way to flip a bit\r\n\r\n`^` is the bitwise exclusive OR operator.\r\nAn _inclusive_ OR operator implies that there is an _exclusive_ OR operator with different behavior.\r\nThe result of the `^` operator will be `1` in each position where _only one_ of the left or right operands has a bit set.\r\nSo, the result of `0001 ^ 0011` would be `0010`.\r\nThe rightmost bit will not be set because _both_ operands have `1` in the rightmost position.\r\nThe exclusive OR operation is sometimes notated as XOR.\r\nIf the result of a value that is XOR'd is itself XOR'd it will return the original value.\r\nThis can be used for a very simple encryption where the same key is used to both encrypt and decrypt the data.\r\nFor example\r\n\r\n```c\r\n#include <stdio.h>\r\n\r\nint main() {\r\n    char a = 'a';\r\n    char b = 'b';\r\n    char c = 'c';\r\n    // we will use \"a\" for the \"key\"\r\n    char first = a ^ 'a';\r\n    char second = b ^ 'a';\r\n    char third = c ^ 'a';\r\n    // prints three \"dots\" for unprintable characters\r\n    printf(\"%c %c %c\\n\", first, second, third);\r\n    // prints the ascii values 0 3 2\r\n    printf(\"%d %d %d\\n\", first, second, third);\r\n    first = first ^ 'a';\r\n    second = second ^ 'a';\r\n    third = third ^ 'a';\r\n    // prints a b c\r\n    printf(\"%c %c %c\\n\", first, second, third);\r\n    // prints the ascii values 97 98 99\r\n    printf(\"%d %d %d\\n\", first, second, third);\r\n}\r\n```\r\n\r\n### Bitwise shift right operator: a way to halve a value\r\n\r\n`>>` is the bitwise operator for shifting right.\r\nUsually, for every position that a value's bits are shifted right, the result is the value divided by two.\r\nFor example\r\n\r\n```c\r\n#include <stdio.h>\r\n\r\nint main() {\r\n    int number = 16;\r\n    number >>= 2;\r\n    // prints 4, or 16 / 2 = 8 / 2 = 4\r\n    printf(\"%d\\n\", number);\r\n}\r\n```\r\n\r\nIf the value of the right operand is negative or is greater than or equal to the width of the promoted left operand, the behavior is undefined.\r\nThat also applies to the left shift operator.\r\nWhen a signed integer is used instead of an unsigned integer, then the signedness may also factor in.\r\nThe following example shows behavior on a system when shifting too far to the left or right for a signed integer.\r\n\r\n```c\r\n#include <stdio.h>\r\n\r\nint main() {\r\n    int number = 16;\r\n    number <<= 250;\r\n    // prints 1073741824\r\n    printf(\"%d\\n\", number);\r\n    number <<= 1;\r\n    // prints -2147483648\r\n    printf(\"%d\\n\", number);\r\n    number <<= 1;\r\n    // prints 0\r\n    printf(\"%d\\n\", number);\r\n    // total shifts are now 256, done incrementally\r\n    number <<= 4;\r\n    // prints 0\r\n    printf(\"%d\\n\", number);\r\n    number = 16;\r\n    // prints 16 when 256 total shifts done at once\r\n    printf(\"%d\\n\", number << 256);\r\n    // prints 0 when bits shifted right far enough\r\n    printf(\"%d\\n\", number >> 5);    \r\n    // still prints 0\r\n    printf(\"%d\\n\", number >> 255);\r\n    // prints 16 when shifted right far enough to \"wrap around\"\r\n    printf(\"%d\\n\", number >> 256);\r\n}\r\n```\r\n\r\nSince the behavior is undefined, a different system may yield different results.\r\nIt is important when shifting bits to understand the confines of the data type being used.\r\n\r\n## Bit Fields\r\n\r\nWe've seen how bits packed into a simple data type can be addressed by their position.\r\nBits packed into a `struct` can be addressed by name.\r\nSuch a data type is called a `bit field`.\r\nA use case for `bit fields` can be when a collection of ON/OFF flags is needed and the minimizing of memory use is desired.\r\n\r\n```c\r\n#include <stdio.h>\r\n\r\nint main() {\r\n\r\n    struct lights {\r\n        unsigned int number_of_lights;\r\n        unsigned int red   : 1;\r\n        unsigned int green : 1;\r\n        unsigned int blue  : 1;\r\n    };\r\n    struct lights lightboard = {3, 0, 0, 0};\r\n     \r\n    //  prints 000\r\n    printf(\"%d\", lightboard.red);\r\n    printf(\"%d\", lightboard.green);\r\n    printf(\"%d\\n\", lightboard.blue);\r\n    \r\n    lightboard.green = 1;\r\n\r\n    //  prints 010\r\n    printf(\"%d\", lightboard.red);\r\n    printf(\"%d\", lightboard.green);\r\n    printf(\"%d\\n\", lightboard.blue);\r\n    \r\n    // prints 3\r\n    printf(\"%d\\n\", lightboard.number_of_lights);\r\n}\r\n```\r\n\r\nThe syntax of `unsigned int variable_name : 1;` creates a field of `1` bit within an `unsigned int` placed within the struct.\r\nInstead of an `unsigned int`, a `signed int` could be used, or, as of C99 or later, a `bool` type could be used.\r\nA struct containing bit fields can also contain fields of other data types, such as `number_of_lights` in the above example.\r\n\r\n",
    "introduction": "# Introduction\r\n\r\nA `bit` is the most granular value in computing.\r\nThe word `bit` stands for \"binary digit\".\r\nIt is a unit of data storage in the execution environment large enough to hold an object that may have one of two values.\r\nAs such, it has a binary value of either `1` or `0`.\r\nAll other data types consist of multiple `bits`.\r\nFor example, a `byte` commonly consists of eight `bits`.\r\n\r\n## Bit Masks\r\n\r\nA bit mask can be any value that is used for setting individual bits.\r\nFor instance, there are twenty-six letters in the English alphabet.\r\nA value of at least twenty-six bits, such as an unsigned 32-bit integer, could be used as a bit mask to set a `true` or `false` condition for every English letter.\r\nAny value with enough bits to handle a required set of `true` or `false` conditions can serve as a bit mask.\r\nSetting and reading the individual bits is done through the use of bitwise operators.\r\n\r\n## Bitwise Operators\r\n\r\nLet's say we want to keep track of which letters occur in a `string`.\r\nFor our example, we will use only the twenty-six letters in the English alphabet.\r\nOur bit mask will be an unsigned 32-bit integer.\r\nA `0` will represent that the letter does not occur.\r\nA `1` will represent that the letter occurs one or more times.\r\nAt the beginning, the bit representation of our bit mask will be 32 `0s` in a row: `00000000000000000000000000000000`.\r\nThe rightmost position will be for `A`.\r\nSecond from the left will be for `B`, and so on.\r\nSay that we are processing all of the letters in the string in a loop, so we want one line of code that will work for setting any letter.\r\n\r\n### Bitwise shift left operator: a way to position a bit\r\n\r\n`<<` is the bitwise operator for shifting left.\r\n\r\nIf our letter is `A` we don't want to shift left, but if our letter is `B` we want to shift left one position, and if our letter is `C` we want to shift left two positions, and so on.\r\nAlthough we can perceive `chars` as letters like `A` or `B`,  a `char` is implemented as an integer type in memory, so we can do simple math with a `char`.\r\nGiven a variable named `letter` which represents the `char` we are processing, we can shift left the required number of positions by shifting `1` to the left by the difference between `letter` and the `A` `char`, like so: `1 << letter - 'A'`.\r\n`A` - `A` is `0`, so it would shift left `0` positions if `letter` is `A`.\r\n`B` - `A` is `1`, so it would shift left `1` position if `letter` is `B`, and so on.\r\n\r\n### Bitwise inclusive OR operator: a way to set a bit\r\n\r\nOnce we know _where_ we want to set a bit, we can actually set it by using the bitwise inclusive OR operator, which is `|`.\r\nThe result of the `|` operator will be `1` in each position where either the left or right operand has a bit set.\r\nSo, the result of `0010 | 0001` would be `0011`.\r\n(It's important to remember that the value is `11` in binary, but is `3` in decimal.)\r\nTo assign the result to a value, the `|` operator can be combined with the assignment operator to set the bits like so: `|=`.\r\nTo keep it simple, the following example does not use a loop, but it demonstrates how we could process the letters `ABA` in a bit mask.\r\n\r\n```c\r\n#include <stdio.h>\r\n#include <stdint.h>\r\n\r\nint main() {\r\n    // it's important to initialize the mask to 0 so we don't get garbage values\r\n    uint32_t mask = 0;\r\n    char letter_A = 'A';\r\n    char letter_B = 'B';\r\n    char letter_A_again = 'A';\r\n    mask |= 1 << letter_A - 'A';\r\n    mask |= 1 << letter_B - 'A';\r\n    mask |= 1 << letter_A_again - 'A';\r\n    // prints 3\r\n    printf(\"%d\", mask);\r\n}\r\n```\r\n\r\nWe set the rightmost part of our mask to `0001` for `A`, and then set the mask to `0011` for `B`.\r\nSetting another `A` results in no change to the existing mask.\r\nWe could have avoided setting the bit again by looking to see if `A` had already been set.\r\n\r\n### Bitwise AND operator: a way to read a bit\r\n\r\n`&` is the bitwise AND operator.\r\nThe result of the `&` operator will be `1` in each position where both the left and right operand has a bit set.\r\nSo, the result of `0011 & 0001` would be `0001`.\r\nWe can see this in action in the following example.\r\n\r\n```c\r\n#include <stdio.h>\r\n#include <stdint.h>\r\n\r\nint main() {\r\n    uint32_t mask = 0;\r\n    char letter_A = 'A';\r\n    char letter_B = 'B';\r\n    char letter_A_again = 'A';\r\n    mask |= 1 << letter_A - 'A';\r\n    mask |= 1 << letter_B - 'A';\r\n    // prints A already set\r\n    if (mask & 1 << letter_A_again - 'A')\r\n        printf(\"A already set\\n\");\r\n    else\r\n        mask |= 1 << letter_A_again - 'A';\r\n    printf(\"%d\", mask);\r\n}\r\n```\r\n\r\n### Bitwise exclusive OR operator: a way to flip a bit\r\n\r\n`^` is the bitwise exclusive OR operator.\r\nAn _inclusive_ OR operator implies that there is an _exclusive_ OR operator with different behavior.\r\nThe result of the `^` operator will be `1` in each position where _only one_ of the left or right operands has a bit set.\r\nSo, the result of `0001 ^ 0011` would be `0010`.\r\nThe rightmost bit will not be set because _both_ operands have `1` in the rightmost position.\r\nThe exclusive OR operation is sometimes notated as XOR.\r\nIf the result of a value that is XOR'd is itself XOR'd it will return the original value.\r\nThis can be used for a very simple encryption where the same key is used to both encrypt and decrypt the data.\r\nFor example\r\n\r\n```c\r\n#include <stdio.h>\r\n\r\nint main() {\r\n    char a = 'a';\r\n    char b = 'b';\r\n    char c = 'c';\r\n    // we will use \"a\" for the \"key\"\r\n    char first = a ^ 'a';\r\n    char second = b ^ 'a';\r\n    char third = c ^ 'a';\r\n    // prints three \"dots\" for unprintable characters\r\n    printf(\"%c %c %c\\n\", first, second, third);\r\n    // prints the ascii values 0 3 2\r\n    printf(\"%d %d %d\\n\", first, second, third);\r\n    first = first ^ 'a';\r\n    second = second ^ 'a';\r\n    third = third ^ 'a';\r\n    // prints a b c\r\n    printf(\"%c %c %c\\n\", first, second, third);\r\n    // prints the ascii values 97 98 99\r\n    printf(\"%d %d %d\\n\", first, second, third);\r\n}\r\n```\r\n\r\n## Bit Fields\r\n\r\nWe've seen how bits packed into a simple data type can be addressed by their position.\r\nBits packed into a `struct` can be addressed by name.\r\nSuch a data type is called a `bit field`.\r\nA use case for `bit fields` can be when a collection of ON/OFF flags is needed and the minimizing of memory use is desired.\r\n\r\n```c\r\n#include <stdio.h>\r\n\r\nint main() {\r\n\r\n    struct lights {\r\n        unsigned int number_of_lights;\r\n        unsigned int red   : 1;\r\n        unsigned int green : 1;\r\n        unsigned int blue  : 1;\r\n    };\r\n    struct lights lightboard = {3, 0, 0, 0};\r\n     \r\n    //  prints 000\r\n    printf(\"%d\", lightboard.red);\r\n    printf(\"%d\", lightboard.green);\r\n    printf(\"%d\\n\", lightboard.blue);\r\n    \r\n    lightboard.green = 1;\r\n\r\n    //  prints 010\r\n    printf(\"%d\", lightboard.red);\r\n    printf(\"%d\", lightboard.green);\r\n    printf(\"%d\\n\", lightboard.blue);\r\n    \r\n    // prints 3\r\n    printf(\"%d\\n\", lightboard.number_of_lights);\r\n}\r\n```\r\n\r\nThe syntax of `unsigned int variable_name : 1;` creates a field of `1` bit within an `unsigned int` placed within the struct.\r\nInstead of an `unsigned int`, a `signed int` could be used, or, as of C99 or later, a `bool` type could be used.\r\nA struct containing bit fields can also contain fields of other data types, such as `number_of_lights` in the above example.\r\n"
  },
  "meta": {},
  "links": []
}