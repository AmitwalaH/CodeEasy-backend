{
  "language": "c",
  "slug": "pointers",
  "title": "Pointers",
  "docs": {
    "about": "# About\r\n\r\nA pointer is a variable or constant whose value is the address of another variable or constant.\r\nPointers are a powerful and potentially dangerous feature of C.\r\nIt can be challenging to understand pointers.\r\n\r\n```c\r\nint i = 5;\r\n```\r\n\r\nWhen we assign a value to a variable we can then ask two questions.\r\n\r\nWho are you?\r\n\r\n_I am `i`_.\r\n\r\nWhat do you have?\r\n\r\n_I have the integer `5`_.\r\n\r\nThere is also a third question we can ask.\r\n\r\nWhere are you?\r\n\r\n_I am at `0x6dfed4`_.\r\n\r\nWait, what?\r\n\r\nVariables and constants store their value in a memory location.\r\nThat location in memory is known as the address of the variable or constant.\r\n\r\n## Address operator, and Indirection operator (part 1)\r\n\r\nTo get the address of a variable we use the address operator, which is `&`.\r\n```c\r\nint i = 5;\r\nint *i_address = &i;\r\n```\r\n\r\nWait, what does that `*` mean before `i_address`? Doesn't that mean multiply?\r\n\r\nA type followed by a `*` followed by an identifier is the way to declare a pointer to a variable of that type.\r\nThe `*` is known as the indirection operator because it indirectly refers to the value for which the pointer holds the address.\r\n\r\nOkay, but why make a variable just to hold the address of another variable? \r\n\r\nWhy do we care what the address of a variable is in the first place?\r\n\r\nWell, we care where variables are when they are in an array.\r\n\r\n## Arrays and Pointers\r\n\r\nWhen we create an array like so\r\n\r\n```c\r\nint my_ints[] = {1, 2};\r\n```\r\n\r\nThe value of `my_ints` is actually its address, which also happens to be the same as the address of its first element.\r\nThe address of its second element will be the first element's address plus the size of an `int` on the system.\r\n\r\nTo better see this, try running the following\r\n\r\n```c\r\n#include <stdio.h>\r\n\r\nint main() {\r\n    // my_int's value is its address\r\n    int my_ints[] = {1, 2};\r\n    \r\n    // since my_ints is already an address\r\n    // we don't need the address operator to make a pointer from it.\r\n    // a pointer to my_ints holds the address of my_ints\r\n    int *my_ptr = my_ints;\r\n    \r\n    // the address of my_ints and the value of my_ptr are the same\r\n    printf(\"my_ints is %p. my_ptr is %p.\\n\", my_ints, my_ptr);\r\n    \r\n    // the address of the first element is the same as the values in the line above\r\n    printf(\"&my_ints[0] is %p. my_ptr + 0 is %p.\\n\", &my_ints[0], my_ptr + 0);\r\n    \r\n    // the address of the second element has increased by the size of an int\r\n    printf(\"&my_ints[1] is %p. my_ptr + 1 is %p.\\n\", &my_ints[1], my_ptr + 1); // \r\n    \r\n    return 0;\r\n}\r\n```\r\n\r\n## Pointer Arithmetic, or Why Array Indexes begin at 0\r\n\r\nThe previous example shows why array indexing begins at `0` instead of `1`.\r\nThe index into an array multiplies the index by the size of the type and adds it to the starting address of the array.\r\nSince the first element aligns with the beginning of the array, we multiply the type by `0` for adding to the start address to get the first element.\r\nTo get the second element we multiply the type by `1` for adding to the start address.\r\nIf the type is four bytes in length, the address of the second element will be four bytes higher than the first element.\r\n\r\nThis is also why pointers are declared to be of a certain type.\r\nIf a pointer did not know what type it points to, it would not know how many bytes to advance when adding `1` to it.\r\nAdding `1` to a pointer does not necessarily mean we're adding one byte to the address.\r\nIt means we're adding `1` times the length of its type in bytes.\r\n\r\nBut wait, there's more! You didn't think we were finished with `*`, did you?\r\n\r\n## Indirection Operator (part 2)\r\n\r\nNow that we understand how addresses work with array indexing, what good is it if we don't get the value stored at an address?\r\nHow do we do that?\r\nTo get the value stored at an address we use the indirection operator, which, you may recall, is `*`.\r\nIn this situation the indirection operator is also sometimes referred to as the dereference operator, because it dereferences the value for which the pointer has the address.\r\nCalling it the dereference operator when used for dereferencing distinguishes it from the indirection operator for defining a pointer, but `*` for both uses is technically named the indirection operator.\r\n\r\nCome on!\r\nAre you kidding me?\r\nHow many uses are there for `*`?!\r\nMultiplication, declaring a pointer, and now dereferencing!\r\nIt's confusing!\r\nAnd what exactly is dereferencing, anyway?\r\n\r\nAn example shows how to use the indirection operator for dereferencing\r\n\r\n```c\r\n#include <stdio.h>\r\n\r\nint main() {\r\n    // define the variable\r\n    int my_ints[] = {1, 2};\r\n    \r\n    // define the pointer from the address of the variable\r\n    int *my_ptr = my_ints;\r\n    \r\n    // prints: my_ints[0] is 1. *(my_ptr + 0) is 1.\r\n    printf(\"my_ints[0] is %u. *(my_ptr + 0) is %u.\\n\", my_ints[0], *(my_ptr + 0));\r\n    \r\n    // prints: my_ints[1] is 2. *(my_ptr + 1) is 2.\r\n    printf(\"my_ints[1] is %u. *(my_ptr + 1) is %u.\\n\", my_ints[1], *(my_ptr + 1));\r\n    \r\n    return 0;\r\n}\r\n```\r\n\r\nUsing parentheses can help remove ambiguity of intentions when using pointer arithmetic.\r\nThe following example may not print what the programmer intended to\r\n\r\n```c\r\n#include <stdio.h>\r\n\r\nint main() {\r\n    int my_ints[] = {1, 42};\r\n    int *my_ptr = my_ints;\r\n    \r\n    // prints: my_ints[0] is 1. *++my_ptr is 42.\r\n    printf(\"my_ints[0] is %u. *++my_ptr is %u.\\n\", my_ints[0], *++my_ptr);\r\n    \r\n    // prints: my_ints[1] is 43. ++*my_ptr++ is 43.\r\n    printf(\"my_ints[1] is %u. ++*my_ptr++ is %u.\\n\", my_ints[1], ++*my_ptr);\r\n\r\n    return 0;\r\n}\r\n```\r\n\r\nBoth the `*` and `++` have the same precedence, but they evaluate from right to left.\r\nIn the first line `my_ptr` is first incremented to the second element, which is then dereferenced.\r\nIn the second line `my_ptr`, which was incremented to the second element in the first line, is first dereferenced, and then the dereferenced value is incremented.\r\nIf we add this line to the above example\r\n\r\n```c\r\n// prints: my_ints[1] is 43. *++my_ptr is (some garbage value).\r\nprintf(\"my_ints[1] is %u. *++my_ptr is %u.\\n\", my_ints[1], *++my_ptr);\r\n```\r\n\r\nIn that line we have incremented the pointer to be beyond the array.\r\nWe have overrun the array and we are pointing at the next four bytes in memory which the pointer interprets as an `int`, but, in fact, those bytes could belong to another variable or variables.\r\nThose four bytes could  be part of a `double` or they could be four `char`s.\r\nThe problem is we shouldn't even be looking at them with our pointer.\r\n\r\nWe could have used\r\n\r\n```c\r\n// prints: my_ints[2] is (some garbage value).\r\nprintf(\"my_ints[2] is %u\", my_ints[2]);\r\n```\r\n\r\nSince array indexing is implemented with a pointer, the same danger of over-running the array applies.\r\n\r\nAnd, since a string is an array of `char`s, pointers can be used with strings, too.\r\nA string is often declared using pointer syntax, like so\r\n\r\n```c\r\nchar *my_string = \"This is my string\";\r\n// instead of\r\n// char my_string[] = \"This is my string\";\r\n```\r\n\r\nOne question, though.\r\nWhy do we put the star next to the identifier?\r\nWhy not put it next to the type, since it's a pointer to that type?\r\nBecause this\r\n\r\n```c\r\nint* my_ptr1, my_ptr2_that_is_really_an_int;\r\n```\r\n\r\ndoes not declare two pointers to an `int`, but declares a pointer to an `int`, and an `int`.\r\nTo declare two pointers to an `int` would be like so\r\n\r\n```c\r\nint *my_ptr1, *my_ptr2;\r\n```\r\n\r\nSo it's good to put the `*` near the identifier to minimize ambiguity.\r\nOr declare only one identifier per line.\r\nAnd, if you haven't had enough of `*`, welcome to...\r\n\r\n## Pointer to Pointers\r\n\r\nIt is common to see arrays of strings represented like so\r\n\r\n```c\r\n#include <stdio.h>\r\n\r\nvoid print_strings(char **passed_in_strings) {\r\n    printf(\"%s\\n\", *passed_in_strings);\r\n    printf(\"%s\\n\", *(passed_in_strings + 1));\r\n}\r\n\r\nint main() {\r\n    char *my_strings[] = {\"One string\", \"Two string\"};\r\n    print_strings(my_strings);\r\n    return 0;\r\n}\r\n```\r\n\r\nIt may not be obvious, but the array of strings is declared and initialized as a pointer to an array of `char` arrays.\r\nWhen the array of `char` arrays is passed into `print_strings()`, the signature describes it as a pointer to pointer(s) to `char`.\r\n\r\nSo how do we know that `char **` is really a pointer to an array of pointers to `char` arrays, and not a pointer to a pointer of a single `char`?\r\n\r\nWe don't.\r\n\r\nThis is one of the may things that can make using pointers confusing.\r\nThe following may compile\r\n\r\n```c\r\n#include <stdio.h>\r\n\r\nvoid print_strings(char **passed_in_strings) {\r\n    // prints: A (followed by gibberish)\r\n    printf(\"%s\\n\", *passed_in_strings);\r\n    // prints gibberish\r\n    printf(\"%s\\n\", *(passed_in_strings + 1));\r\n}\r\n\r\nint main() {\r\n    char my_char = 'A';\r\n    char *my_ptr = &my_char;\r\n    char **my_ptr_to_ptr = &my_ptr;\r\n    print_strings(my_ptr_to_ptr);\r\n    return 0;\r\n}\r\n```\r\n\r\nBut `print_strings()` is not being used as intended.\r\nUsing a different signature doesn't help. Changing the signature to this\r\n\r\n```c\r\nvoid print_strings(char *passed_in_strings[]) {\r\n    // code snipped\r\n}\r\n```\r\n\r\nmay still compile and still print gibberish.\r\nBut there is really no value to passing in a pointer to a pointer to a single `char`.\r\nChances are, when you see `char **`, it represents a pointer to an array of pointers to `char` arrays.\r\n\r\nWe've seen a pointer passed into a function.\r\nBut why pass a pointer into a function?\r\n\r\n## Passing a Pointer to a Function\r\n\r\nIn C, arguments are passed to functions by value. \r\nThat means that the value is copied from the argument and that copy is local to the function.\r\nWhen the function ends, so does the copied value.\r\n\r\nSee what happens when we try to change values inside a function\r\n\r\n```c\r\n#include <stdio.h>\r\n\r\nvoid swap(int a, int b) {\r\n    int temp = a;\r\n    a = b;\r\n    b = temp;\r\n    //prints:  In 'swap', a is 4 and b is 3.\r\n    printf(\"In 'swap', a is %d and b is %d.\\n\", a, b);\r\n}\r\n\r\nint main() {\r\n    int a = 3, b = 4;\r\n    swap(a, b);\r\n    // prints: After 'swap', a is 3 and b is 4\r\n    printf(\"After 'swap', a is %d and b is %d.\\n\", a, b);\r\n    return 0;\r\n}\r\n```\r\n\r\nThis is because, even though the variables have the same names, `a` and `b` in `swap()` are not the same `a` and `b` in `main()`.\r\nThey are _copies_ of the values of `a` and `b`.\r\nCan we change `swap` to make it work as we intend?\r\n\r\nYes we can!\r\nWe can pass in the addresses of `a` and `b` as pointers.\r\nBut, what good will that do, since the function copies the pointers?\r\nIt is good, because a copied address is still the same address.\r\nBy dereferencing the address we can get access to the original value as it was defined in `main()`.\r\n\r\n```c\r\n#include <stdio.h>\r\n\r\n// pass in pointers to a and b\r\nvoid swap(int *a, int *b) {\r\n    // set temp to value at a's dereferenced address\r\n    int temp = *a;\r\n\r\n    // set a's value to value at b's dereferenced address\r\n    *a = *b;\r\n\r\n    // set b's value to temp\r\n    *b = temp;\r\n\r\n    // prints: In 'swap', a is 4 and b is 3.\r\n    printf(\"In 'swap', a is %d and b is %d.\\n\", *a, *b);\r\n}\r\n\r\nint main() {\r\n    int a = 3, b = 4;\r\n    swap(&a, &b);\r\n    // prints: After 'swap', a is 4 and b is 3.\r\n    printf(\"After 'swap', a is %d and b is %d.\\n\", a, b);\r\n    return 0;\r\n}\r\n```\r\n\r\nThat's a lot of `*`s in `swap` now, but it now works as intended.\r\n\r\nA way to read the indirection operator is \"value at\".\r\nSo, `*a` is the value at `a`.\r\nHow well does this work with strings?\r\n\r\n## Pointers to Char\r\n\r\nWe know that the value of an array variable is the address where the array starts.\r\nAnd we know we can define a string as either a `char` array, `char my_string[]`, or as a pointer to `char`, `char *`.\r\nHow are they different?\r\n\r\nIn this code we pass a `char *` argument to `describe_me()`.\r\nThe `adjective` argument is defined as a `char` array and is accepted by the function as a pointer to `char`.\r\n\r\n```c\r\n#include <stdio.h>\r\n#include <string.h>\r\n\r\n// takes pointer to char\r\nvoid describe_me(char *adjective){\r\n    strcpy(adjective, \"evil\");\r\n    // prints: I am evil.\r\n    printf(\"I am %s.\\n\", adjective);\r\n}\r\n\r\nint main() {\r\n    // defined as a char array\r\n    char adjective[] = \"good\";\r\n    describe_me(adjective);\r\n    // prints: I am really evil.\r\n    printf(\"I am really %s.\\n\", adjective);\r\n    \r\n    return 0;\r\n}\r\n```\r\n\r\nWe are able to make a persistent change to `adjective`, demonstrating that the defined `char` array can be accepted as a pointer to `char`.\r\n\r\nNow let's try defining `adjective` as a pointer to `char` directly.\r\n\r\n```c\r\n#include <stdio.h>\r\n#include <string.h>\r\n\r\nvoid describe_me(char *adjective){\r\n    // segmentation fault on this line when program is executed\r\n    strcpy(adjective, \"evil\");\r\n    printf(\"I am %s.\\n\", adjective);\r\n}\r\n\r\nint main() {\r\n    char *adjective = \"good\";\r\n    describe_me(adjective);\r\n    printf(\"I am really %s.\\n\", adjective);\r\n    \r\n    return 0;\r\n}\r\n```\r\n\r\nRemember how pointers are powerful, but also potentially dangerous?\r\nBut why doesn't it work?\r\nAn array is a pointer and a pointer worked with a `char` array!\r\nThe reason is that, before, `adjective` was defined as a `char` array which is a variable belonging to `main()`.\r\nNow, `adjective` is defined as a string _literal_, meaning that the `chars` are written to read-only static memory which belongs to the entire program.\r\nThey are both pointers, but they point to different things.\r\nTrying to change a literal string value is like trying to change the literal value of `5`.\r\nIt is not allowed.\r\nSo, the problem isn't really that it's a pointer.\r\nThe problem is what it is pointing to.\r\n",
    "introduction": "## Introduction\r\n\r\nA pointer is a variable or constant whose value is the address of another variable or constant.\r\nPointers are a powerful and potentially dangerous feature of C.\r\nIt can be challenging to understand pointers.\r\n\r\nVariables and constants store their value in a memory location.\r\nThat location in memory is known as the address of the variable or constant.\r\n\r\nTo get the address of a variable we use the address operator, which is `&`.\r\n```c\r\nint i = 5;\r\nint *i_address = &i;\r\n```\r\n\r\nA type followed by a `*` followed by an identifier is the way to declare a pointer to a variable of that type.\r\nThe `*` is known as the indirection operator because it indirectly refers to the value for which the pointer holds the address.\r\n\r\nWhen we create an array like so\r\n\r\n```c\r\nint my_ints[] = {1, 2};\r\n```\r\n\r\nThe value of `my_ints` is actually its address, which also happens to be the same as the address of its first element.\r\nThe address of its second element will be the first element's address plus the size of an `int` on the system.\r\n\r\nThis is why pointers are declared to be of a certain type.\r\nIf a pointer did not know what type it points to, it would not know how many bytes to advance when adding `1` to it.\r\nAdding `1` to a pointer does not necessariy mean we're adding one byte to the address.\r\nIt means we're adding `1` times the length of its type in bytes.\r\n"
  },
  "meta": {},
  "links": []
}