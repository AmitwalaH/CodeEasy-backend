{
  "language": "c",
  "slug": "dynamic-memory-management",
  "title": "Dynamic Memory Management",
  "docs": {
    "about": "# About\r\n\r\nDynamic memory is implemented by library functions which the programmer uses to allocate and deallocate memory at runtime.\r\nSince the programmer controls the allocation and deallocation of memory, dynamic memory is as safe as the programmer is free from human error.\r\nFor that reason, dynamic memory is one of the  major sources for programming bugs and a major target for hacking attacks.\r\n\r\nDynamic memory is used for variables whose size is only known at runtime.\r\nThis is commonly useful for arrays whose number of elements may vary between one runtime and the next.\r\nVariable length arrays (VLA) are another way to handle arrays whose element size is known only at runtime.\r\nA VLA uses automatic storage, which means its memory is destroyed on leaving its defining block.\r\n(For more on storage, please see the [storage class specifiers](https://github.com/exercism/c/tree/main/concepts/storage-class-specifiers) concept.)\r\nVLAs were brought into the C language by C99, but as of C11 VLAs are optional, so compilers supporting C11 onward do not have to support VLAs.\r\nA detailed analysis of variable length arrays is outside the scope of this article.\r\n\r\n## malloc\r\n\r\n`malloc` is a function declared in `stdlib.h` which is used for allocating dynamic memory.\r\nIf the allocation is successful, a pointer is returned which points to the address of the first byte of the allocated memory.\r\nIf the allocation is not successful, `NULL` is returned.\r\nIt is prudent to check the result of `malloc` for `NULL` and gracefully handle it if it fails.\r\nThe pointer returned is of type `pointer-to-void` which can roughly be considered as a \"generic\" pointer that can be converted to the specific type used by the memory.\r\n`malloc` has one parameter, which is the size of the desired memory in bytes.\r\nThe total size for allocating an array is the size of each element's data type multiplied by the number of elements.\r\nThe `sizeof` operator is commonly used to get the size of each element's data type.\r\nThe following example demonstrates this\r\n\r\n```c\r\n#include <stdio.h>\r\n#include <stdlib.h>\r\n\r\nint * my_function(int count) {\r\n    // pointer-to-void from malloc is converted to a pointer-to-int\r\n    int * numbers = malloc(sizeof(int) * count);\r\n    return numbers;\r\n}\r\n\r\nint main() {\r\n    int * numbers = my_function(3);\r\n    if (!numbers) return -1;\r\n    // printed The size of numbers is 8 bytes (can vary by system)\r\n    printf(\"The size of numbers is %zu bytes\\n\", sizeof(numbers));\r\n    numbers[0] = 1;\r\n    numbers[1] = 2;\r\n    numbers[2] = 3;\r\n    // prints The first element of the array is 1\r\n    printf(\"The first element of the array is %d\\n\", numbers[0]);\r\n    // prints The second element of the array is 2\r\n    printf(\"The second element of the array is %d\\n\", numbers[1]);\r\n    // prints The third element of the array is 3\r\n    printf(\"The third element of the array is %d\\n\", numbers[2]);\r\n    free(numbers);\r\n    numbers = NULL;\r\n}\r\n```\r\n\r\nIt's important to remember that the memory newly allocated by `malloc` is not initialized but may hold garbage values.\r\nNote that the `sizeof` the `numbers` pointer is not the number of the array's elements, nor the total amount of memory allocated.\r\nThe size of the pointer returned by `malloc` is the size of any pointer on that particular system.\r\nThe example code was run on a 64-bit system, so the size of the pointer was 8 byes (multiplied by 8 bits per byte = 64 bits.)\r\nThe pointer type was implicitly converted from pointer-to-void to pointer-to-int.\r\nWhether the pointer-to-int points to a single `int` or to an array of `ints` is something the programmer can deal with as seen fit.\r\nFor example\r\n\r\n```c\r\n#include <stdio.h>\r\n#include <stdlib.h>\r\n\r\nint * my_function(int count) {\r\n    int * numbers = malloc(sizeof(int) * count);\r\n    return numbers;\r\n}\r\n\r\nint main() {\r\n    int * numbers = my_function(1);\r\n    if (!numbers) return -1;\r\n    // treat numbers as a single value\r\n    *numbers = 1;\r\n    // prints numbers is 1\r\n    printf(\"numbers is %d\\n\", *numbers);\r\n    // treat numbers as an array\r\n    // prints The first element of the array is 1\r\n    printf(\"The first element of the array is %d\\n\", numbers[0]);\r\n    numbers[0] = 2;\r\n    // prints The first element of the array is 2\r\n    printf(\"The first element of the array is %d\\n\", numbers[0]);\r\n    // treat numbers as a single value again\r\n    // prints numbers is 2\r\n    printf(\"numbers is %d\\n\", *numbers);    \r\n    free(numbers);\r\n    numbers = NULL;    \r\n}\r\n```\r\n\r\nIf the value(s) will definitely be written to before being read, then to use `malloc` can be an efficient way to allocate memory.\r\nBut, if there is a chance the value(s) will be read before being intialized, then to use `malloc` is risky.\r\nA safer way to allocate memory is to use `calloc`, which initializes the newly allocated memory to zero.\r\n\r\nNote in the examples above that `free(numbers)` was used.\r\n\r\n## free\r\n\r\n`free` is a function declared in `stdlib.h` which is used for deallocating memory which has been dynamically allocated.\r\nDynamically allocated memory stays claimed in memory until released by `free`.\r\nSome operating systems may automatically free dynamically allocated memory when the program finishes, but it is best practice not to depend on that.\r\n`free` has one parameter, which is a pointer to the memory which was dynamically allocated.\r\nThe use or lack of use of `free` is associated with several memory issues.\r\n\r\n#### memory leak\r\n\r\nNot freeing dynamically allocated memory after the reference to that memory reaches the end of its lifetime, or is otherwise destroyed, is referred to as a memory leak.\r\nLeaked memory is memory which is claimed by the system but is no longer accessible by the program.\r\nThis can be a particular problem if memory is allocated in a loop, not freed at the end of the loop, and allocated again at the beginning of the loop.\r\nIf enough memory is allocated without being freed, the call to allocate memory will fail due to insufficient memory remaining to allocate.\r\nIt's important to remember that, although dynamically allocated memory is claimed by the system until freed, the pointer it is assigned to may only have block scope.\r\nFor instance, in the `malloc` examples, memory is allocated in `my_function`.\r\nThat memory would be leaked if the pointer to it were not returned and used to set the `numbers` pointer in `main`.\r\nThus, passing that `numbers` pointer to `free` releases the memory allocated in `my_function`.\r\n\r\n#### use after free (**UAF**)\r\n\r\nIf memory is accessed after it is freed, the value(s) could be anything.\r\nIn the following example, the memory pointed to by `numbers` is freed and then is read from in `printf`.\r\n\r\n```c\r\n#include <stdio.h>\r\n#include <stdlib.h>\r\n\r\nint * my_function(int count) {\r\n    // pointer-to-void from malloc is converted to a pointer-to-int\r\n    int * numbers = (int *) malloc(sizeof(int) * count);\r\n    return numbers;\r\n}\r\n\r\nint main() {\r\n    int * numbers = my_function(1);\r\n    if (!numbers) return -1;\r\n    *numbers = 1;\r\n    // prints numbers is 1\r\n    printf(\"numbers is %d\\n\", *numbers);\r\n    free(numbers);\r\n    // could  print anything, e.g.\r\n    // The first element of the array is 18178656\r\n    printf(\"The first element of the array is %d\\n\", numbers[0]);\r\n}\r\n```\r\n\r\nThe `numbers` pointer, after it has been freed, is referred to as a dangling pointer.\r\nA dangling pointer can refer to other memory than that for which it was intended.\r\nThus, a dangling pointer can lead to data corruption and arbitrary code substitution and execution.\r\nA pointer to allocated memory which has not been cleared by setting to `NULL` can be used to hack the program.\r\nIn the above example, if `numbers` was set to `NULL` like so: `numbers = NULL;` after being freed, the following `printf` would result in program termination, perhaps reporting a segmentation fault when attempting to read `numbers[0]`.\r\n\r\n#### double free\r\n\r\nIf `free` is called twice on a pointer to dynamically allocated memory, it results in undefined behavior (**UB**.)\r\nThis means the compiler can arbitrarily handle it any way it wants to.\r\nThe following example, compiled with two different compilers, can have two different outcomes\r\n\r\n```c\r\n#include <stdio.h>\r\n#include <stdlib.h>\r\n\r\nint * my_function(int count) {\r\n    // pointer-to-void from malloc is converted to a pointer-to-int\r\n    int * numbers = malloc(sizeof(int) * count);\r\n    return numbers;\r\n}\r\n\r\nint main() {\r\n    int * numbers = my_function(1);\r\n    if (!numbers) return -1;\r\n    *numbers = 1;\r\n    // prints numbers is 1\r\n    printf(\"numbers is %d\\n\", *numbers);\r\n    free(numbers);\r\n    // numbers = NULL;\r\n    // first compiler generates runtime error: double free detected in tcache 2\r\n    // second compiler generates no error\r\n    free(numbers);\r\n}\r\n```\r\n\r\nThe first and second compiler generated no runtime error when `numbers` was set to `NULL` between each call to `free`, but that would not be guaranteed to work with a third compiler.\r\nA common source of double free is to have two pointers which point at the same dynamically allocated memory.\r\nOne pointer may point at the beginning of an array at one place in the program, and the other pointer may be used to step though the array at another place in the program.\r\nAt different places in the program, each pointer is freed, thus causing a double free.\r\n\r\n## calloc\r\n\r\n`calloc` is a function declared in `stdlib.h` which is used for both allocating dynamic memory and initializing the newly allocated memory to zero.\r\nIf the allocation is successful, a pointer is returned which points to the address of the first byte of the allocated memory.\r\nIf the allocation is not successful, `NULL` is returned.\r\nIt is prudent to check the result of `calloc` for `NULL` and gracefully handle it if it fails.\r\nThe pointer returned is of type `pointer-to-void` which can roughly be considered as a \"generic\" pointer that can be converted to the specific type used by the memory.\r\n`calloc` has two parameters.\r\nThe first parameter is for how many of the specified data type is to be allocated.\r\nThe second parameter is for the size of the specified data type to be allocated.\r\n\r\nIn the following example all of the `printf` statements should always show `0`, since `calloc` is guaranteed to zero the newly allocated values.\r\n\r\n```c\r\n#include <stdio.h>\r\n#include <stdlib.h>\r\n\r\nint * my_function(int count) {\r\n    // allocates the amount of bytes in an int, multiplied by count\r\n    int * numbers = calloc(count, sizeof(int));\r\n    return numbers;\r\n}\r\n\r\nint main() {\r\n    int * numbers = my_function(3);\r\n    if (!numbers) return -1;\r\n    // prints The first element of the array is 0\r\n    printf(\"The first element of the array is %d\\n\", numbers[0]);\r\n    // prints The second element of the array is 0\r\n    printf(\"The second element of the array is %d\\n\", numbers[1]);\r\n    // prints The third element of the array is 0\r\n    printf(\"The third element of the array is %d\\n\", numbers[2]);\r\n    free(numbers);\r\n    numbers = NULL;\r\n}\r\n```\r\n\r\n## realloc\r\n\r\n`realloc` is a function declared in `stdlib.h` which is used for either expanding or shrinking existing allocated memory.\r\nIf the reallocation is successful, a pointer is returned which points to the address of the first byte of the reallocated memory.\r\nIf the reallocation is not successful, `NULL` is returned.\r\nIt is prudent to check the result of `realloc` for `NULL` and gracefully handle it if it fails.\r\n`realloc` has two parameters.\r\nThe first parameter is a pointer to the existing memory to be reallocated.\r\nThe second parameter is for the size in bytes of the reallocated memory.\r\nValues that were set before memory is expanded are retained.\r\nIt is important to remember that memory added when expanding memory is not initialized to zero and its value(s) could be anything.\r\nAlso, memory which is removed when shrinking memory is also not initialized and could retain the value(s).\r\nThe following example demonstrates expanding and shrinking an array\r\n\r\n```c\r\n#include <stdio.h>\r\n#include <stdlib.h>\r\n\r\nint * my_function(int count) {\r\n    // allocates the amount of bytes in an int, multiplied by count\r\n    int * numbers = calloc(count, sizeof(int));\r\n    return numbers;\r\n}\r\n\r\nint * my_function_2 (int * ptr , int count) {\r\n    // reallocates the memory to the size of an int multiplied by count\r\n    int * numbers = realloc(ptr, sizeof(int) * count);\r\n    // if realloc fails, exit the program\r\n    if (!numbers) exit(-1);\r\n    return numbers;\r\n}\r\n\r\nint main() {\r\n    int * numbers = my_function(3);\r\n    if (!numbers) return -1;\r\n    numbers[0] = 1;\r\n    numbers[1] = 2;\r\n    numbers[2] = 3;\r\n    // expand the size of the array\r\n    numbers = my_function_2(numbers, 6);\r\n    // prints The first element of the array is 1\r\n    printf(\"The first element of the array is %d\\n\", numbers[0]);\r\n    // prints The sixth element of the array is [whatever is there]\r\n    // the additional memory is not initialized, so it could be\r\n    // 0 or it could be 18728 or anything else\r\n    printf(\"The sixth element of the array is %d\\n\", numbers[5]);\r\n    numbers[5] = 6;\r\n    // shrink the size of the array\r\n    numbers = my_function_2(numbers, 3);\r\n    // prints The sixth element of the array is [whatever is there]\r\n    // the removed memory is not initialized, so it could be\r\n    // 6 or it could be 43164 or anything else\r\n    printf(\"The sixth element of the array is %d\\n\", numbers[5]);\r\n    free(numbers);\r\n}\r\n```\r\n\r\n## When the size passed is 0\r\n\r\nIf the size passed to `malloc`, `calloc`, or `relloac` is `0`, then what happens depends on how the compiler implements it.\r\nA compiler may either return a `NULL` pointer or a non-null pointer.\r\nFor example, if allocating memory for a pointer to `char`, the compiler may return either `NULL` or a non-null pointer to an empty string.\r\nTo avoid differing results with differing compilers it is best to not allocate with a size of 0.\r\n",
    "introduction": "# Introduction\r\n\r\nDynamic memory is implemented by library functions which the programmer uses to allocate and deallocate memory at runtime.\r\nSince the programmer controls the allocation and deallocation of memory, dynamic memory is as safe as the programmer is free from human error.\r\nFor that reason, dynamic memory is one of the  major sources for programming bugs and a major target for hacking attacks.\r\n\r\n## malloc\r\n\r\n`malloc` is a function declared in `stdlib.h` which is used for allocating dynamic memory.\r\nIf the allocation is successful, a pointer is returned which points to the address of the first byte of the allocated memory.\r\nIf the allocation is not successful, `NULL` is returned.\r\nIt is prudent to check the result of `malloc` for `NULL` and gracefully handle it if it fails.\r\nThe pointer returned is of type `pointer-to-void` which can roughly be considered as a \"generic\" pointer that can be converted to the specific type used by the memory.\r\n`malloc` has one parameter, which is the size of the desired memory in bytes.\r\nThe total size for allocating an array is the size of each element's data type multiplied by the number of elements.\r\nThe `sizeof` operator is commonly used to get the size of each element's data type.\r\nThe following example demonstrates this\r\n\r\n```c\r\n#include <stdio.h>\r\n#include <stdlib.h>\r\n\r\nint * my_function(int count) {\r\n    // pointer-to-void from malloc is converted to a pointer-to-int\r\n    int * numbers = malloc(sizeof(int) * count);\r\n    return numbers;\r\n}\r\n\r\nint main() {\r\n    int * numbers = my_function(3);\r\n    if (!numbers) return -1;\r\n    // printed The size of numbers is 8 bytes (can vary by system)\r\n    printf(\"The size of numbers is %zu bytes\\n\", sizeof(numbers));\r\n    numbers[0] = 1;\r\n    numbers[1] = 2;\r\n    numbers[2] = 3;\r\n    // prints The first element of the array is 1\r\n    printf(\"The first element of the array is %d\\n\", numbers[0]);\r\n    // prints The second element of the array is 2\r\n    printf(\"The second element of the array is %d\\n\", numbers[1]);\r\n    // prints The third element of the array is 3\r\n    printf(\"The third element of the array is %d\\n\", numbers[2]);\r\n    free(numbers);\r\n    numbers = NULL;\r\n}\r\n```\r\n\r\nIt's important to remember that the memory newly allocated by `malloc` is not initialized but may hold garbage values.\r\nNote that the `sizeof` the `numbers` pointer is not the number of the array's elements, nor the total amount of memory allocated.\r\nThe size of the pointer returned by `malloc` is the size of any pointer on that particular system.\r\nThe example code was run on a 64-bit system, so the size of the pointer was 8 byes (multiplied by 8 bits per byte = 64 bits.)\r\nThe pointer type was implicitly converted from pointer-to-void to pointer-to-int.\r\nIt could also have been explicitly converted like so : `int * numbers = (int *) malloc(sizeof(int) * count);`.\r\nIf the value(s) will definitely be written to before being read, then to use `malloc` can be an efficient way to allocate memory.\r\nBut, if there is a chance the value(s) will be read before being intialized, then to use `malloc` is risky.\r\nA safer way to allocate memory is to use `calloc`, which initializes the newly allocated memory to zero.\r\n\r\nNote in the examples above that `free(numbers)` was used.\r\n\r\n## free\r\n\r\n`free` is a function declared in `stdlib.h` which is used for deallocating memory which has been dynamically allocated.\r\nDynamically allocated memory stays claimed in memory until released by `free`.\r\nSome operating systems may automatically free dynamically allocated memory when the program finishes, but it is best practice not to depend on that.\r\n`free` has one parameter, which is a pointer to the memory which was dynamically allocated.\r\nA pointer which is not set to `NULL` after it has been freed is referred to as a dangling pointer.\r\nA dangling pointer can refer to other memory than that for which it was intended.\r\nThus, a dangling pointer can lead to data corruption and arbitrary code substitution and execution.\r\nA pointer to allocated memory which has not been cleared by setting to `NULL` can be used to hack the program.\r\nIt is best practice to set a pointer to `NULL` after it has been passed to `free`.\r\n\r\n## calloc\r\n\r\n`calloc` is a function declared in `stdlib.h` which is used for both allocating dynamic memory and initializing the newly allocated memory to zero.\r\nIf the allocation is successful, a pointer is returned which points to the address of the first byte of the allocated memory.\r\nIf the allocation is not successful, `NULL` is returned.\r\nIt is prudent to check the result of `calloc` for `NULL` and gracefully handle it if it fails.\r\nThe pointer returned is of type `pointer-to-void` which can roughly be considered as a \"generic\" pointer that can be converted to the specific type used by the memory.\r\n`calloc` has two parameters.\r\nThe first parameter is for how many of the specified data type is to be allocated.\r\nThe second parameter is for the size of the specified data type to be allocated.\r\n\r\nIn the following example all of the `printf` statements should always show `0`, since `calloc` is guaranteed to zero the newly allocated values.\r\n\r\n```c\r\n#include <stdio.h>\r\n#include <stdlib.h>\r\n\r\nint * my_function(int count) {\r\n    // allocates the amount of bytes in an int, multiplied by count\r\n    int * numbers = calloc(count, sizeof(int));\r\n    return numbers;\r\n}\r\n\r\nint main() {\r\n    int * numbers = my_function(3);\r\n    if (!numbers) return -1;\r\n    // prints The first element of the array is 0\r\n    printf(\"The first element of the array is %d\\n\", numbers[0]);\r\n    // prints The second element of the array is 0\r\n    printf(\"The second element of the array is %d\\n\", numbers[1]);\r\n    // prints The third element of the array is 0\r\n    printf(\"The third element of the array is %d\\n\", numbers[2]);\r\n    free(numbers);\r\n    numbers = NULL;\r\n}\r\n```\r\n\r\n## realloc\r\n\r\n`realloc` is a function declared in `stdlib.h` which is used for either expanding or shrinking existing allocated memory.\r\nIf the reallocation is successful, a pointer is returned which points to the address of the first byte of the reallocated memory.\r\nIf the reallocation is not successful, `NULL` is returned.\r\nIt is prudent to check the result of `realloc` for `NULL` and gracefully handle it if it fails.\r\n`realloc` has two parameters.\r\nThe first parameter is a pointer to the existing memory to be reallocated.\r\nThe second parameter is for the size in bytes of the reallocated memory.\r\nValues that were set before memory is expanded are retained.\r\nIt is important to remember that memory added when expanding memory is not initialized to zero and its value(s) could be anything.\r\nAlso, memory which is removed when shrinking memory is also not initialized and could retain the value(s).\r\nThe following example demonstrates expanding and shrinking an array\r\n\r\n```c\r\n#include <stdio.h>\r\n#include <stdlib.h>\r\n\r\nint * my_function(int count) {\r\n    // allocates the amount of bytes in an int, multiplied by count\r\n    int * numbers = calloc(count, sizeof(int));\r\n    return numbers;\r\n}\r\n\r\nint * my_function_2 (int * ptr , int count) {\r\n    // reallocates the memory to the size of an int multiplied by count\r\n    int * numbers = realloc(ptr, sizeof(int) * count);\r\n    // if realloc fails, exit the program\r\n    if (!numbers) exit(-1);\r\n    return numbers;\r\n}\r\n\r\nint main() {\r\n    int * numbers = my_function(3);\r\n    if (!numbers) return -1;\r\n    numbers[0] = 1;\r\n    numbers[1] = 2;\r\n    numbers[2] = 3;\r\n    // expand the size of the array\r\n    numbers = my_function_2(numbers, 6);\r\n    // prints The first element of the array is 1\r\n    printf(\"The first element of the array is %d\\n\", numbers[0]);\r\n    // prints The sixth element of the array is [whatever is there]\r\n    // the additional memory is not initialized, so it could be\r\n    // 0 or it could be 18728 or anything else\r\n    printf(\"The sixth element of the array is %d\\n\", numbers[5]);\r\n    numbers[5] = 6;\r\n    // shrink the size of the array\r\n    numbers = my_function_2(numbers, 3);\r\n    // prints The sixth element of the array is [whatever is there]\r\n    // the removed memory is not initialized, so it could be\r\n    // 6 or it could be 43164 or anything else\r\n    printf(\"The sixth element of the array is %d\\n\", numbers[5]);\r\n}\r\n```\r\n"
  },
  "meta": {},
  "links": []
}