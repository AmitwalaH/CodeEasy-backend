{
  "language": "c",
  "slug": "blocks",
  "title": "Blocks",
  "docs": {
    "about": "# About\r\n\r\nA block is a set of statements and declarations grouped into one syntactic unit.\r\nBlocks are often, but not always, defined within curly braces.\r\nBlocks can be nested within functions and within other blocks.\r\n\r\nIn the following example, `number` is defined within the `main` function.\r\n`flag` is defined within the `if` block which is nested within the `main` function.\r\nVariables defined within a block are only valid within that block.\r\nThus, attempting to compile the code results in a compilation error.\r\n\r\n```c\r\n#include <stdio.h>\r\n\r\nint main() {\r\n\r\n  int number = 1;\r\n\r\n  if (number == 1) {\r\n      int flag = 1;\r\n      printf(\"%d\", flag);\r\n  }\r\n\r\n  // this line generates a compilation error\r\n  // error: 'flag' undeclared (first use in this function)\r\n  printf(\"%d\", flag);\r\n    \r\n}\r\n```\r\n\r\nThe error message may be confusing, as `flag` _is_ used earlier in the function.\r\nHowever, `flag` is defined within a block inside the function.\r\nThe inner block can \"see\" the variable `number` in its outer function, but the outer function can't \"see\" the `flag` variable defined within its inner block.\r\nOnce execution leaves the block, the `flag` variable is automatically destroyed and is no longer available to the program.\r\nThe `main` function itself sees the `flag` identifier for the first time in the last `printf` statement.\r\nIf the last `printf` statement is removed, the program will compile and print `1` when run.\r\nThat is because the `flag` variable is valid in the block containing the first `printf` statement.\r\n\r\nAs of `C99`, single-line `if`, `for`, `while` and `do` statements are also considered blocks.\r\nIn the following example, although `i` is not defined within curly braces, it exists only in the block defined by the `for` statement, and is not visible to the outer `main` function.\r\n\r\n```c\r\n#include <stdio.h>\r\n\r\nint main() {\r\n\r\n    for (int i = 0, j = 11; i < j; i+=2)\r\n        printf(\"%d\", i);\r\n\r\n    // this line generates a compilation error\r\n    // error: 'i' undeclared (first use in this function)\r\n    printf(\"%d\", i);\r\n    \r\n}\r\n```\r\n\r\nIf the last `printf` statement is removed, the program will compile and print `0 2 4 6 8 10 ` when run.\r\nSome languages, such as Go and Rust, are explicit that single-line conditional and loop statements constitute a block.\r\nThey require that such single-line statements still be enclosed in curly braces.\r\n\r\nA function acts somewhat like a block.\r\nAn identifier for a variable defined in a function cannot be seen outside the function, just as an indentifier for a variable defined in a block cannot be seen outside the block.\r\nTwo variables in two functions can have the same name, since the two functions don't see into each other, just as two variables in two blocks can have the same name, since the two blocks don't see into each other.\r\nBut functions and blocks are not identical.\r\nA function cannot be defined inside another function, but a block can be nested inside another block.\r\nAnd some identifiers in a block can be seen outside the block.\r\nIn the following example, the code will not compile\r\n\r\n```c\r\n#include <stdio.h>\r\n\r\nint main() {\r\n\r\n  {\r\n      int i = 0;\r\n      begin:\r\n      printf(\"i == %d\\n\", i);\r\n      if (i == 0) {\r\n          i = 1;\r\n          goto begin;\r\n      }\r\n  }\r\n\r\n  {\r\n      int i = 1;\r\n      begin:\r\n      printf(\"i == %d\\n\", i);\r\n      if (i == 1) {\r\n          i = 0;\r\n          goto begin;\r\n      }\r\n  }\r\n\r\n}\r\n```\r\n\r\nThe code above fails to compile with the following error\r\n\r\n```\r\n/tmp/gH2TVYnTSJ.c: In function 'main':\r\n/tmp/gH2TVYnTSJ.c:17:5: error: duplicate label 'begin'\r\n   17 |     begin:\r\n      |     ^~~~~\r\n/tmp/gH2TVYnTSJ.c:7:5: note: previous definition of 'begin' was here\r\n    7 |     begin:\r\n      |     ^~~~~\r\n```\r\n\r\nAlthough `i` can be defined in each block, `label` names must be unique in a function.\r\nThat is because `labels` have function scope, meaning each label is seen by the function no matter where in the function it is defined.\r\nSo, unlike variables, no matter where a `label` is defined in a function it must have a unique name within that same function.\r\nTo make the code work requires changing the name of one of the `labels` so they are both unique, as in the following example\r\n\r\n```c\r\n#include <stdio.h>\r\n\r\nint main() {\r\n\r\n    {\r\n        int i = 0;\r\n        begin:\r\n        // prints\r\n        // i == 0\r\n        // i == 1\r\n        printf(\"i == %d\\n\", i);\r\n        if (i == 0) {\r\n            i = 1;\r\n            goto begin;\r\n        }\r\n    }\r\n\r\n    {\r\n        int i = 1;\r\n        start:\r\n        // prints\r\n        // i == 1\r\n        // i == 0    \r\n        printf(\"i == %d\\n\", i);\r\n        if (i == 1) {\r\n            i = 0;\r\n            goto start;\r\n        }\r\n    }\r\n\r\n}\r\n```\r\n\r\nSingle-line statements can be \"stacked\" and still be within one block without the use of curly braces.\r\nIn the example below, the `for` statement contains an `if` statement which in turn contains a `printf` statement.\r\nAlthough there are two total statements in the `for` block, only its single-line `if` statement is evaluated as the body of the `for` loop.\r\nThe `if` statement's single-line `printf` statement in turn is evaluated as its body.\r\nIf nested blocks are each only a single line, none of the blocks need curly braces.\r\nNote that the comment does not require curly braces for enclosing it and the `printf` statement within the `if` block, since the comment is not a statement.\r\nThe indentation makes it clear what's happening, but a development team may have have its own coding guidelines about placing curly braces in such situations to remove any kind of ambiguity.\r\n\r\n```c\r\n#include <stdio.h>\r\n\r\nint main() {\r\n\r\n    for (int i = 0, j = 11; i < j; i++)\r\n        if (i & 1 == 1)\r\n            // prints 1 3 5 7 9 \r\n            printf(\"%d \", i);\r\n}\r\n```\r\n\r\nWe've seen that values defined within a block cannot be accessed from outside of the block.\r\nAnd we've seen that values defined outside of a block can usually be accessed from within the block.\r\nIt is possible for a variable outside of a block to be hidden inside a block if the identifier for that variable is used in defining a block variable.\r\nIn the following example, the `number` identifier is used for both a function-level variable and a block-level variable.\r\nWe say that the block-level variable hides or _shadows_ the function-level variable.\r\n\r\n```c\r\n#include <stdio.h>\r\n\r\nint main() {\r\n    int number = 1;\r\n    // prints number in function is 1\r\n    printf(\"number in function is %d\\n\", number);\r\n    \r\n    if (number == 1) {\r\n        // the definition of a block-level variable using the same name\r\n        // shadows the function-level variable\r\n        int number = 2;\r\n        // prints number in function is 2\r\n        printf(\"number in if block is %d\\n\", number);\r\n    }\r\n    // prints number in function is 1\r\n    printf(\"number in function is %d\\n\", number);\r\n}\r\n```\r\n\r\nCompilers may generate an error if a function parameter is attempted to be shadowed.\r\nThe following example\r\n\r\n```c\r\n#include <stdio.h>\r\n\r\nvoid print_number(int number) {\r\n    // will fail to compile\r\n    int number = 2;\r\n    printf(\"number in function is %d\\n\", number);\r\n}\r\n\r\nint main() {\r\n    int number = 1;\r\n    printf(\"number in main is %d\\n\", number);\r\n    print_number(number);\r\n    printf(\"number in main is %d\\n\", number);\r\n}\r\n```\r\n\r\nresults in the following errors on two platforms\r\n\r\n```\r\n/tmp/jIvhD5UOop.c: In function 'print_number':\r\n/tmp/jIvhD5UOop.c:5:9: error: 'number' redeclared as different kind of symbol\r\n    5 |     int number = 2;\r\n      |         ^~~~~~\r\n/tmp/jIvhD5UOop.c:3:23: note: previous definition of 'number' was here\r\n    3 | void print_number(int number) {\r\n      |                   ~~~~^~~~~~\r\n```\r\n\r\nand\r\n\r\n```\r\nredefinition of formal parameter 'number'\r\n```\r\n",
    "introduction": "# Introduction\r\n\r\nA block is a set of statements and declarations grouped into one syntactic unit.\r\nBlocks are often, but not always, defined within curly braces.\r\nBlocks can be nested within functions and within other blocks.\r\n\r\nA function acts somewhat like a block.\r\nAn identifier for a variable defined in a function cannot be seen outside the function, just as an indentifier for a variable defined in a block cannot be seen outside the block.\r\nTwo variables in two functions can have the same name, since the two functions don't see into each other, just as two variables in two blocks can have the same name, since the two blocks don't see into each other.\r\nBut functions and blocks are not identical.\r\nA function cannot be nested inside another function, but a block can be nested inside another block.\r\n\r\nIn the following example, `number` is defined within the `main` function.\r\n`flag` is defined within the `if` block which is nested within the `main` function.\r\nVariables defined within a block are only valid within that block.\r\nThus, attempting to compile the code results in a compilation error.\r\n\r\n```c\r\n#include <stdio.h>\r\n\r\nint main() {\r\n\r\n  int number = 1;\r\n\r\n  if (number == 1) {\r\n      int flag = 1;\r\n      printf(\"%d\", flag);\r\n  }\r\n\r\n  // this line generates a compilation error\r\n  // error: 'flag' undeclared (first use in this function)\r\n  printf(\"%d\", flag);\r\n    \r\n}\r\n```\r\n\r\nThe error message may be confusing, as `flag` _is_ used earlier in the function.\r\nHowever, `flag` is defined within a block inside the function.\r\nThe inner block can \"see\" the variable `number` in its outer function, but the outer function can't \"see\" the `flag` variable defined within its inner block.\r\nOnce execution leaves the block, the `flag` variable is automatically destroyed and is no longer available to the program.\r\nThe `main` function itself sees the `flag` identifier for the first time in the last `printf` statement.\r\nIf the last `printf` statement is removed, the program will compile and print `1` when run.\r\nThat is because the `flag` variable is valid in the block containing the first `printf` statement.\r\n\r\nAs of `C99`, single-line `if`, `for`, `while` and `do` statements are also considered blocks.\r\nIn the following example, although `i` is not defined within curly braces, it exists only in the block defined by the `for` statement, and is not visible to the outer `main` function.\r\n\r\n```c\r\n#include <stdio.h>\r\n\r\nint main() {\r\n\r\n    for (int i = 0, j = 11; i < j; i+=2)\r\n        printf(\"%d\", i);\r\n\r\n    // this line generates a compilation error\r\n    // error: 'i' undeclared (first use in this function)\r\n    printf(\"%d\", i);\r\n    \r\n}\r\n```\r\n\r\nIf the last `printf` statement is removed, the program will compile and print `0 2 4 6 8 10 ` when run.\r\nSome languages, such as Go and Rust, are explicit that single-line conditional and loop statements constitute a block.\r\nThey require that such single-line statements still be enclosed in curly braces.\r\n"
  },
  "meta": {},
  "links": []
}