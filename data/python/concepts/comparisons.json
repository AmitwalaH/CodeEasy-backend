{
  "concept": "comparisons",
  "about": "# About\r\n\r\nA [comparison operator][comparisons] in Python (_also called a Python relational operator_), looks at the _values_ of two [operands][operand] and returns a boolean `True` or `False` if the `comparison` condition is or is not met.\r\n\r\nThe table below shows the most common Python comparison operators:\r\n\r\n| Operator | Operation                  | Description                                                               |\r\n| -------- | -------------------------- | ------------------------------------------------------------------------- |\r\n| `>`      | \"greater than\"             | `a > b` is `True` if `a` is **strictly** greater in value than `b`        |\r\n| `<`      | \"less than\"                | `a < b` is `True` if `a` is **strictly** less in value than `b`           |\r\n| `==`     | \"equal to\"                 | `a == b` is `True` if `a` is **strictly** equal to `b` in value           |\r\n| `>=`     | \"greater than or equal to\" | `a >= b` is `True` if `a > b` OR `a == b` in value                        |\r\n| `<=`     | \"less than or equal to\"    | `a <= b` is `True` if `a < b` or `a == b` in value                        |\r\n| `!=`     | \"not equal to\"             | `a != b` is `True` if `a == b` is `False`                                 |\r\n| `is`     | \"identity\"                 | `a is b` is `True` if **_and only if_** `a` and `b` are the same _object_ |\r\n| `is not` | \"negated identity\"         | `a is not b` is `True` if `a` and `b` are **not** the same _object_       |\r\n| `in`     | \"containment test\"         | `a in b` is `True` if `a` is member, subset, or element of `b`            |\r\n| `not in` | \"negated containment test\" | `a not in b` is `True` if `a` is not a member, subset, or element of `b`  |\r\n\r\nThey all have the same priority (_which is higher than that of [Boolean operations][boolean operations], but lower than that of arithmetic or bitwise operations_).\r\n\r\n## Comparison between different data types\r\n\r\nObjects that are different types (_except numeric types_) never compare equal by default.\r\nNon-identical instances of a `class` will also _**not**_ compare as equal unless the `class` defines special [rich comparison][rich comparisons] methods that customize the default `object` comparison behavior.\r\nFor (much) more detail, see [Value comparisons][value comparisons] in the Python documentation.\r\n\r\nNumeric types are (mostly) an exception to this type matching rule.\r\nAn `integer` **can** be considered equal to a `float` (_or an [`octal`][octal] equal to a [`hexadecimal`][hex]_), as long as the types can be implicitly converted for comparison.\r\n\r\nFor the other numeric types ([complex][complex numbers], [decimal][decimal numbers], [fractions][rational numbers]), comparison operators are defined where they \"make sense\" (_where implicit conversion does not change the outcome_), but throw a `TypeError` if the underlying objects cannot be accurately converted for comparison.\r\nFor more information on the rules that Python uses for numeric conversion, see [arithmetic conversions][arithmetic conversions] in the Python documentation.\r\n\r\n```python\r\n>>> import fractions\r\n\r\n# A string cannot be converted to an int.\r\n>>> 17 == '17'\r\nFalse\r\n\r\n# An int can be converted to float for comparison.\r\n>>> 17 == 17.0\r\nTrue\r\n\r\n# The fraction 6/3 can be converted to the int 2\r\n# The int 2 can be converted to 0b10 in binary.\r\n>>> 6/3 == 0b10\r\nTrue\r\n\r\n# An int can be converted to a complex \r\n# number with a 0 imaginary part.\r\n>>> 17 == complex(17)\r\nTrue\r\n\r\n# The fraction 2/5 can be converted to the float 0.4\r\n>>> 0.4 == 2/5\r\nTrue\r\n\r\n>>> complex(2/5, 1/2) == complex(0.4, 0.5)\r\nTrue\r\n```\r\n\r\nAny ordered comparison of a number to a `NaN` (_not a number_) type is `False`.\r\nA confusing side effect of Python's `NaN` definition is that `NaN` never compares equal to `NaN`.\r\nIf you are curious as to why `NaN` was defined this way in Python, this [Stack Overflow Post on NaN][so nan post] around the setting of the international standard is an interesting read.\r\n\r\n```python\r\n>>> x = float('NaN')\r\n\r\n>>> 3 < x\r\nFalse\r\n\r\n>>> x < 3\r\nFalse\r\n\r\n# NaN never compares equal to NaN\r\n>>> x == x\r\nFalse\r\n```\r\n\r\n## Comparing Strings\r\n\r\nStrings (`str`) are compared [_lexicographically_][lexographic order], using their individual Unicode code points (_the result of passing each code point in the `str` to the built-in function [`ord()`][ord], which returns an `int`_).\r\nIf all code points in both strings match and are _**in the same order**_, the two strings are considered equal.\r\nThis comparison is done in a 'pair-wise' fashion - first-to-first, second-to-second, etc.\r\nIn Python 3.x, `str` and `bytes` cannot be directly coerced/compared.\r\n\r\n```python\r\n>>> 'Python' > 'Rust'\r\nFalse\r\n\r\n>>> 'Python' > 'JavaScript'\r\nTrue\r\n\r\n# Examples with Mandarin.\r\n# hello < goodbye\r\n>>> '你好' < '再见'\r\nTrue\r\n\r\n# ord() of first characters\r\n>>> ord('你'), ord('再')\r\n(20320, 20877)\r\n\r\n# ord() of second characters\r\n>>> ord('好'), ord('见')\r\n(22909, 35265)\r\n\r\n# And with Korean words.\r\n# Pretty < beautiful.\r\n>>> '예쁜' < '아름다운'\r\nFalse\r\n\r\n>>> ord('예'), ord('아')\r\n(50696, 50500)\r\n```\r\n\r\n## Comparing Container Data Types\r\n\r\nContainer data types (_`lists`, `tuples`, `sets`, `dicts`, etc._) also compare [_lexicographically_][lexographic order] - they are equal if both containers have the same data **and** the same data types (_in the case of `lists` and `tuples`, they must also have the same **ordering**_), unequal otherwise.\r\n\r\n```python\r\n>>> [1, 2] == [1, 2]\r\nTrue\r\n\r\n# But if the data is not in the same order, they are not equal.\r\n>>> [2, 1] == [1, 2]\r\nFalse\r\n\r\n# The same holds true for tuples\r\n>>> (3,4,5) == (5,4,3)\r\nFalse\r\n\r\n# Length is also compared\r\n>>> [1, 2] < [1, 2, 3]\r\nTrue\r\n\r\n# Comparing dicts\r\n>>> {'name': 'John', 'age': 19} == {'name': 'John', 'age': 18}\r\nFalse\r\n\r\n>>> {'name': 'John', 'age': 19} == {'name': 'John', 'age': 19}\r\nTrue\r\n```\r\n\r\n## Comparison Chaining\r\n\r\nComparison operators can be chained _arbitrarily_.\r\nNote that the evaluation of an expression takes place from `left` to `right`.\r\nFor example, `x < y <= z` is equivalent to `x < y` `and` `y <= z`, except that `y` is evaluated **only once**.\r\nIn both cases, `z` is _not_ evaluated **at all** when `x < y` is found to be `False`.\r\nThis is often called `short-circuit evaluation` - the evaluation stops if the truth value of the expression has already been determined.\r\n\r\n`Short circuiting` is supported by various boolean operators, functions, and also by comparison chaining in Python.\r\nUnlike many other programming languages, including `C`, `C++`, `C#`, and `Java`, chained expressions like `a < b < c` in Python have a conventional [mathematical interpretation][three way boolean comparison] and precedence.\r\n\r\n```python\r\n>>> x = 2\r\n>>> y = 5\r\n>>> z = 10\r\n\r\n>>> x < y < z\r\nTrue\r\n\r\n>>> x < y > z\r\nFalse\r\n\r\n>>> x > y < z\r\nFalse\r\n```\r\n\r\n## Identity comparisons\r\n\r\nThe operators `is` and `is not` test for object [_identity_][object identity], as opposed to object _value_.\r\nAn object's identity never changes after creation and can be found by using the [`id()`][id function] function.\r\n\r\n`<apple> is <orange>` evaluates to `True` if _**and only if**_ `id(<apple>)` == `id(<orange>)`.\r\n`<apple> is not <orange>` yields the inverse.\r\n\r\nDue to their singleton status, `None` and `NotImplemented` should always be compared to items using `is` and `is not`.\r\nSee the Python reference docs on [value comparisons][value comparisons none] and [PEP8][PEP8 programming recommendations] for more details on this convention.\r\n\r\n```python\r\n>>> \r\n# A list of favorite numbers.\r\n>>> my_fav_numbers = [1, 2, 3]\r\n\r\n>>> your_fav_numbers = my_fav_numbers\r\n\r\n>>> my_fav_numbers is your_fav_numbers\r\nTrue\r\n\r\n# The returned id will differ by system and Python version.\r\n>>> id(my_fav_numbers)\r\n4517478208\r\n\r\n# your_fav_numbers is only an alias pointing to the original my_fav_numbers object.\r\n# Assigning a new name does not create a new object.\r\n>>> id(your_fav_numbers)\r\n4517478208\r\n\r\n\r\n>>> my_fav_numbers is not your_fav_numbers\r\nFalse\r\n\r\n>>> my_fav_numbers is not None\r\nTrue\r\n\r\n>>> my_fav_numbers is NotImplemented\r\nFalse\r\n```\r\n\r\n## Membership comparisons\r\n\r\nThe operators `in` and `not in` test for _membership_.\r\n`<fish> in <soup>` evaluates to `True` if `<fish>` is a member of `<soup>` (_if `<fish>` is a subset of or is contained within `<soup>`_), and evaluates `False` otherwise.\r\n`<fish> not in <soup>` returns the negation, or _opposite of_ `<fish> in <soup>`.\r\n\r\nFor string and bytes types, `<name> in <fullname>` is `True` _**if and only if**_ `<name>` is a substring of `<fullname>`.\r\n\r\n```python\r\n>>> \r\n# A set of lucky numbers.\r\n>>> lucky_numbers = {11, 22, 33}\r\n>>> 22 in lucky_numbers\r\nTrue\r\n\r\n>>> 44 in lucky_numbers\r\nFalse\r\n\r\n# A dictionary of employee information.\r\n>>> employee = {'name': 'John Doe', 'id': 67826, 'age': 33, 'title': 'ceo'}\r\n\r\n# Checking for the membership of certain keys.\r\n>>> 'age' in employee\r\nTrue\r\n\r\n>>> 33 in employee\r\nFalse\r\n\r\n>>> 'lastname' not in employee\r\nTrue\r\n\r\n# Checking for substring membership\r\n>>> name = 'Super Batman'\r\n>>> 'Bat' in name\r\nTrue\r\n\r\n>>> 'Batwoman' in name\r\nFalse\r\n```\r\n\r\n# Customizing comparison behavior\r\n\r\nComparison behavior for objects can be customized through the implementation of `rich comparison methods`.\r\nFor more information, see [Python Tutorial: classes][classes], [Python Classes and Magic Methods (Dan Bader)][magic methods], and [Special method names][dunder methods].\r\n\r\n[PEP8 programming recommendations]: https://pep8.org/#programming-recommendations\r\n[arithmetic conversions]: https://docs.python.org/3/reference/expressions.html?highlight=number%20conversion#arithmetic-conversions\r\n[boolean operations]: https://docs.python.org/3/library/stdtypes.html#boolean-operations-and-or-not\r\n[classes]: https://docs.python.org/3/tutorial/classes.html#classes\r\n[comparisons]: https://docs.python.org/3/library/stdtypes.html?highlight=comparisons#comparisons\r\n[complex numbers]: https://docs.python.org/3/library/functions.html#complex\r\n[decimal numbers]: https://docs.python.org/3/library/decimal.html\r\n[dunder methods]: https://docs.python.org/3/reference/datamodel.html#special-method-names\r\n[hex]: https://docs.python.org/3/library/functions.html?highlight=hex#hex\r\n[id function]: https://docs.python.org/3/library/functions.html#id\r\n[lexographic order]: https://en.wikipedia.org/wiki/Lexicographic_order\r\n[magic methods]: https://dbader.org/blog/python-dunder-methods\r\n[object identity]: https://docs.python.org/3/reference/datamodel.html\r\n[octal]: https://docs.python.org/3/library/functions.html?#oct\r\n[operand]: https://www.computerhope.com/jargon/o/operand.htm\r\n[ord]: https://docs.python.org/3/library/functions.html#ord\r\n[rational numbers]: https://docs.python.org/3/library/fractions.html\r\n[rich comparisons]: https://docs.python.org/3/reference/datamodel.html#object.__lt__\r\n[so nan post]: https://stackoverflow.com/questions/1565164/what-is-the-rationale-for-all-comparisons-returning-false-for-ieee754-nan-values\r\n[three way boolean comparison]: https://en.wikipedia.org/wiki/Three-way_comparison\r\n[value comparisons none]: https://docs.python.org/3/reference/expressions.html?highlight=none#value-comparisons\r\n[value comparisons]: https://docs.python.org/3/reference/expressions.html?highlight=nan#value-comparisons\r\n",
  "introduction": "# Introduction\r\n\r\nA [comparison operator][comparisons] in Python (_also called a Python relational operator_), looks at the _values_ of two [operands][operand] and returns a boolean `True` or `False` if the `comparison` condition is or is not met.\r\n\r\nThe table below shows the most common Python comparison operators:\r\n\r\n| Operator | Operation                  | Description                                                               |\r\n| -------- | -------------------------- | ------------------------------------------------------------------------- |\r\n| `>`      | \"greater than\"             | `a > b` is `True` if `a` is **strictly** greater in value than `b`        |\r\n| `<`      | \"less than\"                | `a < b` is `True` if `a` is **strictly** less in value than `b`           |\r\n| `==`     | \"equal to\"                 | `a == b` is `True` if `a` is **strictly** equal to `b` in value           |\r\n| `>=`     | \"greater than or equal to\" | `a >= b` is `True` if `a > b` OR `a == b` in value                        |\r\n| `<=`     | \"less than or equal to\"    | `a <= b` is `True` if `a < b` or `a == b` in value                        |\r\n| `!=`     | \"not equal to\"             | `a != b` is `True` if `a == b` is `False`                                 |\r\n| `is`     | \"identity\"                 | `a is b` is `True` if **_and only if_** `a` and `b` are the same _object_ |\r\n| `is not` | \"negated identity\"         | `a is not b` is `True` if `a` and `b` are **not** the same _object_       |\r\n| `in`     | \"containment test\"         | `a in b` is `True` if `a` is member, subset, or element of `b`            |\r\n| `not in` | \"negated containment test\" | `a not in b` is `True` if `a` is not a member, subset, or element of `b`  |\r\n\r\nThey all have the same priority (_which is higher than that of [Boolean operations][boolean operations], but lower than that of arithmetic or bitwise operations_).\r\n\r\n## Comparison between different data types\r\n\r\nObjects that are different types (_except numeric types_) never compare equal by default.\r\nNon-identical instances of a `class` will also _**not**_ compare as equal unless the `class` defines special methods that customize the default `object` comparison behavior.\r\n\r\nNumeric types are (mostly) an exception to this type matching rule.\r\nAn `integer` **can** be considered equal to a `float` (_or an [`octal`][octal] equal to a [`hexadecimal`][hex]_), as long as the types can be implicitly converted for comparison.\r\n\r\nFor the other numeric types ([complex][complex numbers], [decimal][decimal numbers], [fractions][rational numbers]), comparison operators are defined where they \"make sense\" (_where implicit conversion does not change the outcome_), but throw a `TypeError` if the underlying objects cannot be accurately converted for comparison.\r\n\r\n## Comparing object identity\r\n\r\nThe operators `is` and `is not` test for object [_identity_][object identity], as opposed to object _value_.\r\nAn object's identity never changes after creation and can be found by using the [`id()`][id function] function.\r\n\r\n`<apple> is <orange>` evaluates to `True` if _**and only if**_ `id(<apple>)` == `id(<orange>)`.\r\n`<apple> is not <orange>` yields the inverse.\r\n\r\n## Membership comparisons\r\n\r\nThe operators `in` and `not in` test for _membership_.\r\n`<fish> in <soup>` evaluates to `True` if `<fish>` is a member of `<soup>` (_if `<fish>` is a subset of or is contained within `<soup>`_), and evaluates `False` otherwise.\r\n`<fish> not in <soup>` returns the negation, or _opposite of_ `<fish> in <soup>`.\r\n\r\nFor string and bytes types, `<name> in <fullname>` is `True` _**if and only if**_ `<name>` is a substring of `<fullname>`.\r\n\r\n[boolean operations]: https://docs.python.org/3/library/stdtypes.html#boolean-operations-and-or-not\r\n[comparisons]: https://docs.python.org/3/library/stdtypes.html?highlight=comparisons#comparisons\r\n[complex numbers]: https://docs.python.org/3/library/functions.html#complex\r\n[decimal numbers]: https://docs.python.org/3/library/decimal.html\r\n[hex]: https://docs.python.org/3/library/functions.html?highlight=hex#hex\r\n[id function]: https://docs.python.org/3/library/functions.html#id\r\n[object identity]: https://docs.python.org/3/reference/datamodel.html\r\n[octal]: https://docs.python.org/3/library/functions.html?#oct\r\n[operand]: https://www.computerhope.com/jargon/o/operand.htm\r\n[rational numbers]: https://docs.python.org/3/library/fractions.html\r\n",
  "links": [
    {
      "url": "https://www.tutorialspoint.com/python/python_basic_operators.htm",
      "description": "Python basic operators on Tutorials Point"
    },
    {
      "url": "https://docs.python.org/3/reference/expressions.html#comparisons",
      "description": "Comparisons in Python (Python language reference)"
    },
    {
      "url": "https://docs.python.org/3/reference/expressions.html#is-not",
      "description": "Identity comparisons in Python (Python language reference)"
    },
    {
      "url": "https://docs.python.org/3/reference/expressions.html#value-comparisons",
      "description": "Value comparisons in Python (Python language reference)"
    },
    {
      "url": "https://docs.python.org/3/library/stdtypes.html#typesnumeric",
      "description": "Numeric types (Python Docs)"
    },
    {
      "url": "https://docs.python.org/3/library/decimal.html#decimal.Decimal",
      "description": "Decimal types (Python Docs)"
    },
    {
      "url": "https://docs.python.org/3/library/fractions.html#fractions.Fraction",
      "description": "Fractions (Python Docs)"
    },
    {
      "url": "https://docs.python.org/3/library/stdtypes.html#sequence-types-list-tuple-range",
      "description": "Sequence types (Python Docs)"
    },
    {
      "url": "https://docs.python.org/3/reference/datamodel.html#objects",
      "description": "Python Object Model (Python docs)"
    },
    {
      "url": "https://www.python.org/dev/peps/pep-0207/",
      "description": "PEP 207 to allow Operator Overloading for Comparison"
    },
    {
      "url": "https://docs.python.org/3/reference/datamodel.html#customization",
      "description": "Basic Customization (Python language reference)"
    }
  ],
  "config": {}
}