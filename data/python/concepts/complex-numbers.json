{
  "concept": "complex-numbers",
  "about": "# About\r\n\r\n`Complex numbers` are not complicated.\r\nThey just need a less alarming name.\r\n\r\nThey are so useful, especially in engineering and science, that Python includes [`complex`][complex] as a standard numeric type alongside integers ([`int`s][ints]) and floating-point numbers ([`float`s][floats]).\r\n\r\n\r\n## Basics\r\n\r\nA `complex` value in Python is essentially a pair of floating-point numbers.\r\nThese are called the \"real\" and \"imaginary\" parts, for unfortunate historical reasons.\r\nAgain, it is best to focus on the underlying simplicity and not the strange names.\r\n\r\nThere are two common ways to create complex numbers.\r\n\r\n1) The [`complex(real, imag)`][complex] constructor takes two `float` parameters:\r\n\r\n```python\r\n>>> z1 = complex(1.5, 2.0)\r\n>>> z1\r\n(1.5+2j)\r\n```\r\n\r\nThe constructor can also parse string input.\r\nThis has the odd limitation that it fails if the string contains spaces.\r\n\r\n```python\r\n>>> complex('4+2j')\r\n(4+2j)\r\n\r\n>>> complex('4 + 2j')\r\nTraceback (most recent call last):\r\n  File \"<stdin>\", line 1, in <module>\r\nValueError: complex() arg is a malformed string\r\n```\r\n\r\n\r\n2) The complex number can be specified as `<real part> + <complex part>j` literal, or just `<complex part>j` if the real part is zero:\r\n\r\n\r\n```python\r\n>>> z2 = 2.0 + 1.5j\r\n>>> z2\r\n(2+1.5j)\r\n```\r\nThe end result is identical to using the `complex()` constructor.\r\n\r\n\r\nThere are two rules for that imaginary part of the complex number:\r\n\r\n\r\n- It is designated with `j` (not `i` as you may see in math textbooks).\r\n\r\n- The `j` must immediately follow a number, to prevent Python seeing it as a variable name. If necessary, use `1j`.\r\n\r\n```python\r\n>>> j\r\nTraceback (most recent call last):\r\n  File \"<stdin>\", line 1, in <module>\r\nNameError: name 'j' is not defined\r\n\r\n>>> 1j\r\n1j\r\n\r\n>>> type(1j)\r\n<class 'complex'>\r\n```\r\n\r\nMost engineers are happy with `j`.\r\nMost scientists and mathematicians prefer the mathematical notation `i` for _imaginary_, but that notation conflicts with the use of `i` to mean _current_ in Electrical Engineering.\r\nSo in designing Python, the Electrical Engineers won.\r\n\r\n\r\nTo access the parts of a complex number individually:\r\n\r\n```python\r\n>>> z2.real\r\n2.0\r\n>>> z2.imag\r\n1.5\r\n```\r\n\r\nEither part can be zero and mathematicians may then talk of the number being \"wholly real\" or \"wholly imaginary\".\r\nHowever, it is still a complex number in Python:\r\n\r\n\r\n```python\r\n>>> complex(0, 1)\r\n1j\r\n>>> type(complex(0, 1))\r\n<class 'complex'>\r\n\r\n>>> complex(1, 0)\r\n(1+0j)\r\n```\r\n\r\nYou may have heard that \"`i` (or `j`) is the square root of -1\".\r\n\r\nFor now, all this means is that the imaginary part _by definition_ satisfies the equality\r\n```python\r\n1j * 1j == -1  # => True\r\n```\r\n\r\nThis is a simple idea, but it leads to interesting consequences.\r\n\r\n## Arithmetic\r\n\r\nMost of the [`operators`][operators] used with floats and ints also work with complex numbers:\r\n\r\n\r\n```python\r\n>>> z1 = (1.5+2j)\r\n>>> z2 = (2+1.5j)\r\n\r\n\r\n>>> z1 + z2  # addition\r\n(3.5+3.5j)\r\n\r\n>>> z1 - z2  # subtraction\r\n(-0.5+0.5j)\r\n\r\n>>> z1 * z2  # multiplication\r\n6.25j\r\n\r\n>>> z1 / z2  # division\r\n(0.96+0.28j)\r\n\r\n>>> z1 ** 2  # exponentiation\r\n(-1.75+6j)\r\n\r\n>>> 2 ** z1  # another exponentiation\r\n(0.5188946835878313+2.7804223253571183j)\r\n\r\n>>> 1j ** 2  # j * j == -1\r\n(-1+0j)\r\n```\r\n\r\nExplaining the rules for complex number multiplication and division is out of scope for this concept (_and you are unlikely to have to perform those operations \"by hand\" very often_).\r\n\r\nAny [mathematical][math-complex] or [electrical engineering][engineering-complex] introduction to complex numbers will cover this, should you want to dig into the topic.\r\n\r\nAlternatively, Exercism has a `Complex Numbers` practice exercise where you can implement a complex number class with these operations from first principles.\r\n\r\n\r\nInteger division is ___not___ possible on complex numbers, so the `//` and `%` operators and `divmod()` functions will fail for the complex number type.\r\n\r\n\r\nThere are two functions implemented for numeric types that are very useful when working with complex numbers:\r\n\r\n- `<complex number>.conjugate()` simply flips the sign of the imaginary part of a complex number (_from + to - or vice-versa_).\r\n    - Because of the way complex multiplication works, this is more useful than you might think.\r\n- `abs(<complex number>)` is guaranteed to return a real number with no imaginary part.\r\n\r\n\r\n```python\r\n>>> z1\r\n(1.5+2j)\r\n\r\n>>> z1.conjugate() # flip the z1.imag sign\r\n(1.5-2j)\r\n\r\n>>> abs(z1) # sqrt(z1.real ** 2 + z1.imag ** 2)\r\n2.5\r\n```\r\n\r\n## The `cmath` module\r\n\r\nThe Python standard library has a [`math`][math-module] module full of useful functionality for working with real numbers.\r\n\r\nIt also has an equivalent [`cmath`][cmath] module for working with complex numbers.\r\n\r\n\r\nWe encourage you to read through the module and experiment, but the main categories are:\r\n\r\n- Conversion between Cartesian and polar coordinates,\r\n- Exponential and log functions,\r\n- Trigonometric functions,\r\n- Hyperbolic functions,\r\n- Classification functions, and\r\n- Useful constants.\r\n\r\nHere is an example using some constants:\r\n\r\n```python\r\n>>> import cmath\r\n\r\n>>> euler = cmath.exp(1j * cmath.pi) # Euler's equation\r\n\r\n>>> euler.real\r\n-1.0\r\n>>> round(euler.imag, 15) # round to 15 decimal places\r\n0.0\r\n```\r\n\r\nSo a simple expression with three of the most important constants in nature `e`, `i` (or `j`) and `pi` gives the result `-1`. \r\nSome people believe this is the most beautiful result in all of mathematics.\r\nIt dates back to around 1740.\r\n\r\n-----\r\n\r\n## Optional section: a Complex Numbers FAQ\r\n\r\nThis part can be skipped, unless you are interested.\r\n\r\n### Isn't this some strange new piece of pure mathematics?\r\n\r\nIt was strange and new in the 16th century.\r\n\r\n500 years later, it is central to most of engineering and the physical sciences.\r\n\r\n### Why would anyone use these?\r\n\r\nIt turns out that complex numbers are the simplest way to describe anything that rotates or anything with a wave-like property.\r\nSo they are used widely in electrical engineering, audio processing, physics, computer gaming, and navigation - to name only a few applications.\r\n\r\nYou can see things rotate.\r\nComplex numbers may not make the world go round, but they are great for explaining _what happens_ as a result of the world going round: look at any satellite image of a major storm.\r\n\r\n\r\nLess obviously, sound is wave-like, light is wave-like, radio signals are wave-like, and even the economy of your home country is at least partly wave-like.\r\n\r\n\r\nA lot of this wave processing can be done with trig functions (`sin()` and `cos()`) but that gets messy quite quickly.\r\n\r\nComplex exponentials are ___much___ easier to work with.\r\n\r\n### But I don't need complex numbers!\r\n\r\n\r\nOnly true if you are living in a cave and foraging for your food.\r\n\r\nIf you are reading this on any sort of screen, you are utterly dependent on some useful 20th-Century advances made through the use of complex numbers.\r\n\r\n\r\n1. __Semiconductor chips__. \r\n    - These make no sense in classical physics and can only be explained (and designed) by quantum mechanics (QM).\r\n    - In QM, everything is complex-valued by definition. (_its waveforms all the way down_)\r\n\r\n2. __The Fast Fourier Transform algorithm__. \r\n    - FFT is an application of complex numbers, and it is in _everything_ connected to sound transmission, audio processing, photos, and video.\r\n\r\n    -MP3 and other audio formats use FFT for compression, ensuring more audio can fit within a smaller storage space. \r\n    - JPEG compression and MP4 video, among many other image and video formats also use FTT for compression.\r\n\r\n    - FFT is also deployed in the digital filters that allow cellphone towers to separate your personal cell signal from everyone else's.\r\n\r\n\r\nSo, you are probably using technology that relies on complex number calculations thousands of times per second.\r\n\r\n\r\n[complex]: https://docs.python.org/3/library/functions.html#complex\r\n[cmath]: https://docs.python.org/3/library/cmath.html\r\n[operators]: https://docs.python.org/3/library/stdtypes.html#numeric-types-int-float-complex\r\n[math-module]: https://docs.python.org/3/library/math.html\r\n[math-complex]: https://www.nagwa.com/en/videos/143121736364/\r\n[engineering-complex]: https://www.khanacademy.org/science/electrical-engineering/ee-circuit-analysis-topic/ee-ac-analysis/v/ee-complex-numbers\r\n[ints]: https://docs.python.org/3/library/functions.html#int\r\n[floats]: https://docs.python.org/3/library/functions.html#float\r\n\r\n",
  "introduction": "# Introduction\r\n\r\n`Complex numbers` are not complicated.\r\nThey just need a less alarming name.\r\n\r\nThey are so useful, especially in engineering and science (_everything from JPEG compression to quantum mechanics_), that Python includes [`complex`][complex] as a standard numeric type alongside integers ([`int`s][ints]) and floating-point numbers ([`float`s][floats]).\r\n\r\nA `complex` value in Python is essentially a pair of floating-point numbers:\r\n\r\n```python\r\n>>> my_complex = 5.443+6.77j\r\n(5.443+6.77j)\r\n```\r\n\r\nThese are called the \"real\" and \"imaginary\" parts.\r\nYou may have heard that \"`i` (or `j`) is the square root of -1\".\r\nFor now, all this means is that the imaginary part _by definition_ satisfies the equality `1j * 1j == -1`.\r\nThis is a simple idea, but it leads to interesting mathematical consequences.\r\n\r\nIn Python, the \"imaginary\" part is designated with `j` (_not `i` as you would see in math textbooks_), and\r\nthe `j` must immediately follow a number, to prevent Python seeing it as a variable name:\r\n\r\n\r\n```python\r\n>>> j\r\nTraceback (most recent call last):\r\n  File \"<stdin>\", line 1, in <module>\r\nNameError: name 'j' is not defined\r\n\r\n>>> 1j\r\n1j\r\n\r\n>>> type(1j)\r\n<class 'complex'>\r\n```\r\n\r\n\r\nThere are two common ways to create complex numbers.\r\n\r\n1) The [`complex(real, imag)`][complex] constructor takes two `float` parameters:\r\n\r\n    ```python\r\n    >>> z1 = complex(1.5, 2.0)\r\n    >>> z1\r\n    (1.5+2j)\r\n    ```\r\n\r\n    The constructor can also parse string input.\r\n    This has the odd limitation that it fails if the string contains spaces.\r\n\r\n    ```python\r\n    >>> complex('4+2j')\r\n    (4+2j)\r\n    \r\n    >>> complex('4 + 2j')\r\n    Traceback (most recent call last):\r\n      File \"<stdin>\", line 1, in <module>\r\n    ValueError: complex() arg is a malformed string\r\n    ```\r\n\r\n\r\n2) The complex number can be specified as `<real part> + <complex part>j` literal, or just `<complex part>j` if the real part is zero:\r\n\r\n\r\n    ```python\r\n    >>> z2 = 2.0 + 1.5j\r\n    >>> z2\r\n    (2+1.5j)\r\n    ```\r\n    The end result is identical to using the `complex()` constructor.\r\n\r\n\r\n## Arithmetic\r\n\r\nMost of the [`operators`][operators] used with floats and ints also work with complex numbers.\r\n\r\nInteger division is _**not**_ possible on complex numbers, so the `//` and `%` operators and `divmod()` functions will fail for the complex number type.\r\n\r\nExplaining the rules for complex number multiplication and division is out of scope for this concept (_and you are unlikely to have to perform those operations \"by hand\" very often_).\r\n\r\nAny [mathematical][math-complex] or [electrical engineering][engineering-complex] introduction to complex numbers will cover these scenarios, should you want to dig into the topic.\r\n\r\nThe Python standard library has a [`math`][math-module] module full of useful functionality for working with real numbers and the [`cmath`][cmath] module is its equivalent for working with complex numbers.\r\n\r\n\r\n[cmath]: https://docs.python.org/3/library/cmath.html\r\n[complex]: https://docs.python.org/3/library/functions.html#complex\r\n[engineering-complex]: https://www.khanacademy.org/science/electrical-engineering/ee-circuit-analysis-topic/ee-ac-analysis/v/ee-complex-numbers\r\n[floats]: https://docs.python.org/3/library/functions.html#float\r\n[ints]: https://docs.python.org/3/library/functions.html#int\r\n[math-complex]: https://www.nagwa.com/en/videos/143121736364/\r\n[math-module]: https://docs.python.org/3/library/math.html\r\n[operators]: https://docs.python.org/3/library/stdtypes.html#numeric-types-int-float-complex\r\n",
  "links": [
    {
      "url": "https://docs.python.org/3/library/stdtypes.html#numeric-types-int-float-complex/",
      "description": "Operations on numeric types."
    },
    {
      "url": "https://docs.python.org/3/library/functions.html#complex/",
      "description": "The complex class."
    },
    {
      "url": "https://docs.python.org/3/library/cmath.html/",
      "description": "Module documentation for cmath."
    },
    {
      "url": "https://docs.python.org/3/library/math.html/",
      "description": "Module documentation for math."
    }
  ],
  "config": {}
}