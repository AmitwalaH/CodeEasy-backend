{
  "concept": "unpacking-and-multiple-assignment",
  "about": "# Unpacking and Multiple Assignment\r\n\r\nUnpacking refers to the act of extracting the elements of a collection, such as a `list`, `tuple`, or `dict`, using iteration.\r\nUnpacked values can then be assigned to variables within the same statement.\r\nA very common example of this behavior is `for item in list`, where `item` takes on the value of each `list` element in turn throughout the iteration.\r\n\r\n[Multiple assignment][multiple assignment] is the ability to assign multiple variables to unpacked values within one statement.\r\nThis allows for code to be more concise and readable, and is done by separating the variables to be assigned with a comma such as `first, second, third = (1,2,3)` or `for index, item in enumerate(iterable)`.\r\n\r\nThe special operators `*` and `**` are often used in unpacking contexts.\r\n`*` can be used to combine multiple `lists`/`tuples` into one `list`/`tuple` by _unpacking_ each into a new common `list`/`tuple`.\r\n`**` can be used to combine multiple dictionaries into one dictionary by _unpacking_ each into a new common `dict`.\r\n\r\nWhen the `*` operator is used without a collection, it _packs_ a number of values into a `list`.\r\nThis is often used in multiple assignment to group all \"leftover\" elements that do not have individual assignments into a single variable.\r\n\r\nIt is common in Python to also exploit this unpacking/packing behavior when using or defining functions that take an arbitrary number of positional or keyword arguments.\r\nYou will often see these \"special\" parameters defined as `def some_function(*args, **kwargs)` and the \"special\" arguments used as `some_function(*some_tuple, **some_dict)`.\r\n\r\n~~~~exercism/caution\r\n`*<variable_name>` and `**<variable_name>` should not be confused with `*` and `**`. While `*` and `**` are used for multiplication and exponentiation respectively, `*<variable_name>` and `**<variable_name>` are used as packing and unpacking operators.\r\n~~~~\r\n\r\n## Multiple assignment\r\n\r\nIn multiple assignment, the number of variables on the left side of the assignment operator (`=`) must match the number of values on the right side.\r\nTo separate the values, use a comma `,`:\r\n\r\n```python\r\n>>> a, b = 1, 2\r\n>>> a\r\n1\r\n```\r\n\r\nIf the multiple assignment gets an incorrect number of variables for the values given, a `ValueError` will be thrown:\r\n\r\n```python\r\n>>> x, y, z = 1, 2\r\n\r\nValueError: too many values to unpack (expected 3, got 2)\r\n```\r\n\r\nMultiple assignment is not limited to one data type:\r\n\r\n```python\r\n>>> x, y, z = 1, \"Hello\", True\r\n>>> x\r\n1\r\n\r\n>>> y\r\n'Hello'\r\n\r\n>>> z\r\nTrue\r\n```\r\n\r\nMultiple assignment can be used to swap elements in `lists`.\r\nThis practice is pretty common in [sorting algorithms][sorting algorithms].\r\nFor example:\r\n\r\n```python\r\n>>> numbers = [1, 2]\r\n>>> numbers[0], numbers[1] = numbers[1], numbers[0]\r\n>>> numbers\r\n[2, 1]\r\n```\r\n\r\nSince `tuples` are immutable, you can't swap elements in a `tuple`.\r\n\r\n## Unpacking\r\n\r\n~~~~exercism/note\r\nThe examples below use `lists` but the same concepts apply to `tuples`.\r\n~~~~\r\n\r\nIn Python, it is possible to [unpack the elements of `list`/`tuple`/`dictionary`][unpacking] into distinct variables.\r\nSince values appear within `lists`/`tuples` in a specific order, they are unpacked into variables in the same order:\r\n\r\n```python\r\n>>> fruits = [\"apple\", \"banana\", \"cherry\"]\r\n>>> x, y, z = fruits\r\n>>> x\r\n\"apple\"\r\n```\r\n\r\nIf there are values that are not needed then you can use `_` to flag them:\r\n\r\n```python\r\n>>> fruits = [\"apple\", \"banana\", \"cherry\"]\r\n>>> _, _, z = fruits\r\n>>> z\r\n\"cherry\"\r\n```\r\n\r\n### Deep unpacking\r\n\r\nUnpacking and assigning values from a `list`/`tuple` inside of a `list` or `tuple` (_also known as nested lists/tuples_), works in the same way a shallow unpacking does, but often needs qualifiers to clarify the values context or position:\r\n\r\n```python\r\n>>> fruits_vegetables = [[\"apple\", \"banana\"], [\"carrot\", \"potato\"]]\r\n>>> [[a, b], [c, d]] = fruits_vegetables\r\n>>> a\r\n\"apple\"\r\n\r\n>>> d\r\n\"potato\"\r\n```\r\n\r\nYou can also deeply unpack just a portion of a nested `list`/`tuple`:\r\n\r\n```python\r\n>>> fruits_vegetables = [[\"apple\", \"banana\"], [\"carrot\", \"potato\"]]\r\n>>> [a, [c, d]] = fruits_vegetables\r\n>>> a\r\n[\"apple\", \"banana\"]\r\n\r\n>>> c\r\n\"carrot\"\r\n```\r\n\r\nIf the unpacking has variables with incorrect placement and/or an incorrect number of values, you will get a `ValueError`:\r\n\r\n```python\r\n>>> fruits_vegetables = [[\"apple\", \"banana\"], [\"carrot\", \"potato\"]]\r\n>>> [[a, b], [d]] = fruits_vegetables\r\n\r\nValueError: too many values to unpack (expected 1)\r\n```\r\n\r\n### Unpacking a list/tuple with `*`\r\n\r\nWhen [unpacking a `list`/`tuple`][packing and unpacking] you can use the `*` operator to capture \"leftover\" values.\r\nThis is clearer than slicing the `list`/`tuple` (_which in some situations is less readable_).\r\nFor example, we can extract the first element and pack the remaining values into a new `list` without the first element:\r\n\r\n```python\r\n>>> fruits = [\"apple\", \"banana\", \"cherry\", \"orange\", \"kiwi\", \"melon\", \"mango\"]\r\n>>> x, *last = fruits\r\n>>> x\r\n\"apple\"\r\n\r\n>>> last\r\n[\"banana\", \"cherry\", \"orange\", \"kiwi\", \"melon\", \"mango\"]\r\n```\r\n\r\nWe can also extract the values at the beginning and end of the `list` while grouping all the values in the middle:\r\n\r\n```python\r\n>>> fruits = [\"apple\", \"banana\", \"cherry\", \"orange\", \"kiwi\", \"melon\", \"mango\"]\r\n>>> x, *middle, y, z = fruits\r\n>>> y\r\n\"melon\"\r\n\r\n>>> middle\r\n[\"banana\", \"cherry\", \"orange\", \"kiwi\"]\r\n```\r\n\r\nWe can also use `*` in deep unpacking:\r\n\r\n```python\r\n>>> fruits_vegetables = [[\"apple\", \"banana\", \"melon\"], [\"carrot\", \"potato\", \"tomato\"]]\r\n>>> [[a, *rest], b] = fruits_vegetables\r\n>>> a\r\n\"apple\"\r\n\r\n>>> rest\r\n[\"banana\", \"melon\"]\r\n```\r\n\r\n### Unpacking a dictionary\r\n\r\n[Unpacking a dictionary][packing and unpacking] is a bit different from unpacking a `list`/`tuple`.\r\nIteration over dictionaries defaults to the **keys**.\r\nSo when unpacking a `dict`, you can only unpack the **keys** and not the **values**:\r\n\r\n```python\r\n>>> fruits_inventory = {\"apple\": 6, \"banana\": 2, \"cherry\": 3}\r\n>>> x, y, z = fruits_inventory\r\n>>> x\r\n\"apple\"\r\n```\r\n\r\nIf you want to unpack the values then you can use the `<dict>.values()` method:\r\n\r\n```python\r\n>>> fruits_inventory = {\"apple\": 6, \"banana\": 2, \"cherry\": 3}\r\n>>> x, y, z = fruits_inventory.values()\r\n>>> x\r\n6\r\n```\r\n\r\nIf both **keys** and **values** are needed, use the [`<dict>.items()`][items] method.\r\n`<dict>.items()` generates an [iterable view][view-objects] containing **key-value** pairs.\r\nThese can be unpacked into a `tuple`:\r\n\r\n```python\r\n>>> fruits_inventory = {\"apple\": 6, \"banana\": 2, \"cherry\": 3}\r\n>>> x, y, z = fruits_inventory.items()\r\n>>> x\r\n(\"apple\", 6)\r\n```\r\n\r\n## Packing\r\n\r\n[Packing][packing and unpacking] is the ability to group multiple values into one `list` that is assigned to a variable.\r\nThis is useful when you want to _unpack_ values, make changes, and then _pack_ the results back into a variable.\r\nIt also makes it possible to perform merges on 2 or more `lists`/`tuples`/`dicts`.\r\n\r\n### Packing a list/tuple with `*`\r\n\r\nPacking a `list`/`tuple` can be done using the `*` operator.\r\nThis will pack all the values into a `list`/`tuple`.\r\n\r\n```python\r\n>>> fruits = (\"apple\", \"banana\", \"cherry\")\r\n>>> more_fruits = [\"orange\", \"kiwi\", \"melon\", \"mango\"]\r\n\r\n# fruits and more_fruits are unpacked and then their elements are packed into combined_fruits\r\n>>> combined_fruits = *fruits, *more_fruits\r\n\r\n# If there is no * on to the left of the \"=\" the result is a tuple\r\n>>> combined_fruits\r\n(\"apple\", \"banana\", \"cherry\", \"orange\", \"kiwi\", \"melon\", \"mango\")\r\n\r\n# If the * operator is used on the left side of \"=\" the result is a list.\r\n# Note the trailing comma. \r\n>>> *combined_fruits_too, = *fruits, *more_fruits\r\n>>> combined_fruits_too\r\n['apple', 'banana', 'cherry', 'orange', 'kiwi', 'melon', 'mango']\r\n\r\n# A list literal can be used instead, but might not be as readable.\r\n>>> [*combined_fruits_too] = *fruits, *more_fruits\r\n>>> combined_fruits_too\r\n['apple', 'banana', 'cherry', 'orange', 'kiwi', 'melon', 'mango']\r\n```\r\n\r\nFor more details on the use of `*` and `**`, check out [PEP 3132][pep-3132] and [PEP 448][pep-448].\r\n\r\n### Packing a dictionary with `**`\r\n\r\nPacking a dictionary is done by using the `**` operator.\r\nThis will pack all **key**-**value** pairs from one dictionary into another dictionary, or combine two dictionaries together.\r\n\r\n```python\r\n>>> fruits_inventory = {\"apple\": 6, \"banana\": 2, \"cherry\": 3}\r\n>>> more_fruits_inventory = {\"orange\": 4, \"kiwi\": 1, \"melon\": 2, \"mango\": 3}\r\n\r\n# fruits_inventory and more_fruits_inventory are unpacked into key-values pairs and combined.\r\n>>> combined_fruits_inventory = {**fruits_inventory, **more_fruits_inventory}\r\n\r\n# then the pairs are packed into combined_fruits_inventory\r\n>>> combined_fruits_inventory\r\n{\"apple\": 6, \"banana\": 2, \"cherry\": 3, \"orange\": 4, \"kiwi\": 1, \"melon\": 2, \"mango\": 3}\r\n```\r\n\r\n## Usage of `*` and `**` with functions\r\n\r\n### Packing with function parameters\r\n\r\nWhen you create a function that accepts an arbitrary number of arguments, you can use [`*args` or `**kwargs`][args and kwargs] in the function definition.\r\n`*args` is used to pack an arbitrary number of positional (non-keyworded) arguments and\r\n`**kwargs` is used to pack an arbitrary number of keyword arguments.\r\n\r\nUsage of `*args`:\r\n\r\n```python\r\n# This function is defined to take any number of positional arguments\r\n\r\n>>> def my_function(*args):\r\n...   print(args)\r\n\r\n# Arguments given to the function are packed into a tuple\r\n\r\n>>> my_function(1, 2, 3)\r\n(1, 2, 3)\r\n\r\n>>> my_function(\"Hello\")\r\n(\"Hello\")\r\n\r\n>>> my_function(1, 2, 3, \"Hello\", \"Mars\")\r\n(1, 2, 3, \"Hello\", \"Mars\")\r\n```\r\n\r\nUsage of `**kwargs`:\r\n\r\n```python\r\n# This function is defined to take any number of keyword arguments\r\n\r\n>>> def my_function(**kwargs):\r\n...   print(kwargs)\r\n\r\n# Arguments given to the function are packed into a dictionary\r\n\r\n>>> my_function(a=1, b=2, c=3)\r\n{\"a\": 1, \"b\": 2, \"c\": 3}\r\n```\r\n\r\n`*args` and `**kwargs` can also be used in combination with one another:\r\n\r\n```python\r\n>>> def my_function(*args, **kwargs):\r\n...   print(sum(args))\r\n...   for key, value in kwargs.items():\r\n...       print(str(key) + \" = \" + str(value))\r\n\r\n>>> my_function(1, 2, 3, a=1, b=2, c=3)\r\n6\r\na = 1\r\nb = 2\r\nc = 3\r\n```\r\n\r\nYou can also write parameters before `*args` to allow for specific positional arguments.\r\nIndividual keyword arguments then have to appear before `**kwargs`.\r\n\r\n~~~~exercism/caution\r\n[Arguments have to be structured](https://www.python-engineer.com/courses/advancedpython/18-function-arguments/) like this:\r\n\r\n`def my_function(<positional_args>, *args, <key-word_args>, **kwargs)`\r\n\r\nIf you don't follow this order then you will get an error.\r\n~~~~\r\n\r\n```python\r\n>>> def my_function(a, b, *args):\r\n...   print(a)\r\n...   print(b)\r\n...   print(args)\r\n\r\n>>> my_function(1, 2, 3, 4, 5)\r\n1\r\n2\r\n(3, 4, 5)\r\n```\r\n\r\nWriting arguments in an incorrect order will result in an error:\r\n\r\n```python\r\n>>> def my_function(*args, a, b):\r\n...   print(args)\r\n\r\n>>>my_function(1, 2, 3, 4, 5)\r\nTraceback (most recent call last):\r\n  File \"c:\\something.py\", line 3, in <module>\r\n    my_function(1, 2, 3, 4, 5)\r\nTypeError: my_function() missing 2 required keyword-only arguments: 'a' and 'b'\r\n```\r\n\r\n### Unpacking into function calls\r\n\r\nYou can use `*` to unpack a `list`/`tuple` of arguments into a function call.\r\nThis is very useful for functions that don't accept an `iterable`:\r\n\r\n```python\r\n>>> def my_function(a, b, c):\r\n...   print(c)\r\n...   print(b)\r\n...   print(a)\r\n\r\nnumbers = [1, 2, 3]\r\n>>> my_function(*numbers)\r\n3\r\n2\r\n1\r\n```\r\n\r\nUsing `*` unpacking with the [`zip()` built-in][zip] is another common use case.\r\nThe `zip()` function takes multiple iterables and returns a `list` of `tuples` with the values from each `iterable` grouped:\r\n\r\n```python\r\n>>> values = (['x', 'y', 'z'], [1, 2, 3], [True, False, True])\r\n>>> a, *rest = zip(*values)\r\n>>> rest\r\n[('y', 2, False), ('z', 3, True)]\r\n```\r\n\r\n[args and kwargs]: https://www.geeksforgeeks.org/args-kwargs-python/\r\n[items]: https://docs.python.org/3/library/stdtypes.html#dict.items\r\n[multiple assignment]: https://www.geeksforgeeks.org/assigning-multiple-variables-in-one-line-in-python/\r\n[packing and unpacking]: https://www.geeksforgeeks.org/packing-and-unpacking-arguments-in-python/\r\n[pep-448]: https://peps.python.org/pep-0448/\r\n[pep-3132]: https://peps.python.org/pep-3132/\r\n[sorting algorithms]: https://realpython.com/sorting-algorithms-python/\r\n[unpacking]: https://www.geeksforgeeks.org/unpacking-arguments-in-python/?ref=rp\r\n[view-objects]: https://docs.python.org/3/library/stdtypes.html#dict-views\r\n[zip]: https://docs.python.org/3/library/functions.html#zip\r\n",
  "introduction": "# Unpacking and Multiple Assignment\r\n\r\nUnpacking refers to the act of extracting the elements of a collection, such as a `list`, `tuple`, or `dict`, using iteration.\r\nUnpacked values can then be assigned to variables within the same statement.\r\nA very common example of this behavior is `for item in list`, where `item` takes on the value of each `list` element in turn throughout the iteration.\r\n\r\n[Multiple assignment][multiple assignment] is the ability to assign multiple variables to unpacked values within one statement.\r\nThis allows for code to be more concise and readable, and is done by separating the variables to be assigned with a comma such as `first, second, third = (1,2,3)` or `for index, item in enumerate(iterable)`.\r\n\r\nThe special operators `*` and `**` are often used in unpacking contexts.\r\n`*` can be used to combine multiple `lists`/`tuples` into one `list`/`tuple` by _unpacking_ each into a new common `list`/`tuple`.\r\n`**` can be used to combine multiple dictionaries into one dictionary by _unpacking_ each into a new common `dict`.\r\n\r\nWhen the `*` operator is used without a collection, it _packs_ a number of values into a `list`.\r\nThis is often used in multiple assignment to group all \"leftover\" elements that do not have individual assignments into a single variable.\r\n\r\nIt is common in Python to also exploit this unpacking/packing behavior when using or defining functions that take an arbitrary number of positional or keyword arguments.\r\nYou will often see these \"special\" parameters defined as `def some_function(*args, **kwargs)` and the \"special\" arguments used as `some_function(*some_tuple, **some_dict)`.\r\n\r\n~~~~exercism/caution\r\n`*<variable_name>` and `**<variable_name>` should not be confused with `*` and `**`. While `*` and `**` are used for multiplication and exponentiation respectively, `*<variable_name>` and `**<variable_name>` are used as packing and unpacking operators.\r\n~~~~\r\n\r\n[multiple assignment]: https://www.geeksforgeeks.org/assigning-multiple-variables-in-one-line-in-python/\r\n",
  "links": [
    {
      "url": "https://treyhunner.com/2018/10/asterisks-in-python-what-they-are-and-how-to-use-them/",
      "description": "Trey Hunner: Asterisks in Python - What they are and How to Use Them."
    },
    {
      "url": "https://treyhunner.com/2018/03/tuple-unpacking-improves-python-code-readability/",
      "description": "Trey Hunner: Tuple Unpacking Improves Python Code Readability."
    },
    {
      "url": "https://stackabuse.com/unpacking-in-python-beyond-parallel-assignment/",
      "description": "Stack Abuse: Unpacking in Python Beyond Parallel Assignment."
    },
    {
      "url": "https://dbader.org/blog/python-nested-unpacking",
      "description": "Dan Bader: Python Nested Unpacking."
    },
    {
      "url": "https://peps.python.org/pep-3132/",
      "description": "Pep 3132: Extended Iterable Unpacking."
    },
    {
      "url": "https://peps.python.org/pep-0448/",
      "description": "PEP 0448: Additional Unpacking Generalizations."
    }
  ],
  "config": {}
}