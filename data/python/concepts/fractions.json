{
  "concept": "fractions",
  "about": "# About\r\n\r\nThe [`Fractions`][fractions] module allows us to create and work with [`rational numbers`][rational]: fractions with an integer numerator divided by an integer denominator.\r\n\r\nFor example, we can store `2/3` as an exact fraction instead of the approximate `float` value `0.6666...`\r\n\r\n## Creating Fractions\r\n\r\n\r\nUnlike `int`, `float`, and `complex` numbers, fractions do not have a literal form.\r\nHowever, the fractions constructor is quite flexible.\r\n\r\nMost obviously, it can take take two integers.\r\nCommon factors are automatically removed, converting the fraction to its \"lowest form\": the smallest integers that accurately represent the fraction.\r\n\r\n\r\n```python\r\n>>> from fractions import Fraction\r\n\r\n>>> f1 = Fraction(2, 3) # 2/3\r\n>>> f1\r\nFraction(2, 3)\r\n\r\n>>> f2 = Fraction(6, 9)\r\n>>> f2\r\nFraction(2, 3)  # automatically simplified\r\n\r\n>>> f1 == f2\r\nTrue\r\n```\r\n\r\nThe fractions constructor can also parse a string representation:\r\n\r\n\r\n```python\r\n>>> f3 = Fraction('2/3')\r\n>>> f3\r\nFraction(2, 3)\r\n```\r\n\r\nIt can also work with `float` parameters, but this may run into problems with the approximate nature of representing the decimal value internally as binary.\r\nFor more on this representation issue, see the [0.30000000000000004][0.30000000000000004] website, and [Floating Point Arithmetic: Issues and Limitations ][fp-issues] in the Python documentation. \r\n\r\nFor a more reliable result when using floats with fractions, there is the `<fraction>.limit_denominator()` method.\r\n\r\n\r\n[`.limit_denominator()`][limit_denominator] can take an integer parameter if you have specific requirements, but even the default (`max_denominator=1000000`) can work well and give an acceptable, simple approximation.\r\n\r\n```python\r\n>>> Fraction(1.2)\r\nFraction(5404319552844595, 4503599627370496)\r\n\r\n>>> Fraction(1.2).limit_denominator()\r\nFraction(6, 5)\r\n```\r\n\r\n## Arithmetic with Fractions\r\n\r\n\r\nThe usual [`arithmetic operators`][operators] `+ - * / **` work with fractions, as with other numeric types.\r\n\r\nIntegers and other `Fraction`s can be included and give a `Fraction` result.\r\nIncluding a `float` in the expression results in `float` output, with a consequent (possible) loss in precision.\r\n\r\n\r\n```python\r\n>>> Fraction(2, 3) + Fraction(1, 4) # addition\r\nFraction(11, 12)\r\n\r\n>>> Fraction(2, 3) * Fraction(6, 5) # multiply fractions\r\nFraction(4, 5)\r\n\r\n>>> Fraction(2, 3) * 6 / 5 # fraction with integers\r\nFraction(4, 5)\r\n\r\n>>> Fraction(2, 3) * 1.2  # fraction with float -> float\r\n0.7999999999999999\r\n\r\n>>> Fraction(2, 3) ** 2  # exponentiation with integer\r\nFraction(4, 9)\r\n```\r\n\r\n## Conversions to and from Fractions\r\n\r\n\r\nFractions are great for preserving precision during intermediate calculations, but may not be what you want for the final output.\r\n\r\nIt is possible to get the numerator and denominator individually or as a tuple ([`tuples`][tuple] will be discussed in a later Concept):\r\n\r\n```python\r\n>>> Fraction(2, 3).numerator\r\n2\r\n>>> Fraction(2, 3).denominator\r\n3\r\n>>> Fraction(2, 3).as_integer_ratio()\r\n(2, 3)\r\n```\r\n\r\nVarious standard Python numeric functions also give the result you might expect from working with `int` and `float` types:\r\n\r\n```python\r\n>>> round(Fraction(11, 3))\r\n4\r\n\r\n>>> from math import floor, ceil\r\n>>> floor(Fraction(11, 3))\r\n3\r\n>>> ceil(Fraction(11, 3))\r\n4\r\n\r\n>>> float(Fraction(11, 3))\r\n3.6666666666666665\r\n```\r\n\r\n[fractions]: https://docs.python.org/3/library/fractions.html\r\n[0.30000000000000004]: https://0.30000000000000004.com/\r\n[fp-issues]: https://docs.python.org/3/tutorial/floatingpoint.html#tut-fp-issues\r\n[tuple]: https://docs.python.org/3/tutorial/datastructures.html#tuples-and-sequences\r\n\r\n[operators]: https://docs.python.org/3/library/stdtypes.html#numeric-types-int-float-complex\r\n[rational]: https://en.wikipedia.org/wiki/Rational_number\r\n[limit_denominator]: https://docs.python.org/3/library/fractions.html\r\n",
  "introduction": "# Introduction\r\n\r\nThe [`Fractions`][fractions] module allows us to create and work with [`rational numbers`][rational]: fractions with an integer numerator divided by an integer denominator.\r\nFor example, we can store `2/3` as an exact fraction instead of the approximate `float` value `0.6666...`.\r\n\r\nUnlike `int`, `float`, and `complex` numbers, fractions do not have a literal form.\r\nHowever, the fractions constructor is quite flexible.\r\n\r\nMost obviously, it can take take two integers as arguments.\r\nCommon factors are automatically removed, converting the fraction to its \"lowest form\": the smallest integers that accurately represent the fraction:\r\n\r\n```python\r\n>>> from fractions import Fraction\r\n\r\n>>> f1 = Fraction(2, 3) # 2/3\r\n>>> f1\r\nFraction(2, 3)\r\n\r\n>>> f2 = Fraction(6, 9)\r\n>>> f2\r\nFraction(2, 3)  # automatically simplified\r\n\r\n>>> f1 == f2\r\nTrue\r\n```\r\n\r\nThe fractions constructor can also parse a string representation:\r\n\r\n```python\r\n>>> f3 = Fraction('2/3')\r\n>>> f3\r\nFraction(2, 3)\r\n```\r\n\r\nFractions can also work with `float` parameters, but this may run into problems with the approximate nature of representing the decimal value internally as binary.\r\nFor more on this representation issue, see the [0.30000000000000004][0.30000000000000004] website, and [Floating Point Arithmetic: Issues and Limitations ][fp-issues] in the Python documentation.\r\n\r\nFor a more reliable result when using floats with fractions, there is the `<fraction>.limit_denominator()` method.\r\n\r\n\r\n## Arithmetic with Fractions\r\n\r\nThe usual [`arithmetic operators`][operators] `+ - * / **` will work with fractions, as with other numeric types.\r\n\r\nIntegers and other `Fraction`s can be included in the equation and give a `Fraction` result.\r\nIncluding a `float` in the expression results in `float` output, with a consequent (possible) loss in precision:\r\n\r\n```python\r\n>>> Fraction(2, 3) + Fraction(1, 4) # addition\r\nFraction(11, 12)\r\n\r\n>>> Fraction(2, 3) * Fraction(6, 5) # multiply fractions\r\nFraction(4, 5)\r\n\r\n>>> Fraction(2, 3) * 6 / 5 # fraction with integers\r\nFraction(4, 5)\r\n\r\n>>> Fraction(2, 3) * 1.2  # fraction with float -> float\r\n0.7999999999999999\r\n\r\n>>> Fraction(2, 3) ** 2  # exponentiation with integer\r\nFraction(4, 9)\r\n```\r\n\r\nVarious standard Python numeric functions also give the result you might expect from working with `int` and `float` types:\r\n\r\n```python\r\n>>> round(Fraction(11, 3))\r\n4\r\n\r\n>>> from math import floor, ceil\r\n>>> floor(Fraction(11, 3))\r\n3\r\n>>> ceil(Fraction(11, 3))\r\n4\r\n\r\n>>> float(Fraction(11, 3))\r\n3.6666666666666665\r\n```\r\n\r\n[0.30000000000000004]: https://0.30000000000000004.com/\r\n[fp-issues]: https://docs.python.org/3/tutorial/floatingpoint.html#tut-fp-issues\r\n[fractions]: https://docs.python.org/3/library/fractions.html\r\n[operators]: https://docs.python.org/3/library/stdtypes.html#numeric-types-int-float-complex\r\n[rational]: https://en.wikipedia.org/wiki/Rational_number\r\n",
  "links": [
    {
      "url": "https://docs.python.org/3/library/fractions.html/",
      "description": "Documentation for the Fractions module."
    },
    {
      "url": "https://docs.python.org/3/tutorial/floatingpoint.html#tut-fp-issues",
      "description": "Limitations of Floating Point Arithmetic."
    },
    {
      "url": "https://leancrew.com/all-this/2023/08/decimal-to-fraction/",
      "description": "And now it's all this: Decimal to fraction."
    },
    {
      "url": "https://nrich.maths.org/2515",
      "description": "History of Fractions."
    }
  ],
  "config": {}
}