{
  "concept": "classes",
  "about": "# About\r\n\r\n`Classes` combine data with behavior.\r\nClasses are used to create copies or `instances` of bundled data and behavior, commonly known as `objects`.\r\nObjects can represent real world entities (_such as cars or cats_) - or more abstract concepts (_such as integers, vehicles, or mammals_).\r\nClasses are integral to an [object oriented programming][oop] (OOP) approach, which asks the programmer to think about modeling a problem as one or more objects that interact with one another, keep state, and act upon data.\r\n\r\n## Classes\r\n\r\nClasses are the definitions of new _object types_, and from which new `instances` of objects are created.\r\nThey often bundle data (_known as `fields`, `attributes`, `properties`, `data members`, or `variables`_) with code or functions (_known as `methods`_) that operate on that data.\r\nIn this sense, a class is a  _blueprint_ or a set of instructions from which many objects of a similar type can be built and used.\r\nA complex program can have many classes, each building many different flavors of objects.\r\nThe process of building and customizing an object from a class is known as `instantiation` (_or creating an instance of the class_).\r\n\r\nA class definition in Python is straightforward:\r\n\r\n```python\r\nclass MyClass:\r\n    # Class body goes here\r\n```\r\n\r\n### Class Attributes\r\n\r\nClass fields (_otherwise known as properties, attributes, data members, or variables_) can be added to the body of the class.\r\n\r\n```python\r\nclass MyClass:\r\n    number = 5\r\n    string = \"Hello!\"\r\n```\r\n\r\nAn instance (_object_) of `MyClass` can be created and bound to a name:\r\n\r\n```python\r\n>>> new_object = MyClass()\r\n\r\n# Class is instantiated and resulting object is bound to the \"new_object\" name (variable).\r\n# Note: the object address 'at 0x15adc55b0' will vary by computer.\r\n>>> new_object\r\n<__main__.MyClass at 0x15adc55b0>\r\n```\r\n\r\n`Class attributes` are shared across all objects (_or instances_) created from a class, and can be accessed via [`dot notation`][dot notation]  -  a `.` placed after the object name and before the attribute name:\r\n\r\n```python\r\n>>> new_object = MyClass()\r\n\r\n# Accessing the class attribute \"number\" via dot-notation.\r\n>>> new_object.number\r\n5\r\n\r\n# Accessing the class attribute \"string\" via dot-notation.\r\n>>> new_object.string\r\n'Hello!'\r\n\r\n# Instantiating an additional object and binding it to the \"second_new_object\" name.\r\n>>> second_new_object = MyClass()\r\n\r\n>>> second_new_object\r\n<__main__.MyClass at 0x15ad99970>\r\n\r\n# Second_new_object shares the same class attributes as new_object.\r\n>>> new_object.number == second_new_object.number\r\nTrue\r\n```\r\n\r\nClass attributes are defined in the body of the class itself, before any other methods.\r\nThey are owned by the class - allowing them to be shared across instances.\r\nBecause these attributes are shared by all instances of the class, their value can be accessed and manipulated from the class directly.\r\nAltering the value of class attributes alters the value _**for all objects instantiated from the class**_:\r\n\r\n```python\r\n>>> obj_one = MyClass()\r\n>>> obj_two = MyClass()\r\n\r\n# Accessing a class attribute from an object.\r\n>>> obj_two.number\r\n5\r\n\r\n# Accessing the class attribute from the class itself.\r\n>>> MyClass.number\r\n5\r\n\r\n# Modifying the value of the \"number\" class attribute.\r\n>>> MyClass.number = 27\r\n\r\n# Modifying the \"number\" class attribute changes the \"number\" attribute for all objects.\r\n>>> obj_one.number\r\n27\r\n\r\n>>> obj_two.number\r\n27\r\n```\r\n\r\nHaving a bunch of objects with synchronized data at all times is not particularly useful.\r\nFortunately, objects created from a class can be customized with their own `instance attributes` (_or instance properties, variables, or fields_).\r\nAs their name suggests, instance attributes are unique to each object, and can be modified independently.\r\n\r\n## Customizing Object Instantiation with `__init__()`\r\n\r\nThe special [\"dunder method\"][dunder] (_short for \"double underscore method\"_) `__init__()` is used to customize class instances, and can be used to initialize instance attributes or properties for objects.\r\nFor its role in initializing instance attributes, `__init__()` is also referred to as a `class constructor` or `initializer`.\r\n`__init__()` takes one required parameter called `self`, which refers to the newly initiated or created object.\r\nData for instance attributes or properties can then be passed as arguments of `__init__()`, following the `self` parameter.\r\n\r\nBelow, `MyClass` now has instance attributes called `location_x` and `location_y`.\r\nAs you can see, the two attributes have been assigned to the first and second indexes of the `location` (_a tuple_) argument that has been passed to `__init__()`.\r\nThe `location_x` and `location_y` attributes for a class instance will now be initialized when you instantiate the class and an object is created:\r\n\r\n```python\r\nclass MyClass:\r\n    # These are class attributes, variables, or fields.\r\n    number = 5\r\n    string = \"Hello!\"\r\n\r\n    # This is the class \"constructor\", with a \"location\" parameter that is a tuple.\r\n    def __init__(self, location):\r\n\r\n        # This is an instance or object property, attribute, or variable.\r\n        # Note that we are unpacking the tuple argument into two separate instance variables.\r\n        self.location_x = location[0]\r\n        self.location_y = location[1]\r\n\r\n# Create a new object \"new_object_one\", with object property (1, 2).\r\n>>> new_object_one = MyClass((1, 2))\r\n\r\n# Create a second new object \"new_object_two\" with object property (-8, -9).\r\n>>> new_object_two = MyClass((-8, -9))\r\n\r\n# Note that new_object_one.location_x and new_object_two.location_x two different values.\r\n>>> new_object_one.location_x\r\n1\r\n\r\n>>> new_object_two.location_x\r\n-8\r\n```\r\n\r\nNote that you only need to pass one argument when initializing `MyClass` above -- Python takes care of passing `self` when the class is called.\r\n\r\n~~~~exercism/advanced\r\nAnother way of creating an instance variable is to simply access a class variable via an object, and change it to something else:\r\n\r\n```python\r\n>>> obj_one = MyClass()\r\n>>> obj_two = MyClass()\r\n>>> MyClass.string\r\n'Hello!'\r\n\r\n>>> obj_two.string = \"Hi!\"\r\n>>> obj_two.string\r\n'Hi!'\r\n\r\n>>> obj_one.string\r\n'Hello!'\r\n```\r\n\r\nNow, watch what happens when the class variable changes:\r\n\r\n```python\r\n>>> MyClass.string = \"World!\"\r\n>>> obj_two.string\r\n\r\n# obj_two.string has not changed\r\n'Hi!'\r\n\r\n>>> obj_one.string\r\n\r\n# obj_one.string changed\r\n'World!'\r\n```\r\n\r\nThe attribute `string` is now an _instance variable_ in the case of `obj_two`, but remains a _class variable_ in `obj_one`.\r\n\r\nThis can also be done from within the class:\r\n\r\n```python\r\nclass Demo:\r\n    new_var = 3\r\n\r\n    def add_two(self):\r\n        self.new_var += 2\r\n```\r\n\r\nThe moment that `<object>.add_two()` is called, and `self.new_var += 2` is read, `new_var` changes from a class variable to an instance variable of the same name.\r\n\r\nThis can be useful during initialization when all instances of a class will need some attribute(s) to start with the same value.\r\nHowever, the instance variable then shadows* the class variable, making the class variable inaccessible from the instance where it is shadowed.\r\nGiven this situation, it may be safer and clearer to set instance attributes from the `__init__()` method as `self.<attribute>`.\r\n~~~~\r\n_*[_shadows_][shadowing]\r\n\r\n## Methods\r\n\r\nA `method` is a `function` that is bound to either the class itself (_known as a [class method][class method], which will be discussed in depth in a later exercise_) or an _instance_ of the class (object).\r\nMethods that operate on an object or instance need to be defined with `self` as the first parameter.\r\nYou can then define the rest of the parameters as you would for a \"normal\" or non-bound function.\r\nMethods that operate on a class need to be defined with the `@classmethod` decorator and (_by convention_) with `cls` as the first parameter.\r\nClass methods are called on a class directly without first creating an object from the class.\r\n\r\n```python\r\nclass MyClass:\r\n    number = 5\r\n    string = \"Hello!\"\r\n\r\n    # Class constructor.\r\n    def __init__(self, location):\r\n\r\n        # Instance properties\r\n        self.location_x = location[0]\r\n        self.location_y = location[1]\r\n\r\n    # Class method. Uses the @classmethod decorator, and cls as the first parameter.\r\n    # Can be called without first making an instance of the class.\r\n    @classmethod\r\n    def change_string(cls, new_string):\r\n        #Class attributes are referred to with cls.\r\n        cls.string = new_string\r\n        return cls.string\r\n\r\n    # Instance method.  Note \"self\" as first parameter.\r\n    def change_location(self, amount):\r\n        self.location_x += amount\r\n        self.location_y += amount\r\n        return self.location_x, self.location_y\r\n```\r\n\r\nLike attribute access, calling a method is as simple as putting a `.` after the object name and before the method name.\r\nThe called method does not need a copy of the object as a first parameter -- Python fills in `self` automatically:\r\n\r\n```python\r\nclass MyClass:\r\n    number = 5\r\n    string = \"Hello!\"\r\n\r\n    def __init__(self, location):\r\n        self.location_x = location[0]\r\n        self.location_y = location[1]\r\n\r\n    def change_location(self, amount):\r\n        self.location_x += amount\r\n        self.location_y += amount\r\n        return  self.location_x, self.location_y\r\n\r\n# Make a new test_object with location (3,7)\r\n>>> test_object = MyClass((3,7))\r\n>>> (test_object.location_x, test_object.location_y)\r\n(3,7)\r\n\r\n# Call change_location to increase location_x and location_y by 7.\r\n>>> test_object.change_location(7)\r\n(10, 14)\r\n```\r\n\r\nClass attributes can be accessed from within instance methods in the same way that they are accessed outside of the class:\r\n\r\n```python\r\nclass MyClass:\r\n    number = 5\r\n    string = \"Hello!\"\r\n\r\n    def __init__(self, location):\r\n        self.location_x = location[0]\r\n        self.location_y = location[1]\r\n\r\n    # Alter instance variable location_x and location_y\r\n    def change_location(self, amount):\r\n        self.location_x += amount\r\n        self.location_y += amount\r\n        return  self.location_x, self.location_y\r\n\r\n    # Alter class variable number for all instances from within an instance.\r\n    def increment_number(self):\r\n        # Increment the 'number' class variable by 1.\r\n        MyClass.number += 1\r\n\r\n\r\n>>> test_object_one = MyClass((0,0))\r\n>>> test_object_one.number\r\n5\r\n\r\n>>> test_object_two = MyClass((13, -3))\r\n>>> test_object_two.increment_number()\r\n>>> test_object_one.number\r\n6\r\n```\r\n\r\n## Placeholding or Stubbing Implementation with `pass`\r\n\r\nIn previous concept exercises and practice exercise stubs, you will have seen the `pass` keyword used within the body of functions in place of actual code.\r\n\r\nThe `pass` keyword is a syntactically valid placeholder - it prevents Python from throwing a syntax error for an empty function or class definition.\r\nEssentially, it is a way to say to the Python interpreter, 'Don't worry! I _will_ put code here eventually, I just haven't done it yet.'\r\n\r\n```python\r\nclass MyClass:\r\n    number = 5\r\n    string = \"Hello!\"\r\n\r\n    def __init__(self, location):\r\n        self.location_x = location[0]\r\n        self.location_y = location[1]\r\n\r\n    # Alter instance variable location_x and location_y.\r\n    def change_location(self, amount):\r\n        self.location_x += amount\r\n        self.location_y += amount\r\n        return  self.location_x, self.location_y\r\n\r\n    # Alter class variable number for all instances.\r\n    def increment_number(self):\r\n        # Increment the 'number' class variable by 1.\r\n        MyClass.number += 1\r\n\r\n    # This will compile and run without error, but has no current functionality.\r\n    def pending_functionality(self):\r\n       # Stubbing or place-holding the body of this method.\r\n       pass\r\n```\r\n\r\n[class method]: https://stackoverflow.com/questions/17134653/difference-between-class-and-instance-methods\r\n[dunder]: https://mathspp.com/blog/pydonts/dunder-methods\r\n[oop]: https://www.educative.io/blog/object-oriented-programming\r\n[dot notation]: https://stackoverflow.com/questions/45179186/understanding-the-dot-notation-in-python\r\n[shadowing]: https://oznetnerd.com/2017/07/17/python-shadowing/\r\n",
  "introduction": "# Introduction\r\n\r\nClasses are definitions combining data (_otherwise known as `attributes`, `properties`,`data members`, `variables`, or `fields`_) with `functions` (_otherwise known as `methods`_).\r\nClass definitions are used to create copies or `instances` of the `class`, commonly known as `objects`.\r\nObjects can represent real world entities (_such as cars or cats_) - or more abstract concepts (_such as integers, vehicles, or mammals_).\r\nEach object is unique in computer memory and represents some part of an overall model.\r\nClasses and objects can be found in several programming paradigms, but are integral to [object oriented programming][oop] (OOP), in which programs are made up of objects that interact with one another.\r\n\r\n[oop]:https://www.educative.io/blog/object-oriented-programming\r\n",
  "links": [
    {
      "url": "https://docs.python.org/3/tutorial/classes.html",
      "description": "The official Python classes tutorial."
    },
    {
      "url": "https://pybit.es/articles/when-classes/",
      "description": "A handy guide as to when to use classes, and when not to."
    },
    {
      "url": "https://realpython.com/python3-object-oriented-programming/",
      "description": "Another overview of what classes are and how to apply them in Python."
    },
    {
      "url": "https://www.pythonmorsels.com/topics/classes/",
      "description": "Python Morsels Rundown on Classes."
    },
    {
      "url": "https://dbader.org/blog/6-things-youre-missing-out-on-by-never-using-classes-in-your-python-code",
      "description": "6 Things You are Missing out on by never using classes in your Python code."
    },
    {
      "url": "http://python-history.blogspot.com/2010/06/inside-story-on-new-style-classes.html",
      "description": "The History of Python: The Inside Story on New-Style Classes."
    },
    {
      "url": "https://realpython.com/instance-class-and-static-methods-demystified/",
      "description": "Pythons Instance, Class, and Static Methods Demystified."
    },
    {
      "url": "https://stackabuse.com/pythons-classmethod-and-staticmethod-explained/",
      "description": "Python's @classmethod and @staticmethod Explained."
    },
    {
      "url": "https://www.digitalocean.com/community/tutorials/how-to-construct-classes-and-define-objects-in-python-3",
      "description": "An even gentler introduction to classes and objects from Digital Ocean."
    },
    {
      "url": "https://www.digitalocean.com/community/tutorials/understanding-class-and-instance-variables-in-python-3",
      "description": "An even gentler introduction to instance variables and class variables from Digital Ocean."
    }
  ],
  "config": {}
}