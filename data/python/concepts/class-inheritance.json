{
  "concept": "class-inheritance",
  "about": "# About\r\n\r\nInheritance is one of the ['four pillars'][four-pillars] of Object Oriented Programming (`OOP`).\r\nIn situations where only a small amount of functionality needs to be customized for a new class, `inheritance` allows code re-use from one or more parent classes, and can help make programs cleaner and more maintainable.\r\n\r\n## Inheritance\r\n\r\n`Inheritance` describes `is a kind of` relationship between two or more classes, abstracting common details into super (_base_ or _parent_) class and storing specific ones in the subclass (_derived class_ or _child class_).\r\n\r\nTo create a child class, specify the parent class name inside the pair of parenthesis, followed by its name.\r\nExample\r\n```python\r\nclass Child(Parent):  \r\n   pass\r\n```\r\nEvery child class inherits all the behaviors (_attributes, constructors, methods_) exhibited by their parent class.\r\n \r\n\r\n## Single Inheritance\r\n\r\nWhen a derived (or child) class inherits only from one base (or parent) class, it is known as _single inheritance_.\r\n\r\n\r\n```python\r\n# The parent or base class.\r\nclass Person:\r\n\r\n    def __init__(self, fname, lname):\r\n        self.fname = fname\r\n        self.lname = lname\r\n\r\n# The child or derived class, inheriting from Person.                \r\nclass Employee(Person):\r\n\r\n    all_employees = []\r\n    def __init__(self, fname, lname, empid):\r\n        # Using the Parent constructor to create the base object.\r\n        Person.__init__(self, fname, lname)\r\n\r\n        # Adding an attribute specific to the Child class.\r\n        self.empid = empid\r\n\r\n        Employee.all_employees.append(self)\r\n```\r\n`Employee` class is derived from `Person`.\r\nNow, we can create an `Employee` object.\r\n\r\n\r\n```python\r\n...\r\np1 = Person('George', 'smith')\r\nprint(p1.fname, '-', p1.lname)\r\ne1 = Employee('Jack', 'simmons', 456342)\r\ne2 = Employee('John', 'williams', 123656)\r\nprint(e1.fname, '-', e1.empid)\r\nprint(e2.fname, '-', e2.empid)\r\n```\r\nAfter running the program we will get the following output\r\n```bash\r\n\r\nGeorge - smith\r\nJack - 456342\r\nJohn - 123656\r\n```\r\n## Multiple Inheritance\r\nAs we've seen, `single inheritance` is where a class inherits directly from another class. \r\nOn the other side, `multiple inheritance` is a Python feature that allows a child class to inherit characteristics and methods from more than one parent class.\r\n\r\n```python\r\nclass SubclassName(BaseClass1, BaseClass2, ...):\r\n    pass\r\n```\r\n### Multiple Inheritance and the Diamond Problem\r\n\r\nThe \"diamond problem\" (also known as the \"deadly diamond of death\") refers to an ambiguity that occurs when two classes B and C inherit from a superclass A, while another class D inherits from both B and C. If A has a method \"m\" that B or C (or even both of them) has overridden, and if it does not override this method, the question becomes which version of the method D inherits. It's possible that it's from A, B, or C.\r\nLet's have a look at the problem using an example:\r\n\r\n```python\r\nclass A:\r\n    def m(self):\r\n        print(\"m of A called\")\r\nclass B(A):\r\n    def m(self):\r\n        print(\"m of B called\")\r\nclass C(A):\r\n    def m(self):\r\n        print(\"m of C called\")\r\nclass D(B,C):\r\n    pass\r\n```\r\nIf we call an instance x of class D, we will get the output as `m of B called`. But if we interchange the order of inheritance in class D i.e. `Class D(C, D)`. We will get the output as `m of C called`. \r\nTo solve the diamond problem in python, we will look into a new method `mro()`.\r\n### Method resolution order(MRO)\r\n\r\nTo get the method resolution order of a class we can use either `__mro__` attribute or `mro()` method. By using these methods we can display the order in which methods are resolved. For Example\r\n\r\n```python\r\nclass A:\r\n    def m(self):\r\n        print(\" m of A called\")\r\nclass B:\r\n    def m(self):\r\n        print(\" m of B called\")\r\n  \r\n# classes ordering\r\nclass C(A, B):\r\n    def __init__(self):\r\n        print(\"Constructor C\")\r\n  \r\nr = C()\r\n  \r\n# it prints the lookup order \r\nprint(C.__mro__)\r\nprint(C.mro())\r\n```\r\nThe output \r\n```cmd\r\nConstructor C\r\n(<class '__main__.C'>, <class '__main__.A'>, <class '__main__.B'>, <class 'object'>)\r\n[<class '__main__.C'>, <class '__main__.A'>, <class '__main__.B'>, <class 'object'>]\r\n```\r\n### Mixins\r\nA mixin is a type of multiple inheritance that is unique. Mixins are typically employed in one of two scenarios:\r\n\r\n1. We wish to give a class a number of optional features.\r\n1. We want to use a specific feature in a variety of classes.\r\n\r\nFor example \r\n```python\r\nclass A1(object):\r\n    def method(self):\r\n        return 1\r\n\r\nclass A2(object):\r\n    def method(self):\r\n        return 2\r\n\r\nclass B1(object):\r\n    def usesMethod(self):\r\n        return self.method() + 10\r\n\r\nclass B2(object):\r\n    def usesMethod(self):\r\n        return self.method() + 20\r\n\r\nclass C1_10(A1, B1): pass\r\nclass C1_20(A1, B2): pass\r\nclass C2_10(A2, B1): pass\r\nclass C2_20(A2, B2): pass\r\n```\r\nMixins helps us to recombine functionalities with different choices of base classes.\r\n#### Pros and Cons of Mixins\r\n| Advantages | Disadvantages |\r\n|:-- | :-- |\r\n|Mixin classes tend to be simple because they represent simple orthogonal concepts. | Execution of statements at run time tends to jump around in different mixins, making it hard to follow and debug|\r\n|Helps us to recombine functionalities with different choices | Potential for long compile times|\r\n## __super()__\r\nIn a nutshell, `super()` gives us access to methods in a superclass from the subclass that inherits from it.\r\n`super()` by itself returns a temporary object of the superclass, which may subsequently be used to call the methods of that superclass.\r\n\r\nBut why we want to use `super()`?\r\n\r\nUsing `super()` to call already created methods avoids having to rebuild those methods in our subclass and allows us to swap out superclasses with little code modifications.\r\n\r\n[four-pillars]: https://www.educative.io/edpresso/what-are-the-four-pillars-of-oops-in-python\r\n\r\n[four-pillars]: https://www.educative.io/edpresso/what-are-the-four-pillars-of-oops-in-python\r\n\r\n",
  "introduction": "# Introduction\r\n\r\n[Inheritance](inherit) represents what is known as a relationship. When a Derived class inherits from a Base class, you've established a relationship in which Derived is a specialised version of Base.\r\nEither by using single or multiple inheritance, we can inherit the properties from the base class. Inheritance is used because it helps in code reusability.\r\n\r\n\r\n[inherit]:https://realpython.com/inheritance-composition-python/#whats-inheritance\r\n",
  "links": [
    {
      "url": "https://docs.python.org/3/tutorial/classes.html",
      "description": "Classes in python"
    },
    {
      "url": "https://www.geeksforgeeks.org/access-modifiers-in-python-public-private-and-protected/",
      "description": "Access Modifiers in python"
    },
    {
      "url": "https://www.geeksforgeeks.org/accessor-and-mutator-methods-in-python/",
      "description": "Functions in classes"
    },
    {
      "url": "https://realpython.com/inheritance-composition-python/#whats-inheritance",
      "description": "About inheritance"
    },
    {
      "url": "https://python-course.eu/oop/multiple-inheritance.php",
      "description": "Multiple inheritance and Diamond inheritance problem"
    },
    {
      "url": "https://stackoverflow.com/questions/533631/what-is-a-mixin-and-why-are-they-useful",
      "description": "Python mixins"
    },
    {
      "url": "https://raganwald.com/2016/07/16/why-are-mixins-considered-harmful.html",
      "description": "Mixins cons"
    },
    {
      "url": "https://gaopinghuang0.github.io/2018/12/29/dig-into-python-super-and-mro",
      "description": "Super and mixins functions"
    },
    {
      "url": "https://www.python.org/download/releases/2.3/mro/",
      "description": "MRO"
    },
    {
      "url": "https://nedbatchelder.com/blog/201210/multiple_inheritance_is_hard.html",
      "description": "Multiple inheritancs and mixins"
    }
  ],
  "config": {}
}