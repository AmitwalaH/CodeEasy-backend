{
  "concept": "sets",
  "about": "# Sets\r\n\r\nA [`set`][type-set] is a _mutable_ and _unordered_ collection of [_hashable_][hashable] objects.\r\nSet members must be distinct ‚Äî duplicate items are not allowed.\r\nThey can hold multiple different data types and even nested structures like a `tuple` of `tuples` ‚Äî as long as all elements can be _hashed_.\r\nSets also come in an immutable [`frozensets`][type-frozenset] flavor.\r\n\r\nSets are most commonly used to quickly remove duplicates from other data structures or item groupings.\r\nThey are also used for efficient comparisons when sequencing and duplicate tracking are not needed.\r\n\r\nLike other collection types (_dictionaries, lists, tuples_), `sets` support:\r\n- Iteration via `for item in <set>`\r\n- Membership checking via `in` and `not in`,\r\n- Length calculation through `len()`, and\r\n- Shallow copies through `copy()`\r\n\r\n`sets` do not support:\r\n- Indexing of any kind\r\n- Ordering via sorting or insertion\r\n- Slicing\r\n- Concatenation via `+`\r\n\r\n\r\nChecking membership in a `set` has constant time complexity (on average) versus checking membership in a `list` or `string`, where the time complexity grows as the length of the data increases.\r\nMethods such as `<set>.union()`, `<set>.intersection()`, or `<set>.difference()` also have constant time complexity (on average).\r\n\r\n\r\n## Set Construction\r\n\r\nWhile sets can be created in many different ways, the most straightforward construction methods are declaring a _set literal_, using the `set` class constructor (`set()`), and using a _set comprehension_.\r\n\r\n### Set Literals\r\n\r\nA `set` can be directly entered as a _set literal_ with curly `{}` brackets and commas between elements.\r\nDuplicates are silently omitted:\r\n\r\n\r\n```python\r\n>>> one_element = {'‚ûï'}\r\n{'‚ûï'}\r\n\r\n>>> multiple_elements = {'‚ûï', 'üîª', 'üîπ', 'üîÜ'}\r\n{'‚ûï', 'üîª', 'üîπ', 'üîÜ'}\r\n\r\n>>> multiple_duplicates =  {'Hello!', 'Hello!', 'Hello!', \r\n                            '¬°Hola!','–ü—Ä–∏–≤—ñ—Ç!', '„Åì„Çì„Å´„Å°„ÅØÔºÅ', \r\n                            '¬°Hola!','–ü—Ä–∏–≤—ñ—Ç!', '„Åì„Çì„Å´„Å°„ÅØÔºÅ'}\r\n{'„Åì„Çì„Å´„Å°„ÅØÔºÅ', '¬°Hola!', 'Hello!', '–ü—Ä–∏–≤—ñ—Ç!'}\r\n```\r\n\r\nSet literals use the same curly braces as `dict` literals, which means you need to use `set()` to create an empty `set`.\r\n\r\n### The Set Constructor\r\n\r\n`set()` (_the constructor for the `set` class_) can be used with any `iterable` passed as an argument.\r\nElements of the `iterable` are cycled through and added to the `set` individually.\r\nElement order is not preserved and duplicates are silently omitted:\r\n\r\n\r\n```python\r\n# To create an empty set, the constructor must be used.\r\n>>> no_elements = set()\r\nset()\r\n\r\n# The tuple is unpacked & each element is added.  \r\n# Duplicates are removed.\r\n>>> elements_from_tuple = set((\"Parrot\", \"Bird\", \r\n                               334782, \"Bird\", \"Parrot\"))\r\n{334782, 'Bird', 'Parrot'}\r\n\r\n# The list is unpacked & each element is added.\r\n# Duplicates are removed.\r\n>>> elements_from_list = set([2, 3, 2, 3, 3, 3, 5, \r\n                              7, 11, 7, 11, 13, 13])\r\n{2, 3, 5, 7, 11, 13}\r\n```\r\n\r\n### Set Comprehensions\r\n\r\nLike `lists` and `dicts`, sets can be created via _comprehension_:\r\n\r\n```python\r\n# First, a list with duplicates\r\n>>> numbers = [1,2,3,4,5,6,6,5,4,8,9,9,9,2,3,12,18]\r\n\r\n# This set comprehension squares the numbers divisible by 3\r\n# Duplicates are removed.\r\n>>> calculated = {item**2 for item in numbers if item % 3 == 0}\r\n{9, 36, 81, 144, 324}\r\n```\r\n\r\n### Gotchas when Creating Sets\r\n\r\nDue to its \"unpacking\" behavior, using the `set` constructor with a string might be surprising:\r\n\r\n```python\r\n# String elements (Unicode code points) are \r\n# iterated through and added *individually*.\r\n>>> elements_string = set(\"Timbuktu\")\r\n{'T', 'b', 'i', 'k', 'm', 't', 'u'}\r\n\r\n# Unicode separators and positioning code points \r\n# are also added *individually*.\r\n>>> multiple_code_points_string = set('‡§Ö‡§≠‡•ç‡§Ø‡§æ‡§∏')\r\n{'‡§Ö', '‡§≠', '‡§Ø', '‡§∏', '‡§æ', '‡•ç'}\r\n```\r\n\r\nRemember: sets can hold different datatypes and _nested_ datatypes, but all `set` elements must be _hashable_:\r\n\r\n```python\r\n# Attempting to use a list for a set member throws a TypeError\r\n>>> lists_as_elements = {['üåà','üí¶'], \r\n                        ['‚òÅÔ∏è','‚≠êÔ∏è','üåç'], \r\n                        ['‚õµÔ∏è', 'üö≤', 'üöÄ']}\r\n\r\nTraceback (most recent call last):\r\n  File \"<stdin>\", line 1, in <module>\r\nTypeError: unhashable type: 'list'\r\n\r\n\r\n# Standard sets are mutable, so they cannot be hashed.\r\n>>> sets_as_elements = {{'üåà','üí¶'}, \r\n                        {'‚òÅÔ∏è','‚≠êÔ∏è','üåç'}, \r\n                        {'‚õµÔ∏è', 'üö≤', 'üöÄ'}}\r\n\r\nTraceback (most recent call last):\r\n  File \"<stdin>\", line 1, in <module>\r\nTypeError: unhashable type: 'set'\r\n```\r\n\r\nHowever, a  `set` of `sets` can be created via type `frozenset()`:\r\n\r\n```python\r\n# Frozensets don't have a literal form.\r\n>>> set_1 = frozenset({'üåà','üí¶'})\r\n>>> set_2 = frozenset({'‚òÅÔ∏è','‚≠êÔ∏è','üåç'})\r\n>>> set_3 = frozenset({'‚õµÔ∏è', 'üö≤', 'üöÄ'})\r\n\r\n>>> frozen_sets_as_elements = {set_1, set_2, set_3}\r\n>>> frozen_sets_as_elements\r\n{frozenset({'‚õµÔ∏è', 'üöÄ', 'üö≤'}),\r\n frozenset({'üåà', 'üí¶'}),\r\n frozenset({'‚òÅÔ∏è', '‚≠êÔ∏è', 'üåç'})}\r\n```\r\n\r\n\r\n## Adding and Removing Set Members\r\n\r\nElements can be added or removed from a `set` using the methods `<set>.add(<item>)` and `<set>.remove(<item>)`.\r\nThe `.remove(<item>)` method will raise a `KeyError` if the item is not present in the `set`:\r\n\r\n```python\r\n>>> creatures = {'crow', 'duck', 'fish', 'monkey', 'elephant'}\r\n>>> creatures.add('beaver')\r\n>>> creatures.remove('duck')\r\n>>> creatures\r\n{'beaver', 'crow', 'elephant', 'fish', 'monkey'}\r\n\r\n# Trying to remove an item that is not present raises a KeyError\r\n>>> creatures.remove('bear')\r\nTraceback (most recent call last):\r\n  File \"<stdin>\", line 1, in <module>\r\n  KeyError: 'bear'\r\n```\r\n\r\n### Additional Strategies for Removing Set Members\r\n\r\n- `<set>.discard(<item>)` will remove an item from the `set`, but will **not** raise a `KeyError` if the item is not present.\r\n- `<set>.clear()` will remove all items from the set.\r\n- `<set>.pop()` will remove and _return_ an **arbitrary** item, and raises a `KeyError` if the `set` is empty.\r\n\r\n\r\n## Set Operations\r\n\r\nSets have methods that generally mimic [mathematical set operations][mathematical-sets].\r\nMost (_not all_) of these methods have an [operator][operator] equivalent.\r\nMethods generally take any `iterable` as an argument, while operators require that both sides of the operation are `sets` or `frozensets`.\r\n\r\n\r\n### Membership Testing Between Sets\r\n\r\nThe `<set>.isdisjoint(<other_collection>)` method is used to test if a `sets` elements have any overlap with the elements of another.\r\nThe method will accept any `iterable` or `set` as an argument.\r\nIt will return `True` if the two sets have **no elements in common**, `False` if elements are **shared**.\r\n\r\n```python\r\n# Both mammals and additional_animals are lists.\r\n>>> mammals = ['squirrel','dog','cat','cow', 'tiger', 'elephant']\r\n>>> additional_animals = ['pangolin', 'panda', 'parrot', \r\n                          'lemur', 'tiger', 'pangolin']\r\n\r\n# Animals is a dict.\r\n>>> animals = {'chicken': 'white',\r\n               'sparrow': 'grey',\r\n               'eagle': 'brown and white',\r\n               'albatross': 'grey and white',\r\n               'crow': 'black',\r\n               'elephant': 'grey', \r\n               'dog': 'rust',\r\n               'cow': 'black and white',\r\n               'tiger': 'orange and black',\r\n               'cat': 'grey',\r\n               'squirrel': 'black'}\r\n               \r\n# Birds is a set.\r\n>>> birds = {'crow','sparrow','eagle','chicken', 'albatross'}\r\n\r\n# Mammals and birds don't share any elements.\r\n>>> birds.isdisjoint(mammals)\r\nTrue\r\n\r\n# There are also no shared elements between \r\n# additional_animals and birds.\r\n>>> birds.isdisjoint(additional_animals)\r\nTrue\r\n\r\n# Animals and mammals have shared elements.\r\n# **Note** The first object needs to be a set or converted to a set\r\n# since .isdisjoint() is a set method.\r\n>>> set(animals).isdisjoint(mammals)\r\nFalse\r\n```\r\n\r\n### Checking for Subsets and Supersets\r\n\r\n`<set>.issubset(<other_collection>)` is used to check if every element in `<set>` is also in `<other_collection>`.\r\nThe operator form is `<set> <= <other_set>`:\r\n\r\n```python\r\n# Set methods will take any iterable as an argument.\r\n# All members of birds are also members of animals.\r\n>>> birds.issubset(animals)\r\nTrue\r\n\r\n# All members of mammals also appear in animals.\r\n# **Note** The first object needs to be a set or converted to a set\r\n# since .issubset() is a set method.\r\n>>> set(mammals).issubset(animals)\r\nTrue\r\n\r\n# Both objects need to be sets to use a set operator\r\n>>> birds <= set(mammals)\r\nFalse\r\n\r\n# A set is always a loose subset of itself.\r\n>>> set(additional_animals) <= set(additional_animals)\r\nTrue\r\n```\r\n\r\n`<set>.issuperset(<other_collection>)` is the inverse of `.issubset()`.\r\nIt is used to check if every element in `<other_collection>` is also in `<set>`.\r\nThe operator form is `<set> >= <other_set>`:\r\n\r\n\r\n```python\r\n# All members of mammals also appear in animals.\r\n# **Note** The first object needs to be a set or converted to a set\r\n# since .issuperset() is a set method.\r\n>>> set(animals).issuperset(mammals)\r\nTrue\r\n\r\n# All members of animals do not show up as members of birds.\r\n>>> birds.issuperset(animals)\r\nFalse\r\n\r\n# Both objects need to be sets to use a set operator\r\n>>> birds >= set(mammals)\r\nFalse\r\n\r\n# A set is always a loose superset of itself.\r\n>>> set(animals) >= set(animals)\r\nTrue\r\n```\r\n\r\n### 'Proper' Subsets and Supersets\r\n\r\n`<set> < <other_set>` and `<set> > <other_set>` are used to test for _proper subsets_.\r\nA `set` is a proper subset if (`<set>` <= `<other_set>`) **AND** (`<set>` != `<other_set>`) for the `<` operator.\r\n\r\nA `set is a proper superset if `(`<set>` >= `<other_set>`) **AND** (`<set>` != `<other_set>`) for the `>` operator.\r\nThese operators have no method equivalent:\r\n\r\n```python\r\n>>> animal_names = {'albatross','cat','chicken','cow','crow','dog',\r\n                   'eagle','elephant','sparrow','squirrel','tiger'}\r\n\r\n>>> animals_also = {'albatross','cat','chicken','cow','crow','dog',\r\n                   'eagle','elephant','sparrow','squirrel','tiger'}\r\n\r\n>>> mammals = {'squirrel','dog','cat','cow', 'tiger', 'elephant'}\r\n>>> birds   = {'crow','sparrow','eagle','chicken', 'albatross'}\r\n\r\n>>> mammals < animal_names\r\nTrue\r\n\r\n>>> animal_names > birds\r\nTrue\r\n\r\n# A set is not a *proper subset* if set == other set.\r\n>>> animals_also < animal_names\r\nFalse\r\n\r\n# A set is never a *proper subset* of itself\r\n>>> animals_also < animals_also\r\nFalse\r\n```\r\n\r\n### Set Unions\r\n\r\n`<set>.union(*<other iterables>)` returns a new `set` with elements from `<set>` and all `<other iterables>`.\r\nThe operator form of this method is `<set> | <other set 1> | <other set 2> | ... | <other set n>`.\r\n\r\n```python\r\n>>> perennials = {'Asparagus', 'Broccoli', 'Sweet Potato', 'Kale'}\r\n>>> annuals = {'Corn', 'Zucchini', 'Sweet Peas', 'Summer Squash'}\r\n>>> more_perennials = ['Radicchio', 'Rhubarb', \r\n                      'Spinach', 'Watercress']\r\n\r\n# Methods will take any iterable as an argument.\r\n>>> perennials.union(more_perennials)\r\n{'Asparagus','Broccoli','Kale','Radicchio','Rhubarb',\r\n'Spinach','Sweet Potato','Watercress'}\r\n\r\n# Operators require sets.\r\n>>> set(more_perennials) | perennials\r\n{'Asparagus',\r\n 'Broccoli',\r\n 'Kale',\r\n 'Radicchio',\r\n 'Rhubarb',\r\n 'Spinach',\r\n 'Sweet Potato',\r\n 'Watercress'}\r\n```\r\n\r\n### Set Differences\r\n\r\n`<set>.difference(*<other iterables>)` returns a new `set` with elements from the original `<set>` that are not in `<others>`.\r\nThe operator version of this method is `<set> - <other set 1> - <other set 2> - ...<other set n>`.\r\n\r\n```python\r\n>>> berries_and_veggies = {'Asparagus', \r\n                          'Broccoli', \r\n                          'Watercress', \r\n                          'Goji Berries', \r\n                          'Goose Berries', \r\n                          'Ramps', \r\n                          'Walking Onions', \r\n                          'Blackberries', \r\n                          'Strawberries', \r\n                          'Rhubarb', \r\n                          'Kale', \r\n                          'Artichokes', \r\n                          'Currants'}\r\n\r\n>>> veggies = ('Asparagus', 'Broccoli', 'Watercress', 'Ramps',\r\n               'Walking Onions', 'Rhubarb', 'Kale', 'Artichokes')\r\n\r\n# Methods will take any iterable as an argument.\r\n>>> berries = berries_and_veggies.difference(veggies)\r\n{'Blackberries','Currants','Goji Berries',\r\n 'Goose Berries', 'Strawberries'}\r\n\r\n# Operators require sets.\r\n>>> berries_and_veggies - berries\r\n{'Artichokes','Asparagus','Broccoli','Kale',\r\n'Ramps','Rhubarb','Walking Onions','Watercress'}\r\n```\r\n\r\n### Set Intersections\r\n\r\n`<set>.intersection(*<other iterables>)` returns a new `set` with elements common to the original `set` and all `<others>` (in other words, the `set` where everything [intersects][intersection]).\r\nThe operator version of this method is  `<set> & <other set> & <other set 2> & ... <other set n>`\r\n\r\n```python\r\n>>> perennials = {'Annatto','Asafetida','Asparagus','Azalea',\r\n                 'Winter Savory', 'Broccoli','Curry Leaf','Fennel', \r\n                 'Kaffir Lime','Kale','Lavender','Mint','Oranges',\r\n                 'Oregano', 'Tarragon', 'Wild Bergamot'}\r\n\r\n>>> annuals = {'Corn', 'Zucchini', 'Sweet Peas', 'Marjoram', \r\n              'Summer Squash', 'Okra','Shallots', 'Basil', \r\n              'Cilantro', 'Cumin', 'Sunflower', 'Chervil', \r\n              'Summer Savory'}\r\n\r\n>>> herbs = ['Annatto','Asafetida','Basil','Chervil','Cilantro',\r\n            'Curry Leaf','Fennel','Kaffir Lime','Lavender',\r\n            'Marjoram','Mint','Oregano','Summer Savory' \r\n            'Tarragon','Wild Bergamot','Wild Celery',\r\n            'Winter Savory']\r\n\r\n\r\n# Methods will take any iterable as an argument.\r\n>>> perennial_herbs = perennials.intersection(herbs)\r\n{'Annatto', 'Asafetida', 'Curry Leaf', 'Fennel', 'Kaffir Lime',\r\n 'Lavender', 'Mint', 'Oregano', 'Wild Bergamot','Winter Savory'}\r\n\r\n# Operators require both groups be sets.\r\n>>> annuals & set(herbs)\r\n {'Basil', 'Chervil', 'Marjoram', 'Cilantro'}\r\n```\r\n\r\n### Set Symmetric Differences\r\n\r\n`<set>.symmetric_difference(<other iterable>)` returns a new `set` that contains elements that are in `<set>` OR `<other>`, but **not in both**.\r\nThe operator version of this method is  `<set> ^ <other set>`.\r\n\r\n```python\r\n>>> plants_1 = {'üå≤','üçà','üåµ', 'ü•ë','üå¥', 'ü•≠'}\r\n>>> plants_2 = ('üå∏','üå¥', 'üå∫', 'üå≤', 'üåª', 'üåµ')\r\n\r\n\r\n# Methods will take any iterable as an argument.\r\n>>> fruit_and_flowers = plants_1.symmetric_difference(plants_2)\r\n>>> fruit_and_flowers\r\n{'üå∏', 'üå∫', 'üçà', 'ü•ë', 'ü•≠','üåª' }\r\n\r\n\r\n# Operators require both groups be sets.\r\n>>> fruit_and_flowers ^ plants_1\r\n{'üå≤',  'üå∏', 'üå¥', 'üåµ','üå∫', 'üåª'}\r\n\r\n>>> fruit_and_flowers ^ plants_2\r\n{ 'ü•ë', 'üå¥','üå≤', 'üåµ', 'üçà', 'ü•≠'}\r\n```\r\n\r\n~~~~exercism/note\r\n\r\nA symmetric difference of more than two sets will result in a `set` that includes both the elements unique to each `set` AND elements shared between more than two sets in the series (_details in the Wikipedia article on [symmetric difference][symmetric_difference]_).  \r\n\r\nTo obtain only items unique to each `set` in the series, intersections between all 2-set combinations need to be aggregated in a separate step, and removed:  \r\n\r\n\r\n```python\r\n>>> one = {'black pepper','breadcrumbs','celeriac','chickpea flour',\r\n           'flour','lemon','parsley','salt','soy sauce',\r\n           'sunflower oil','water'}\r\n\r\n>>> two = {'black pepper','cornstarch','garlic','ginger',\r\n           'lemon juice','lemon zest','salt','soy sauce','sugar',\r\n           'tofu','vegetable oil','vegetable stock','water'}\r\n\r\n>>> three = {'black pepper','garlic','lemon juice','mixed herbs',\r\n             'nutritional yeast', 'olive oil','salt','silken tofu',\r\n             'smoked tofu','soy sauce','spaghetti','turmeric'}\r\n\r\n>>> four = {'barley malt','bell pepper','cashews','flour',\r\n            'fresh basil','garlic','garlic powder', 'honey',\r\n            'mushrooms','nutritional yeast','olive oil','oregano',\r\n            'red onion', 'red pepper flakes','rosemary','salt',\r\n            'sugar','tomatoes','water','yeast'}\r\n\r\n>>> intersections = (one & two | one & three | one & four | \r\n                     two & three | two & four | three & four)\r\n...\r\n{'black pepper','flour','garlic','lemon juice','nutritional yeast', \r\n'olive oil','salt','soy sauce', 'sugar','water'}\r\n\r\n# The ^ operation will include some of the items in intersections, \r\n# which means it is not a \"clean\" symmetric difference - there\r\n# are overlapping members.\r\n>>> (one ^ two ^ three ^ four) & intersections\r\n{'black pepper', 'garlic', 'soy sauce', 'water'}\r\n\r\n# Overlapping members need to be removed in a separate step\r\n# when there are more than two sets that need symmetric difference.\r\n>>> (one ^ two ^ three ^ four) - intersections\r\n...\r\n{'barley malt','bell pepper','breadcrumbs', 'cashews','celeriac',\r\n  'chickpea flour','cornstarch','fresh basil', 'garlic powder',\r\n  'ginger','honey','lemon','lemon zest','mixed herbs','mushrooms',\r\n  'oregano','parsley','red onion','red pepper flakes','rosemary',\r\n  'silken tofu','smoked tofu','spaghetti','sunflower oil', 'tofu', \r\n  'tomatoes','turmeric','vegetable oil','vegetable stock','yeast'}\r\n```\r\n\r\n[symmetric_difference]: https://en.wikipedia.org/wiki/Symmetric_difference\r\n~~~~\r\n\r\n[hashable]: https://docs.python.org/3.7/glossary.html#term-hashable\r\n[mathematical-sets]: https://en.wikipedia.org/wiki/Set_theory#Basic_concepts_and_notation\r\n[operator]: https://www.computerhope.com/jargon/o/operator.htm\r\n[type-frozenset]: https://docs.python.org/3/library/stdtypes.html#frozenset\r\n[type-set]: https://docs.python.org/3/library/stdtypes.html#set\r\n[intersection]: https://www.mathgoodies.com/lessons/sets/intersection\r\n",
  "introduction": "# Sets\r\n\r\nA [`set`][type-set] is a _mutable_ and _unordered_ collection of [_hashable_][hashable] objects.\r\nSet members must be distinct ‚Äî duplicate items are not allowed.\r\nThey can hold multiple different data types and even nested structures like a `tuple` of `tuples` ‚Äî as long as all elements can be _hashed_.\r\nSets also come in an immutable [`frozensets`][type-frozenset] flavor.\r\n\r\nSets are most commonly used to quickly remove duplicates from other data structures or item groupings.\r\nThey are also used for efficient comparisons when sequencing and duplicate tracking are not needed.\r\n\r\nLike other collection types (_dictionaries, lists, tuples_), `sets` support:\r\n- Iteration via `for item in <set>`\r\n- Membership checking via `in` and `not in`,\r\n- Length calculation through `len()`, and\r\n- Shallow copies through `copy()`\r\n\r\n`sets` do not support:\r\n- Indexing of any kind\r\n- Ordering via sorting or insertion\r\n- Slicing\r\n- Concatenation via `+`\r\n\r\n\r\nChecking membership in a `set` has constant time complexity (on average) versus checking membership in a `list` or `string`, where the time complexity grows as the length of the data increases.\r\nMethods such as `<set>.union()`, `<set>.intersection()`, or `<set>.difference()` also have constant time complexity (on average).\r\n\r\n[type-set]: https://docs.python.org/3/library/stdtypes.html#set\r\n[hashable]: https://docs.python.org/3.7/glossary.html#term-hashable\r\n[type-frozenset]: https://docs.python.org/3/library/stdtypes.html#frozenset\r\n",
  "links": [
    {
      "url": "https://docs.python.org/3/library/stdtypes.html#set",
      "description": "Python Documentation on Standard Types: Set"
    },
    {
      "url": "https://realpython.com/python-sets/",
      "description": "Real Python: Sets in Python."
    },
    {
      "url": "https://towardsdatascience.com/5-pythons-sets-problems-to-solve-before-your-coding-interview-41bb1d14ac25",
      "description": "5 Problems with Sets to Solve (Towards Data Science)"
    },
    {
      "url": "http://notes.imt-decal.org/sets/cheat-sheet.html",
      "description": "Set and Logic symbols cheat sheet."
    }
  ],
  "config": {}
}