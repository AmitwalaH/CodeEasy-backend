{
  "concept": "lists",
  "about": "# About\r\n\r\nA [`list`][list] is a mutable collection of items in _sequence_.\r\n Like most collections (_see the built-ins [`tuple`][tuple], [`dict`][dict] and [`set`][set]_), lists can hold reference to any (or multiple) data type(s) - including other lists.\r\n Like any [sequence][sequence type], items can be accessed via `0-based index` number from the left and `-1-based index` from the right.\r\n Lists can be copied in whole or in part via [slice notation][slice notation] or `<list>.copy()`.\r\n\r\n\r\nLists support both [common][common sequence operations] and [mutable][mutable sequence operations] sequence operations such as `min()`/`max()`, `<list>.index()`, `.append()` and `.reverse()`.\r\n List elements can be iterated over using the `for item in <list>` construct. `for index, item in enumerate(<list>)` can be used when both the element index and the element value are needed.\r\n\r\n\r\nLists are implemented as [dynamic arrays][dynamic array] -- similar to Java's [`Arraylist`][arraylist] type, and are most often used to store groups of similar data (_strings, numbers, sets etc._) of unknown length (_the number of entries may arbitrarily expand or shrink_).\r\n\r\n\r\nAccessing elements, checking for membership via `in`, or appending items to the \"right-hand\" side of a list are all very efficient.\r\n Prepending (_appending to the \"left-hand\" side_) or inserting into the middle of a list are much _less_ efficient because those operations require shifting elements to keep them in sequence.\r\n For a similar data structure that supports memory efficient `appends`/`pops` from both sides, see [`collections.deque`][deque], which has approximately the same O(1) performance in either direction.\r\n\r\n\r\nBecause lists are mutable and can contain references to arbitrary Python objects, they also take up more space in memory than an [`array.array`][array.array] or a [`tuple`][tuple] (_which is immutable_) of the same apparent length.\r\n Despite this, lists are an extremely flexible and useful data structure and many built-in methods and operations in Python produce lists as their output.\r\n\r\n\r\n## Construction\r\n\r\nA `list` can be declared as a _literal_ with square `[]` brackets and commas between elements:\r\n\r\n\r\n```python\r\n>>> no_elements = []\r\n\r\n>>> no_elements\r\n[]\r\n\r\n>>> one_element = [\"Guava\"]\r\n\r\n>>> one_element\r\n['Guava']\r\n\r\n>>> elements_separated_with_commas = [\"Parrot\", \"Bird\", 334782]\r\n\r\n>>> elements_separated_with_commas\r\n['Parrot', 'Bird', 334782]\r\n```\r\n\r\nFor readability, line breaks can be used when there are many elements or nested data structures within a list:\r\n\r\n\r\n```python\r\n>>> lots_of_entries = [\r\n      \"Rose\",\r\n      \"Sunflower\",\r\n      \"Poppy\",\r\n      \"Pansy\",\r\n      \"Tulip\",\r\n      \"Fuchsia\",\r\n      \"Cyclamen\",\r\n      \"Lavender\"\r\n   ]\r\n\r\n>>> lots_of_entries\r\n['Rose', 'Sunflower', 'Poppy', 'Pansy', 'Tulip', 'Fuchsia', 'Cyclamen', 'Lavender']\r\n\r\n\r\n# Each data structure is on its own line to help clarify what they are.\r\n>>> nested_data_structures = [\r\n      {\"fish\": \"gold\", \"monkey\": \"brown\", \"parrot\": \"grey\"},\r\n      (\"fish\", \"mammal\", \"bird\"),\r\n      ['water', 'jungle', 'sky']\r\n   ]\r\n\r\n>>> nested_data_structures\r\n[{'fish': 'gold', 'monkey': 'brown', 'parrot': 'grey'}, ('fish', 'mammal', 'bird'), ['water', 'jungle', 'sky']]\r\n```\r\n\r\nThe `list()` constructor can be used empty or with an _iterable_ as an argument.\r\n Elements in the iterable are cycled through by the constructor and added to the list in order:\r\n\r\n\r\n```python\r\n>>> no_elements = list()\r\n>>> no_elements\r\n[]\r\n\r\n# The tuple is unpacked and each element is added.\r\n>>> multiple_elements_from_tuple = list((\"Parrot\", \"Bird\", 334782))\r\n\r\n>>> multiple_elements_from_tuple\r\n['Parrot', 'Bird', 334782]\r\n\r\n# The set is unpacked and each element is added.\r\n>>> multiple_elements_from_set = list({2, 3, 5, 7, 11})\r\n\r\n>>> multiple_elements_from_set\r\n[2, 3, 5, 7, 11]\r\n```\r\n\r\nResults when using a list constructor with a string or a dict may be surprising:\r\n\r\n```python\r\n# String elements (Unicode code points) are iterated through and added *individually*.\r\n>>> multiple_elements_string = list(\"Timbuktu\")\r\n\r\n>>> multiple_elements_string\r\n['T', 'i', 'm', 'b', 'u', 'k', 't', 'u']\r\n\r\n# Unicode separators and positioning code points are also added *individually*.\r\n>>> multiple_code_points_string = list('à¤…à¤­à¥à¤¯à¤¾à¤¸')\r\n\r\n>>> multiple_code_points_string\r\n['à¤…', 'à¤­', 'à¥', 'à¤¯', 'à¤¾', 'à¤¸']\r\n\r\n# The iteration default for dictionaries is over the keys, so only key data is inserted into the list.\r\n>>> source_data = {\"fish\": \"gold\", \"monkey\": \"brown\"}\r\n>>> list(source_data)\r\n['fish', 'monkey']\r\n```\r\n\r\nBecause the `list()` constructor will only take iterables (or nothing) as arguments, objects that are **not** iterable will raise a `TypeError`. Consequently, it is much easier to create a one-item list via the literal method.\r\n\r\n```python\r\n# Numbers are not iterable, and so attempting to create a list with a number passed to the constructor fails.\r\n>>> one_element = list(16)\r\nTraceback (most recent call last):\r\n  File \"<stdin>\", line 1, in <module>\r\nTypeError: 'int' object is not iterable\r\n\r\n# Tuples *are* iterable, so passing a one-element tuple to the constructor does work, but it's awkward\r\n>>> one_element_from_iterable = list((16,))\r\n\r\n>>> one_element_from_iterable\r\n[16]\r\n```\r\n\r\n## Accessing elements\r\n\r\nItems inside lists (_as well as elements in other sequence types such as [`str`][string] & [`tuple`][tuple]_), can be accessed using  _bracket notation_.\r\nIndexes can be from **`left`** --> **`right`** (_starting at zero_) or **`right`** --> **`left`** (_starting at -1_).\r\n\r\n\r\n<table>\r\n<tr>\r\n  <td style=\"vertical-align: top\"> index from left âŸ¹<br><br><br><br><br><br><br></td><td style=\"vertical-align: middle\">\r\n\r\n|  0<br>ğŸ‘‡ğŸ¾ \t|  1<br>ğŸ‘‡ğŸ¾ \t|  2<br>ğŸ‘‡ğŸ¾ \t|  3<br>ğŸ‘‡ğŸ¾ \t|  4<br>ğŸ‘‡ğŸ¾ \t|  5<br>ğŸ‘‡ğŸ¾ \t|\r\n|:--------:\t|:--------:\t|:--------:\t|:--------:\t|:--------:\t|:--------:\t|\r\n|     P    \t|     y    \t|     t    \t|     h    \t|     o    \t|     n    \t|\r\n| ğŸ‘†ğŸ¾<br>-6 \t| ğŸ‘†ğŸ¾<br>-5 \t| ğŸ‘†ğŸ¾<br>-4 \t| ğŸ‘†ğŸ¾<br>-3 \t| ğŸ‘†ğŸ¾<br>-2 \t| ğŸ‘†ğŸ¾<br>-1 \t|\r\n</td><td style=\"vertical-align: bottom\"><br><br><br><br><br>âŸ¸ index from right</td>\r\n</tr>\r\n</table>\r\n\r\n\r\n```python\r\n>>> breakfast_foods = [\"Oatmeal\", \"Fruit Salad\", \"Eggs\", \"Toast\"]\r\n\r\n# Oatmeal is at index 0 or index -4.\r\n>>> breakfast_foods[0]\r\n'Oatmeal'\r\n\r\n>>> breakfast_foods[-4]\r\n'Oatmeal'\r\n\r\n# Eggs are at index -2 or 2\r\n>>> breakfast_foods[-2]\r\n'Eggs'\r\n\r\n>>> breakfast_foods[2]\r\n'Eggs'\r\n\r\n# Toast is at -1\r\n>>> breakfast_foods[-1]\r\n'Toast'\r\n```\r\n\r\nA section of a list can be accessed via _slice notation_ (`<list>[start:stop]`).\r\nA _slice_ is defined as an element sequence at position `index`, such that `start <= index < stop`.\r\n[_Slicing_][slice notation] returns a copy of the \"sliced\" items and does not modify the original `list`.\r\n\r\nA `step` parameter can also be used in the slice (`<list>[<start>:<stop>:<step>]`) to \"skip over\" or filter the returned elements (_for example, a `step` of 2 will select every other element in the section_):\r\n\r\n```python\r\n>>> colors = [\"Red\", \"Purple\", \"Green\", \"Yellow\", \"Orange\", \"Pink\", \"Blue\", \"Grey\"]\r\n\r\n# If there is no step parameter, the step is assumed to be 1.\r\n>>> middle_colors = colors[2:6]\r\n\r\n>>> middle_colors\r\n['Green', 'Yellow', 'Orange', 'Pink']\r\n\r\n# If the start or stop parameters are omitted, the slice will\r\n# start at index zero, and will stop at the end of the list.\r\n>>> primary_colors = colors[::3]\r\n\r\n>>> primary_colors\r\n['Red', 'Yellow', 'Blue']\r\n```\r\n\r\n\r\n## Working with lists\r\n\r\nLists supply an [_iterator_][iterator], and can be looped through/over in the same manner as other _sequence types_, using either `for item in <list>` or `for index, item in enumerate(<list>)`:\r\n\r\n```python\r\n# Make a list, and then loop through it to print out the elements\r\n>>> colors = [\"Orange\", \"Green\", \"Grey\", \"Blue\"]\r\n>>> for item in colors:\r\n...     print(item)\r\n...\r\nOrange\r\nGreen\r\nGrey\r\nBlue\r\n\r\n\r\n# Print the same list, but with the indexes of the colors included\r\n>>> colors = [\"Orange\", \"Green\", \"Grey\", \"Blue\"]\r\n>>> for index, item in enumerate(colors):\r\n...     print(item, \":\", index)\r\n...\r\nOrange : 0\r\nGreen : 1\r\nGrey : 2\r\nBlue : 3\r\n\r\n\r\n# Start with a list of numbers and then loop through and print out their cubes.\r\n>>> numbers_to_cube = [5, 13, 12, 16]\r\n>>> for number in numbers_to_cube:\r\n...     print(number**3)\r\n...\r\n125\r\n2197\r\n1728\r\n4096\r\n```\r\n\r\nOne common way to compose a list of values is to use `<list>.append()` within a loop:\r\n\r\n```python\r\n>>> cubes_to_1000 = []\r\n>>> for number in range(11):\r\n...    cubes_to_1000.append(number**3)\r\n\r\n>>> cubes_to_1000\r\n[0, 1, 8, 27, 64, 125, 216, 343, 512, 729, 1000]\r\n```\r\n\r\nLists can also be combined via various techniques:\r\n\r\n```python\r\n# Using the plus + operator unpacks each list and creates a new list, but it is not efficient.\r\n>>> new_via_concatenate = [\"George\", 5] + [\"cat\", \"Tabby\"]\r\n\r\n>>> new_via_concatenate\r\n['George', 5, 'cat', 'Tabby']\r\n\r\n# Likewise, using the multiplication operator * is the equivalent of using + n times.\r\n>>> first_group = [\"cat\", \"dog\", \"elephant\"]\r\n>>> multiplied_group = first_group * 3\r\n\r\n>>> multiplied_group\r\n['cat', 'dog', 'elephant', 'cat', 'dog', 'elephant', 'cat', 'dog', 'elephant']\r\n\r\n# Another method for combining 2 lists is to use slice assignment or a loop-append.\r\n# This assigns the second list to index 0 in the first list.\r\n>>> first_one = [\"cat\", \"Tabby\"]\r\n>>> second_one = [\"George\", 5]\r\n>>> first_one[0:0] = second_one\r\n\r\n>>> first_one\r\n['George', 5, 'cat', 'Tabby']\r\n\r\n# This loops through the first list and appends its items to the end of the second list.\r\n>>> first_one = [\"cat\", \"Tabby\"]\r\n>>> second_one = [\"George\", 5]\r\n\r\n>>> for item in first_one:\r\n...      second_one.append(item)\r\n\r\n>>> second_one\r\n['George', 5, 'cat', 'Tabby']\r\n```\r\n\r\n\r\n## Some cautions\r\n\r\nRecall that variables in Python are _labels_ that point to _underlying objects_.\r\n`lists` add one more layer as  _container objects_ -- they hold object _references_ for their collected items.\r\nThis can lead to multiple potential issues when working with lists, if not handled properly.\r\n\r\n\r\n### Assigning more than one variable name\r\nAssigning a `list` object to a new variable _name_ **does not copy the `list` object nor its elements**.\r\nAny change made to the elements in the `list` under the _new_ name _impact the original_.\r\n\r\n\r\nMaking a `shallow_copy` via `list.copy()` or slice will avoid this first-level referencing complication.\r\nA `shallow_copy` will create a new `list` object, but **will not** create new objects for the contained list _elements_. This type of copy will usually be enough for you to add or remove items from the two `list` objects independently, and effectively have two \"separate\" lists.\r\n\r\n\r\n```python\r\n>>> actual_names = [\"Tony\", \"Natasha\", \"Thor\", \"Bruce\"]\r\n\r\n# Assigning a new variable name does not make a copy of the container or its data.\r\n>>> same_list = actual_names\r\n\r\n#  Altering the list via the new name is the same as altering the list via the old name.\r\n>>> same_list.append(\"Clarke\")\r\n[\"Tony\", \"Natasha\", \"Thor\", \"Bruce\", \"Clarke\"]\r\n\r\n>>> actual_names\r\n[\"Tony\", \"Natasha\", \"Thor\", \"Bruce\", \"Clarke\"]\r\n\r\n#  Likewise, altering the data in the list via the original name will also alter the data under the new name.\r\n>>> actual_names[0] = \"Wanda\"\r\n['Wanda', 'Natasha', 'Thor', 'Bruce', 'Clarke']\r\n\r\n# If you copy the list, there will be two separate list objects which can be changed independently.\r\n>>> copied_list = actual_names.copy()\r\n>>> copied_list[0] = \"Tony\"\r\n\r\n>>> actual_names\r\n['Wanda', 'Natasha', 'Thor', 'Bruce', 'Clarke']\r\n\r\n>>> copied_list\r\n[\"Tony\", \"Natasha\", \"Thor\", \"Bruce\", \"Clarke\"]\r\n```\r\n\r\n\r\nThis reference complication becomes exacerbated when working with nested or multiplied lists (_the following examples are from the excellent 2013 [`Ned Batchelder`][ned batchelder] blog post [Names and values: making a game board][names and values]_):\r\n\r\n```python\r\nfrom pprint import pprint\r\n\r\n# This will produce a game grid that is 8x8, pre-populated with zeros.\r\n>>> game_grid = [[0]*8] *8\r\n\r\n>>> pprint(game_grid)\r\n[[0, 0, 0, 0, 0, 0, 0, 0],\r\n [0, 0, 0, 0, 0, 0, 0, 0],\r\n [0, 0, 0, 0, 0, 0, 0, 0],\r\n [0, 0, 0, 0, 0, 0, 0, 0],\r\n [0, 0, 0, 0, 0, 0, 0, 0],\r\n [0, 0, 0, 0, 0, 0, 0, 0],\r\n [0, 0, 0, 0, 0, 0, 0, 0],\r\n [0, 0, 0, 0, 0, 0, 0, 0]]\r\n\r\n# An attempt to put a \"X\" in the bottom right corner.\r\n>>> game_grid[7][7] = \"X\"\r\n\r\n# This attempt doesn't work because all the rows are referencing the same underlying list object.\r\n>>> pprint(game_grid)\r\n[[0, 0, 0, 0, 0, 0, 0, 'X'],\r\n [0, 0, 0, 0, 0, 0, 0, 'X'],\r\n [0, 0, 0, 0, 0, 0, 0, 'X'],\r\n [0, 0, 0, 0, 0, 0, 0, 'X'],\r\n [0, 0, 0, 0, 0, 0, 0, 'X'],\r\n [0, 0, 0, 0, 0, 0, 0, 'X'],\r\n [0, 0, 0, 0, 0, 0, 0, 'X'],\r\n [0, 0, 0, 0, 0, 0, 0, 'X']]\r\n```\r\n\r\nBut in this circumstance, a `shallow_copy` is enough to allow the behavior we'd like:\r\n\r\n```python\r\nfrom pprint import pprint\r\n\r\n# This loop will safely produce a game grid that is 8x8, pre-populated with zeros\r\n>>> game_grid = []\r\n>>> filled_row = [0] * 8\r\n>>> for row in range(8):\r\n...    game_grid.append(filled_row.copy()) # This is making a new shallow copy of the inner list object each iteration.\r\n\r\n>>> pprint(game_grid)\r\n[[0, 0, 0, 0, 0, 0, 0, 0],\r\n [0, 0, 0, 0, 0, 0, 0, 0],\r\n [0, 0, 0, 0, 0, 0, 0, 0],\r\n [0, 0, 0, 0, 0, 0, 0, 0],\r\n [0, 0, 0, 0, 0, 0, 0, 0],\r\n [0, 0, 0, 0, 0, 0, 0, 0],\r\n [0, 0, 0, 0, 0, 0, 0, 0],\r\n [0, 0, 0, 0, 0, 0, 0, 0]]\r\n\r\n# An attempt to put a \"X\" in the bottom right corner.\r\n>>> game_grid[7][7] = \"X\"\r\n\r\n# The game grid now works the way we expect it to!\r\n>>> pprint(game_grid)\r\n[[0, 0, 0, 0, 0, 0, 0, 0],\r\n [0, 0, 0, 0, 0, 0, 0, 0],\r\n [0, 0, 0, 0, 0, 0, 0, 0],\r\n [0, 0, 0, 0, 0, 0, 0, 0],\r\n [0, 0, 0, 0, 0, 0, 0, 0],\r\n [0, 0, 0, 0, 0, 0, 0, 0],\r\n [0, 0, 0, 0, 0, 0, 0, 0],\r\n [0, 0, 0, 0, 0, 0, 0, 'X']]\r\n```\r\n\r\nAs mentioned earlier, lists are containers of _references_, so there is a second layer of potential complication.\r\nIf a list contains variables, objects, or nested data structures, those second-level references **will not be copied** via `shallow_copy` or slice.\r\nMutating the underlying objects will then affect _any and all_ copies, since each `list` object only contains _references pointing to_ the contained elements.\r\n\r\n```python\r\nfrom pprint import pprint\r\n\r\n>>> pprint(game_grid)\r\n[[0, 0, 0, 0, 0, 0, 0, 0],\r\n [0, 0, 0, 0, 0, 0, 0, 0],\r\n [0, 0, 0, 0, 0, 0, 0, 0],\r\n [0, 0, 0, 0, 0, 0, 0, 0],\r\n [0, 0, 0, 0, 0, 0, 0, 0],\r\n [0, 0, 0, 0, 0, 0, 0, 0],\r\n [0, 0, 0, 0, 0, 0, 0, 0],\r\n [0, 0, 0, 0, 0, 0, 0, 'X']]\r\n\r\n# We'd like a new board, so we make a shallow copy.\r\n>>> new_game_grid = game_grid.copy()\r\n\r\n# But a shallow copy doesn't copy the contained references or objects.\r\n>>> new_game_grid[0][0] = 'X'\r\n\r\n# So changing the items in the copy also changes the originals items.\r\n>>>  pprint(game_grid)\r\n[['X', 0, 0, 0, 0, 0, 0, 0],\r\n [0, 0, 0, 0, 0, 0, 0, 0],\r\n [0, 0, 0, 0, 0, 0, 0, 0],\r\n [0, 0, 0, 0, 0, 0, 0, 0],\r\n [0, 0, 0, 0, 0, 0, 0, 0],\r\n [0, 0, 0, 0, 0, 0, 0, 0],\r\n [0, 0, 0, 0, 0, 0, 0, 0],\r\n [0, 0, 0, 0, 0, 0, 0, 'X']]\r\n```\r\n\r\n## Related data types\r\n\r\nLists are often used as _stacks_ and _queues_ -- although their underlying implementation makes prepending and inserting slow.\r\nThe [collections][collections] module offers a [deque][deque] variant optimized for fast appends and pops from either end that is implemented as a [doubly linked list][doubly linked list].\r\nNested lists are also used to model small _matrices_ -- although the [Numpy][numpy] and [Pandas][pandas] libraries are much more robust for efficient matrix and tabular data manipulation.\r\nThe collections module also provides a `UserList` type that can be customized to fit specialized list needs.\r\n\r\n[array.array]: https://docs.python.org/3/library/array.html\r\n[arraylist]: https://beginnersbook.com/2013/12/java-arraylist/\r\n[collections]: https://docs.python.org/3/library/collections.html\r\n[common sequence operations]: https://docs.python.org/3/library/stdtypes.html#common-sequence-operations\r\n[deque]: https://docs.python.org/3/library/collections.html#collections.deque\r\n[dict]: https://docs.python.org/3/library/stdtypes.html#dict\r\n[doubly linked list]: https://en.wikipedia.org/wiki/Doubly_linked_list\r\n[dynamic array]: https://en.wikipedia.org/wiki/Dynamic_array\r\n[iterator]: https://docs.python.org/3/glossary.html#term-iterator\r\n[list]: https://docs.python.org/3/library/stdtypes.html#list\r\n[mutable sequence operations]: https://docs.python.org/3/library/stdtypes.html#typesseq-mutable\r\n[names and values]: https://nedbatchelder.com/blog/201308/names_and_values_making_a_game_board.html\r\n[ned batchelder]: https://nedbatchelder.com/\r\n[numpy]: https://numpy.org/\r\n[pandas]: https://pandas.pydata.org/\r\n[sequence type]: https://docs.python.org/3/library/stdtypes.html#sequence-types-list-tuple-range\r\n[set]: https://docs.python.org/3/library/stdtypes.html#set\r\n[slice notation]: https://docs.python.org/3/reference/expressions.html#slicings\r\n[string]: https://docs.python.org/3/library/stdtypes.html#text-sequence-type-str\r\n[tuple]: https://docs.python.org/3/library/stdtypes.html#tuple\r\n",
  "introduction": "# Introduction\r\n\r\nA [list][list] is a mutable collection of items in _sequence_.\r\n They are an extremely flexible and useful data structure that many `built-in` methods and operations in Python produce as output.\r\n Lists can hold reference to any (or multiple) data type(s) - including other lists or data structures such as [tuples][tuples], [sets][sets], or [dicts][dicts].\r\n Content can be iterated over using `for item in <list>` construct.\r\n If indexes are needed with the content, `for index, item in enumerate(<list>)` can be used.\r\n Elements within a `list` can be accessed via `0-based index` number from the left, or `-1-based index` number from the right.\r\n Lists can be copied in whole or in part using  _slice notation_ or `<list>.copy()`.\r\n\r\n[dicts]: https://github.com/exercism/python/tree/main/concepts/dicts\r\n[list]: https://docs.python.org/3/library/stdtypes.html#list\r\n[sets]: https://github.com/exercism/python/tree/main/concepts/sets\r\n[tuples]: https://github.com/exercism/python/tree/main/concepts/tuples\r\n",
  "links": [
    {
      "url": "https://docs.python.org/3/tutorial/datastructures.html",
      "description": "Python Tutorial: Lists"
    },
    {
      "url": "https://docs.python.org/3/library/stdtypes.html#list",
      "description": "Lists Type in Python Docs"
    },
    {
      "url": "https://docs.python.org/3/library/stdtypes.html#sequence-types-list-tuple-range",
      "description": "Sequence Types in Python Docs"
    },
    {
      "url": "https://realpython.com/python-lists-tuples/",
      "description": "Real Python: Lists and Tuples"
    }
  ],
  "config": {}
}