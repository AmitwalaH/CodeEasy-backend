{
  "concept": "functions",
  "about": "# About\r\n\r\nA [`function`][function] is a block of organized, reusable code that is used to perform a specific task.\r\n`Functions` provide better modularity for your application and a high degree of code reuse.\r\nPython, like other programming languages, has [_built-in functions_][built-in functions] ([`print`][print], [`map`][map], and so on) that are readily available.\r\nYou can also define your own functions. Those are called [`user-defined functions`][user defined functions].\r\nFunctions can run something as simple as _printing a message to the console_ or they can be quite complex.\r\n\r\nTo execute the code inside a function, you need to call the function, which is done by using the function name followed by parentheses [`()`].\r\nData, known as [`arguments`][arguments], can be passed to the function by placing them inside the parenthesese.\r\nA function definition may include zero or more [`parameters`][parameters].\r\nParameters define what argument(s) the function accepts.\r\nA parameter defines what _type_ of argument is to be passed.\r\nThe argument is the actual _value_ passed when the function is called.\r\nFunctions can perform different tasks depending on the arguments passed to the parameters.\r\n\r\nA function can also return a value using the [`return`][return] keyword.\r\nThe value returned by the function is known as the `return value`.\r\nThe return value is returned to the caller of the function.\r\n\r\n## Creation\r\n\r\nIn python, functions are created using the [`def`][def] keyword.\r\nThe function definition is followed by the function name and parentheses [`()`].\r\nInside the parentheses, the parameters are specified, separated by commas.\r\nAfter the close parenthesis, the colon (`:`) is used to separate the function signature from the function body.\r\n\r\nThe function body is a block of code that is executed when the function is called.\r\nThe body of the function is indented.\r\nThe indentation is important because Python relies on it to know where that block of code ends.\r\nA value can be returned from the function by using the `return` keyword, which can then be used by the caller of the function.\r\n\r\n```python\r\ndef function_name(parameter1, parameter2, ...):\r\n    # function body\r\n    return parameter1 + parameter2\r\n\r\n```\r\n\r\nWe can also define a function without any parameters or return value.\r\n\r\n```python\r\ndef function_name():\r\n    # function body\r\n    pass\r\n\r\n```\r\n\r\nNote that the function does need a body, even if the body does nothing, or trying to run the program will generate an indentation error:\r\n\r\n```python\r\n>>> def my_bodyless_func():\r\n...      \r\n\r\nFile ~/temp.py:1\r\n    \r\n    ^\r\nIndentationError: expected an indented block\r\n```\r\n\r\n## Calling a Function\r\n\r\nTo call a function, use the function name followed by parenthesese [`()`].\r\nParameters passed to the function are placed inside the parenthesese, separated by commas.\r\n\r\nConsider the following function:\r\n\r\n```python\r\ndef greet():\r\n    print(\"Hello\")\r\n\r\n```\r\n\r\nThe above function can be called by using the following syntax:\r\n\r\n```python\r\n>>> greet()\r\nHello\r\n```\r\n\r\n## Parameters and their Arguments\r\n\r\nArguments are values that are passed to the function when it is called.\r\nThey can be of any data type, including other functions or classes.\r\n\r\nLet's define a function `add` which adds two numbers together:\r\n\r\n```python\r\ndef add(first, second):\r\n    print(first + second)\r\n\r\n```\r\n\r\nThe parameters `first` and `second` define what arguments the `add` function will accept.\r\n(It should be noted that the words `parameter` and `argument` are often used interchangeably, albeit imprecisely.)\r\nWhen the function is called, the arguments are passed to the function.\r\nWe need to pass arguments for both of the parameters, otherwise a [`TypeError`][type-error] will be raised.\r\n\r\n```python\r\n>>> add(2, 3)\r\n5\r\n\r\n# Function can be called multiple times, with different parameters\r\n>>> add(4, 3)\r\n7\r\n>>> add(5, 6)\r\n11\r\n\r\n# Passing an incorrect number of parameters will raise a `TypeError`\r\n>>> add(2)\r\nTraceback (most recent call last):\r\n  File \"<stdin>\", line 1, in <module>\r\nTypeError: add() missing 1 required positional argument: 'second'\r\n\r\n>>> add(2, 3, 4)\r\nTraceback (most recent call last):\r\n  File \"<stdin>\", line 1, in <module>\r\nTypeError: add() takes 2 positional arguments but 3 were given\r\n```\r\n\r\n## Return Value\r\n\r\nThe return value is a value that is returned to the caller of the function.\r\nA `return value` can be any data type including other functions or classes.\r\nIt can be used by caller of the function to perform further operations.\r\nIf a function does not explicitly define a `return value`, the value `None` will be returned by the Python interpreter.\r\n\r\nLet's define a function `add`:\r\n\r\n```python\r\ndef add(first, second):\r\n    return first + second\r\n\r\n```\r\n\r\nWe can store the return value in a variable and then print it:\r\n\r\n```python\r\n>>> result = add(2, 3)\r\n>>> print(result)\r\n5\r\n# Type of result is `int`\r\n>>> type(result)\r\n<class 'int'>\r\n\r\n# We can also perform operations on the return value\r\n>>> result * 2\r\n10\r\n\r\n# A function without an explicit return value will return `None`\r\n>>> def log(message):\r\n    print(message)\r\n\r\n# Hello is printed because of print(message), but return value is `None`\r\n>>> return_value = log(\"Hello\")\r\nHello\r\n>>> return_value\r\nNone\r\n```\r\n\r\nUse of `return` immediately exits the function and returns the value to the caller.\r\n\r\n```python\r\n>>> def show(first, second):\r\n    print(first)\r\n    return first\r\n    print(second)\r\n\r\n# second never gets printed, because the function exits after the return statement\r\n>>> show(1, 2)\r\n1\r\n```\r\n\r\n## Modularity\r\n\r\nComplex programs can be broken down into smaller parts.\r\nDifferent functions can be used to perform different specific tasks.\r\n\r\nAssume a program has to perform the following tasks:\r\n\r\n* Calculate the area of a circle\r\n* Calculate the area of a rectangle\r\n* Calculate the area of a triangle\r\n\r\nWe can break down the program into smaller parts.\r\n\r\n```python\r\ndef circle_area(radius):\r\n    return 3.14 * radius * radius\r\n\r\ndef rectangle_area(length, breadth):\r\n    return length * breadth\r\n\r\ndef triangle_area(base, height):\r\n    return 0.5 * base * height\r\n\r\n```\r\n\r\nNow, we can call the functions in the order we want.\r\n\r\n```python\r\n>>> circle_area(2)\r\n12.56\r\n>>> triangle_area(2, 3)\r\n3.0\r\n>>> rectangle_area(2, 3)\r\n6\r\n>>> rectangle_area(1, 2) + circle_area(2) + triangle_area(1, 2)\r\n15.56\r\n```\r\n\r\n## Scope of Variables\r\n\r\nIf a variable (_or name_) is defined inside a function, it will be only accessible _inside_ the function scope (_or local namespace_), even if there is a variable with the same name outside the function scope.\r\n\r\nVariables defined outside a function at the _module level_ are considered in the _global namespace_.\r\nVariables defined outside a function but _inside_ an enclosing function or class are in the _nonlocal namespace_.\r\n\r\n\r\nPython uses the [LEGB Rule][LEGB Rule] (**L**ocal, **E**nclosing, **G**lobal, **B**uilt-in) to resolve variable names when a program is running:\r\n\r\n1. Lookup in the **local** (or _function_) namespace.\r\n2. Lookup in the **enclosing** (or _nonlocal_) namespace if a name is not found in local.\r\n3. Lookup in the **global** namespace (_module level_) if the name is not found in nonlocal/enclosing.\r\n4. Lookup in the **built-in** (_program or python-wide_) namespace if the name is not found in global.\r\n\r\nIf the name remains unresolved, Python will raise a `NameError exception`.\r\n\r\n```python\r\n# Global namespace.\r\ngeneral_favorite = \"apples\"\r\n\r\n\r\ndef alices_favorite():\r\n   # Local namespace.  \r\n   favorite = \"cherries\"\r\n   \r\n   # This works because Python will eventually find general_favorite in the global namespace.\r\n   # Python will find 'print' in the built-in namespace.\r\n   print(f'Alice has always liked {favorite}, but most people like {general_favorite}.')\r\n\r\n   \r\ndef our_favorite_fruits():\r\n    # Enclosing or nonlocal namespace.\r\n    yours = \"peaches\"\r\n    \r\n    def my_favorite():\r\n        # Local namespace.\r\n        mine = \"pears\"\r\n        \r\n        # This works because Python will eventually find 'yours' in the enclosing/nonlocal namespace.\r\n        print(f'My favorite is {mine}, but you like {yours} instead.')\r\n        \r\n        # This works because Python will eventually find 'general_favorite' in the global namespace.\r\n        print(f'Everyone seems to like {general_favorite}')\r\n    \r\n    # This function is in the local namespace of the 'our_favorite_fruits' function.  \r\n    my_favorite()\r\n\r\n    \r\n# This will raise NameError: name 'favorite' is not defined, because the variable favorite is local to alices_favorite.\r\nprint(favorite)\r\n\r\n```\r\n\r\nIf we want to make a variable name accessible _outside_ the local function scope (_or modify a variable that has been defined outside the function scope_), we need to use either the [`global`][global] or [`nonlocal`][nonlocal] keywords.\r\n\r\nUsing the `global` keyword signals Python to start the lookup in the _global namespace_.\r\nAssignments to the variable will then modify the _global_ variable, instead of creating a _local_ version.\r\nWhen `global` is used to declare a variable, the variable will be _added_ to the global namespace.\r\nAs a result, `global` should be used cautiously, as adding or modifying a global variable could have effects on all other code that uses its value.\r\n\r\nThe `nonlocal` keyword signals to Python to look for/create the variable in the _nonlocal or enclosing namespace_.\r\nIt is used when a function is nested inside another function or class, and needs access to the outer functions variables and scope.\r\n\r\n\r\n## Functions as first class objects\r\n\r\nIn python, functions can be assigned to variables and passed as arguments to other functions.\r\nThey can be used as return values.\r\nFunctions can also be placed into a sequence([`list`][list], [`tuple`][tuple] etc) or as value in a [`dict`][dict].\r\nFunctions can be used anywhere any other object can be used.\r\nThis is because _functions are [_first class objects_][first class objects]_.\r\nAs such, they carry special attributes, and can even define getting and setting custom attributes of their own. \r\n\r\n```python\r\n# print is a function\r\n\r\n# A function can be assigned to a variable.\r\n>>> function_as_variable = print\r\n>>> function_as_variable(\"Hello\")\r\nHello\r\n>>> type(fake_print)\r\n<class 'builtin_function_or_method'>\r\n\r\n# Functions can be passed as an argument to another function.\r\n>>> def check_print(func):\r\n    func(\"Hello\")\r\n>>> check_print(print)\r\nHello\r\n\r\n# Function can be used as an item in a sequence.\r\n>>> my_list = [print, \"Hello\"]\r\n>>> my_list[0](\"Hello\")\r\nHello\r\n\r\n# Functions can be used as a value in a dictionary.\r\n>>> my_dict = {\"key\": print}\r\n>>> my_dict[\"key\"](\"Hello\")\r\nHello\r\n\r\n# Functions can be returned from a function.\r\n>>> def return_func():\r\n    return print\r\n>>> return_func()(\"Hello\")\r\nHello\r\n```\r\n\r\nFunctions can also be nested inside other functions.\r\n\r\n```python\r\ndef outer():\r\n    num = 10\r\n    \r\n    # This is a nested, or \"inner\" function.\r\n    def inner():\r\n        print(num)\r\n    \r\n    # Outer function calling inner function\r\n    inner()\r\n```\r\n\r\nThe inner function can access the variable `num` defined in the outer function.\r\n\r\n```python\r\n>>> outer()\r\n10\r\n```\r\n\r\n\r\n## Special Attributes\r\n\r\nFunctions in python have special attributes. Some of them are:\r\n\r\n* `__name__`: Name of the function\r\n* `__doc__`: Documentation string of the function\r\n* `__module__`: Module in which the function is defined\r\n* `__globals__`: Dictionary of global variables in the function\r\n* `__code__`: Code object containing the instructions of the function\r\n\r\n```python\r\n>>> def add(first, second):\r\n      return first + second\r\n\r\n# Function name\r\n>>> print.__name__\r\n'print'\r\n>>> len.__name__\r\n'len'\r\n>>> add.__name__\r\n'add'\r\n\r\n# Function documentation\r\n>>> abs.__doc__\r\n'Return the absolute value of the argument.'\r\n\r\n# Module\r\n>>> len.__module__\r\n'builtins'\r\n>>> add.__module__\r\n'__main__'\r\n```\r\n\r\nThe full list of function attributes can be found at [Python DataModel][attributes].\r\n\r\n[LEGB Rule]: https://realpython.com/python-scope-legb-rule/\r\n[arguments]: https://www.w3schools.com/python/gloss_python_function_arguments.asp\r\n[attributes]: https://docs.python.org/3/reference/datamodel.html#index-33\r\n[built-in functions]: https://docs.python.org/3/library/functions.html\r\n[def]: https://www.geeksforgeeks.org/python-def-keyword/\r\n[dict]: https://docs.python.org/3/tutorial/datastructures.html#dictionaries\r\n[first class objects]: https://en.wikipedia.org/wiki/First-class_object\r\n[function]: https://docs.python.org/3/glossary.html#term-function\r\n[global]: https://www.programiz.com/python-programming/global-keyword\r\n[list]: https://docs.python.org/3/tutorial/datastructures.html#list-objects\r\n[map]: https://docs.python.org/3/library/functions.html#map\r\n[nonlocal]: https://www.geeksforgeeks.org/python-nonlocal-keyword/\r\n[parameters]: https://www.codecademy.com/learn/flask-introduction-to-python/modules/learn-python3-functions/cheatsheet\r\n[print]: https://docs.python.org/3/library/functions.html#print\r\n[return]: https://www.geeksforgeeks.org/python-return-statement/\r\n[tuple]: https://docs.python.org/3/tutorial/datastructures.html#tuples-and-sequences\r\n[type-error]: https://docs.python.org/3/library/exceptions.html#TypeError\r\n[user defined functions]: https://en.wikipedia.org/wiki/User-defined_function\r\n",
  "introduction": "# Introduction\r\n\r\nA [`function`][function] is a way to compartmentalize code so it can be called by name from one or more places in the program.\r\nFunctions are used to perform specific and repetitive tasks.\r\n\r\nMore formally: a function is any Python object to which the [`function call`][calls] operation can be applied.\r\nA function may be used to [`return`][return] one or more values as a result of some operation(s), or it may be used for one or more [`side effects`][side effects].\r\nIf a function does not specify a return value it will still return `None`. \r\n\r\nFollowing is an example of a function with a side effect:\r\n\r\n```python\r\n>>> def hello():\r\n...        print(\"Hello\")\r\n...\r\n>>> hello()\r\nHello\r\n\r\n```\r\n\r\nIn the example above, the [`def`][def] keyword is used to signal the beginning of the function definition.\r\n`hello` is the name of the function.\r\nThe empty parentheses represent that no values are being passed to the function.\r\nThe body of the function is the single `print(\"Hello\")` statement.\r\n`print` is also a function.\r\nThe `\"Hello\"`  in the `print` function's parentheses is known as an [`argument`][arguments].\r\nThe argument is used by the `print` function to know what to print.\r\nNote that the body of the function is indented.\r\nThe indentation is important because Python relies on it to know where that block of code ends.\r\nThe function body ends at either the end of the program or just before the next line of code that is _not_ indented.\r\nSince `hello()` does not specify a `return` value, it executes its side effect - which is calling `print()`  -- and then returns `None`.\r\nFinally, we call the function by using its name and the parentheses - which signals to the Python interpreter that this is a _callable_ name.\r\n\r\nFollowing is an example of a function with a return value:\r\n\r\n```python\r\n>>> def hello():\r\n...     return \"Hello\"\r\n... \r\nprint(hello())\r\nHello\r\n\r\n```\r\n\r\nThe body of this function has been changed from _calling_ `print` to _returning_  the `string` \"Hello\".\r\nIn the end, the code still prints `\"Hello\"`, but the side effect takes place in the _calling code_ instead of in the `hello` function.\r\nIf the parentheses were left off from  calling the `hello` function (e.g. `print(hello)`), then `print` would output something like\r\n\r\n```\r\n<function hello at 0x0000026E18E93E20>\r\n```\r\n\r\nIt's important that, even if a function accepts no arguments (_i.e. has no parameters_), the empty parentheses must be used to _call_ it correctly.\r\nThis is different from a language such as Ruby which does not require empty parentheses for calling a function without any arguments.\r\n\r\nA function can define zero or more [`parameters`][parameters]. A parameter defines what argument(s) the function accepts.\r\n\r\nFollowing is an example of a function which accepts an argument:\r\n\r\n```python\r\n>>> def hello(name):\r\n...     return f\"Hello, {name}\"\r\n... \r\n>>>print(hello(\"Bob\"))\r\nHello, Bob\r\n\r\n```\r\n\r\nThe parameter is defined as `name`.\r\n`\"Bob\"` is the argument which the program passes to the `hello` function.\r\nThe function _returns_ the `string` \"Hello, Bob\".\r\n\r\nWhat if someone calls `hello` without passing an argument?\r\nThe program throws an error:\r\n\r\n```python\r\nprint(hello())\r\nTraceback (most recent call last):\r\n\r\n  Input In in <line: 1>\r\n    print(hello())\r\n\r\nTypeError: hello() missing 1 required positional argument: 'name'\r\nIf we don't want the program to error with no argument (_but want to allow the calling code to not supply one_), we can define a [default argument][default arguments].\r\nA default argument defines what value to use if the argument is missing when the function is called.\r\n\r\nFollowing is an example of a function with a default argument:\r\n\r\n```python\r\n>>> def hello(name=\"you\"):\r\n...     return f\"Hello, {name}\"\r\n... \r\n>>> print(hello())\r\nHello, you\r\n\r\n```\r\n\r\nThe `name` parameter is given the default argument of `\"you\"`, so the program outputs `Hello, you`, if not passed a `name` argument.\r\n\r\nFor more about function arguments, please see the [function arguments][function arguments] concept.\r\n\r\n\r\n[arguments]: https://www.w3schools.com/python/gloss_python_function_arguments.asp\r\n[calls]: https://docs.python.org/3/reference/expressions.html#calls\r\n[def]: https://www.geeksforgeeks.org/python-def-keyword/\r\n[function arguments]: ../function-arguments/about.md\r\n[function]: https://docs.python.org/3/glossary.html#term-function\r\n[parameters]: https://www.codecademy.com/learn/flask-introduction-to-python/modules/learn-python3-functions/cheatsheet\r\n[return]: https://www.geeksforgeeks.org/python-return-statement/\r\n[side effects]: https://python.plainenglish.io/side-effects-in-python-a50caad1169\r\n",
  "links": [
    {
      "url": "https://docs.python.org/3/tutorial/controlflow.html#defining-functions",
      "description": "Python Documentation Tutorial: Defining Functions"
    },
    {
      "url": "https://docs.python.org/3/reference/compound_stmts.html#function-definitions",
      "description": "Python Documentation: Function definitions"
    },
    {
      "url": "https://dbader.org/blog/python-first-class-functions",
      "description": "Dan Bader: Python's Functions are First-Class"
    },
    {
      "url": "https://docs.python.org/3/tutorial/classes.html#python-scopes-and-namespaces",
      "description": "Python Documentation Tutorial: Python Scopes and Namespaces"
    },
    {
      "url": "https://docs.python.org/3/reference/executionmodel.html#naming-and-binding",
      "description": "Python Reference Documentation: Naming and Binding"
    },
    {
      "url": "https://medium.com/swlh/the-global-and-nonlocal-keywords-in-python-842b13433b24",
      "description": "Maghfoor Ahmad Bilal: Global and Nonlocal Keywords"
    },
    {
      "url": "https://betterprogramming.pub/know-python-functions-better-going-beyond-4-special-attributes-720183078c8e",
      "description": "Yong Cui: 4 Special (Function) Attributes"
    }
  ],
  "config": {}
}