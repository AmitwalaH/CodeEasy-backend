{
  "concept": "recursion",
  "about": "# About\r\n\r\nRecursion is a way to repeatedly execute code inside a function through the function calling itself.\r\nFunctions that call themselves are know as _recursive_ functions.\r\nRecursion can be viewed as another way to loop/iterate. \r\nAnd like looping, a Boolean expression or `True/False` test is used to know when to stop the recursive execution.\r\n_Unlike_ looping, recursion without termination in Python cannot not run infinitely.\r\nValues used in each function call are placed in their own frame on the Python interpreter stack.\r\nIf the total number of function calls takes up more space than the stack has room for, it will result in an error.\r\n\r\n## Looping vs Recursive Implementation\r\n\r\nLooping and recursion may _feel_ similar in that they are both iterative.\r\nHowever, they _look_ different, both at the code level and at the implementation level.\r\nLooping can take place within the same frame on the call stack.\r\nThis is usually managed by updating one or more variable values to progressively maintain state for each iteration.\r\nThis is an efficient implementation, but it can be somewhat cluttered when looking at the code.\r\n\r\nRecursion, rather than updating _variable state_, can pass _updated values_ directly as arguments to the next call (iteration) of the same function.\r\nThis declutters the body of the function and can clarify how each update happens.\r\nHowever,  it is also a less efficient implementation, as each call to the same function adds another frame to the stack.\r\n\r\n## Recursion: Why and Why Not?\r\n\r\nIf there is risk of causing a stack error or overflow, why would anyone use a recursive strategy to solve a problem?\r\n_Readability, traceability, and intent._ \r\nThere may be situations where a solution is more readable and/or easier to reason through when expressed through recursion than when expressed through looping.\r\nThere may also be program constraints with using/mutating data, managing complexity, delegating responsibility, or organizing workloads.\r\nProblems that lend themselves to recursion include complex but repetitive problems that grow smaller over time, particularly [divide and conquer][divide and conquer] algorithms and [cumulative][cumulative] algorithms.\r\nHowever, due to Python's limit for how many frames are allowed on the stack, not all problems will benefit from a fully recursive strategy.\r\nProblems less naturally suited to recursion include ones that have a steady state, but need to repeat for a certain number of cycles, problems that need to execute asynchronously, and situations calling for a great number of iterations.\r\n\r\n## Looping vs Recursive Strategy: Indira's Insecurity\r\n\r\nIndira has her monthly social security auto-deposited in her bank account on the **_second Wednesday_** of every month.\r\nIndira is concerned about balancing her check book.\r\nShe is afraid she will write checks before her money is deposited.\r\nShe asks her granddaughter Adya to give her a list of dates her money will appear in her account.\r\n\r\nAdya, who is just learning how to program in Python, writes a program based on her first thoughts.\r\nShe wants to return a `list` of the deposit dates so they can be printed.\r\nShe wants to write a function that will work for _any year_.\r\nIn case the schedule changes (_or in case other relatives want Adya to calculate their deposit schedules_),  she decides the function needs to take an additional parameter for the _weekday_.\r\nFinally, Adya decides that the function needs a parameter for _which weekday_ of the month it is: the first, second, etc.\r\nFor all these requirements, she decides to use the `date` class imported from `datetime`.\r\nPutting all of that together, Adya comes up with:\r\n\r\n```\r\nfrom datetime import date\r\n\r\n\r\ndef paydates_for_year(year, weekday, ordinal):\r\n    \"\"\"Returns a list of the matching weekday dates.\r\n    \r\n    Keyword arguments:\r\n    year    -- the year, e.g. 2022\r\n    weekday -- the weekday, e.g. 3 (for Wednesday)\r\n    ordinal -- which weekday of the month, e.g. 2 (for the second)\r\n    \"\"\"\r\n    output = []\r\n\r\n    for month in range(1, 13):\r\n        for day_num in range(1, 8):\r\n            if date(year, month, day_num).isoweekday() == weekday:\r\n                output.append(date(year, month, day_num + (ordinal - 1) * 7))\r\n                break\r\n    return output\r\n\r\n# find the second Wednesday of the month for all the months in 2022\r\nprint(paydates_for_year(2022, 3, 2))\r\n```\r\n\r\nThis  first iteration works, but Adya wonders if she can refactor the code to use fewer lines with less nested looping.\r\nShe's also read that it is good to minimize mutating state, so she'd like to see if she can avoid mutating some of her variables such as `output`, `month`, and `day_num` .  \r\n\r\nShe's read about recursion, and thinks about how she might change her program to use a recursive approach.\r\nThe variables that are created and mutated in her looping function could  be passed in as arguments instead.\r\nRather than  mutating the variables _inside_ her function, she could pass _updated values as arguments_ to the next function call.\r\nWith those intentions she arrives at this recursive approach:\r\n\r\n```\r\nfrom datetime import date\r\n\r\n\r\n\r\ndef paydates_for_year_rec(year, weekday, ordinal, month, day_num, output):\r\n    \"\"\"Returns a list of the matching weekday dates\r\n    \r\n    Keyword arguments:\r\n    year    -- the year, e.g. 2022\r\n    weekday -- the weekday, e.g. 3 (for Wednesday)\r\n    ordinal -- which weekday of the month, e.g. 2 (for the second)\r\n    month   -- the month currently being processed\r\n    day_num -- the day of the month currently being processed\r\n    output  -- the list to be returned\r\n    \"\"\"\r\n    if month == 13:\r\n        return output\r\n    if date(year, month, day_num).isoweekday() == weekday:\r\n        return paydates_for_year_rec(year, weekday, ordinal, month + 1, 1, output\r\n                                     + [date(year, month, day_num + (ordinal - 1) * 7)])\r\n    return paydates_for_year_rec(year, weekday, ordinal, month, day_num + 1, output)\r\n\r\n    # find the second Wednesday of the month for all the months in 2022\r\n    print(paydates_for_year_rec(2022, 3, 2, 1, 1, []))\r\n    \r\n```\r\n\r\nAdya is happy that there are no more nested loops, no mutated state, and 2 fewer lines of code!  \r\n\r\nShe is a little concerned that the recursive approach uses more steps than the looping approach, and so is less \"performant\".\r\nBut re-writing the problem using recursion has definitely helped her deal with ugly nested looping (_a performance hazard_), extensive state mutation, and confusion around complex conditional logic.\r\nIt also feels more \"readable\" - she is sure that when she comes back to this code after a break, she will be able to read through and remember what it does more easily. \r\n\r\nIn the future, Adya may try to work through problems recursively first.\r\nShe may find it easier to initially walk through the problem in clear steps when nesting, mutation, and complexity are minimized.\r\nAfter working out the basic logic, she can then focus on optimizing her initial recursive steps into a more performant looping approach.\r\n\r\nEven later, when she learns about `tuples`, Adya could consider further \"optimizing\" approaches, such as using a `list comprehension` with `Calendar.itermonthdates`, or memoizing certain values.\r\n\r\n## Recursive Variation: The Tail Call\r\n\r\nA tail call is when the last statement of a function only calls itself and nothing more.\r\nThis example is not a tail call, as the function adds 1 to the result of calling itself\r\n\r\n```python\r\ndef print_increment(step, max_value):\r\n    if step > max_value:\r\n        return 1\r\n    print(f'The step is {step}')\r\n    return 1 + print_increment(step + 1, max_value)\r\n\r\n\r\ndef main():\r\n    retval = print_increment(1, 2)\r\n    print(f'retval is {retval} after recursion')\r\n\r\nif __name__ == \"__main__\":\r\n    main()\r\n\r\n```\r\n\r\nThis will print\r\n\r\n```\r\nThe step is 1\r\nThe step is 2\r\nretval is 3 after recursion\r\n```\r\n\r\nTo refactor it to a tail call, make `retval` a parameter of `print_increment`\r\n\r\n```python\r\ndef print_increment(step, max_value, retval):\r\n    if step > max_value:\r\n        return retval\r\n    print(f'The step is {step}')\r\n    return print_increment(step + 1, max_value, retval + 1)\r\n\r\n\r\ndef main():\r\n    retval = print_increment(1, 2, 1)\r\n    print(f'retval is {retval} after recursion')\r\n\r\nif __name__ == \"__main__\":\r\n    main()\r\n\r\n```\r\n\r\nYou may find a tail call even easier to reason through than a recursive call that is not a tail call.\r\nHowever, it is always important when using recursion to know that there will not be so many iterations that the stack will overflow.\r\n\r\n## Recursion Limits in Python\r\n\r\nSome languages are able to optimize tail calls so that each recursive call reuses the stack frame of the first call to the function (_similar to the way a loop reuses a frame_), instead of adding an additional frame to the stack.\r\nPython is not one of those languages.\r\nTo guard against stack overflow, Python has a recursion limit that defaults to one thousand frames.\r\nA [RecursionError](https://docs.python.org/3.8/library/exceptions.html#RecursionError) exception is raised when the interpreter detects that the recursion limit has been exceeded.\r\nIt is possible to use the [sys.setrecursionlimit](https://docs.python.org/3.8/library/sys.html#sys.setrecursionlimit) method to increase the recursion limit, but doing so runs the risk of having a runtime segmentation fault that will crash the program, and possibly the operating system.\r\n\r\n## Resources\r\n\r\nTo learn more about using recursion in Python you can start with \r\n- [python-programming: recursion][python-programming: recursion]\r\n- [Real Python: python-recursion][Real Python: python-recursion]\r\n- [Real Python: python-thinking-recursively][Real Python: python-thinking-recursively]\r\n\r\n[python-programming: recursion]: https://www.programiz.com/python-programming/recursion\r\n[Real Python: python-recursion]: https://realpython.com/python-recursion/\r\n[Real Python: python-thinking-recursively]: https://realpython.com/python-thinking-recursively/\r\n[RecursionError]: https://docs.python.org/3.8/library/exceptions.html#RecursionError\r\n[setrecursionlimit]: https://docs.python.org/3.8/library/sys.html#sys.setrecursionlimit\r\n[divide and conquer]: https://afteracademy.com/blog/divide-and-conquer-approach-in-programming\r\n[cumulative]: https://www.geeksforgeeks.org/sum-of-natural-numbers-using-recursion/\r\n",
  "introduction": "# Introduction\r\n\r\nRecursion is a way to repeat code in a function by the function calling itself.\r\nIt can be viewed as another way to loop/iterate. \r\nLike looping, a Boolean expression or `True/False` test is used to know when to stop the recursive execution.\r\n_Unlike_ looping, recursion without termination in Python cannot not run infinitely.\r\nValues used in each function call are placed in their own frame on the Python interpreter stack.\r\nIf the total number of function calls takes up more space than the stack has room for, it will result in an error.\r\n\r\n```python\r\ndef print_increment(step, max_value):\r\n    if step > max_value:\r\n        return\r\n    print(f'The step is {step}')\r\n    print_increment(step + 1, max_value)\r\n\r\n\r\ndef main():\r\n    print_increment(1, 2)\r\n    print(\"After recursion\")\r\n\r\nif __name__ == \"__main__\":\r\n    main()\r\n\r\n```\r\n\r\nThis will print\r\n\r\n```\r\nThe step is 1\r\nThe step is 2\r\nAfter recursion\r\n```\r\n\r\nThere may be some situations that are more readable and/or easier to reason through when expressed through recursion than when expressed through looping.\r\n",
  "links": [
    {
      "url": "https://hackernoon.com/recursion-vs-looping-in-python-9261442f70a5",
      "description": "Hackernoon: Recursion vs Looping in Python"
    },
    {
      "url": "https://towardsdatascience.com/a-friendly-guide-for-writing-recursive-functions-with-python-52441bd7ff5f",
      "description": "Towards Data Science: A Friendly Guide to Writing Recursive Functions"
    },
    {
      "url": "https://stackabuse.com/understanding-recursive-functions-with-python/",
      "description": "Stack Abuse: Understanding Recursive Functions"
    },
    {
      "url": "https://inventwithpython.com/blog/2022/03/20/how-many-recursive-cases-and-base-cases-does-a-recursive-function-need/",
      "description": "Al Sweigart: How Many Recursive Cases and Base Cases Does a Recursive Function Need?"
    },
    {
      "url": "https://realpython.com/python-thinking-recursively/",
      "description": "Real Python: Thinking Recursively"
    },
    {
      "url": "https://inventwithpython.com/blog/2018/08/24/pyohio-2018-recursion-tutorial/",
      "description": "Al Sweigart:  PyOhio 2018 Tutorial on Recursion."
    },
    {
      "url": "https://inventwithpython.com/recursion/",
      "description": "Invent With Python: The Recursive Book of Recursion"
    },
    {
      "url": "https://understanding-recursion.readthedocs.io/en/latest/index.html",
      "description": "Understanding Recursion Using Python"
    }
  ],
  "config": {}
}