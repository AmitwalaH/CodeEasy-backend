{
  "concept": "generators",
  "about": "# About\r\n\r\nA `generator` is a function or expression that returns a special type of [iterator][iterator] called [generator iterator][generator-iterator].\r\n`Generator-iterators` are [lazy][lazy iterator]: they do not store their `values` in memory, but _generate_ their values when needed.\r\n\r\nA generator function looks like any other function, but contains one or more [yield expressions][yield expression].\r\nEach `yield` will suspend code execution, saving the current execution state (_including all local variables and try-statements_).\r\nWhen the generator resumes, it picks up state from the suspension - unlike regular functions which reset with every call.\r\n\r\n\r\n## Constructing a generator\r\n\r\nGenerators are constructed much like other looping or recursive functions, but require a [`yield` expression](#the-yield-expression), which we will explore in depth a bit later.\r\n\r\nAn example is a function that returns the _squares_ from a given list of numbers.  \r\nAs currently written, all input must be processed before any values can be returned:\r\n\r\n```python\r\n>>> def squares(list_of_numbers):\r\n...     squares = []\r\n...     for number in list_of_numbers:\r\n...         squares.append(number ** 2)\r\n...     return squares\r\n```\r\n\r\nYou can convert that function into a generator like this:\r\n\r\n```python\r\n>>> def squares_generator(list_of_numbers):\r\n...     for number in list_of_numbers:\r\n...         yield number ** 2\r\n```\r\n\r\nThe rationale behind this is that you use a generator when you do not need all the values _at once_.\r\n\r\nThis saves memory and processing power, since only the value you are _currently working on_ is calculated.\r\n\r\n## Using a generator\r\n\r\nGenerators may be used in place of most `iterables` in Python. This includes _functions_ or _objects_ that require an `iterable`/`iterator` as an argument.\r\n\r\nTo use the `squares_generator()` generator:\r\n\r\n```python\r\n>>> squared_numbers = squares_generator([1, 2, 3, 4])\r\n\r\n>>> for square in squared_numbers:\r\n...     print(square)\r\n...\r\n1\r\n4\r\n9\r\n16\r\n```\r\n\r\nValues within a generator can also be produced/accessed via the `next()` function.\r\n`next()` calls the `__next__()` method of a generator object, \"advancing\" or evaluating the generator code up to its `yield` expression, which then \"yields\" or returns the value.\r\n\r\n```python\r\n>>> squared_numbers = squares_generator([1, 2])\r\n\r\n>>> next(squared_numbers)\r\n1\r\n>>> next(squared_numbers)\r\n4\r\n```\r\n\r\nWhen a `generator` is fully consumed and has no more values to return, it throws a `StopIteration` error.\r\n\r\n```python\r\n>>> next(squared_numbers)\r\nTraceback (most recent call last):\r\n  File \"<stdin>\", line 1, in <module>\r\nStopIteration\r\n```\r\n\r\n### Difference between iterables and generators\r\n\r\nGenerators are a special sub-set of _iterators_.\r\n`Iterators` are the mechanism/protocol that enables looping over _iterables_.\r\nGenerators and the iterators returned by common Python [`iterables`][iterables] act very similarly, but there are some important differences to note:\r\n\r\n- Generators are _one-way_; there is no \"backing up\" to a previous value.\r\n\r\n- Iterating over generators consume the returned values; no resetting.\r\n\r\n- Generators (_being lazily evaluated_) are not sortable and can not be reversed.\r\n\r\n- Generators do _not_ have `indexes`, so you can't reference a previous or future value using addition or subtraction.\r\n\r\n- Generators cannot be used with the `len()` function.\r\n\r\n- Generators can be _finite_ or _infinite_, be careful when collecting all values from an _infinite_ generator.\r\n\r\n## The yield expression\r\n\r\nThe [yield expression][yield expression] is very similar to the `return` expression.\r\n\r\n_Unlike_ the `return` expression, `yield` gives up values to the caller at a _specific point_, suspending evaluation/return of any additional values until they are requested.\r\n\r\nWhen `yield` is evaluated, it pauses the execution of the enclosing function and returns any values of the function _at that point in time_.\r\n\r\nThe function then _stays in scope_, and when `__next__()` is called, execution resumes until `yield` is encountered again.\r\n\r\n~~~~exercism/note\r\nUsing `yield` expressions is prohibited outside of functions.\r\n~~~~\r\n\r\n```python\r\n>>> def infinite_sequence():\r\n...     current_number = 0\r\n...     while True:\r\n...         yield current_number\r\n...         current_number += 1\r\n\r\n>>> lets_try = infinite_sequence()\r\n>>> lets_try.__next__()\r\n0\r\n>>> lets_try.__next__()\r\n1\r\n```\r\n\r\n## Why generators?\r\n\r\nGenerators are useful in a lot of applications.\r\n\r\nWhen working with a large collection, you might not want to put all of its values into `memory`.\r\nA generator can be used to work on larger data piece-by-piece, saving memory and improving performance.\r\n\r\nGenerators are also very helpful when a process or calculation is _complex_, _expensive_, or _infinite_:\r\n\r\n```python\r\n>>> def infinite_sequence():\r\n...     current_number = 0\r\n...     while True:\r\n...         yield current_number\r\n...         current_number += 1\r\n```\r\n\r\nNow whenever `__next__()` is called on the `infinite_sequence` object, it will return the _previous number_ + 1.\r\n\r\n\r\n[generator-iterator]: https://docs.python.org/3.11/glossary.html#term-generator-iterator\r\n[iterables]: https://wiki.python.org/moin/Iterator\r\n[iterator]: https://docs.python.org/3.11/glossary.html#term-iterator\r\n[lazy iterator]: https://en.wikipedia.org/wiki/Lazy_evaluation\r\n[yield expression]: https://docs.python.org/3.11/reference/expressions.html#yield-expressions\r\n",
  "introduction": "# Introduction\r\n\r\nA generator in Python is a _callable function_ or expression that returns a special type of [iterator][iterator] called [generator iterator][generator-iterator].\r\n`Generator-iterators` are [lazy][lazy iterator]: they do not store their `values` in memory, but _generate_ their values when needed.\r\n\r\nA generator function looks like any other function, but contains one or more [yield expressions][yield expression].\r\nEach `yield` will suspend code execution, saving the current execution state (_including all local variables and try-statements_).\r\nWhen the generator function resumes, it picks up state from the suspension - unlike regular functions which reset with every call.\r\n\r\n[lazy iterator]: https://en.wikipedia.org/wiki/Lazy_evaluation\r\n[iterator]: https://docs.python.org/3.11/glossary.html#term-iterator\r\n[yield expression]: https://docs.python.org/3.11/reference/expressions.html#yield-expressions\r\n[generator-iterator]: https://docs.python.org/3.11/glossary.html#term-generator-iterator\r\n",
  "links": [
    {
      "url": "https://docs.python.org/3.11/reference/expressions.html#yield-expressions",
      "description": "Official Python 3.10 docs for the yield expression."
    },
    {
      "url": "https://en.wikipedia.org/wiki/Lazy_evaluation",
      "description": "Wikipedia page about lazy evaluation"
    },
    {
      "url": "https://www.pythonmorsels.com/iterators/",
      "description": "Python Morsels: Iterators & Generators"
    },
    {
      "url": "https://realpython.com/introduction-to-python-generators/",
      "description": "Real python, introduction to generators and yield"
    }
  ],
  "config": {}
}