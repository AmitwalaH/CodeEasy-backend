{
  "concept": "bitwise-operators",
  "about": "# About\r\n\r\nDown at the hardware level, transistors can only be on or off: two states that we traditionally represent with `1` and `0`.\r\nThese are the [`binary digits`][binary-digits], abbreviated as [`bits`][bits].\r\nAwareness of `bits` and `binary` is particularly important for systems programmers working in low-level languages.\r\n\r\nHowever, for most of the history of computing the programming priority has been to find increasingly sophisticated ways to _abstract away_ this binary reality.\r\nIn Python (and many other [high-level programming languages][high-level-language]), we work with `int`, `float`, `string` and other defined _types_, up to and including audio and video formats.\r\nWe let the Python internals take care of (eventually) translating everything to bits.\r\n\r\nNevertheless, using [bitwise-operators][python-bitwise-operators] and [bitwise operations][python-bitwise-operations] can sometimes have significant advantages in speed and memory efficiency, even in a high-level language like Python.\r\n\r\n\r\n## Entering and Displaying Binary Numbers\r\n\r\nUnsurprisingly, Python interacts with the user using decimal numbers, but a programmer can override this default.\r\nIn fact, Python will readily accept an `int` in `binary`, `hexadecimal`, or `octal` format, and will happily perform mathematical operations between them.\r\nFor more details, you can review the [concept:python/binary-octal-hexadecimal]() concept.\r\n\r\nBinary numbers are entered with a `0b` prefix, just as `0x` can be used for hexadecimal (_hex numbers are a concise way to represent groups of 4 bits_), and `oct` can be used for octal numbers.\r\n\r\nThere are multiple ways to convert integers to binary strings, varying in whether they include the `0b` prefix and whether they support left-padding with zeros:\r\n\r\n\r\n```python\r\n# Binary entry.\r\n>>> 0b10111\r\n23\r\n\r\n# Converting an int display to binary string, with prefix.\r\n>>> bin(23)  \r\n'0b10111'\r\n\r\n>>> number = 23\r\n\r\n# Binary without prefix, padded to 8 digits.\r\n>>> format(number, '08b')  \r\n'00010111'\r\n\r\n# Same format, but using an f-string.\r\n>>> f\"{number} in decimal is {number:08b} in binary and {number:x} in hex\" \r\n'23 in decimal is 00010111 in binary and 17 in hex'\r\n```\r\n\r\n\r\n## [`Bitwise Logic`][python-bitwise-operations]\r\n\r\nIn the [concept:python/bools]() concept, we discussed the _logical operators_ `and`, `or` and `not` used with Boolean (_`True` and `False`_) values.\r\nThe same logic rules apply when working with bits.\r\n\r\nHowever, the bitwise equivalents of the logical operators `&` (_and_), `|` (_or_), `~` (_not_), and  `^` (_[XOR][xor]_), are applied to each _bit_ in a binary representation, treating `1` as `True` (\"on\") and `0` as `False` (\"off\").\r\nAn example with the bitwise `&` might make this clearer:\r\n\r\n\r\n```python\r\n>>> x = 0b01100110\r\n>>> y = 0b00101010\r\n\r\n>>> format(x & y, '08b')\r\n'00100010'\r\n```\r\n\r\nOnly positions with a `1` in _**both**_ the input numbers are set to `1` in the output.\r\n\r\nBitwise `&` is commonly used as a way to isolate single bits in a compacted set of `True`/`False` values, such as user-configurable settings in an app.\r\nThis enables the value of individual bits to control program logic:\r\n\r\n\r\n```python\r\n>>> number = 0b0110\r\n>>> number & 0b0001 > 0\r\nFalse\r\n\r\n>>> number & 0b0010 > 0\r\nTrue\r\n```\r\n\r\n\r\nFor a bitwise `|` (or), a `1` is set in the output if there is a `1` in _**either**_ of the inputs:\r\n\r\n\r\n```python\r\n>>> x = 0b01100110\r\n>>> y = 0b00101010\r\n\r\n>>> format(x | y, '08b')\r\n'01101110'\r\n```\r\n\r\n\r\nWith the `^` operator for bitwise e**x**clusive **or** (xor), a `1` is set if it appears in _**either**_ of the inputs _**but not both**_ inputs.\r\nThis symbol might seem familiar from the [concept:python/sets]() concept, where it is used for `set` _symmetric difference_, which is the same as [xor applied to sets][symmetric-difference].\r\nIf xor `^` seems strange, be aware that this is by far the [most common operation in cryptography][xor-cipher].\r\n\r\n\r\n```python\r\n>>> x = 0b01100110\r\n>>> y = 0b00101010\r\n\r\n>>> format(x ^ y, '08b')\r\n'01001100'\r\n```\r\n\r\n\r\nFinally, there is the `~` operator (_the [tilde][tilde] character_), which is a bitwise `not` that takes a single input and _**inverts all the bits**_, which might not be the result you were expecting!\r\nEach `1` in the representation changes to `0`, and vice versa.\r\nSee the section below for details.\r\n\r\n\r\n## Negative Numbers and Binary Representation\r\n\r\nIn decimal representation, we distinguish positive and negative numbers by using a `+` or `-` sign to the left of the digits.\r\nUsing these symbols at a binary level proved inefficient for digital computing and raised the problem that `+0` is not the same as `-0`.\r\n\r\nRather than using `-` and `+`, all modern computers use a [`twos-complement`][twos-complement] representation for negative numbers, right down to the silicon chip level.\r\nThis means that all bits are inverted and a number is _**interpreted as negative**_ if the left-most bit (also termed the \"most significant bit\", or MSB) is a `1`.\r\nPositive numbers have an MSB of `0`.\r\nThis representation has the advantage of only having one version of zero, so that the programmer doesn't have to manage `-0` and `+0`.\r\n\r\nThis way of representing negative and positive numbers adds a complication for Python: there are no finite-integer concepts like `int32` or `int64` internally in the core language.\r\nIn 'modern' Python, `int`s are of unlimited size (_limited only by hardware capacity_), and a negative or bit-inverted number has a (_theoretically_) infinite number of `1`'s to the left, just as a positive number has unlimited `0`'s.\r\n\r\nThis makes it difficult to give a useful example of `bitwise not`:\r\n\r\n```python\r\n>>> x = 0b01100110\r\n>>> format(x, '08b')\r\n'01100110'\r\n\r\n# This is a negative binary (not twos-complement display).\r\n>>> format(~x, '08b')\r\n'-1100111'  \r\n\r\n # Decimal representation.\r\n>>> x\r\n102\r\n\r\n# Using the Bitwise not, with an unintuitive result.\r\n>>> ~x\r\n-103\r\n```\r\n\r\nThis is **not** the `0b10011001` we would see in languages with fixed-size integers.\r\n\r\nThe `~` operator only works as expected with _**unsigned**_ byte or integer types, or with fixed-sized integer types.\r\nThese numeric types are supported in third-party packages such as [`NumPy`][numpy], [`pandas`][pandas], and [`sympy`][sympy] but not in core Python.\r\n\r\nIn practice, Python programmers quite often use the shift operators described below and `& | ^` with positive numbers only.\r\nBitwise operations with negative numbers are much less common.\r\nOne technique is to add [`2**32 (or 1 << 32)`][unsigned-int-python] to a negative value to make an `int` unsigned, but this gets difficult to manage.\r\nAnother strategy is to work with the [`ctypes`][ctypes-module] module, and use c-style integer types, but this is equally unwieldy.\r\n\r\n\r\n## [`Shift operators`][bitwise-shift-operators]\r\n\r\nThe left-shift operator `x << y` simply moves all the bits in `x` by `y` places to the left, filling the new gaps with zeros.\r\nNote that this is arithmetically identical to multiplying a number by `2**y`.\r\n\r\nThe right-shift operator `x >> y` does the opposite.\r\nThis is arithmetically identical to integer division `x // 2**y`.\r\n\r\nKeep in mind the previous section on negative numbers and their pitfalls when shifting.\r\n\r\n\r\n```python\r\n>>> x = 8\r\n>>> format(x, '08b')\r\n'00001000'\r\n\r\n# A left bit shift. \r\n>>> x << 2  \r\n32\r\n\r\n>>> format(x << 2, '08b')\r\n'00100000'\r\n\r\n# A right bit shift. \r\n>>> format(x >> 2, '08b')\r\n'00000010'\r\n```\r\n\r\n[binary-digits]: https://www.khanacademy.org/computing/computers-and-internet/xcae6f4a7ff015e7d:digital-information/xcae6f4a7ff015e7d:binary-numbers/v/the-binary-number-system\r\n[bits]: https://en.wikipedia.org/wiki/Bit\r\n[bitwise-shift-operators]: https://docs.python.org/3/reference/expressions.html#shifting-operations\r\n[ctypes-module]: https://docs.python.org/3/library/ctypes.html#module-ctypes\r\n[high-level-language]: https://en.wikipedia.org/wiki/High-level_programming_language\r\n[numpy]: https://numpy.org/doc/stable/user/basics.types.html\r\n[pandas]: https://pandas.pydata.org/docs/reference/arrays.html#nullable-integer\r\n[python-bitwise-operations]: https://docs.python.org/3/reference/expressions.html#binary-bitwise-operations\r\n[python-bitwise-operators]: https://docs.python.org/3/reference/expressions.html#binary-arithmetic-operations\r\n[symmetric-difference]: https://math.stackexchange.com/questions/84184/relation-between-xor-and-symmetric-difference#:~:text=It%20is%20the%20same%20thing,they%20are%20indeed%20the%20same.\r\n[sympy]: https://docs.sympy.org/latest/modules/codegen.html#predefined-types\r\n[tilde]: https://en.wikipedia.org/wiki/Tilde\r\n[twos-complement]: https://en.wikipedia.org/wiki/Two%27s_complement#:~:text=Two's%20complement%20is%20the%20most,number%20is%20positive%20or%20negative.\r\n[unsigned-int-python]: https://stackoverflow.com/a/20768199\r\n[xor-cipher]: https://en.wikipedia.org/wiki/XOR_cipher\r\n[xor]: https://stackoverflow.com/a/2451393\r\n",
  "introduction": "# Introduction\r\n\r\nDown at the hardware level, transistors can only be on or off: two states that we traditionally represent with `1` and `0`.\r\nThese are the [`binary digits`][binary-digits], abbreviated as [`bits`][bits].\r\nAwareness of `bits` and `binary` is particularly important for systems programmers working in low-level languages.\r\n\r\nHowever, for most of the history of computing the programming priority has been to find increasingly sophisticated ways to _abstract away_ this binary reality.\r\n\r\n\r\nIn Python (and many other [high-level programming languages][high-level-language]), we work with `int`, `float`, `string` and other defined _types_, up to and including audio and video formats.\r\nWe let the Python internals take care of (eventually) translating everything to bits.\r\n\r\n\r\nNevertheless, using [bitwise-operators][python-bitwise-operators] and [bitwise operations][python-bitwise-operations] can sometimes have significant advantages in speed and memory efficiency, even in a high-level language like Python.\r\n\r\n[high-level-language]: https://en.wikipedia.org/wiki/High-level_programming_language\r\n[binary-digits]: https://www.khanacademy.org/computing/computers-and-internet/xcae6f4a7ff015e7d:digital-information/xcae6f4a7ff015e7d:binary-numbers/v/the-binary-number-system\r\n[bits]: https://en.wikipedia.org/wiki/Bit\r\n[python-bitwise-operations]: https://docs.python.org/3/reference/expressions.html#binary-bitwise-operations\r\n[python-bitwise-operators]: https://docs.python.org/3/reference/expressions.html#binary-arithmetic-operations\r\n",
  "links": [
    {
      "url": "https://wiki.python.org/moin/BitwiseOperators/",
      "description": "BitwiseOperators on the Python wiki."
    },
    {
      "url": "https://realpython.com/python-bitwise-operators",
      "description": "Real Python: Bitwise Operators in Python."
    },
    {
      "url": "https://stackoverflow.com/a/20768199",
      "description": "Stack Overflow: Convert a Python int to an unsigned int."
    },
    {
      "url": "https://www.khanacademy.org/computing/computer-science/cryptography/ciphers/a/xor-bitwise-operation",
      "description": "Khan Academy: The Ultimate Shift Cipher."
    },
    {
      "url": "https://en.wikipedia.org/wiki/XOR_cipher",
      "description": "The XOR Cipher"
    }
  ],
  "config": {}
}