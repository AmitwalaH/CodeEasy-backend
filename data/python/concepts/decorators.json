{
  "concept": "decorators",
  "about": "# About\r\n\r\nDecorators are functions that take another function as an argument for the purpose of extending or replacing the behavior of the passed-in function.\r\nIf function `A` is a decorator, and function `B` is its argument, then function `A` modifies, extends, or replaces function `B`'s **behavior** _without modifying_ function `B`'s code.\r\nWe say that the decorator function `A` _wraps_ function `B`.\r\nWhile we talk about \"modifying\" behavior, the wrapped function is _not actually changed_.\r\nBehavior is either added _around_ the wrapped function (_and what it returns_), or the wrapped function's behavior is _substituted_ for some other behavior.\r\n\r\n## A Decorator is a Higher-Order Function\r\n\r\nA [higher-order function][higher-order functions] is a function that accepts one or more functions as arguments and/or returns one or more functions.\r\nA function, used as an argument or returned from another function, is a [first-class function][first-class functions].\r\nA Python function, as a [callable object][callable objects], is a first-class function which can be stored in a variable or used as an argument, much like any other value or object.\r\nHigher-order functions and first-class functions work together to make decorators possible.\r\n\r\n## What Using a Decorator Looks Like\r\n\r\nThe `@` symbol is prepended to the name of the decorator function and placed just above the function to be decorated, like so:\r\n\r\n```python\r\n@decorator\r\ndef decorated_function():\r\n    pass\r\n```\r\n\r\nSome decorators accept arguments:\r\n\r\n```python\r\n@decorator_with_arg(name=\"Bob\")\r\ndef decorated_function2():\r\n    pass\r\n```\r\n\r\nIf a decorator has defined default arguments, you must use parenthesis in the `@decorator()` call for the decorator to work, as you would in calling any function:\r\n\r\n```python\r\n@decorator_with_default_arg()\r\ndef decorated_function3():\r\n    pass\r\n```\r\n\r\nIf a decorator takes a _positional_ arguments, not supplying the arguments will result in an error which will look something like:\r\n\r\n```\r\nTypeError: decorator_with_pos_arg() missing 1 required positional argument: 'name'\r\n```\r\n\r\nThe `@decorator` syntax is syntactic sugar or a shorthand for calling the _decorating function_ and passing the _decorated function_ to it as an argument.\r\nFollowing are examples of alternative ways for calling a decorator:\r\n\r\n```python\r\ndef function():\r\n    pass\r\n\r\nfunction = decorator(function)\r\n\r\n\r\ndef function2():\r\n    pass\r\n\r\nfunction2 = decorator_with_arg(name=\"Bob\")(function2)\r\n\r\n\r\ndef function3():\r\n    pass\r\n\r\nfunction3 = decorator_with_default_arg()(function3)\r\n```\r\n\r\n## Writing a Simple Decorator\r\n\r\nMost decorators are intended to _extend_ or _replace_ the behavior of another function, but some decorators may do nothing but return the functions they are wrapping.\r\n\r\nDecorators are functions which take at least one argument - the function which they are wrapping.\r\nThey usually return either the wrapped function or the result of an expression that uses the wrapped function.\r\n\r\nA simple decorator - one that simply returns its wrapped function - can be written as follows:\r\n```python\r\n>>> def do_nothing(func):\r\n...     return func\r\n...\r\n... @do_nothing\r\n... def function4():\r\n...     return 4\r\n...\r\n>>> print(function4())\r\n4\r\n```\r\n\r\nA decorator may only add side effects, such as additional information used for logging:\r\n\r\n```python\r\n>>> def my_logger(func):\r\n...     print(f\"Entering {func.__name__}\")\r\n...     return func\r\n...\r\n... @my_logger\r\n... def my_func():\r\n...     print(\"Hello\")\r\n...\r\n>>> my_func()\r\nEntering my_func\r\nHello\r\n```\r\n\r\nA decorator does not return itself.\r\nIt may return its function arguments, another function, or one or more values that replace the return from the passed-in or decorated function.\r\nIf a decorator returns another function, it will usually return an [inner function][inner functions].\r\n\r\n## Inner Functions\r\n\r\nA function can be defined within a function.\r\nSuch a nested function is called an [inner function][inner functions].\r\nA decorator may use an inner function to wrap its function argument.\r\nThe decorator then returns its inner function.\r\nThe inner function may then return the original function argument.\r\n\r\n### A Validating Decorator Using an Inner Function\r\n\r\nFollowing is an example of a decorator being used for validation:\r\n\r\n```python\r\n>>> def my_validator(func):\r\n...     def my_wrapper(world):\r\n...         print(f\"Entering {func.__name__} with {world} argument\")\r\n...         if (\"Pluto\" == world):\r\n...             print(\"Pluto is not a planet!\")\r\n...         else:\r\n...             return func(world)\r\n...     return my_wrapper\r\n...\r\n... @my_validator\r\n... def my_func(planet):\r\n...     print(f\"Hello, {planet}!\")\r\n...\r\n>>> my_func(\"World\")\r\nEntering my_func with World argument\r\nHello, World!\r\n...\r\n>>> my_func(\"Pluto\")\r\nEntering my_func with Pluto argument\r\nPluto is not a planet!\r\n```\r\n\r\nOn the first line, we have the definition for the decorator with its `func` argument.\r\nOn the next line is the definition for the decorators _inner function_, which wraps the `func` argument.\r\nSince the _inner function_ wraps the decorator's `func` argument, it is passed the same argument that is passed to `func`.\r\nNote that the wrapper doesn't have to use the same name for the argument that was defined in `func`.\r\nThe original function uses `planet` and the decorator uses `world`, and the decorator still works.\r\n\r\nThe inner function returns either `func` or, if `planet` equals `Pluto`, it will print that Pluto is not a planet.\r\nIt could be coded to raise a `ValueError` instead.\r\nSo, the inner function wraps `func`, and returns either `func` or does something that substitutes what `func` would do.\r\nThe decorator returns its _inner function_.\r\nThe _inner_function_ may or may not return the original, passed-in function.\r\nDepending on what code conditionally executes in the wrapper function or _inner_function_, `func` may be returned, an error could be raised, or a value of `func`'s return type could be returned.\r\n\r\n### Decorating a Function that Takes an Arbitrary Number of Arguments\r\n\r\nDecorators can be written for functions that take an arbitrary number of arguments by using the `*args` and `**kwargs` syntax.\r\n\r\nFollowing is an example of a decorator for a function that takes an arbitrary number of arguments:\r\n\r\n```python\r\n>>> def double(func):\r\n...     def wrapper(*args, **kwargs):\r\n...         return func(*args, **kwargs) * 2\r\n...     return wrapper\r\n...\r\n... @double\r\n... def add(*args):\r\n...     return sum(args)\r\n...\r\n>>> print(add(2, 3, 4))\r\n18\r\n>>> print(add(2, 3, 4, 5, 6))\r\n40\r\n```\r\n\r\nThis works for doubling the return value from the function argument.\r\nIf we want to triple, quadruple, etc. the return value, we can add a parameter to the decorator itself, as we show in the next section.\r\n\r\n### Decorators Which Have Their own Parameters\r\n\r\nFollowing is an example of a decorator that can be configured to multiply the decorated function's return value by an arbitrary amount:\r\n\r\n```python\r\n>>> def multi(factor=1):\r\n...     if (factor == 0):\r\n...         raise ValueError(\"factor must not be 0\")\r\n...\r\n...     def outer_wrapper(func):\r\n...         def inner_wrapper(*args, **kwargs):\r\n...             return func(*args, **kwargs) * factor\r\n...         return inner_wrapper\r\n...     return outer_wrapper\r\n...\r\n... @multi(factor=3)\r\n... def add(*args):\r\n...     return sum(args)\r\n...\r\n>>> print(add(2, 3, 4))\r\n27\r\n>>> print(add(2, 3, 4, 5, 6))\r\n60\r\n```\r\n\r\nThe first lines validate that `factor` is not `0`.\r\nThen the outer wrapper is defined.\r\nThis has the same signature we expect for an unparameterized decorator.\r\nThe outer wrapper has an inner function with the same signature as the original function.\r\nThe inner wrapper does the work of multiplying the returned value from the original function by the argument passed to the decorator.\r\nThe outer wrapper returns the inner wrapper, and the decorator returns the outer wrapper.\r\n\r\nFollowing is an example of a parameterized decorator that controls whether it validates the argument passed to the original function:\r\n\r\n```python\r\n>>> def check_for_pluto(check=True):\r\n...     def my_validator(func):\r\n...         def my_wrapper(world):\r\n...             print(f\"Entering {func.__name__} with {world} argument\")\r\n...             if (check and \"Pluto\" == world):\r\n...                 print(\"Pluto is not a planet!\")\r\n...             else:\r\n...                 return func(world)\r\n...         return my_wrapper\r\n...     return my_validator\r\n...\r\n... @check_for_pluto(check=False)\r\n... def my_func(planet):\r\n...     print(f\"Hello, {planet}!\")\r\n...\r\n>>> my_func(\"World\")\r\nEntering my_func with World argument\r\nHello, World!\r\n>>> my_func(\"Pluto\")\r\nEntering my_func with Pluto argument\r\nHello, Pluto!\r\n```\r\n\r\nThis allows for easy toggling between checking for `Pluto` or not, and is done without having to modify `my_func`.\r\n\r\n[callable objects]: https://www.pythonmorsels.com/callables/\r\n[first-class functions]: https://www.geeksforgeeks.org/first-class-functions-python/\r\n[higher-order functions]: https://www.geeksforgeeks.org/higher-order-functions-in-python/\r\n[inner functions]: https://www.geeksforgeeks.org/python-inner-functions/\r\n",
  "introduction": "# Introduction\r\n\r\nFunctions are first-class objects in Python, which means they can also be passed as arguments to other functions.\r\nDecorators are [higher-order functions][hofunc] that take another function as an argument and return it after extending or modifying its behavior.\r\nDecorators are defined in the same way as any other function, but they are applied on the line above the functions they are decorating using the `@` symbol before their names (`@my_decorator`). While they can take multiple arguments, decorators must take _at least_ the function they are decorating as an argument.\r\n\r\n[hofunc]:https://en.wikipedia.org/wiki/Higher-order_function\r\n",
  "links": [
    {
      "url": "https://peps.python.org/pep-0318/",
      "description": "PEP 318 â€“ Decorators for Functions and Methods"
    },
    {
      "url": "https://www.geeksforgeeks.org/first-class-functions-python/",
      "description": "First Class Functions in Python"
    },
    {
      "url": "https://www.geeksforgeeks.org/higher-order-functions-in-python/",
      "description": "Higher Order Functions in Python"
    },
    {
      "url": "https://realpython.com/primer-on-python-decorators/",
      "description": "Primer on Python Decorators"
    },
    {
      "url": "https://www.geeksforgeeks.org/chain-multiple-decorators-in-python/",
      "description": "Chain Multiple Decorators in Python"
    }
  ],
  "config": {}
}