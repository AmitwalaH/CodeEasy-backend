{
  "concept": "plane-tickets",
  "docs": {
    "introduction": "# Generators\r\n\r\nA `generator` is a function or expression that returns a special type of [iterator][iterator] called [generator iterator][generator-iterator].\r\n`Generator-iterators` are [lazy][lazy iterator]: they do not store their `values` in memory, but _generate_ their values when needed.\r\n\r\nA generator function looks like any other function, but contains one or more [yield expressions][yield expression].\r\nEach `yield` will suspend code execution, saving the current execution state (_including all local variables and try-statements_).\r\nWhen the generator resumes, it picks up state from the suspension - unlike regular functions which reset with every call.\r\n\r\n\r\n## Constructing a generator\r\n\r\nGenerators are constructed much like other looping or recursive functions, but require a [`yield` expression](#the-yield-expression), which we will explore in depth a bit later.\r\n\r\nAn example is a function that returns the _squares_ from a given list of numbers.\r\nAs currently written, all input must be processed before any values can be returned:\r\n\r\n```python\r\n>>> def squares(list_of_numbers):\r\n...     squares = []\r\n...     for number in list_of_numbers:\r\n...         squares.append(number ** 2)\r\n...     return squares\r\n```\r\n\r\nYou can convert that function into a generator like this:\r\n\r\n```python\r\n>>> def squares_generator(list_of_numbers):\r\n...     for number in list_of_numbers:\r\n...         yield number ** 2\r\n```\r\n\r\nThe rationale behind this is that you use a generator when you do not need to produce all the values _at once_.\r\nThis saves memory and processing power, since only the value you are _currently working on_ is calculated.\r\n\r\n\r\n## Using a generator\r\n\r\nGenerators may be used in place of most `iterables` in Python.\r\nThis includes _functions_ or _objects_ that require an `iterable`/`iterator` as an argument.\r\n\r\nTo use the `squares_generator()` generator:\r\n\r\n```python\r\n>>> squared_numbers = squares_generator([1, 2, 3, 4])\r\n\r\n>>> for square in squared_numbers:\r\n...     print(square)\r\n...\r\n1\r\n4\r\n9\r\n16\r\n```\r\n\r\nValues within a `generator` can also be produced/accessed via the `next()` function.\r\n`next()` calls the `__next__()` method of a generator-iterator object, \"advancing\" or evaluating the code up to its `yield` expression, which then \"yields\" or returns a value:\r\n\r\n```python\r\n>>> squared_numbers = squares_generator([1, 2])\r\n\r\n>>> next(squared_numbers)\r\n1\r\n>>> next(squared_numbers)\r\n4\r\n```\r\n\r\nWhen a `generator-iterator` is fully consumed and has no more values to return, it throws a `StopIteration` error.\r\n\r\n```python\r\n>>> next(squared_numbers)\r\nTraceback (most recent call last):\r\n  File \"<stdin>\", line 1, in <module>\r\nStopIteration\r\n```\r\n\r\n\r\n~~~~exercism/note\r\n\r\nGenerator-iterators are a special sub-set of [iterators][iterator].\r\n`Iterators` are the mechanism/protocol that enables looping over _iterables_.\r\nGenerator-iterators and the iterators returned by common Python [`iterables`][iterables] act very similarly, but there are some important differences to note:\r\n\r\n- They are _[lazily evaluated][lazy evaluation]_; iteration is _one-way_ and there is no \"backing up\" to a previous value.\r\n- They are _consumed_ by iterating over the returned values; there is no resetting or saving in memory.\r\n- They are not sortable and cannot be reversed.\r\n- They are not sequence types, and _do not_ have `indexes`. \r\n  You cannot reference a previous or future value using addition or subtraction and you cannot use bracket (`[]`) notation or slicing.\r\n- They cannot be used with the `len()` function, as they have no length.\r\n- They can be _finite_ or _infinite_ - be careful when collecting all values from an _infinite_ `generator-iterator`!\r\n\r\n[iterator]: https://docs.python.org/3.11/glossary.html#term-iterator\r\n[iterables]: https://wiki.python.org/moin/Iterator\r\n[lazy evaluation]: https://en.wikipedia.org/wiki/Lazy_evaluation\r\n~~~~\r\n\r\n\r\n## The yield expression\r\n\r\nThe [yield expression][yield expression] is very similar to the `return` expression.\r\n_Unlike_ the `return` expression, `yield` gives up values to the caller at a _specific point_, suspending evaluation/return of any additional values until they are requested.\r\nWhen `yield` is evaluated, it pauses the execution of the enclosing function and returns any values of the function _at that point in time_.\r\nThe function then _stays in scope_, and when `__next__()` is called, execution resumes until `yield` is encountered again.\r\n\r\n\r\n~~~~exercism/note\r\nUsing `yield` expressions is prohibited outside of functions.\r\n~~~~\r\n\r\n```python\r\n>>> def infinite_sequence():\r\n...     current_number = 0\r\n...     while True:\r\n...         yield current_number\r\n...         current_number += 1\r\n\r\n>>> lets_try = infinite_sequence()\r\n>>> lets_try.__next__()\r\n0\r\n>>> lets_try.__next__()\r\n1\r\n```\r\n\r\n\r\n## Why Create a Generator?\r\n\r\nGenerators are useful in a lot of applications.\r\n\r\nWhen working with a potentially large collection of values, you might not want to put all of them into memory.\r\nA generator can be used to work on larger data piece-by-piece, saving memory and improving performance.\r\n\r\nGenerators are also very helpful when a process or calculation is _complex_, _expensive_, or _infinite_:\r\n\r\n```python\r\n>>> def infinite_sequence():\r\n...     current_number = 0\r\n...     while True:\r\n...         yield current_number\r\n...         current_number += 1\r\n```\r\n\r\nNow whenever `__next__()` is called on the `infinite_sequence` object, it will return the _previous number_ + 1.\r\n\r\n\r\n[generator-iterator]: https://docs.python.org/3.11/glossary.html#term-generator-iterator\r\n[iterables]: https://wiki.python.org/moin/Iterator\r\n[iterator]: https://docs.python.org/3.11/glossary.html#term-iterator\r\n[lazy evaluation]: https://en.wikipedia.org/wiki/Lazy_evaluation\r\n[lazy iterator]: https://en.wikipedia.org/wiki/Lazy_evaluation\r\n[yield expression]: https://docs.python.org/3.11/reference/expressions.html#yield-expressions\r\n",
    "hints": "# Hints\r\n\r\n## 1. Generate seat letters\r\n\r\n- The returned value should be of _type_ `generator`.\r\n- You can have a sequence of letters from `A` to `D` and cycle through them.\r\n- Use `yield` to return the next letter.\r\n\r\n## 2. Generate seats\r\n\r\n- The returned value should be of _type_ `generator`.\r\n- Row `13` should be skipped, so go from `12` to `14`.\r\n- Keep in mind that the returned values should be ordered from low to high. `1A, 1B, 2A, ...`\r\n- Here it might be good to reuse or call functions you have already defined.\r\n\r\n## 3. Assign seats to passengers\r\n\r\n- Make sure your seat numbers do not have any spaces in them.\r\n- Here it might be good to reuse or call functions you have already defined.\r\n\r\n## 4. Ticket codes\r\n\r\n- You can use `len()` to get the length of a string.\r\n- You can use `\"<string>\" * <int>` to repeat a string.\r\n",
    "instructions": "# Instructions\r\n\r\nConda Airlines is the programming-world's biggest airline, with over 10,000 flights a day!\r\n\r\nThey are currently assigning all seats to passengers by hand; this will need to be automated.\r\n\r\nThey have asked _you_ to create software to automate passenger seat assignments.\r\nThey require your software to be memory efficient and performant.\r\n\r\n## 1. Generate seat letters\r\n\r\nConda wants to generate seat letters for their airplanes.\r\nAn airplane is made of rows of seats.\r\nEach row has _4 seats_.\r\nThe seats in each row are always named `A`, `B`, `C`, and `D`.\r\nThe first seat in the row is `A`, the second seat in the row is `B`, and so on.\r\nAfter reaching `D`, it should start again with `A`.\r\n\r\nImplement a function `generate_seat_letters(<number>)` that accepts an `int` that holds how many seat letters to be generated.\r\nThe function should then return an _iterable_ of seat letters.\r\n\r\n```python\r\n>>> letters = generate_seat_letters(4)\r\n>>> next(letters)\r\n\"A\"\r\n>>> next(letters)\r\n\"B\"\r\n```\r\n\r\n## 2. Generate seats\r\n\r\nConda wants a system that can generate a given number of seats for their airplanes.\r\nEach airplane has _4 seats_ in each row.\r\nThe rows are defined using numbers, starting from `1` and going up.\r\nThe seats should be ordered, like: `1A`, `1B`, `1C`, `1D`, `2A`, `2B`, `2C`, `2D`, `3A`, `3B`, `3C`, `3D`, ...\r\n\r\nHere is an example:\r\n\r\n|      x      |  1  |  2  |\r\n| :---------: | :-: | :-: |\r\n|     Row     |  5  | 21  |\r\n| Seat letter |  A  |  D  |\r\n|   Result    | 5A  | 21D |\r\n\r\nMany airlines do not have _row_ number 13 on their flights, due to superstition amongst passengers.\r\nConda Airlines also follows this convention, so make sure you _don't_ generate seats for _row_ number 13.\r\n\r\nImplement a function `generate_seats(<number>)` that accepts an `int` that holds how many seats to be generated.\r\nThe function should then return an _iterable_ of seats given.\r\n\r\n```python\r\n>>> seats = generate_seats(10)\r\n>>> next(seats)\r\n\"1A\"\r\n>>> next(seats)\r\n\"1B\"\r\n```\r\n\r\n## 3. Assign seats to passengers\r\n\r\nNow that you have a function that generates seats, you can use it to assign seats to passengers.\r\n\r\nImplement a function `assign_seats(<passengers>)` that accepts a `list` of passenger names.\r\nThe function should then return a _dictionary_ of `passenger` as _key_, and `seat_number` as _value_.\r\n\r\n```python\r\n>>> passengers = ['Jerimiah', 'Eric', 'Bethany', 'Byte', 'SqueekyBoots', 'Bob']\r\n\r\n>>> assign_seats(passengers)\r\n{'Jerimiah': '1A', 'Eric': '1B', 'Bethany': '1C', 'Byte': '1D', 'SqueekyBoots': '2A', 'Bob': '2B'}\r\n```\r\n\r\n## 4. Ticket codes\r\n\r\nConda Airlines would like to have a unique code for each ticket.\r\nSince they are a big airline, they have a lot of flights.\r\nThis means that there are multiple flights with the same seat number.\r\nThey want you to create a system that creates a unique ticket that is _12_ characters long string code for identification.\r\n\r\nThis code begins with the `assigned_seat` followed by the `flight_id`.\r\nThe rest of the code is appended by `0s`.\r\n\r\nImplement a function `generate_codes(<seat_numbers>, <flight_id>)` that accepts a `list` of `seat_numbers` and a `string` with the flight number.\r\nThe function should then return a `generator` that yields a `ticket_number`.\r\n\r\n```python\r\n>>> seat_numbers = ['1A', '17D']\r\n>>> flight_id = 'CO1234'\r\n>>> ticket_ids = generate_codes(seat_numbers, flight_id)\r\n\r\n>>> next(ticket_ids)\r\n'1ACO12340000'\r\n>>> next(ticket_ids)\r\n'17DCO1234000'\r\n```\r\n",
    "design": "This issue describes how to implement the `generators` concept exercise for the Python track.\r\n\r\n## Goal\r\n\r\nThe goal of this exercise is to teach the syntax and use of `generators` in Python.\r\n\r\n## Learning objectives\r\n\r\n- Understand what generators are and how/when to use them\r\n- Understand how generators relate to `loops` and `iterators`\r\n- Understand how to use the `yield` keyword\r\n- Understand the `__next__()` method\r\n- Create a generator\r\n\r\n## Out of scope\r\n\r\n- Memory and performance characteristics and optimizations\r\n- `throw(type, value=None, traceback=None)`\r\n- `close()`\r\n- `generator expressions`\r\n- `yield from`\r\n- `generators` used as coroutines\r\n\r\n## Concepts covered\r\n\r\n- `generators`\r\n- `yield`\r\n- `__next__()`\r\n- `iterators`\r\n\r\n## Prerequisites\r\n\r\n- `conditionals`\r\n- `dicts`\r\n- `functions`\r\n- `higher-order-functions`\r\n- `lists`\r\n- `loops`\r\n- `iteration`\r\n- `iterators`\r\n- `sequences`\r\n- `classes`\r\n\r\n## Resources to refer to\r\n\r\n- [Generators (Python official docs)](https://docs.python.org/3/howto/functional.html#generators)\r\n- [generator (Python official docs glossary)](https://docs.python.org/3/glossary.html#term-generator)\r\n- [The yield statement (Python official docs)](https://docs.python.org/3/reference/simple_stmts.html#the-yield-statement)\r\n- [Yield expressions (Python official docs)](https://docs.python.org/3/reference/expressions.html#yieldexpr)\r\n- [Iterators(Python official docs)](https://docs.python.org/3/howto/functional.html?#iterators)\r\n- [Generator-iterator methods (Python official docs)](https://docs.python.org/3/reference/expressions.html#generator-iterator-methods)\r\n- [How to Use Generators and yield in Python (Real Python)](https://realpython.com/introduction-to-python-generators/)\r\n\r\n### Hints\r\n\r\n- Referring to one or more of the resources linked above, or analogous resources from a trusted source.\r\n- `Generators` section of the Python Docs Functional How to tutorial: [Generators](https://docs.python.org/3/howto/functional.html#generators)\r\n\r\n## Concept Description\r\n\r\n(_a variant of this can be used for the `v3/languages/python/concepts/<concept>/about.md` doc and this exercises `introduction.md` doc._)\r\n\r\n_**Concept Description Needs to Be Filled In Here/Written**_\r\n\r\n_Some \"extras\" that we might want to include as notes in the concept description, or as links in `links.json`:_\r\n\r\n- Additional `Generator-iterator methods`, such as `generator.send()` and `generator.throw()`\r\n- `generator expressions`\r\n- Asynchronous generator functions\r\n- `generators` used as coroutines\r\n\r\n## Implementing\r\n\r\nThe general Python track concept exercise implantation guide can be found [here](https://github.com/exercism/v3/blob/master/languages/python/reference/implementing-a-concept-exercise.md).\r\n\r\nTests should be written using `unittest.TestCase` and the test file named `generators_test.py`.\r\n\r\nCode in the `.meta/example.py` file should **only use syntax & concepts introduced in this exercise or one of its prerequisites.** Please do not use comprehensions, generator expressions, or other syntax not previously covered. Please also follow [PEP8](https://www.python.org/dev/peps/pep-0008/) guidelines.\r\n\r\n## Help\r\n\r\nIf you have any questions while implementing the exercise, please post the questions as comments in this issue, or contact one of the maintainers on our Slack channel.\r\n"
  },
  "config": {
    "authors": [
      "J08K"
    ],
    "contributors": [
      "BethanyG",
      "kytrinyx",
      "meatball133"
    ],
    "files": {
      "solution": [
        "generators.py"
      ],
      "test": [
        "generators_test.py"
      ],
      "exemplar": [
        ".meta/exemplar.py"
      ]
    },
    "icon": "new-passport",
    "blurb": "Learn about generators by assigning seats to passengers on Anaconda Airlines."
  },
  "starter_code": "\"\"\"Functions to automate Conda airlines ticketing system.\"\"\"\r\n\r\n\r\ndef generate_seat_letters(number):\r\n    \"\"\"Generate a series of letters for airline seats.\r\n\r\n    :param number: int - total number of seat letters to be generated.\r\n    :return: generator - generator that yields seat letters.\r\n\r\n    Seat letters are generated from A to D.\r\n    After D it should start again with A.\r\n\r\n    Example: A, B, C, D\r\n\r\n    \"\"\"\r\n\r\n    pass\r\n\r\n\r\ndef generate_seats(number):\r\n    \"\"\"Generate a series of identifiers for airline seats.\r\n\r\n    :param number: int - total number of seats to be generated.\r\n    :return: generator - generator that yields seat numbers.\r\n\r\n    A seat number consists of the row number and the seat letter.\r\n\r\n    There is no row 13.\r\n    Each row has 4 seats.\r\n\r\n    Seats should be sorted from low to high.\r\n\r\n    Example: 3C, 3D, 4A, 4B\r\n\r\n    \"\"\"\r\n\r\n    pass\r\n\r\ndef assign_seats(passengers):\r\n    \"\"\"Assign seats to passengers.\r\n\r\n    :param passengers: list[str] - a list of strings containing names of passengers.\r\n    :return: dict - with the names of the passengers as keys and seat numbers as values.\r\n\r\n    Example output: {\"Adele\": \"1A\", \"Björk\": \"1B\"}\r\n\r\n    \"\"\"\r\n\r\n    pass\r\n\r\ndef generate_codes(seat_numbers, flight_id):\r\n    \"\"\"Generate codes for a ticket.\r\n\r\n    :param seat_numbers: list[str] - list of seat numbers.\r\n    :param flight_id: str - string containing the flight identifier.\r\n    :return: generator - generator that yields 12 character long ticket codes.\r\n\r\n    \"\"\"\r\n\r\n    pass\r\n",
  "exemplar_code": "\"\"\"Functions to automate Conda airlines ticketing system.\"\"\"\r\n\r\nimport math\r\n\r\nSEATS_IN_ROW = ['A', 'B', 'C', 'D']\r\n\r\n\r\ndef generate_seat_letters(number):\r\n    \"\"\"Generate a series of letters for airline seats.\r\n\r\n    :param number: int - total number of seat letters to be generated.\r\n    :return: generator - generator that yields seat letters.\r\n\r\n    Seat letters are generated from A to D.\r\n    After D it should start again with A.\r\n\r\n    Example: A, B, C, D\r\n\r\n    \"\"\"\r\n\r\n    for seat in range(number):\r\n        yield SEATS_IN_ROW[seat % 4]\r\n\r\n\r\ndef generate_seats(number):\r\n    \"\"\"Generate a series of identifiers for airline seats.\r\n\r\n    :param number: int - total number of seats to be generated.\r\n    :return: generator - generator that yields seat numbers.\r\n\r\n    A seat number consists of the row number and the seat letter.\r\n\r\n    There is no row 13.\r\n    Each row has 4 seats.\r\n\r\n    Seats should be sorted from low to high.\r\n\r\n    Example: 3C, 3D, 4A, 4B\r\n\r\n    \"\"\"\r\n\r\n    number = number + 4 if number >= 13 else number\r\n    letters = generate_seat_letters(number)\r\n    for seat in range(number):\r\n        row_number = math.ceil((seat+1) / 4)\r\n        if row_number != 13:\r\n            yield f'{str(row_number)}{next(letters)}'\r\n\r\n    # return (f'{str(row_number)}{next(letters)}' for seat in range(number)\r\n    #         if (row_number := math.ceil((seat+1) / 4)) and row_number != 13)\r\n\r\n\r\ndef assign_seats(passengers):\r\n    \"\"\"Assign seats to passengers.\r\n\r\n    :param passengers: list[str] - a list of strings containing names of passengers.\r\n    :return: dict - with the names of the passengers as keys and seat numbers as values.\r\n\r\n    Example output: {\"Adele\": \"1A\", \"Björk\": \"1B\"}\r\n\r\n    \"\"\"\r\n\r\n    number = len(passengers)\r\n    output = {}\r\n    for passenger, seat_number in zip(passengers, generate_seats(number)):\r\n        output[passenger] = seat_number\r\n    return output\r\n\r\ndef generate_codes(seat_numbers, flight_id):\r\n    \"\"\"Generate codes for a ticket.\r\n\r\n    :param seat_numbers: list[str] - list of seat numbers.\r\n    :param flight_id: str - string containing the flight identifier.\r\n    :return: generator - generator that yields 12 character long ticket codes.\r\n\r\n    \"\"\"\r\n\r\n    for seat in seat_numbers:\r\n        base_string = f'{seat}{flight_id}'\r\n        yield base_string + '0' * (12 - len(base_string))\r\n",
  "tests": "import inspect\r\nimport unittest\r\nimport pytest\r\n\r\nfrom generators import (\r\n    generate_seat_letters,\r\n    generate_seats,\r\n    assign_seats,\r\n    generate_codes\r\n)\r\n\r\nclass PlaneTicketsTest(unittest.TestCase):\r\n    @pytest.mark.task(taskno=1)\r\n    def test_task1_returns_generator(self):\r\n        \"\"\"Test if  generate_seat_letters() returns a generator type.\"\"\"\r\n\r\n        number = 5\r\n        error_message = (f'Called generate_seat_letters({number}). '\r\n                         f'The function returned a {type(generate_seat_letters(number))} type, '\r\n                         f\"but the tests expected the function to return a <class 'generator'> type.\")\r\n\r\n        self.assertTrue(inspect.isgenerator(generate_seat_letters(number)), msg=error_message)\r\n\r\n    @pytest.mark.task(taskno=1)\r\n    def test_generate_seat_letters(self):\r\n        test_data = [1, 2, 3, 4, 5]\r\n        result_data = [[\"A\"],\r\n                       [\"A\", \"B\"],\r\n                       [\"A\", \"B\", \"C\"],\r\n                       [\"A\", \"B\", \"C\", \"D\"],\r\n                       [\"A\", \"B\", \"C\", \"D\", \"A\"]]\r\n\r\n        for variant, (number, expected) in enumerate(zip(test_data, result_data), start=1):\r\n            with self.subTest(f\"variation #{variant}\", number=number, expected=expected):\r\n                actual_result = list(generate_seat_letters(number))\r\n                error_message = (f'Called generate_seat_letters({number}). '\r\n                                 f'The function returned {actual_result}, but the tests '\r\n                                 f'expected {expected} when generating {number} seat(s).')\r\n\r\n                self.assertEqual(actual_result, expected, msg=error_message)\r\n\r\n    @pytest.mark.task(taskno=2)\r\n    def test_task2_returns_generator(self):\r\n        \"\"\"Test if generate_seats() returns a generator type.\"\"\"\r\n\r\n        number = 7\r\n        error_message = (f'Called generate_seats({number}). '\r\n                         f'The function returned a {type(generate_seats(number))} type, '\r\n                         f\"but the tests expected the function to return a <class 'generator'> type.\")\r\n\r\n        self.assertTrue(inspect.isgenerator(generate_seats(number)), msg=error_message)\r\n\r\n    @pytest.mark.task(taskno=2)\r\n    def test_generate_seats(self):\r\n        test_data = [1, 2, 3, 4, 5]\r\n        result_data = [[\"1A\"],\r\n                       [\"1A\", \"1B\"],\r\n                       [\"1A\", \"1B\", \"1C\"],\r\n                       [\"1A\", \"1B\", \"1C\", \"1D\"],\r\n                       [\"1A\", \"1B\", \"1C\", \"1D\", \"2A\"]]\r\n\r\n        for variant, (number, expected) in enumerate(zip(test_data, result_data), start=1):\r\n            with self.subTest(f\"variation #{variant}\", number=number, expected=expected):\r\n                actual_result = list(generate_seats(number))\r\n                error_message = (f'Called generate_seats({number}). '\r\n                                 f'The function returned {actual_result}, but the tests '\r\n                                 f'expected {expected} when generating {number} seat(s).')\r\n\r\n                self.assertEqual(actual_result, expected, msg=error_message)\r\n\r\n    @pytest.mark.task(taskno=2)\r\n    def test_generate_seats_skips_row_13(self):\r\n        test_data = [14 * 4]\r\n        result_data = [[\"1A\", \"1B\", \"1C\", \"1D\", \"2A\", \"2B\", \"2C\", \"2D\",\r\n                        \"3A\", \"3B\", \"3C\", \"3D\", \"4A\", \"4B\", \"4C\", \"4D\",\r\n                        \"5A\", \"5B\", \"5C\", \"5D\", \"6A\", \"6B\", \"6C\", \"6D\",\r\n                        \"7A\", \"7B\", \"7C\", \"7D\", \"8A\", \"8B\", \"8C\", \"8D\",\r\n                        \"9A\", \"9B\", \"9C\", \"9D\", \"10A\", \"10B\", \"10C\", \"10D\",\r\n                        \"11A\", \"11B\", \"11C\", \"11D\", \"12A\", \"12B\", \"12C\", \"12D\",\r\n                        \"14A\", \"14B\", \"14C\", \"14D\", \"15A\", \"15B\", \"15C\", \"15D\"]]\r\n\r\n        for variant, (number, expected) in enumerate(zip(test_data, result_data), start=1):\r\n            with self.subTest(f\"variation #{variant}\", number=number, expected=expected):\r\n                actual_result = list(generate_seats(number))\r\n                error_message = (f'Called generate_seats({number}). '\r\n                                 f'The function returned {actual_result}, but the tests '\r\n                                 f'expected: {expected}, when generating {number} seat(s).')\r\n\r\n                self.assertEqual(actual_result, expected, msg=error_message)\r\n\r\n    @pytest.mark.task(taskno=3)\r\n    def test_assign_seats(self):\r\n        test_data = [[\"Passenger1\", \"Passenger2\", \"Passenger3\", \"Passenger4\", \"Passenger5\"],\r\n                     [\"TicketNo=5644\", \"TicketNo=2273\", \"TicketNo=493\", \"TicketNo=5411\", \"TicketNo=824\"]]\r\n        result_data = [{\"Passenger1\": \"1A\", \"Passenger2\": \"1B\",\r\n                        \"Passenger3\": \"1C\", \"Passenger4\": \"1D\", \"Passenger5\": \"2A\"},\r\n                       {\"TicketNo=5644\": \"1A\", \"TicketNo=2273\": \"1B\",\r\n                        \"TicketNo=493\": \"1C\", \"TicketNo=5411\": \"1D\", \"TicketNo=824\": \"2A\"}]\r\n\r\n        for variant, (passengers, expected) in enumerate(zip(test_data, result_data), start=1):\r\n            with self.subTest(f\"variation #{variant}\", passengers=passengers, expected=expected):\r\n                actual_result = assign_seats(passengers)\r\n                error_message = (f'Called assign_seats({passengers}). '\r\n                                 f'The function returned {actual_result}, but the tests '\r\n                                 f'expected {expected}, when assigning seats.')\r\n\r\n                self.assertEqual(actual_result, expected, msg=error_message)\r\n\r\n    @pytest.mark.task(taskno=4)\r\n    def test_task4_returns_generator(self):\r\n        \"\"\"Test if generate_codes() returns a generator type.\"\"\"\r\n\r\n        seat_numbers, flight_id = \"11B\", \"HA80085\"\r\n        error_message = (f'Called generate_codes({seat_numbers}, {flight_id}). '\r\n                         f'The function returned a {type(generate_codes(seat_numbers, flight_id))} type, '\r\n                         f\"but the tests expected the function to return a <class 'generator'> type.\")\r\n\r\n        self.assertTrue(inspect.isgenerator(generate_codes(seat_numbers, flight_id)), msg=error_message)\r\n\r\n\r\n    @pytest.mark.task(taskno=4)\r\n    def test_generate_codes(self):\r\n        test_data = [([\"12A\", \"38B\", \"69C\", \"102B\"],\"KL1022\"),\r\n                      ([\"22C\", \"88B\", \"33A\", \"44B\"], \"DL1002\")]\r\n        result_data = [['12AKL1022000', '38BKL1022000', '69CKL1022000', '102BKL102200'],\r\n                       ['22CDL1002000', '88BDL1002000', '33ADL1002000', '44BDL1002000']]\r\n\r\n        for variant, ((seat_numbers, flight_id), expected) in enumerate(zip(test_data, result_data), start=1):\r\n            with self.subTest(f\"variation #{variant}\", seat_numbbers=seat_numbers,\r\n                              flight_id=flight_id, expected=expected):\r\n\r\n                actual_result = list(generate_codes(seat_numbers, flight_id))\r\n                error_message = (f'Called generate_codes({seat_numbers}, {flight_id}). '\r\n                                 f'The function returned {actual_result}, but the tests '\r\n                                 f'expected {expected} when generating ticket numbers.')\r\n\r\n                # Note: DO NOT call the function here again, in case the student is using list.pop()\r\n                # to process the input.  If another call is done with that condition,\r\n                # the test will fail with a terrible error message.\r\n                self.assertEqual(actual_result, expected, msg=error_message)\r\n"
}