{
  "concept": "electric-bill",
  "docs": {
    "introduction": "# Introduction\r\n\r\nPython has three different types of built-in numbers: integers ([`int`][int]), floating-point ([`float`][float]), and complex ([`complex`][complex]).\r\nFractions ([`fractions.Fraction`][fractions]) and Decimals ([`decimal.Decimal`][decimals]) are also available via import from the standard library.\r\n\r\nWhole numbers including hexadecimal ([_`hex()`_][hex]), octal ([_`oct()`_][oct]) and binary ([_`bin()`_][bin]) numbers **without** decimal places are also identified as `ints`:\r\n\r\n```python\r\n# Ints are whole numbers.\r\n>>> 1234\r\n1234\r\n>>> type(1234)\r\n<class 'int'>\r\n\r\n>>> -12\r\n-12\r\n```\r\n\r\nNumbers containing a decimal point (with or without fractional parts) are identified as `floats`:\r\n\r\n```python\r\n>>> 3.45\r\n3.45\r\n>>> type(3.45)\r\n<class 'float'>\r\n```\r\n\r\n## Arithmetic\r\n\r\nPython fully supports arithmetic between these different number types, and will convert narrower numbers to match their less narrow counterparts when used with the binary arithmetic operators (`+`, `-`, `*`, `/`, `//`, and `%`).\r\n\r\n### Addition and subtraction\r\n\r\nAddition and subtraction operators behave as they do in normal math.\r\nIf one or more of the operands is a `float`, the remaining `int`s will be converted to `float`s as well:\r\n\r\n```python\r\n>>> 5 - 3\r\n2\r\n# The int is widened to a float here, and a float is returned.\r\n>>> 3 + 4.0\r\n7.0\r\n```\r\n\r\n### Multiplication\r\n\r\nAs with addition and subtraction, multiplication will convert narrower numbers to match their less narrow counterparts:\r\n\r\n```python\r\n>>> 3 * 2\r\n6\r\n\r\n>>> 3 * 2.0\r\n6.0\r\n```\r\n\r\n### Division\r\n\r\nDivision always returns a `float`, even if the result is a whole number:\r\n\r\n```python\r\n>>> 6/5\r\n1.2\r\n\r\n>>> 6/2\r\n3.0\r\n```\r\n\r\n### Floor division\r\n\r\nIf an `int` result is needed, you can use floor division to truncate the result.\r\nFloor division is performed using the `//` operator:\r\n\r\n```python\r\n>>> 6//5\r\n1\r\n\r\n>>> 6//2\r\n3\r\n```\r\n\r\n### Modulo\r\n\r\nThe modulo operator (`%`) returns the remainder of the division of the two operands:\r\n\r\n```python\r\n# The result of % is zero here, because dividing 8 by 2 leaves no remainder\r\n>>> 8 % 2\r\n0\r\n\r\n# The result of % is 2 here, because 3 only goes into 5 once, with 2 leftover\r\n>>> 5 % 3\r\n2\r\n```\r\n\r\nAnother way to look at 5 % 3:\r\n\r\n```python\r\n>>> whole_part = int(5/3)\r\n1\r\n\r\n>>> decimal_part = 5/3 - whole_part\r\n0.6666666666666667\r\n\r\n>>> whole_remainder = decimal_part * 3\r\n2.0\r\n```\r\n\r\n## Round\r\n\r\nPython provides a built-in function [`round(number, <decimal_places>)`][round] to round off a floating point number to a given number of decimal places.\r\nIf no number of decimal places is specified, the number is rounded off to the nearest integer and will return an `int`:\r\n\r\n```python\r\n>>> round(3.1415926535, 2)\r\n3.14\r\n\r\n>>> round(3.1415926535)\r\n3\r\n```\r\n\r\n## Priority and parentheses\r\n\r\nPython allows you to use parentheses to group expressions.\r\nThis is useful when you want to override the default order of operations.\r\n\r\n```python\r\n>>> 2 + 3 * 4\r\n14\r\n\r\n>>> (2 + 3) * 4\r\n20\r\n```\r\n\r\nPython follows the [PEMDAS][pemdas] rule for operator precedence.\r\nThis means calculations within `()` have the highest priority, followed by `**`, then `*`, `/`, `//`, `%`, `+`, and `-`:\r\n\r\n```python\r\n>>> 2 + 3 - 4 * 4\r\n-11\r\n\r\n>>> (2 + 3 - 4) * 4\r\n4\r\n\r\n# In the following example, the `**` operator has the highest priority, then `*`, then `+`\r\n# Meaning we first do 4 ** 4, then 3 * 64, then 2 + 192\r\n>>> 2 + 3 * 4 ** 4\r\n770\r\n```\r\n\r\n## Precision & Representation\r\n\r\nIntegers in Python have [arbitrary precision][arbitrary-precision] -- the number of digits is limited only by the available memory of the host system.\r\n\r\nFloating point numbers are usually implemented using a `double` in C (_15 decimal places of precision_), but will vary in representation based on the host system.\r\nComplex numbers have a `real` and an `imaginary` part, both of which are represented by floating point numbers.\r\n\r\nFor a more detailed discussions of the issues and limitations of floating point arithmetic across programming languages, take a look at [0.30000000000000004.com][0.30000000000000004.com] and [The Python Tutorial][floating point math].\r\n\r\n[0.30000000000000004.com]: https://0.30000000000000004.com/\r\n[arbitrary-precision]: https://en.wikipedia.org/wiki/Arbitrary-precision_arithmetic\r\n[bin]: https://docs.python.org/3/library/functions.html#bin\r\n[complex]: https://docs.python.org/3/library/functions.html#complex\r\n[decimals]: https://docs.python.org/3/library/decimal.html#module-decimal\r\n[float]: https://docs.python.org/3/library/functions.html#float\r\n[floating point math]: https://docs.python.org/3.9/tutorial/floatingpoint.html\r\n[fractions]: https://docs.python.org/3/library/fractions.html\r\n[hex]: https://docs.python.org/3/library/functions.html#hex\r\n[int]: https://docs.python.org/3/library/functions.html#int\r\n[oct]: https://docs.python.org/3/library/functions.html#oct\r\n[pemdas]: https://mathworld.wolfram.com/PEMDAS.html\r\n[round]: https://docs.python.org/3/library/functions.html#round\r\n",
    "hints": "# General\r\n\r\nRemember that you can always reuse/call previously completed functions when writing new ones.\r\n\r\n## 1. Get extra hours\r\n\r\n- This is all about calculating the _remainder_ left after whole division.\r\n- Take a look at [`divmod()`][divmod], and look for an operator that does something similar.\r\n\r\n## 2. Get kW value\r\n\r\n- Remember to give [`round()`][round] a number of _decimal places_, or you will get a whole number back as a result.\r\n\r\n## 3. Get kwh value\r\n\r\n- The result of dividing an `int` by a `float` is always a `float`.\r\n- To get only an integer value from division, use [_floor_ division][floor], which will truncate the decimal.\r\n\r\n## 4. Get efficiency\r\n\r\n- The result of dividing an `int` by a `float` is always a `float`.\r\n\r\n## 5. Get cost\r\n\r\n- It might be good to _reuse_ or call other functions you have already completed here.\r\n- The result of dividing an `int` by a `float` is always a `float`.\r\n\r\n[divmod]: https://docs.python.org/3/library/functions.html#divmod\r\n[floor]: https://docs.python.org/3/glossary.html#term-floor-division\r\n[round]: https://docs.python.org/3/library/functions.html#round\r\n",
    "instructions": "# Instructions\r\n\r\nThe company you work for wants to reduce their carbon footprint, so they want you to write a program to calculate the power usage and cost of running their electronics.\r\n\r\n## 1. Get extra hours\r\n\r\nYour employer has a program that calculates the time it takes to run different electronics.\r\nCurrently, the time is stored in hours.\r\nWhen your employer added the hours, they noticed that the time duration was not correct.\r\nThey want you to add 3 extra hours to the time data.\r\nThey would also like to know how many \"extra\" hours there are after converting the data to \"full\" days (a day is 24 hours).\r\nThe time to convert may not be in full days.\r\n\r\nImplement a function `get_extra_hours()` that accepts an integer which holds the number of hours.\r\nThe function should make the appropriate \"extra hours\" adjustment, and then `return` an integer representing how many hours needs to be removed from the total to get the time in \"full\" days.\r\n\r\n```python\r\n>>> get_extra_hours(25)\r\n4\r\n```\r\n\r\n## 2. Get kW value\r\n\r\nYour employer wants to know the power usage of the different electronics in kW.\r\nkW stands for kilowatt, where watts are a unit of power.\r\nKilo in the unit name is a prefix in the metric system meaning 1000.\r\nOne kilowatt == 1000 watts.\r\n\r\nImplement a function `get_kW_value()` that accepts an integer which holds the number of watts.\r\nThe function should then `return` the watts as kilowatts rounded to 1 decimal place.\r\n\r\n```python\r\n>>> get_kW_value(1150)\r\n1.2\r\n```\r\n\r\n## 3. Get kWh value\r\n\r\nTo be able to calculate the cost of running the electronics, your employer needs to know the power usage in kWh.\r\nkWh stands for kilowatt-hour, where hour is a unit of time.\r\nOne kilowatt-hour == 1000 watts used for 1 hour.\r\nAn hour is made up of 60 minutes and a minute is made up of 60 seconds.\r\nOne hour is equal to 3600 seconds.\r\nTo calculate the kWh value, you must convert watts to kW, and then floor-divide the result by 3600.\r\n\r\nImplement a function `get_kWh_value()` that accepts an integer which holds the number of watts.\r\nThe function should then `return` the kilowatt-hours as an integer.\r\n\r\n```python\r\n>>> get_kWh_value(5000000)\r\n1\r\n```\r\n\r\n## 4. Get efficiency\r\n\r\nElectronics are not 100% efficient.\r\nTherefore, your employer wants you to calculate the _efficiency_ of the electronics.\r\nTo get efficiency, you must divide the power factor (_a float between 0 and 100_) by 100.\r\n\r\nImplement a function `get_efficiency()` that accepts a float that holds the power factor.\r\nThe function should then `return` the calculated efficiency as a float.\r\n\r\n```python\r\n>>> get_efficiency(80)\r\n0.8\r\n```\r\n\r\n## 5. Get cost\r\n\r\nYour employer wants to know the cost of running the electronics.\r\nThe cost of running the electronics is the power used multiplied by the cost per kWh.\r\nThe power used is the power given divided by the calculated efficiency.\r\n\r\nImplement a function `get_cost(<watts>,<power_factor>,<price>)` that accepts an integer that holds the number of watts, a float that has the power factor, and a float that holds the cost per kWh.\r\nThe function should then `return` the cost of running the electronics as a float.\r\n\r\n```python\r\n>>> get_cost(5000000, 80, 0.25)\r\n0.3125\r\n```\r\n",
    "design": "# Design\r\n\r\n## Goal\r\n\r\nThe goal of this exercise is to teach the student how to use arithmetic operators and type casting between `int` and `float` in Python\r\n\r\n## Learning objectives\r\n\r\n- use `+`, `-`, `*`, `/` to add, subtract, multiply, divide numbers(`int` and `float`).\r\n- use `round()` to round values.\r\n- use `//` to floor divide\r\n- use `%` to calculate remainders.\r\n"
  },
  "config": {
    "authors": [
      "meatball133",
      "BethanyG"
    ],
    "contributors": [
      "MatthijsBlom"
    ],
    "files": {
      "solution": [
        "electric_bill.py"
      ],
      "test": [
        "electric_bill_test.py"
      ],
      "exemplar": [
        ".meta/exemplar.py"
      ]
    },
    "icon": "city-office",
    "blurb": "Learn about numbers in Python while saving your employers money on their electric bill."
  },
  "starter_code": "\"\"\"Functions to help the company calculate their power usage.\"\"\"\r\n\r\n\r\ndef get_extra_hours(hours):\r\n    \"\"\"Return the number of hours.\r\n\r\n    :param: hours: int - number of hours.\r\n    :return: int - number of \"extra\" hours.\r\n    \"\"\"\r\n    pass\r\n\r\n\r\ndef get_kW_amount(watts):\r\n    \"\"\"Return the kW amount of a given watt amount.\r\n\r\n    :param: watts: int - watt amount.\r\n    :return: float - kW amount.\r\n    \"\"\"\r\n    pass\r\n\r\n\r\ndef get_kwh_amount(watts):\r\n    \"\"\"Return the kWh amount of a given watt amount and hours.\r\n\r\n    :param: watts: int - watt amount.\r\n    :return: int - kilowatt hour amount.\r\n    \"\"\"\r\n    pass\r\n\r\n\r\ndef get_efficiency(power_factor):\r\n    \"\"\"Return the efficiency calculated from the power factor.\r\n\r\n    :param: power_factor: float.\r\n    :return: float - efficiency.\r\n    \"\"\"\r\n    pass\r\n\r\n\r\ndef get_cost(watts, power_factor, price):\r\n    \"\"\"Calculate the cost of a given kWh value, efficiency and price.\r\n\r\n    :param: watts: int - watt value.\r\n    :param: power_factor: float - efficiency.\r\n    :param: price: float - price of kWh.\r\n    :return: float - cost of kWh.\r\n    \"\"\"\r\n    pass\r\n",
  "exemplar_code": "\"\"\"Functions to help the company calculate their power usage.\"\"\"\r\n\r\n\r\ndef get_extra_hours(hours):\r\n    \"\"\"Return the number of hours.\r\n\r\n    :param: hours: int - number of hours.\r\n    :return: int - number of \"extra\" hours.\r\n    \"\"\"\r\n\r\n    return (hours + 3) % 24\r\n\r\n\r\ndef get_kW_amount(watts):\r\n    \"\"\"Return the kW amount of a given watt amount.\r\n\r\n    :param: watts: int - watt amount.\r\n    :return: float - kW amount.\r\n    \"\"\"\r\n\r\n    # rounds to one decimal place here\r\n    return round(watts / 1000, 1)\r\n\r\n\r\ndef get_kwh_amount(watts):\r\n    \"\"\"Return the kWh amount of a given watt amount and hours.\r\n\r\n    :param: watts: int - watt amount.\r\n    :return: int - kilowatt hour amount.\r\n    \"\"\"\r\n    return get_kW_amount(watts) // 3600\r\n\r\n\r\ndef get_efficiency(power_factor):\r\n    \"\"\"Return the efficiency calculated from the power factor.\r\n\r\n    :param: power_factor: float.\r\n    :return: float - efficiency.\r\n    \"\"\"\r\n    return power_factor / 100\r\n\r\n\r\ndef get_cost(watts, power_factor, price):\r\n    \"\"\"Calculate the cost of a given kWh value, efficiency and price.\r\n\r\n    :param: watts: int - watt value.\r\n    :param: power_factor: float - efficiency.\r\n    :param: price: float - price of kWh.\r\n    :return: float - cost of kWh.\r\n    \"\"\"\r\n    return price * (get_kwh_amount(watts) / get_efficiency(power_factor))\r\n",
  "tests": "import unittest\r\nimport pytest\r\nfrom electric_bill import (get_extra_hours,\r\n                                 get_kW_amount,\r\n                                 get_kwh_amount,\r\n                                 get_efficiency,\r\n                                 get_cost)\r\n\r\n\r\nclass ElecticBillTest(unittest.TestCase):\r\n\r\n    @pytest.mark.task(taskno=1)\r\n    def test_get_extra_hours(self):\r\n        input_data = [25, 10, 5, 2, 1, 120, 21]\r\n        output_data = [4, 13, 8, 5, 4, 3, 0]\r\n\r\n        for variant, (input_data, output_data) in enumerate(zip(input_data, output_data), start=1):\r\n            with self.subTest(f'variation #{variant}', input_data=input_data, output_data=output_data):\r\n                error_msg=f'Expected: {output_data} but got a different amount.'\r\n                self.assertEqual(get_extra_hours(input_data), output_data, msg=error_msg)\r\n\r\n    @pytest.mark.task(taskno=2)\r\n    def test_get_kW_amount(self):\r\n        input_data = [1000, 2200, 2900, 900, 1160]\r\n        output_data = [1, 2.2, 2.9, 0.9, 1.2]\r\n\r\n        for variant, (input_data, output_data) in enumerate(zip(input_data, output_data), start=1):\r\n            with self.subTest(f'variation #{variant}', input_data=input_data, output_data=output_data):\r\n                error_msg=f'Expected: {output_data} but got a different amount.'\r\n                self.assertEqual(get_kW_amount(input_data), output_data, msg=error_msg)\r\n\r\n    @pytest.mark.task(taskno=3)\r\n    def test_get_kwh_amount(self): \r\n        input_data = (5000000, 2141241, 43252135, 5324623462, 4321512)\r\n        output_data = [1, 0, 12, 1479, 1]\r\n\r\n        for variant, (input_data, output_data) in enumerate(zip(input_data, output_data), start=1):\r\n            with self.subTest(f'variation #{variant}', input_data=input_data, output_data=output_data):\r\n                error_msg=f'Expected: {output_data} but got a different amount.'\r\n                self.assertEqual(get_kwh_amount(input_data), output_data, msg=error_msg)\r\n\r\n    @pytest.mark.task(taskno=4)\r\n    def test_get_efficiency(self): \r\n        input_data = [80.0, 99.99, 0.8, 40.0]\r\n        output_data = [0.8, 0.9999, 0.008, 0.4]\r\n\r\n        for variant, (input_data, output_data) in enumerate(zip(input_data, output_data), start=1):\r\n            with self.subTest(f'variation #{variant}', input_data=input_data, output_data=output_data):\r\n                error_msg=f'Expected: {output_data} but got a different value.'\r\n                self.assertAlmostEqual(get_efficiency(input_data), output_data, msg=error_msg)\r\n\r\n    @pytest.mark.task(taskno=5)\r\n    def test_get_cost(self):\r\n        input_data = ((5000000, 80.0, 0.25), (2141241, 99.99, 2), (43252135, 0.8, 4), (4321512, 40.0, 2))\r\n        output_data = (0.3125, 0, 6000, 5)\r\n        \r\n        for variant, (input_data, output_data) in enumerate(zip(input_data, output_data), start=1):\r\n            with self.subTest(f'variation #{variant}', input_data=input_data, output_data=output_data):\r\n                error_msg=f'Expected: {output_data} but got a different value.'\r\n                self.assertEqual(get_cost(*input_data), output_data, msg=error_msg)\r\n"
}