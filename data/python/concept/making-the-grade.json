{
  "concept": "making-the-grade",
  "docs": {
    "introduction": "# Introduction\r\n\r\nPython has two looping constructs.\r\n`while` loops for _indefinite_ (uncounted) iteration and `for` loops for _definite_, (counted) iteration.\r\nThe keywords `break`, `continue`, and `else` help customize loop behavior.\r\n`range()` and `enumerate()` help with loop counting and indexing.\r\n\r\n\r\n## While\r\n\r\n[`while`][while statement] loops will continue to execute as long as the `loop expression` or \"test\" evaluates to `True` in a [`boolean context`][truth value testing], terminating when it evaluates to `False`:\r\n\r\n```python\r\n\r\n# Lists are considered \"truthy\" in a boolean context if they\r\n# contain one or more values, and \"falsy\" if they are empty.\r\n\r\n>>> placeholders = [\"spam\", \"ham\", \"eggs\", \"green_spam\", \"green_ham\", \"green_eggs\"]\r\n\r\n>>> while placeholders:\r\n...     print(placeholders.pop(0))\r\n...\r\n'spam'\r\n'ham'\r\n'eggs'\r\n'green_spam'\r\n'green_ham'\r\n'green_eggs'\r\n```\r\n\r\n\r\n## For\r\n\r\nThe basic [`for`][for statement] `loop` in Python is better described as a _`for each`_ which cycles through the values of any [iterable object][iterable], terminating when there are no values returned from calling [`next()`][next built-in]:\r\n\r\n```python\r\n\r\n>>> word_list = [\"bird\", \"chicken\", \"barrel\", \"bongo\"]\r\n\r\n>>> for word in word_list:\r\n...    if word.startswith(\"b\"):\r\n...        print(f\"{word.title()} starts with a B.\")\r\n...    else:\r\n...        print(f\"{word.title()} doesn't start with a B.\")\r\n...\r\n'Bird starts with a B.'\r\n'Chicken doesn\\'t start with a B.'\r\n'Barrel starts with a B.'\r\n'Bongo starts with a B.'\r\n```\r\n\r\n\r\n## Sequence Object range()\r\n\r\nWhen there isn't a specific `iterable` given, the special [`range()`][range] sequence is used as a loop counter.\r\n`range()` requires an `int` before which to `stop` the sequence, and can optionally take `start` and `step` parameters.\r\nIf no `start` number is provided, the sequence will begin with 0.\r\n`range()` objects are **lazy** (_values are generated on request_), support all [common sequence operations][common sequence operations], and take up a fixed amount of memory, no matter how long the sequence specified.\r\n\r\n```python\r\n# Here we use range to produce some numbers, rather than creating a list of them in memory.\r\n# The values will start with 1 and stop *before* 7\r\n\r\n>>> for number in range(1, 7):\r\n...    if number % 2 == 0:\r\n...       print(f\"{number} is even.\")\r\n...    else:\r\n...       print(f\"{number} is odd.\")\r\n'1 is odd.'\r\n'2 is even.'\r\n'3 is odd.'\r\n'4 is even.'\r\n'5 is odd.'\r\n'6 is even.'\r\n\r\n# range() can also take a *step* parameter.\r\n# Here we use range to produce only the \"odd\" numbers, starting with 3 and stopping *before* 15.\r\n\r\n>>> for number in range(3, 15, 2):\r\n...    if number % 2 == 0:\r\n...       print(f\"{number} is even.\")\r\n...    else:\r\n...       print(f\"{number} is odd.\")\r\n...\r\n'3 is odd.'\r\n'5 is odd.'\r\n'7 is odd.'\r\n'9 is odd.'\r\n'11 is odd.'\r\n'13 is odd.'\r\n```\r\n\r\n\r\n## Values and Indexes with enumerate()\r\n\r\nIf both values and their indexes are needed, the built-in [`enumerate(<iterable>)`][enumerate] will return (`index`, `value`) pairs:\r\n\r\n```python\r\n\r\n>>> word_list = [\"bird\", \"chicken\", \"barrel\", \"apple\"]\r\n\r\n# *index* and *word* are the loop variables.\r\n# Loop variables can be any valid python name.\r\n\r\n>>> for index, word in enumerate(word_list):\r\n...    if word.startswith(\"b\"):\r\n...        print(f\"{word.title()} (at index {index}) starts with a B.\")\r\n...    else:\r\n...        print(f\"{word.title()} (at index {index}) doesn't start with a B.\")\r\n...\r\n'Bird (at index 0) starts with a B.'\r\n'Chicken (at index 1) doesn\\'t start with a B.'\r\n'Barrel (at index 2) starts with a B.'\r\n'Apple (at index 3) doesn\\'t start with a B.'\r\n\r\n\r\n# The same method can be used as a \"lookup\" for pairing items between two lists.\r\n# Of course, if the lengths or indexes don't line up, this doesn't work.\r\n\r\n>>> word_list = [\"cat\", \"chicken\", \"barrel\", \"apple\", \"spinach\"]\r\n>>> category_list = [\"mammal\", \"bird\", \"thing\", \"fruit\", \"vegetable\"]\r\n\r\n>>> for index, word in enumerate(word_list):\r\n...    print(f\"{word.title()} is in category: {category_list[index]}.\")\r\n...\r\n'Cat is in category: mammal.'\r\n'Chicken is in category: bird.'\r\n'Barrel is in category: thing.'\r\n'Apple is in category: fruit.'\r\n'Spinach is in category: vegetable.'\r\n```\r\n\r\n\r\n## Altering Loop Behavior\r\n\r\nThe [`continue`][continue statement] keyword can be used to skip forward to the next iteration cycle:\r\n\r\n```python\r\nword_list = [\"bird\", \"chicken\", \"barrel\", \"bongo\", \"sliver\", \"apple\", \"bear\"]\r\n\r\n# This will skip *bird*, at index 0\r\nfor index, word in enumerate(word_list):\r\n    if index == 0:\r\n        continue\r\n    if word.startswith(\"b\"):\r\n        print(f\"{word.title()} (at index {index}) starts with a b.\")\r\n\r\n'Barrel (at index 2) starts with a b.'\r\n'Bongo (at index 3) starts with a b.'\r\n'Bear (at index 6) starts with a b.'\r\n```\r\n\r\n\r\nThe [`break`][break statement] (_like in many C-related languages_) keyword can be used to stop the iteration and \"break out\" of the innermost enclosing `loop`:\r\n\r\n```python\r\n>>>  word_list = [\"bird\", \"chicken\", \"barrel\", \"bongo\", \"sliver\", \"apple\"]\r\n\r\n>>> for index, word in enumerate(word_list):\r\n...    if word.startswith(\"b\"):\r\n...        print(f\"{word.title()} (at index {index}) starts with a B.\")\r\n...    elif word == \"sliver\":\r\n...       break\r\n...    else:\r\n...       print(f\"{word.title()} doesn't start with a B.\")\r\n... print(\"loop broken.\")\r\n...\r\n'Bird (at index 0) starts with a B.'\r\n'Chicken doesn\\'t start with a B.'\r\n'Barrel (at index 2) starts with a B.'\r\n'Bongo (at index 3) starts with a B.'\r\n'loop broken.'\r\n```\r\n\r\n[break statement]: https://docs.python.org/3/reference/simple_stmts.html#the-break-statement\r\n[common sequence operations]: https://docs.python.org/3/library/stdtypes.html#common-sequence-operations\r\n[continue statement]: https://docs.python.org/3/reference/simple_stmts.html#the-continue-statement\r\n[enumerate]: https://docs.python.org/3/library/functions.html#enumerate\r\n[for statement]: https://docs.python.org/3/reference/compound_stmts.html#for\r\n[iterable]: https://docs.python.org/3/glossary.html#term-iterable\r\n[next built-in]: https://docs.python.org/3/library/functions.html#next\r\n[range]: https://docs.python.org/3/library/stdtypes.html#range\r\n[truth value testing]: https://docs.python.org/3/library/stdtypes.html#truth-value-testing\r\n[while statement]: https://docs.python.org/3/reference/compound_stmts.html#the-while-statement\r\n",
    "hints": "# Hints\r\n\r\n## General\r\n\r\n- [`while`][while-loops] loops are used for _indefinite_ (uncounted) iteration\r\n- [`for`][for-loops] loops are used for _definite_, (counted) iteration.\r\n- The keywords [`break` and `continue`][control flow] help customize loop behavior.\r\n- [`range(<start>, stop, <step>)`][range] can be used to generate a sequence for a loop counter.\r\n- The built-in [`enumerate()`][enumerate] will return (`<value>`, `<index>`) pairs to iterate over.\r\n\r\nAlso being familiar with the following can help with completing the tasks:\r\n\r\n- [`lists`][list]: indexing, nested lists, [`<list>.append`][append and pop], [`<list>.pop()`][append and pop].\r\n- [`str`][str]: `str()` constructor, using the `+` to concatenate strings, optionally, [`f-strings`][f-strings].\r\n\r\n## 1. Rounding Scores\r\n\r\n- `While` loops will continue to execute until their test condition evaluates to `False`.\r\n- `<list>.pop()` will remove and return the last item in a `list`.\r\n- Empty lists evaluate to `False` (most empty objects in Python are \"Falsy\")\r\n\r\n## 2. Non-Passing Students\r\n\r\n- There's no need to declare `loop` counters or `index` counters when iterating through an object using a `for` loop.\r\n- A results counter does need to be set up and _incremented_ -- you'll want to `return` the count of non-passing students when the loop terminates. \r\n\r\n## 3. The \"Best\"\r\n\r\n- There's no need to declare `loop` counters or `index` counters when iterating through an object using a `for` loop.\r\n- Having an empty `list` to add the \"best\" marks to is helpful here.\r\n- `<list>.append()` can help add things to the results `list`.\r\n\r\n## 4. Calculating Letter Grades\r\n\r\n- These are _lower thresholds_.  The _lower threshold_ for a \"D\" is a score of **41**, since an \"F\" is **<= 40**.\r\n- [`range()`][range] can be helpful here to generate a sequence with the proper \"F\" -> \"A\" increments.\r\n- [`round()`][round] without parameters should round off increments nicely.\r\n- As with \"the best\" task, `<list>.append()` could be useful here to append items from `range()` into a results `list`.\r\n\r\n## 5. Matching Names to Scores\r\n\r\n- [`enumerate()`][enumerate] could be helpful here.\r\n- If both lists are the same length and sorted the same way, could you use the `index` from one to retrieve a `value` from the other?\r\n\r\n## 6. A \"Perfect\" Score\r\n\r\n- There may be or may not be a student with a score of 100, and you can't return `[]` without checking **all** scores.\r\n- The [`control flow`][control flow] statements `continue` and `break` may be useful here to move past unwanted values.\r\n\r\n[append and pop]: https://docs.python.org/3/tutorial/datastructures.html#more-on-lists\r\n[control flow]: https://docs.python.org/3/tutorial/controlflow.html#break-and-continue-statements-and-else-clauses-on-loops\r\n[enumerate]: https://docs.python.org/3/library/functions.html#enumerate\r\n[f-strings]: https://docs.python.org/3/reference/lexical_analysis.html#formatted-string-literals\r\n[for-loops]: https://docs.python.org/3/tutorial/controlflow.html#for-statements\r\n[list]: https://docs.python.org/3/library/stdtypes.html#list\r\n[range]: https://docs.python.org/3/tutorial/controlflow.html#the-range-function\r\n[round]: https://docs.python.org/3/library/functions.html#round\r\n[str]: https://docs.python.org/3/library/stdtypes.html#str\r\n[while-loops]: https://docs.python.org/3/reference/compound_stmts.html#the-while-statement\r\n",
    "instructions": "# Instructions\r\n\r\nYou're a teaching assistant correcting student exams.\r\nKeeping track of results manually is getting both tedious and mistake-prone.\r\nYou decide to make things a little more interesting by putting together some functions to count and calculate results for the class.\r\n\r\n## 1. Rounding Scores\r\n\r\nWhile you can give \"partial credit\" on exam questions, overall exam scores have to be `int`s.\r\nSo before you can do anything else with the class scores, you need to go through the grades and turn any `float` scores into `int`s. Lucky for you, Python has the built-in [`round()`][round] function you can use.\r\n\r\nCreate the function `round_scores(student_scores)` that takes a `list` of `student_scores`.\r\nThis function should _consume_ the input `list` and `return` a new list with all the scores converted to `int`s.\r\nThe order of the scores in the resulting `list` is not important.\r\n\r\n```python\r\n>>> student_scores = [90.33, 40.5, 55.44, 70.05, 30.55, 25.45, 80.45, 95.3, 38.7, 40.3]\r\n>>> round_scores(student_scores)\r\n...\r\n[40, 39, 95, 80, 25, 31, 70, 55, 40, 90]\r\n```\r\n\r\n## 2. Non-Passing Students\r\n\r\nAs you were grading the exam, you noticed some students weren't performing as well as you had hoped.\r\nBut you were distracted, and forgot to note exactly _how many_ students.\r\n\r\nCreate the function `count_failed_students(student_scores)` that takes a `list` of `student_scores`.\r\nThis function should count up the number of students who don't have passing scores and return that count as an integer.\r\nA student needs a score greater than **40** to achieve a passing grade on the exam.\r\n\r\n```python\r\n>>> count_failed_students(student_scores=[90,40,55,70,30,25,80,95,38,40])\r\n5\r\n```\r\n\r\n## 3. The \"Best\"\r\n\r\nThe teacher you're assisting wants to find the group of students who've performed \"the best\" on this exam.\r\nWhat qualifies as \"the best\" fluctuates, so you need to find the student scores that are **greater than or equal to** the current threshold.\r\n\r\nCreate the function `above_threshold(student_scores, threshold)` taking `student_scores` (a `list` of grades), and `threshold` (the \"top score\" threshold) as parameters.\r\nThis function should return a `list` of all scores that are `>=` to `threshold`.\r\n\r\n```python\r\n>>> above_threshold(student_scores=[90,40,55,70,30,68,70,75,83,96], threshold=75)\r\n[90,75,83,96]\r\n```\r\n\r\n## 4. Calculating Letter Grades\r\n\r\nThe teacher you are assisting likes to assign letter grades as well as numeric scores.\r\nSince students rarely score 100 on an exam, the \"letter grade\" lower thresholds are calculated based on the highest score achieved, and increment evenly between the high score and the failing threshold of **<= 40**.\r\n\r\nCreate the function `letter_grades(highest)` that takes the \"highest\" score on the exam as an argument, and returns a `list` of lower score thresholds for each \"American style\" grade interval: `[\"D\", \"C\", \"B\", \"A\"]`.\r\n\r\n\r\n```python\r\n\"\"\"Where the highest score is 100, and failing is <= 40.\r\n       \"F\" <= 40\r\n 41 <= \"D\" <= 55\r\n 56 <= \"C\" <= 70\r\n 71 <= \"B\" <= 85\r\n 86 <= \"A\" <= 100\r\n\"\"\"\r\n\r\n>>> letter_grades(highest=100)\r\n[41, 56, 71, 86]\r\n\r\n\r\n\"\"\"Where the highest score is 88, and failing is <= 40.\r\n       \"F\" <= 40\r\n 41 <= \"D\" <= 52\r\n 53 <= \"C\" <= 64\r\n 65 <= \"B\" <= 76\r\n 77 <= \"A\" <= 88\r\n\"\"\"\r\n\r\n>>> letter_grades(highest=88)\r\n[41, 53, 65, 77]\r\n```\r\n\r\n## 5. Matching Names to Scores\r\n\r\nYou have a list of exam scores in descending order, and another list of student names also sorted in descending order by their exam scores.\r\nYou would like to match each student name with their exam score and print out an overall class ranking.\r\n\r\nCreate the function `student_ranking(student_scores, student_names)` with parameters `student_scores` and `student_names`.\r\nMatch each student name on the student_names `list` with their score from the student_scores `list`.\r\nYou can assume each argument `list` will be sorted from highest score(er) to lowest score(er).\r\nThe function should return a `list` of strings with the format `<rank>. <student name>: <student score>`.\r\n\r\n```python\r\n>>> student_scores = [100, 99, 90, 84, 66, 53, 47]\r\n>>> student_names =  ['Joci', 'Sara','Kora','Jan','John','Bern', 'Fred']\r\n>>> student_ranking(student_scores, student_names)\r\n...\r\n['1. Joci: 100', '2. Sara: 99', '3. Kora: 90', '4. Jan: 84', '5. John: 66', '6. Bern: 53', '7. Fred: 47']\r\n```\r\n\r\n## 6. A \"Perfect\" Score\r\n\r\nAlthough a \"perfect\" score of 100 is rare on an exam, it is interesting to know if at least one student has achieved it.\r\n\r\nCreate the function `perfect_score(student_info)` with parameter `student_info`.\r\n`student_info` is a `list` of lists containing the name and score of each student: `[[\"Charles\", 90], [\"Tony\", 80]]`.\r\nThe function should `return` _the first_ `[<name>, <score>]` pair of the student who scored 100 on the exam.\r\n\r\nIf no 100 scores are found in `student_info`, an empty list `[]` should be returned.\r\n\r\n```python\r\n>>> perfect_score(student_info=[[\"Charles\", 90], [\"Tony\", 80], [\"Alex\", 100]])\r\n[\"Alex\", 100]\r\n\r\n>>> perfect_score(student_info=[[\"Charles\", 90], [\"Tony\", 80]])\r\n[]\r\n```\r\n\r\n[round]: https://docs.python.org/3/library/functions.html#round\r\n",
    "design": "# Design\r\n\r\n## Goal\r\n\r\nThis concept exercise should convey a basic understanding of how to handle the `for` loop and `while` in Python. This concept exercise should also teach how to interrupt or change the normal flow of a loop using the `break` statement and the `continue` statement.\r\n\r\n## Learning objectives\r\n\r\n- use `while` to make a loop: execute something as long as an expression/test is `true`\r\n- use `for` to iterate over an iterable object with the `for ... in` pattern. The Membership testing concept (in) is required to address this concept.\r\n- understand the differences between `while` (indefinite, condition-dependent) and `for` (definite, length or count dependent) loops\r\n- use `break` statement to terminate the nearest enclosing loop\r\n- use `continue` statement to continue with the next cycle of the nearest enclosing loop\r\n\r\n## Out of scope\r\n\r\n- async loops (advanced)\r\n\r\n## Concepts\r\n\r\n- `while` loops\r\n- `for` loops\r\n- `break` statement\r\n- `continue` statement\r\n\r\n## Prerequisites\r\n\r\n- `basics`\r\n- `numbers`\r\n- `arithmetic`\r\n\r\n## Resources\r\n\r\n- [The while key](https://yawpitchroll.com/posts/the-35-words-you-need-to-python/#while)\r\n- [The for loop](https://yawpitchroll.com/posts/the-35-words-you-need-to-python/#for)\r\n- [The break statement](https://yawpitchroll.com/posts/the-35-words-you-need-to-python/#break)\r\n- [The break statement python docs](https://docs.python.org/3/reference/simple_stmts.html#the-break-statement)\r\n- [The continue statement](https://yawpitchroll.com/posts/the-35-words-you-need-to-python/#continue)\r\n- [The continue statement python docs](https://docs.python.org/3/reference/simple_stmts.html#the-continue-statement)\r\n"
  },
  "config": {
    "authors": [
      "mohanrajanr",
      "BethanyG"
    ],
    "contributors": [
      "pranasziaukas"
    ],
    "files": {
      "solution": [
        "loops.py"
      ],
      "test": [
        "loops_test.py"
      ],
      "exemplar": [
        ".meta/exemplar.py"
      ]
    },
    "icon": "grep",
    "blurb": "Learn about loops by grading and organizing your students exam scores."
  },
  "starter_code": "\"\"\"Functions for organizing and calculating student exam scores.\"\"\"\r\n\r\n\r\ndef round_scores(student_scores):\r\n    \"\"\"Round all provided student scores.\r\n\r\n    :param student_scores: list - float or int of student exam scores.\r\n    :return: list - student scores *rounded* to nearest integer value.\r\n    \"\"\"\r\n\r\n    pass\r\n\r\n\r\ndef count_failed_students(student_scores):\r\n    \"\"\"Count the number of failing students out of the group provided.\r\n\r\n    :param student_scores: list - containing int student scores.\r\n    :return: int - count of student scores at or below 40.\r\n    \"\"\"\r\n\r\n    pass\r\n\r\n\r\ndef above_threshold(student_scores, threshold):\r\n    \"\"\"Determine how many of the provided student scores were 'the best' based on the provided threshold.\r\n\r\n    :param student_scores: list - of integer scores.\r\n    :param threshold: int - threshold to cross to be the \"best\" score.\r\n    :return: list - of integer scores that are at or above the \"best\" threshold.\r\n    \"\"\"\r\n\r\n    pass\r\n\r\n\r\ndef letter_grades(highest):\r\n    \"\"\"Create a list of grade thresholds based on the provided highest grade.\r\n\r\n    :param highest: int - value of highest exam score.\r\n    :return: list - of lower threshold scores for each D-A letter grade interval.\r\n            For example, where the highest score is 100, and failing is <= 40,\r\n            The result would be [41, 56, 71, 86]:\r\n\r\n            41 <= \"D\" <= 55\r\n            56 <= \"C\" <= 70\r\n            71 <= \"B\" <= 85\r\n            86 <= \"A\" <= 100\r\n    \"\"\"\r\n\r\n    pass\r\n\r\n\r\ndef student_ranking(student_scores, student_names):\r\n    \"\"\"Organize the student's rank, name, and grade information in descending order.\r\n\r\n    :param student_scores: list - of scores in descending order.\r\n    :param student_names: list - of string names by exam score in descending order.\r\n    :return: list - of strings in format [\"<rank>. <student name>: <score>\"].\r\n    \"\"\"\r\n\r\n    pass\r\n\r\n\r\ndef perfect_score(student_info):\r\n    \"\"\"Create a list that contains the name and grade of the first student to make a perfect score on the exam.\r\n\r\n    :param student_info: list - of [<student name>, <score>] lists.\r\n    :return: list - first `[<student name>, 100]` or `[]` if no student score of 100 is found.\r\n    \"\"\"\r\n\r\n    pass\r\n",
  "exemplar_code": "\"\"\"Functions for organizing and calculating student exam scores.\"\"\"\r\n\r\n\r\ndef round_scores(student_scores):\r\n    \"\"\"Round all provided student scores.\r\n\r\n    :param student_scores: list - float or int of student exam scores.\r\n    :return: list - student scores *rounded* to nearest integer value.\r\n    \"\"\"\r\n\r\n    rounded = []\r\n    while student_scores:\r\n        rounded.append(round(student_scores.pop()))\r\n    return rounded\r\n\r\n\r\ndef count_failed_students(student_scores):\r\n    \"\"\"Count the number of failing students out of the group provided.\r\n\r\n    :param student_scores: list - containing int student scores.\r\n    :return: int - count of student scores at or below 40.\r\n    \"\"\"\r\n\r\n    non_passing = 0\r\n    for score in student_scores:\r\n        if score <= 40:\r\n            non_passing += 1\r\n    return non_passing\r\n\r\n\r\ndef above_threshold(student_scores, threshold):\r\n    \"\"\"Determine how many of the provided student scores were 'the best' based on the provided threshold.\r\n\r\n    :param student_scores: list - of integer scores.\r\n    :param threshold: int - threshold to cross to be the \"best\" score.\r\n    :return: list - of integer scores that are at or above the \"best\" threshold.\r\n    \"\"\"\r\n\r\n    above = []\r\n\r\n    for score in student_scores:\r\n        if score >= threshold:\r\n            above.append(score)\r\n    return above\r\n\r\n\r\ndef letter_grades(highest):\r\n    \"\"\"Create a list of grade thresholds based on the provided highest grade.\r\n\r\n    :param highest: int - value of highest exam score.\r\n    :return: list - of lower threshold scores for each D-A letter grade interval.\r\n            For example, where the highest score is 100, and failing is <= 40,\r\n            The result would be [41, 56, 71, 86]:\r\n\r\n            41 <= \"D\" <= 55\r\n            56 <= \"C\" <= 70\r\n            71 <= \"B\" <= 85\r\n            86 <= \"A\" <= 100\r\n    \"\"\"\r\n\r\n    increment = round((highest - 40) / 4)\r\n    scores = []\r\n    for score in range(41, highest, increment):\r\n        scores.append(score)\r\n    return scores\r\n\r\n\r\ndef student_ranking(student_scores, student_names):\r\n    \"\"\"Organize the student's rank, name, and grade information in ascending order.\r\n\r\n    :param student_scores: list - of scores in descending order.\r\n    :param student_names: list - of string names by exam score in descending order.\r\n    :return: list - of strings in format [\"<rank>. <student name>: <score>\"].\r\n    \"\"\"\r\n\r\n    results = []\r\n    for index, name in enumerate(student_names):\r\n        rank_string = str(index + 1) + \". \" + name + \": \" + str(student_scores[index])\r\n        results.append(rank_string)\r\n\r\n    return results\r\n\r\n\r\ndef perfect_score(student_info):\r\n    \"\"\"Create a list that contains the name and grade of the first student to make a perfect score on the exam.\r\n\r\n    :param student_info: list - of [<student name>, <score>] lists.\r\n    :return: list - first `[<student name>, 100]` or `[]` if no student score of 100 is found.\r\n    \"\"\"\r\n\r\n    result = []\r\n\r\n    for item in student_info:\r\n        if item[1] == 100:\r\n            result = item\r\n            break\r\n\r\n    return result\r\n",
  "tests": "import unittest\r\nimport pytest\r\n\r\nfrom loops import (\r\n    round_scores,\r\n    count_failed_students,\r\n    above_threshold,\r\n    letter_grades,\r\n    student_ranking,\r\n    perfect_score)\r\n\r\n\r\nclass MakingTheGradeTest(unittest.TestCase):\r\n\r\n    @pytest.mark.task(taskno=1)\r\n    def test_round_scores(self):\r\n\r\n        # Because we the input list can be mutated, the test data has been created\r\n        # as tuples, which we then convert to a list when the test runs.\r\n        # this makes accurate error messages easier to create.\r\n        test_data = [tuple(),\r\n                     (.5,),\r\n                     (1.5,),\r\n                     (90.33, 40.5, 55.44, 70.05, 30.55, 25.45, 80.45, 95.3, 38.7, 40.3),\r\n                     (50, 36.03, 76.92, 40.7, 43, 78.29, 63.58, 91, 28.6, 88.0)]\r\n        result_data = [[],\r\n                       [0],\r\n                       [2],\r\n                       [90, 40, 55, 70, 31, 25, 80, 95, 39, 40],\r\n                       [50, 36, 77, 41, 43, 78, 64, 91, 29, 88]]\r\n\r\n        for variant, (student_scores, expected) in enumerate(zip(test_data, result_data), start=1):\r\n            with self.subTest(f'variation #{variant}', student_scores=student_scores, expected=expected):\r\n\r\n                # Because the test_input is a tuple, it has to be converted to a list for the function call.\r\n                actual_result = round_scores(list(student_scores))\r\n                error_message = (f'Called round_scores({list(student_scores)}). '\r\n                                 f'The function returned {sorted(actual_result)} after sorting, but '\r\n                                 f'the tests expected {sorted(expected)} after sorting. '\r\n                                 f'One or more scores were rounded incorrectly.')\r\n\r\n                # everything is sorted for easier comparison.\r\n                self.assertEqual(sorted(actual_result), sorted(expected), msg=error_message)\r\n\r\n    @pytest.mark.task(taskno=2)\r\n    def test_count_failed_students(self):\r\n        test_data = [[89, 85, 42, 57, 90, 100, 95, 48, 70, 96],\r\n                     [40, 40, 35, 70, 30, 41, 90]]\r\n        result_data = [0,4]\r\n\r\n        for variant, (student_scores, expected) in enumerate(zip(test_data, result_data), start=1):\r\n            with self.subTest(f'variation #{variant}',\r\n                              student_scores=student_scores,\r\n                              expected=expected):\r\n\r\n                actual_result = count_failed_students(student_scores)\r\n                error_message = (f'Called count_failed_students({student_scores}). '\r\n                                 f'The function returned {actual_result}, but '\r\n                                 f'the tests expected {expected} for the '\r\n                                 'number of students who failed.')\r\n\r\n                self.assertEqual(actual_result, expected, msg=error_message)\r\n\r\n    @pytest.mark.task(taskno=3)\r\n    def test_above_threshold(self):\r\n        test_data = [([40, 39, 95, 80, 25, 31, 70, 55, 40, 90], 98),\r\n                     ([88, 29, 91, 64, 78, 43, 41, 77, 36, 50], 80),\r\n                     ([100, 89], 100),\r\n                     ([88, 29, 91, 64, 78, 43, 41, 77, 36, 50], 78),\r\n                     ([], 80)]\r\n\r\n        result_data = [[],\r\n                       [88, 91],\r\n                       [100],\r\n                       [88, 91, 78],\r\n                       []]\r\n\r\n        for variant, (params, expected) in enumerate(zip(test_data, result_data), start=1):\r\n            with self.subTest(f'variation #{variant}', params=params, expected=expected):\r\n                actual_result = above_threshold(*params)\r\n                error_message = (f'Called above_threshold{params}. '\r\n                                 f'The function returned {actual_result}, but '\r\n                                 f'the tests expected {expected} for the '\r\n                                 'scores that are above the threshold.')\r\n\r\n                self.assertEqual(actual_result, expected, msg=error_message)\r\n\r\n    @pytest.mark.task(taskno=4)\r\n    def test_letter_grades(self):\r\n        test_data = [100, 97, 85, 92, 81]\r\n\r\n        result_data = [[41, 56, 71, 86],\r\n                       [41, 55, 69, 83],\r\n                       [41, 52, 63, 74],\r\n                       [41, 54, 67, 80],\r\n                       [41, 51, 61, 71]]\r\n\r\n        for variant, (highest, expected) in enumerate(zip(test_data, result_data), start=1):\r\n            with self.subTest(f'variation #{variant}', highest=highest, expected=expected):\r\n                actual_result = letter_grades(highest)\r\n                error_message = (f'Called letter_grades({highest}). '\r\n                                 f'The function returned {actual_result}, but '\r\n                                 f'the tests expected {expected} for the '\r\n                                 'letter grade cutoffs.')\r\n\r\n                self.assertEqual(actual_result, expected, msg=error_message)\r\n\r\n    @pytest.mark.task(taskno=5)\r\n    def test_student_ranking(self):\r\n        test_data = [([82], ['Betty']),\r\n                     ([88, 73], ['Paul', 'Ernest']),\r\n                     ([100, 98, 92, 86, 70, 68, 67, 60],\r\n                      ['Rui', 'Betty', 'Joci', 'Yoshi', 'Kora', 'Bern', 'Jan', 'Rose'])]\r\n\r\n        result_data = [['1. Betty: 82'],\r\n                       ['1. Paul: 88', '2. Ernest: 73'],\r\n                       ['1. Rui: 100', '2. Betty: 98', '3. Joci: 92', '4. Yoshi: 86',\r\n                        '5. Kora: 70', '6. Bern: 68', '7. Jan: 67', '8. Rose: 60']]\r\n\r\n        for variant, (params, expected) in enumerate(zip(test_data, result_data), start=1):\r\n            with self.subTest(f'variation #{variant}', params=params, expected=expected):\r\n                actual_result = student_ranking(*params)\r\n                error_message = (f'Called student_ranking{params}. '\r\n                                 f'The function returned {actual_result}, but '\r\n                                 f'the tests expected {expected} for the '\r\n                                 'student rankings.')\r\n\r\n                self.assertEqual(actual_result, expected, msg=error_message)\r\n\r\n    @pytest.mark.task(taskno=6)\r\n    def test_perfect_score(self):\r\n        test_data = [\r\n                     [['Joci', 100], ['Vlad', 100], ['Raiana', 100], ['Alessandro', 100]],\r\n                     [['Jill', 30], ['Paul', 73]],\r\n                     [],\r\n                     [['Rui', 60], ['Joci', 58], ['Sara', 91], ['Kora', 93], ['Alex', 42],\r\n                      ['Jan', 81], ['Lilliana', 40], ['John', 60], ['Bern', 28], ['Vlad', 55]],\r\n\r\n                     [['Yoshi', 52], ['Jan', 86], ['Raiana', 100], ['Betty', 60],\r\n                      ['Joci', 100], ['Kora', 81], ['Bern', 41], ['Rose', 94]]\r\n                     ]\r\n\r\n\r\n        result_data = [['Joci', 100],[], [], [], ['Raiana', 100]]\r\n\r\n        for variant, (student_info, expected) in enumerate(zip(test_data, result_data), start=1):\r\n\r\n            with self.subTest(f'variation #{variant}', student_info=student_info, expected=expected):\r\n                actual_result = perfect_score(student_info)\r\n                error_message = (f'Called perfect_score({student_info}). '\r\n                                 f'The function returned {actual_result}, but '\r\n                                 f'the tests expected {expected} for the '\r\n                                 'first \"perfect\" score.')\r\n\r\n                self.assertEqual(actual_result, expected, msg=error_message)\r\n"
}