{
  "concept": "tisbury-treasure-hunt",
  "docs": {
    "introduction": "# Introduction\r\n\r\nIn Python, a [tuple][tuple] is an _immutable_ collection of items in _sequence_.\r\nLike most collections, `tuples` can hold any (or multiple) data type(s) -- including other `tuples`.\r\nTuples support all [common sequence operations][common sequence operations], but **do not** support [mutable sequence operations][mutable sequence operations].\r\n\r\nThe elements of a tuple can be iterated over using the `for item in <tuple>` construct.\r\nIf both element index and value are needed, `for index, item in enumerate(<tuple>)` can be used.\r\nLike any sequence, elements within `tuples` can be accessed via _bracket notation_ using a `0-based index` number from the left or a `-1-based index` number from the right.\r\nTuples can also be copied in whole or in part using slice notation (_`<tuple>[<start>:<stop>:<step>]`_).\r\n\r\n\r\n## Tuple Construction\r\n\r\nTuples can be formed in multiple ways, using either the `tuple(<iterable>)` class constructor or the `tuple` literal declaration.\r\n\r\n### Using the `tuple()` constructor empty or with an _iterable_:\r\n\r\n```python\r\n>>> no_elements = tuple()\r\n()\r\n\r\n# The constructor *requires* an iterable, so single elements must be passed in a list or another tuple.\r\n>>> one_element = tuple([16])\r\n(16,)\r\n```\r\n\r\nStrings are iterable, so using a single `str` as an argument to the `tuple()` constructor can have surprising results:\r\n\r\n```python\r\n# String elements (characters) are iterated through and added to the tuple\r\n>>> multiple_elements_string = tuple(\"Timbuktu\")\r\n('T', 'i', 'm', 'b', 'u', 'k', 't', 'u')\r\n```\r\n\r\nSingle iterables have their elements added one by one:\r\n\r\n```python\r\n>>> multiple_elements_list = tuple([\"Parrot\", \"Bird\", 334782])\r\n(\"Parrot\", \"Bird\", 334782)\r\n\r\n>>> multiple_elements_set = tuple({2, 3, 5, 7, 11})\r\n(2,3,5,7,11)\r\n```\r\n\r\n#### Declaring a tuple as a _literal_ :\r\n\r\nBecause the `tuple(<iterable>)` constructor only takes _iterables_ (or nothing) as arguments, it is much easier to create\r\n a one-tuple via the literal method.\r\n\r\n```python\r\n>>> no_elements = ()\r\n()\r\n\r\n>>> one_element = (\"Guava\",)\r\n(\"Guava\",)\r\n```\r\n\r\nNested data structures can be included as `tuple` elements, including other `tuples`:\r\n\r\n```python\r\n>>> nested_data_structures = ({\"fish\": \"gold\", \"monkey\": \"brown\", \"parrot\" : \"grey\"}, (\"fish\", \"mammal\", \"bird\"))\r\n({\"fish\": \"gold\", \"monkey\": \"brown\", \"parrot\" : \"grey\"}, (\"fish\", \"mammal\", \"bird\"))\r\n\r\n>>> nested_data_structures_1 = ([\"fish\", \"gold\", \"monkey\", \"brown\", \"parrot\", \"grey\"], (\"fish\", \"mammal\", \"bird\"))\r\n([\"fish\", \"gold\", \"monkey\", \"brown\", \"parrot\", \"grey\"], (\"fish\", \"mammal\", \"bird\"))\r\n```\r\n\r\n## Tuple Concatenation\r\n\r\nTuples can be concatenated using plus `+` operator, which unpacks each `tuple` creating a new, combined `tuple`.\r\n\r\n```python\r\n>>> new_via_concatenate = (\"George\", 5) + (\"cat\", \"Tabby\")\r\n(\"George\", 5, \"cat\", \"Tabby\")\r\n\r\n#likewise, using the multiplication operator * is the equivalent of using + n times\r\n>>> first_group = (\"cat\", \"dog\", \"elephant\")\r\n\r\n>>> multiplied_group = first_group * 3\r\n('cat', 'dog', 'elephant', 'cat', 'dog', 'elephant', 'cat', 'dog', 'elephant')\r\n```\r\n\r\n## Accessing Elements Inside a Tuple\r\n\r\nElements within a `tuple` can be accessed via _bracket notation_ using a `0-based index` number from the left or a `-1-based index` number from the right.\r\n\r\n```python\r\nstudent_info = (\"Alyssa\", \"grade 3\", \"female\", 8 )\r\n\r\n#gender is at index 2 or index -2\r\n>>> student_gender = student_info[2]\r\n'female'\r\n\r\n>>> student_gender = student_info[-2]\r\n'female'\r\n\r\n#name is at index 0 or index -4\r\n>>> student_name = student_info[0]\r\nAlyssa\r\n\r\n>>> student_name = student_info[-4]\r\nAlyssa\r\n```\r\n\r\n## Iterating Over a Tuples Elements\r\n\r\nElements inside a `tuple` can be _iterated over_ in a loop using `for item in <tuple>` syntax.\r\nIf both indexes and values are needed, `for index, item in enumerate(<tuple>)` can be used.\r\n\r\n```python\r\n>>> student_info = (\"Alyssa\", \"grade 3\", \"female\", 8 )\r\n>>> for item in student_info:\r\n...   print(item)\r\n\r\n...\r\nAlyssa\r\ngrade 3\r\nfemale\r\n8\r\n\r\n>>> for index, item in enumerate(student_info):\r\n...  print(\"Index is: \" + str(index) + \", value is: \" + str(item) +\".\")\r\n\r\n...\r\nIndex is: 0, value is: Alyssa.\r\nIndex is: 1, value is: grade 3.\r\nIndex is: 2, value is: female.\r\nIndex is: 3, value is: 8.\r\n```\r\n\r\n## Checking Membership in a Tuple\r\n\r\nThe `in` operator can be used to check membership in a `tuple`.\r\n\r\n```python\r\n>>> multiple_elements_list = tuple([\"Parrot\", \"Bird\", 334782])\r\n(\"Parrot\", \"Bird\", 334782)\r\n\r\n>>> \"Parrot\" in multiple_elements_list\r\nTrue\r\n```\r\n\r\n[common sequence operations]: https://docs.python.org/3/library/stdtypes.html#common-sequence-operations\r\n[mutable sequence operations]: https://docs.python.org/3/library/stdtypes.html#mutable-sequence-types\r\n[tuple]: https://docs.python.org/3/library/stdtypes.html#tuple\r\n",
    "hints": "# Hints\r\n\r\n## General\r\n\r\n\r\n- [Tuples][tuples] are immutable [sequence Types][sequence types] that can contain any data type.\r\n- Tuples are [iterable][iterable].  If you need indexes as well as values, use [`enumerate()`][enumerate]\r\n- Elements within tuples can be accessed via [bracket notation][bracket notation], using a zero-based index from the left, or -1 from the right. Other [Common Sequence Operations][common sequence operations] can also be used when working with tuples.\r\n\r\n## 1. Extract coordinates\r\n\r\n- Remember: tuples allow access via _index_, using _brackets_. Indexes start from the left at zero.\r\n\r\n## 2. Format coordinates\r\n\r\n- Check [`class tuple`][class tuple] for more details on tuples.\r\n- Check [`class str`][class str] for more details on strings.\r\n\r\n## 3. Match coordinates\r\n\r\n- What methods could be used here for for [testing membership][testing membership]?.\r\n- Check [`class tuple`][class tuple] for more details on tuples.\r\n- Could you re-use your `convert_coordinate()` function?\r\n\r\n## 4. Combine matched records\r\n\r\n- Remember that tuples support all [common sequence operations][common sequence operations].\r\n- Could you re-use your `compare_records()` function here?\r\n\r\n## 5. \"Clean up\" & make a report of all records\r\n\r\n- Remember: tuples are _immutable_, but the contents can be accessed via _index_ using _bracket notation_.\r\n- Tuples don't have to use parentheses unless there is _ambiguity_.\r\n- Python has multiple methods of string formatting. [`str.format()`][str.format] and [`f-strings`][f-strings] are two very common ones.\r\n- There are multiple textual formatting options available via Pythons [`format specification mini-language`][format specification mini-language].\r\n\r\n\r\n[bracket notation]: https://stackoverflow.com/questions/30250282/whats-the-difference-between-the-square-bracket-and-dot-notations-in-python\r\n[class str]: https://docs.python.org/3/library/stdtypes.html#text-sequence-type-str\r\n[class tuple]: https://docs.python.org/3/library/stdtypes.html#tuple\r\n[common sequence operations]: https://docs.python.org/3/library/stdtypes.html#common-sequence-operations\r\n[enumerate]: https://docs.python.org/3/library/functions.html#enumerate\r\n[f-strings]: https://docs.python.org/3/tutorial/inputoutput.html#formatted-string-literals\r\n[format specification mini-language]: https://docs.python.org/3/library/string.html#format-specification-mini-language\r\n[iterable]: https://docs.python.org/3/glossary.html#term-iterable\r\n[sequence types]: https://docs.python.org/3/library/stdtypes.html#typesseq\r\n[str.format]: https://docs.python.org/3/library/stdtypes.html#str.format\r\n[testing membership]: https://docs.python.org/3/reference/expressions.html#membership-test-operations\r\n[tuples]: https://docs.python.org/3/tutorial/datastructures.html#tuples-and-sequences\r\n",
    "instructions": "# Instructions\r\n\r\nAzara and Rui are teammates competing in a pirate-themed treasure hunt.\r\nOne has a list of treasures with map coordinates, the other a list of location names with map coordinates.\r\nThey've also been given blank maps with a starting place marked YOU ARE HERE.\r\n\r\n<br>\r\n<table>\r\n<tr><th>Azara's List</th><th></th><th>Rui's List</th></tr>\r\n<tr><td>\r\n\r\n| Treasure                    | Coordinates |\r\n| --------------------------- | ----------- |\r\n| Amethyst Octopus            | 1F          |\r\n| Angry Monkey Figurine       | 5B          |\r\n| Antique Glass Fishnet Float | 3D          |\r\n| Brass Spyglass              | 4B          |\r\n| Carved Wooden Elephant      | 8C          |\r\n| Crystal Crab                | 6A          |\r\n| Glass Starfish              | 6D          |\r\n| Model Ship in Large Bottle  | 8A          |\r\n| Pirate Flag                 | 7F          |\r\n| Robot Parrot                | 1C          |\r\n| Scrimshawed Whale Tooth     | 2A          |\r\n| Silver Seahorse             | 4E          |\r\n| Vintage Pirate Hat          | 7E          |\r\n\r\n</td><td></td><td>\r\n\r\n| Location Name                         | Coordinates | Quadrant  |\r\n| ------------------------------------- | ----------- | --------- |\r\n| Seaside Cottages                      | (\"1\", \"C\")  | Blue      |\r\n| Aqua Lagoon (Island of Mystery)       | (\"1\", \"F\")  | Yellow    |\r\n| Deserted Docks                        | (\"2\", \"A\")  | Blue      |\r\n| Spiky Rocks                           | (\"3\", \"D\")  | Yellow    |\r\n| Abandoned Lighthouse                  | (\"4\", \"B\")  | Blue      |\r\n| Hidden Spring (Island of Mystery)     | (\"4\", \"E\")  | Yellow    |\r\n| Stormy Breakwater                     | (\"5\", \"B\")  | Purple    |\r\n| Old Schooner                          | (\"6\", \"A\")  | Purple    |\r\n| Tangled Seaweed Patch                 | (\"6\", \"D\")  | Orange    |\r\n| Quiet Inlet (Island of Mystery)       | (\"7\", \"E\")  | Orange    |\r\n| Windswept Hilltop (Island of Mystery) | (\"7\", \"F\")  | Orange    |\r\n| Harbor Managers Office                | (\"8\", \"A\")  | Purple    |\r\n| Foggy Seacave                         | (\"8\", \"C\")  | Purple    |\r\n\r\n</td></tr>\r\n</table>\r\n\r\n<br>\r\n\r\nBut things are a bit disorganized: Azara's coordinates appear to be formatted and sorted differently from Rui's, and they have to keep looking from one list to the other to figure out which treasures go with which locations.\r\nBeing budding pythonistas, they have come to you for help in writing a small program (a set of functions, really) to better organize their hunt information.\r\n\r\n\r\n## 1. Extract coordinates\r\n\r\nImplement the `get_coordinate()` function that takes a `(treasure, coordinate)` pair from Azara's list and returns only the extracted map coordinate.\r\n\r\n\r\n```python\r\n>>> get_coordinate(('Scrimshawed Whale Tooth', '2A'))\r\n2A\r\n```\r\n\r\n## 2. Format coordinates\r\n\r\nImplement the `convert_coordinate()` function that takes a coordinate in the format \"2A\" and returns a tuple in the format `(\"2\", \"A\")`.\r\n\r\n\r\n```python\r\n>>> convert_coordinate(\"2A\")\r\n(\"2\", \"A\")\r\n```\r\n\r\n## 3. Match coordinates\r\n\r\nImplement the `compare_records()` function that takes a `(treasure, coordinate)` pair and a `(location, coordinate, quadrant)` record and compares coordinates from each.\r\nReturn **`True`** if the coordinates \"match\", and return **`False`** if they do not.\r\nRe-format coordinates as needed for accurate comparison.\r\n\r\n\r\n```python\r\n>>> compare_records(('Brass Spyglass', '4B'), ('Seaside Cottages', ('1', 'C'), 'blue'))\r\nFalse\r\n\r\n>>> compare_records(('Model Ship in Large Bottle', '8A'), ('Harbor Managers Office', ('8', 'A'), 'purple'))\r\nTrue\r\n```\r\n\r\n## 4. Combine matched records\r\n\r\nImplement the `create_record()` function that takes a `(treasure, coordinate)` pair from Azara's list and a `(location, coordinate, quadrant)` record from Rui's list and returns `(treasure, coordinate, location, coordinate, quadrant)` **if the coordinates match**.\r\nIf the coordinates _do not_ match, return the string **\"not a match\"**.\r\nRe-format the coordinate as needed for accurate comparison.\r\n\r\n\r\n```python\r\n>>> create_record(('Brass Spyglass', '4B'), ('Abandoned Lighthouse', ('4', 'B'), 'Blue'))\r\n('Brass Spyglass', '4B', 'Abandoned Lighthouse', ('4', 'B'), 'Blue')\r\n\r\n>>> create_record(('Brass Spyglass', '4B'), ('Seaside Cottages', ('1', 'C'), 'blue'))\r\n\"not a match\"\r\n```\r\n\r\n## 5. \"Clean up\" & make a report of all records\r\n\r\nClean up the combined records from Azara and Rui so that there's only one set of coordinates per record. Make a report so they can see one list of everything they need to put on their maps.\r\nImplement the `clean_up()` function that takes a tuple of tuples (_everything from both lists_), looping through the _outer_ tuple, dropping the unwanted coordinates from each _inner_ tuple and adding each to a 'report'.\r\nFormat and return the 'report' so that there is one cleaned record on each line.\r\n\r\n\r\n```python\r\n>>> clean_up((('Brass Spyglass', '4B', 'Abandoned Lighthouse', ('4', 'B'), 'Blue'), ('Vintage Pirate Hat', '7E', 'Quiet Inlet (Island of Mystery)', ('7', 'E'), 'Orange'), ('Crystal Crab', '6A', 'Old Schooner', ('6', 'A'), 'Purple')))\r\n\r\n\"\"\"\r\n('Brass Spyglass', 'Abandoned Lighthouse', ('4', 'B'), 'Blue')\\n\r\n('Vintage Pirate Hat', 'Quiet Inlet (Island of Mystery)', ('7', 'E'), 'Orange')\\n\r\n('Crystal Crab', 'Old Schooner', ('6', 'A'), 'Purple')\\n\r\n\"\"\"\r\n```\r\n",
    "design": "# Design\r\n\r\n## Learning Objectives\r\n\r\n- Access values in a tuple via index using [] (bracket notation).\r\n- Create a tuple via constructor (tuple(_iterable_)) and/or literal (a,b,c or (a, b, c))\r\n- Understand that tuples are an **immutable data type** (like strings). Changing a tuple means creating a new copy.\r\n- Understand that tuples can contain other tuples. (e.g. tuples can be nested).\r\n- Create a new tuple from two or more previous tuples via concatenation using the `+` operator.\r\n- Iterate through a tuple using `for item in`.\r\n- Check for membership of an item in a given tuple using the `in` keyword.\r\n- Understand that it is the comma in a sequence that makes a tuple, and that the () are optional, except for denoting an empty tuple or when omitting them creates ambiguity.\r\n\r\n## Out of Scope\r\n\r\n- Common Sequence type methods such as `min()`, `max()`, `x.index()`, `x.count()`, `len()`\r\n- Slicing or slice notation ([start:stop:step])\r\n- Additional builtin functions as they relate to this data structure (e.g. `sorted()`, `enumerate()`, `reversed()`, or `hash()`.\r\n- Knowing that tuples can be used as objects in other data structures, -- e.g. \" a \"List of tuples\", \"tuples as keys in Dictionaries\", or \"A Set of tuples\".\r\n- Hash-ability and when a tuple is not hash-able.\r\n- Related [collections](https://docs.python.org/3/library/collections.html#collections.namedtuple) module with `namedtuple()`\r\n- Related [dataclass](https://docs.python.org/3.7/library/dataclasses.html) and `@dataclass` decorator\r\n- Memory storage and performance characteristics.\r\n\r\n## Concepts\r\n\r\n- `tuples`\r\n\r\n## Prerequisites\r\n\r\n- `booleans`\r\n- `for-loops`\r\n- `functions`\r\n- `if-keyword`\r\n- `in-keyword`\r\n- `integers`\r\n- `return-keyword`\r\n- `strings`\r\n"
  },
  "config": {
    "authors": [
      "BethanyG"
    ],
    "files": {
      "solution": [
        "tuples.py"
      ],
      "test": [
        "tuples_test.py"
      ],
      "exemplar": [
        ".meta/exemplar.py"
      ]
    },
    "icon": "tisbury-treasure-hunt",
    "blurb": "Learn about tuples by helping out competitors in the Tisbury Treasure Hunt."
  },
  "starter_code": "\"\"\"Functions to help Azara and Rui locate pirate treasure.\"\"\"\r\n\r\n\r\ndef get_coordinate(record):\r\n    \"\"\"Return coordinate value from a tuple containing the treasure name, and treasure coordinate.\r\n\r\n    :param record: tuple - with a (treasure, coordinate) pair.\r\n    :return: str - the extracted map coordinate.\r\n    \"\"\"\r\n\r\n    pass\r\n\r\n\r\ndef convert_coordinate(coordinate):\r\n    \"\"\"Split the given coordinate into tuple containing its individual components.\r\n\r\n    :param coordinate: str - a string map coordinate\r\n    :return: tuple - the string coordinate split into its individual components.\r\n    \"\"\"\r\n\r\n    pass\r\n\r\n\r\ndef compare_records(azara_record, rui_record):\r\n    \"\"\"Compare two record types and determine if their coordinates match.\r\n\r\n    :param azara_record: tuple - a (treasure, coordinate) pair.\r\n    :param rui_record: tuple - a (location, tuple(coordinate_1, coordinate_2), quadrant) trio.\r\n    :return: bool - do the coordinates match?\r\n    \"\"\"\r\n\r\n    pass\r\n\r\n\r\ndef create_record(azara_record, rui_record):\r\n    \"\"\"Combine the two record types (if possible) and create a combined record group.\r\n\r\n    :param azara_record: tuple - a (treasure, coordinate) pair.\r\n    :param rui_record: tuple - a (location, coordinate, quadrant) trio.\r\n    :return: tuple or str - the combined record (if compatible), or the string \"not a match\" (if incompatible).\r\n    \"\"\"\r\n\r\n    pass\r\n\r\n\r\ndef clean_up(combined_record_group):\r\n    \"\"\"Clean up a combined record group into a multi-line string of single records.\r\n\r\n    :param combined_record_group: tuple - everything from both participants.\r\n    :return: str - everything \"cleaned\", excess coordinates and information are removed.\r\n\r\n    The return statement should be a multi-lined string with items separated by newlines.\r\n\r\n    (see HINTS.md for an example).\r\n    \"\"\"\r\n\r\n    pass\r\n",
  "exemplar_code": "\"\"\"Functions to help Azara and Rui locate pirate treasure.\"\"\"\r\n\r\n\r\ndef get_coordinate(record):\r\n    \"\"\"Return coordinate value from a tuple containing the treasure name, and treasure coordinate.\r\n\r\n    :param record: tuple - with a (treasure, coordinate) pair.\r\n    :return: str - the extracted map coordinate.\r\n    \"\"\"\r\n\r\n    return record[1]\r\n\r\n\r\ndef convert_coordinate(coordinate):\r\n    \"\"\"Split the given coordinate into tuple containing its individual components.\r\n\r\n    :param coordinate: str - a string map coordinate\r\n    :return: tuple - the string coordinate split into its individual components.\r\n    \"\"\"\r\n\r\n    return tuple(coordinate)\r\n\r\n\r\ndef compare_records(azara_record, rui_record):\r\n    \"\"\"Compare two record types and determine if their coordinates match.\r\n\r\n    :param azara_record: tuple - a (treasure, coordinate) pair.\r\n    :param rui_record: tuple - a (location, tuple(coordinate_1, coordinate_2), quadrant) trio.\r\n    :return: bool - do the coordinates match?\r\n    \"\"\"\r\n\r\n    return convert_coordinate(azara_record[1]) in rui_record\r\n\r\n\r\ndef create_record(azara_record, rui_record):\r\n    \"\"\"Combine the two record types (if possible) and create a combined record group.\r\n\r\n    :param azara_record: tuple - a (treasure, coordinate) pair.\r\n    :param rui_record: tuple - a (location, coordinate, quadrant) trio.\r\n    :return: tuple or str - the combined record (if compatible), or the string \"not a match\" (if incompatible).\r\n    \"\"\"\r\n\r\n    result = \"not a match\"\r\n\r\n    if compare_records(azara_record, rui_record):\r\n        result = azara_record + rui_record\r\n\r\n    return result\r\n\r\n\r\ndef clean_up(combined_record_group):\r\n    \"\"\"Clean up a combined record group into a multi-line string of single records.\r\n\r\n    :param combined_record_group: tuple - everything from both participants.\r\n    :return: str - everything \"cleaned\", excess coordinates and information are removed.\r\n\r\n    The return statement should be a multi-lined string with items separated by newlines.\r\n\r\n    (see HINTS.md for an example).\r\n    \"\"\"\r\n\r\n    report = \"\"\r\n\r\n    for item in combined_record_group:\r\n        report += f\"{(item[0], item[2], item[3], item[4])}\\n\"\r\n\r\n    return report\r\n",
  "tests": "import unittest\r\nimport pytest\r\nfrom tuples import (get_coordinate,\r\n                    convert_coordinate,\r\n                    compare_records,\r\n                    create_record,\r\n                    clean_up)\r\n\r\n\r\nclass TisburyTreasureTest(unittest.TestCase):\r\n\r\n    @pytest.mark.task(taskno=1)\r\n    def test_get_coordinate(self):\r\n        input_data = [('Scrimshawed Whale Tooth', '2A'),\r\n                      ('Brass Spyglass', '4B'),\r\n                      ('Robot Parrot', '1C'),\r\n                      ('Glass Starfish', '6D'),\r\n                      ('Vintage Pirate Hat', '7E'),\r\n                      ('Pirate Flag', '7F'),\r\n                      ('Crystal Crab', '6A'),\r\n                      ('Model Ship in Large Bottle', '8A'),\r\n                      ('Angry Monkey Figurine', '5B'),\r\n                      ('Carved Wooden Elephant', '8C'),\r\n                      ('Amethyst  Octopus', '1F'),\r\n                      ('Antique Glass Fishnet Float', '3D'),\r\n                      ('Silver Seahorse', '4E')]\r\n\r\n        result_data = ['2A', '4B', '1C', '6D', '7E', '7F', '6A', '8A', '5B', '8C', '1F', '3D', '4E']\r\n\r\n        for variant, (item, expected) in enumerate(zip(input_data, result_data), start=1):\r\n            with self.subTest(f'variation #{variant}', item=item, expected=expected):\r\n                actual_result = get_coordinate(item)\r\n                error_message = (f'Called get_coordinate({item}). '\r\n                                f'The function returned \"{actual_result}\", but '\r\n                                f'the tests expected \"{expected}\" as the coordinates.')\r\n\r\n                self.assertEqual(actual_result, expected, msg=error_message)\r\n\r\n    @pytest.mark.task(taskno=2)\r\n    def test_convert_coordinate(self):\r\n        input_data = ['2A', '4B', '1C', '6D', '7E', '7F',\r\n                      '6A', '8A', '5B', '8C', '1F', '3D', '4E']\r\n        result_data = [('2', 'A'),\r\n                       ('4', 'B'),\r\n                       ('1', 'C'),\r\n                       ('6', 'D'),\r\n                       ('7', 'E'),\r\n                       ('7', 'F'),\r\n                       ('6', 'A'),\r\n                       ('8', 'A'),\r\n                       ('5', 'B'),\r\n                       ('8', 'C'),\r\n                       ('1', 'F'),\r\n                       ('3', 'D'),\r\n                       ('4', 'E')]\r\n\r\n        for variant, (item, expected) in enumerate(zip(input_data, result_data), start=1):\r\n            with self.subTest(f'variation #{variant}', item=item, expected=expected):\r\n                actual_result = convert_coordinate(item)\r\n                error_message = (f'Called convert_coordinate({item}). '\r\n                                 f'The function returned {actual_result}, but the '\r\n                                 f'tests expected {expected} as the converted coordinate.')\r\n\r\n                self.assertEqual(actual_result, expected, msg=error_message)\r\n\r\n    @pytest.mark.task(taskno=3)\r\n    def test_compare_records(self):\r\n        input_data = [\r\n                (('Scrimshawed Whale Tooth', '2A'), ('Deserted Docks', ('2', 'A'), 'Blue')),\r\n                (('Brass Spyglass', '4B'), ('Abandoned Lighthouse', ('4', 'B'), 'Blue')),\r\n                (('Robot Parrot', '1C'), ('Seaside Cottages', ('1', 'C'), 'Blue')),\r\n                (('Glass Starfish', '6D'), ('Tangled Seaweed Patch', ('6', 'D'), 'Orange')),\r\n                (('Vintage Pirate Hat', '7E'), ('Quiet Inlet (Island of Mystery)', ('7', 'E'), 'Orange')),\r\n                (('Amethyst  Octopus', '1F'), ('Seaside Cottages', ('1', 'C'), 'Blue')),\r\n                (('Angry Monkey Figurine', '5B'), ('Aqua Lagoon (Island of Mystery)', ('1', 'F'), 'Yellow')),\r\n                (('Antique Glass Fishnet Float', '3D'), ('Deserted Docks', ('2', 'A'), 'Blue')),\r\n                (('Brass Spyglass', '4B'), ('Spiky Rocks', ('3', 'D'), 'Yellow')),\r\n                (('Carved Wooden Elephant', '8C'), ('Abandoned Lighthouse', ('4', 'B'), 'Blue'))\r\n        ]\r\n        result_data = [True, True, True, True, True, False, False, False, False, False]\r\n\r\n        for variant, (item, expected) in enumerate(zip(input_data, result_data), start=1):\r\n            with self.subTest(f'variation #{variant}', item=item, expected=expected):\r\n                actual_result = compare_records(item[0], item[1])\r\n                error_message = (f'Called compare_records({item[0]}, {item[1]}). '\r\n                                 f'The function returned {actual_result}, but the '\r\n                                 f'tests expected {expected}.')\r\n\r\n                self.assertEqual(actual_result, expected, msg=error_message)\r\n\r\n    @pytest.mark.task(taskno=4)\r\n    def test_create_record(self):\r\n        input_data = [\r\n                (('Angry Monkey Figurine', '5B'), ('Stormy Breakwater', ('5', 'B'), 'Purple')),\r\n                (('Carved Wooden Elephant', '8C'), ('Foggy Seacave', ('8', 'C'), 'Purple')),\r\n                (('Amethyst  Octopus', '1F'), ('Aqua Lagoon (Island of Mystery)', ('1', 'F'), 'Yellow')),\r\n                (('Antique Glass Fishnet Float', '3D'), ('Spiky Rocks', ('3', 'D'), 'Yellow')),\r\n                (('Silver Seahorse', '4E'), ('Hidden Spring (Island of Mystery)', ('4', 'E'), 'Yellow')),\r\n                (('Amethyst  Octopus', '1F'), ('Seaside Cottages', ('1', 'C'), 'Blue')),\r\n                (('Angry Monkey Figurine', '5B'), ('Aqua Lagoon (Island of Mystery)', ('1', 'F'), 'Yellow')),\r\n                (('Antique Glass Fishnet Float', '3D'), ('Deserted Docks', ('2', 'A'), 'Blue')),\r\n                (('Brass Spyglass', '4B'), ('Spiky Rocks', ('3', 'D'), 'Yellow')),\r\n                (('Carved Wooden Elephant', '8C'), ('Abandoned Lighthouse', ('4', 'B'), 'Blue'))\r\n        ]\r\n        result_data = [\r\n                ('Angry Monkey Figurine', '5B', 'Stormy Breakwater', ('5', 'B'), 'Purple'),\r\n                ('Carved Wooden Elephant', '8C', 'Foggy Seacave', ('8', 'C'), 'Purple'),\r\n                ('Amethyst  Octopus', '1F', 'Aqua Lagoon (Island of Mystery)', ('1', 'F'), 'Yellow'),\r\n                ('Antique Glass Fishnet Float', '3D', 'Spiky Rocks', ('3', 'D'), 'Yellow'),\r\n                ('Silver Seahorse', '4E', 'Hidden Spring (Island of Mystery)', ('4', 'E'), 'Yellow'),\r\n                'not a match',\r\n                'not a match',\r\n                'not a match',\r\n                'not a match',\r\n                'not a match'\r\n        ]\r\n\r\n        for variant, (item, expected) in enumerate(zip(input_data, result_data), start=1):\r\n            with self.subTest(f'variation #{variant}', item=item, expected=expected):\r\n                actual_result = create_record(item[0], item[1])\r\n                error_message = (f'Called create_record({item[0]},{item[1]}). '\r\n                                 f'The function returned '\r\n                                 f'{actual_result}, but the tests expected '\r\n                                 f'{expected} for the record.')\r\n\r\n                self.assertEqual(actual_result, expected, msg=error_message)\r\n\r\n    @pytest.mark.task(taskno=5)\r\n    def test_clean_up(self):\r\n        input_data = (\r\n                ('Scrimshawed Whale Tooth', '2A', 'Deserted Docks', ('2', 'A'), 'Blue'),\r\n                ('Brass Spyglass', '4B', 'Abandoned Lighthouse', ('4', 'B'), 'Blue'),\r\n                ('Robot Parrot', '1C', 'Seaside Cottages', ('1', 'C'), 'Blue'),\r\n                ('Glass Starfish', '6D', 'Tangled Seaweed Patch', ('6', 'D'), 'Orange'),\r\n                ('Vintage Pirate Hat', '7E', 'Quiet Inlet (Island of Mystery)', ('7', 'E'), 'Orange'),\r\n                ('Pirate Flag', '7F', 'Windswept Hilltop (Island of Mystery)', ('7', 'F'), 'Orange'),\r\n                ('Crystal Crab', '6A', 'Old Schooner', ('6', 'A'), 'Purple'),\r\n                ('Model Ship in Large Bottle', '8A', 'Harbor Managers Office', ('8', 'A'), 'Purple'),\r\n                ('Angry Monkey Figurine', '5B', 'Stormy Breakwater', ('5', 'B'), 'Purple'),\r\n                ('Carved Wooden Elephant', '8C', 'Foggy Seacave', ('8', 'C'), 'Purple'),\r\n                ('Amethyst  Octopus', '1F', 'Aqua Lagoon (Island of Mystery)', ('1', 'F'), 'Yellow'),\r\n                ('Antique Glass Fishnet Float', '3D', 'Spiky Rocks', ('3', 'D'), 'Yellow'),\r\n                ('Silver Seahorse', '4E', 'Hidden Spring (Island of Mystery)', ('4', 'E'), 'Yellow')\r\n        )\r\n\r\n        result_data = \"\"\"('Scrimshawed Whale Tooth', 'Deserted Docks', ('2', 'A'), 'Blue')\\n\\\r\n('Brass Spyglass', 'Abandoned Lighthouse', ('4', 'B'), 'Blue')\\n\\\r\n('Robot Parrot', 'Seaside Cottages', ('1', 'C'), 'Blue')\\n\\\r\n('Glass Starfish', 'Tangled Seaweed Patch', ('6', 'D'), 'Orange')\\n\\\r\n('Vintage Pirate Hat', 'Quiet Inlet (Island of Mystery)', ('7', 'E'), 'Orange')\\n\\\r\n('Pirate Flag', 'Windswept Hilltop (Island of Mystery)', ('7', 'F'), 'Orange')\\n\\\r\n('Crystal Crab', 'Old Schooner', ('6', 'A'), 'Purple')\\n\\\r\n('Model Ship in Large Bottle', 'Harbor Managers Office', ('8', 'A'), 'Purple')\\n\\\r\n('Angry Monkey Figurine', 'Stormy Breakwater', ('5', 'B'), 'Purple')\\n\\\r\n('Carved Wooden Elephant', 'Foggy Seacave', ('8', 'C'), 'Purple')\\n\\\r\n('Amethyst  Octopus', 'Aqua Lagoon (Island of Mystery)', ('1', 'F'), 'Yellow')\\n\\\r\n('Antique Glass Fishnet Float', 'Spiky Rocks', ('3', 'D'), 'Yellow')\\n\\\r\n('Silver Seahorse', 'Hidden Spring (Island of Mystery)', ('4', 'E'), 'Yellow')\\n\"\"\"\r\n\r\n        self.assertEqual(clean_up(input_data), result_data)\r\n"
}