{
  "concept": "ellens-alien-game",
  "docs": {
    "introduction": "# Introduction\r\n\r\n## Object Oriented Programming in Python\r\n\r\nIf you have been programming in a [functional][functional], [declarative][declarative], or [imperative][imperative] style, shifting focus to [object oriented programming][oop] (OOP) may feel a bit foreign.\r\nAn OOP approach asks the programmer to think about modeling a problem as one or more `objects` that interact with one another, keep state, and act upon data.\r\nObjects can represent real world entities (_such as cars or cats_) - or more abstract concepts (_such as integers, vehicles, or mammals_).\r\nEach object becomes a unique instance in computer memory and represents some part of the overall model.\r\n\r\n## Classes\r\n\r\n`Classes` are the definitions of new object types, and from which new `instances` of objects are created.\r\nThey often bundle data with code or functions that operate on that data.\r\nIn this sense, classes are _blueprints_ or sets of instructions from which many objects of a similar type can be built and used.\r\nA complex program can have many classes, each building many different flavors of objects.\r\nThe process of building an object from a class is known as `instantiation` (_or creating an instance of the class_).\r\n\r\nA class definition in Python is straightforward:\r\n\r\n```python\r\nclass MyClass:\r\n    # Class body goes here\r\n```\r\n\r\n### Class Attributes\r\n\r\nClass fields (_otherwise known as `properties`, `attributes`, `data members`, or `variables`_) can be added to the body of the class:\r\n\r\n```python\r\nclass MyClass:\r\n    number = 5\r\n    string = \"Hello!\"\r\n```\r\n\r\nAn instance (_object_) of `MyClass` can be created and bound to a name by [_calling_][calling] the class (_in the same way a function is called_):\r\n\r\n```python\r\n>>> new_object = MyClass()\r\n\r\n# Class is instantiated and resulting object is bound to the \"new_object\" name.\r\n# Note: the object address 'at 0x15adc55b0' will vary by computer.\r\n>>> new_object\r\n<__main__.MyClass at 0x15adc55b0>\r\n```\r\n\r\n`Class attributes` are shared across all objects (_or instances_) created from a class, and can be accessed via [`dot notation`][dot notation]  -  a `.` placed after the object name and before the attribute name:\r\n\r\n```python\r\n>>> new_object = MyClass()\r\n\r\n# Accessing the class attribute \"number\" via dot-notation.\r\n>>> new_object.number\r\n5\r\n\r\n# Accessing the class attribute \"string\" via dot-notation.\r\n>>> new_object.string\r\n'Hello!'\r\n\r\n# Instantiating an additional object and binding it to the \"second_new_object\" name.\r\n>>> second_new_object = MyClass()\r\n\r\n>>> second_new_object\r\n# Note: the object address \"at 0x15ad99970\" will vary by computer.\r\n<__main__.MyClass at 0x15ad99970>\r\n\r\n# Second_new_object shares the same class attributes as new_object.\r\n>>> new_object.number == second_new_object.number\r\nTrue\r\n```\r\n\r\nClass attributes are defined in the body of the class itself, before any other methods.\r\nThey are owned by the class - allowing them to be shared across instances of the class.\r\nBecause these attributes are shared, their value can be accessed and manipulated from the class _directly_.\r\nAltering the value of class attributes alters the value _**for all objects instantiated from the class**_:\r\n\r\n```python\r\n>>> obj_one = MyClass()\r\n>>> obj_two = MyClass()\r\n\r\n# Accessing a class attribute from an object.\r\n>>> obj_two.number\r\n5\r\n\r\n# Accessing the class attribute from the class itself.\r\n>>> MyClass.number\r\n5\r\n\r\n# Modifying the value of the \"number\" class attribute.\r\n>>> MyClass.number = 27\r\n\r\n# Modifying the \"number\" class attribute changes the \"number\" attribute for all objects.\r\n>>> obj_one.number\r\n27\r\n\r\n>>> obj_two.number\r\n27\r\n```\r\n\r\nHaving a bunch of objects with synchronized data at all times is not particularly useful.\r\nFortunately, objects created from a class can be customized with their own `instance attributes` (_or instance properties, variables, or fields_).\r\nAs their name suggests, instance attributes are unique to each object, and can be modified independently.\r\n\r\n\r\n## Customizing Object Instantiation with `__init__()`\r\n\r\nThe special [\"dunder method\"][dunder] (_short for \"double underscore method\"_) `__init__()` is used to customize class instances, and can be used to initialize instance attributes or properties for objects.\r\nFor its role in initializing instance attributes, `__init__()` is also referred to as a `class constructor` or `initializer`.\r\n`__init__()` takes one required parameter called `self`, which refers to the newly initialized or created object.\r\nData for instance attributes or properties can then be passed as arguments of `__init__()`, following the `self` parameter.\r\n\r\nBelow, `MyClass` now has instance attributes called `location_x` and `location_y`.\r\nAs you can see, the two attributes have been assigned to the first and second indexes of the `location` (_a tuple_) argument that has been passed to `__init__()`.\r\nThe `location_x` and `location_y` attributes for a class instance will now be initialized when you instantiate the class, and an object is created:\r\n\r\n```python\r\nclass MyClass:\r\n    # These are class attributes, variables, or fields.\r\n    number = 5\r\n    string = \"Hello!\"\r\n\r\n    # This is the class \"constructor\", with a \"location\" parameter that is a tuple.\r\n    def __init__(self, location):\r\n\r\n        # This is an instance or object property, attribute, or variable.\r\n        # Note that we are unpacking the tuple argument into two separate instance variables.\r\n        self.location_x = location[0]\r\n        self.location_y = location[1]\r\n\r\n# Create a new object \"new_object_one\", with object property (1, 2).\r\n>>> new_object_one = MyClass((1, 2))\r\n\r\n# Create a second new object \"new_object_two\" with object property (-8, -9).\r\n>>> new_object_two = MyClass((-8, -9))\r\n\r\n# Note that new_object_one.location_x and new_object_two.location_x two different values.\r\n>>> new_object_one.location_x\r\n1\r\n\r\n>>> new_object_two.location_x\r\n-8\r\n```\r\n\r\nNote that you only need to pass one argument when initializing `MyClass` above -- Python takes care of passing `self` when the class is called.\r\n\r\n\r\n## Methods\r\n\r\nA `method` is a `function` that is bound to either the class itself (_known as a [class method][class method], which will be discussed in a later exercise_) or an _instance_ of the class (object).\r\nMethods that operate on an object (instance) need to be defined with `self` as the first parameter.\r\nYou can then define the rest of the parameters as you would for a \"normal\" or non-bound function:\r\n\r\n```python\r\nclass MyClass:\r\n    number = 5\r\n    string = \"Hello!\"\r\n\r\n    # Class constructor.\r\n    def __init__(self, location):\r\n        # Instance properties\r\n        self.location_x = location[0]\r\n        self.location_y = location[1]\r\n\r\n    # Instance method. Note \"self\" as first parameter.\r\n    def change_location(self, amount):\r\n        self.location_x += amount\r\n        self.location_y += amount\r\n        return self.location_x, self.location_y\r\n```\r\n\r\nLike attribute access, calling a method simply requires putting a `.` after the object name, and before the method name.\r\nThe called method does not need a copy of the object as a first parameter -- Python fills in `self` automatically:\r\n\r\n```python\r\nclass MyClass:\r\n    number = 5\r\n    string = \"Hello!\"\r\n\r\n    def __init__(self, location):\r\n        self.location_x = location[0]\r\n        self.location_y = location[1]\r\n\r\n    def change_location(self, amount):\r\n        self.location_x += amount\r\n        self.location_y += amount\r\n        return  self.location_x, self.location_y\r\n\r\n# Make a new test_object with location (3,7)\r\n>>> test_object = MyClass((3,7))\r\n>>> (test_object.location_x, test_object.location_y)\r\n(3,7)\r\n\r\n# Call change_location to increase location_x and location_y by 7.\r\n>>> test_object.change_location(7)\r\n(10, 14)\r\n```\r\n\r\nClass attributes can be accessed from within instance methods in the same way that they are accessed outside of the class:\r\n\r\n```python\r\nclass MyClass:\r\n    number = 5\r\n    string = \"Hello!\"\r\n\r\n    def __init__(self, location):\r\n        self.location_x = location[0]\r\n        self.location_y = location[1]\r\n\r\n    # Alter instance variable location_x and location_y\r\n    def change_location(self, amount):\r\n        self.location_x += amount\r\n        self.location_y += amount\r\n        return  self.location_x, self.location_y\r\n\r\n    # Alter class variable number for all instances from within an instance.\r\n    def increment_number(self):\r\n        # Increment the 'number' class variable by 1.\r\n        MyClass.number += 1\r\n\r\n\r\n>>> test_object_one = MyClass((0,0))\r\n>>> test_object_one.number\r\n5\r\n\r\n>>> test_object_two = MyClass((13, -3))\r\n>>> test_object_two.increment_number()\r\n>>> test_object_one.number\r\n6\r\n```\r\n\r\n## Placeholding or Stubbing Implementation with Pass\r\n\r\nIn previous concept exercises and practice exercise stubs, you will have seen the `pass` keyword used within the body of  functions in place of actual code.\r\nThe `pass` keyword is a syntactically valid placeholder - it prevents Python from throwing a syntax error for an empty function or class definition.\r\nEssentially, it is a way to say to the Python interpreter, 'Don't worry! I _will_ put code here eventually, I just haven't done it yet.'\r\n\r\n```python\r\nclass MyClass:\r\n    number = 5\r\n    string = \"Hello!\"\r\n\r\n    def __init__(self, location):\r\n        self.location_x = location[0]\r\n        self.location_y = location[1]\r\n\r\n    # Alter instance variable location_x and location_y\r\n    def change_location(self, amount):\r\n        self.location_x += amount\r\n        self.location_y += amount\r\n        return  self.location_x, self.location_y\r\n\r\n    # Alter class variable number for all instances\r\n    def increment_number(self):\r\n        # Increment the 'number' class variable by 1.\r\n        MyClass.number += 1\r\n\r\n    # This will compile and run without error, but has no current functionality.\r\n    def pending_functionality(self):\r\n       # Stubbing or placholding the body of this method.\r\n       pass\r\n```\r\n\r\n[calling]: https://www.pythonmorsels.com/topics/calling-a-function\r\n[class method]: https://stackoverflow.com/questions/17134653/difference-between-class-and-instance-methods\r\n[dunder]: https://mathspp.com/blog/pydonts/dunder-methods\r\n[imperative]: https://en.wikipedia.org/wiki/Imperative_programming\r\n[declarative]: https://en.wikipedia.org/wiki/Declarative_programming\r\n[oop]: https://www.digitalocean.com/community/tutorials/how-to-construct-classes-and-define-objects-in-python-3\r\n[functional]: https://en.wikipedia.org/wiki/Functional_programming\r\n[dot notation]: https://stackoverflow.com/questions/45179186/understanding-the-dot-notation-in-python\r\n",
    "hints": "# Hints\r\n\r\n## 1. Create the Alien Class\r\n\r\n- Remember that `object methods` are always passed `self` as the first parameter.\r\n- Remember the double underscores on _both_ sides of `__init__()`.\r\n- Instance variables are unique to the `class` instance (_object_) that possesses them.\r\n- Class variables are the same across all instances of a `class`.\r\n\r\n## 2. The `hit` Method\r\n\r\n- Remember that `object methods` are always passed `self` as the first parameter.\r\n- You can choose to allow the Alien's health to fall below zero, or require that it does not.\r\n\r\n## 3. The `is_alive` Method\r\n\r\n- Remember that `object methods` are always passed `self` as the first parameter.\r\n- 0 may not be the only 'dead' condition, depending on how `hit()` is implemented.\r\n\r\n## 4. The `teleport` Method\r\n\r\n- Remember that `object methods` are always passed `self` as the first parameter.\r\n- Instance attributes can be updated from a method by using `self.<attribute>` = `<new attribute value>`.\r\n\r\n## 5. The `collision_detection` Method\r\n\r\n- Remember that `object methods` are always passed `self` as the first parameter.\r\n- This method seems like an excellent place to use some kind of placeholderâ€¦\r\n\r\n## 6. Alien Counter\r\n\r\n- Class attributes are the same across all instances of a `class`.\r\n- Ideally, this counter would increment whenever someone _made an new Alien_.\r\n- Class attributes can be changed from an instance method by using the _class name_:  `Alien.<class attribute name>`.\r\n- `__init__()` is considered an instance method since it _initializes a new object_.\r\n\r\n## 7. Object Creation\r\n\r\n- A `tuple` would be a _single_ parameter.\r\n- The Alien constructor takes _2 parameters_.\r\n- Unpacking what is _inside_ the tuple would yield two parameters.\r\n- The standalone function is outside of the `class`\r\n",
    "instructions": "# Instructions\r\n\r\nEllen is making a game where the player has to fight aliens.\r\nShe has just learned about Object Oriented Programming (OOP) and is eager to take advantage of what using `classes` could offer her program.\r\n\r\nTo Ellen's delight, you have offered to help and she has given you the task of programming the aliens that the player has to fight.\r\n\r\n\r\n## 1. Create the Alien Class\r\n\r\nDefine the Alien class with a constructor that accepts two parameters `<x_coordinate>` and `<y_coordinate>`, putting them into `x_coordinate` and `y_coordinate` instance variables.\r\nEvery alien will also start off with a health level of 3, so the `health` variable should be initialized as well.\r\n\r\n```python\r\n>>> alien = Alien(2, 0)\r\n>>> alien.x_coordinate\r\n2\r\n>>> alien.y_coordinate\r\n0\r\n>>> alien.health\r\n3\r\n```\r\n\r\nNow, each alien should be able to internally track its own position and health.\r\n\r\n## 2. The `hit` Method\r\n\r\nEllen would like the Alien `class` to have a `hit` method that decrements the health of an alien object by 1 when called.\r\nThis way, she can simply call `<alien>.hit()` instead of having to manually change an alien's health.\r\nIt is up to you if `hit()` takes healths points _to_ or _below_ zero.\r\n\r\n```python\r\n>>> alien = Alien(0, 0)\r\n>>> alien.health\r\n\r\n# Initialized health value.\r\n3\r\n\r\n# Decrements health by 1 point.\r\n>>> alien.hit()\r\n>>> alien.health\r\n2\r\n```\r\n\r\n## 3. The `is_alive` Method\r\n\r\nYou realize that if the health keeps decreasing, at some point it will probably hit 0 (_or even less!_).\r\nIt would be a good idea to add an `is_alive` method that Ellen can quickly call to check if the alien is... well... alive. ðŸ˜‰\r\n`<alien>.is_alive()` should return a boolean.\r\n\r\n```python\r\n>>> alien.health\r\n1\r\n>>> alien.is_alive()\r\nTrue\r\n>>> alien.hit()\r\n>>> alien.health\r\n0\r\n>>> alien.is_alive()\r\nFalse\r\n```\r\n\r\n## 4. The `teleport` Method\r\n\r\nIn Ellen's game, the aliens have the ability to teleport!\r\nYou will need to write a `teleport` method that takes new `x_coordinate` and `y_coordinate` values, and changes the alien's coordinates accordingly.\r\n\r\n```python\r\n>>> alien.teleport(5, -4)\r\n>>> alien.x_coordinate\r\n5\r\n>>> alien.y_coordinate\r\n-4\r\n```\r\n\r\n## 5. The `collision_detection` Method\r\n\r\nObviously, if the aliens can be hit by something, then they need to be able to detect when such a collision has occurred.\r\nHowever, collision detection algorithms can be tricky, and you do not yet know how to implement one.\r\nEllen has said that she will do it later, but she would still like the `collision_detection` method to appear in the class as a reminder to build out the functionality.\r\nIt will need to take a variable of some kind (probably another object), but that's really all you know.\r\nYou will need to make sure that putting the method definition into the class doesn't cause any errors when called:\r\n\r\n```python\r\n>>> alien.collision_detection(other_object)\r\n>>>\r\n```\r\n\r\n## 6. Alien Counter\r\n\r\nEllen has come back with a new request for you.\r\nShe wants to keep track of how many aliens have been created over the game's lifetime.\r\nShe says that it's got something to do with the scoring system.\r\n\r\nFor example:\r\n\r\n```python\r\n>>> alien_one = Alien(5, 1)\r\n>>> alien_one.total_aliens_created\r\n1\r\n>>> alien_two = Alien(3, 0)\r\n>>> alien_two.total_aliens_created\r\n2\r\n>>> alien_one.total_aliens_created\r\n2\r\n>>> Alien.total_aliens_created\r\n# Accessing the variable from the class directly\r\n2\r\n```\r\n\r\n## 7. Creating a List of Aliens\r\n\r\nEllen loves what you've done so far, but she has one more favor to ask.\r\nShe would like a standalone (_outside the `Alien()` class_) function that creates a `list` of `Alien()` objects, given a list of positions (as `tuples`).\r\n\r\nFor example:\r\n\r\n```python\r\n>>> alien_start_positions = [(4, 7), (-1, 0)]\r\n>>> aliens = new_aliens_collection(alien_start_positions)\r\n...\r\n>>> for alien in aliens:\r\n    \tprint(alien.x_coordinate, alien.y_coordinate)\r\n(4, 7)\r\n(-1, 0)\r\n```\r\n",
    "design": "# Design\r\n\r\n## Goal\r\n\r\nThe goal of this exercise is to introduce the student to the concept of classes.\r\n\r\n## Learning objectives\r\n\r\n- Understand the _basic_ idea behind Object Oriented Programming (OOP).\r\n- Learn what a class represents.\r\n- Learn what an object is.\r\n- Understand the difference between classes and objects.\r\n- Know how to create a class.\r\n- Know how to create objects.\r\n- Understand that instantiating a class creates an object.\r\n- Know that `__init__()` is a 'constructor' and is used to initialize the object upon instantiation.\r\n- Know that `__init__()` is called upon instantiation/object creation.\r\n- Know what a method is and how it differs from a function.\r\n- Know how to create a method.\r\n- Implement instance variables.\r\n- Implement class variables.\r\n- Understand the difference between instance variables and class variables.\r\n- Use `pass` as a placeholder for class methods.\r\n\r\n## Out of scope\r\n\r\n- `class-customiation`, including `@classmethod` & `@staticmethod` - but ok to mention in `about.md`.\r\n- `@property` decorator, getters, and setters\r\n- class members & non-public methods\r\n- `class-inheritance`, `multiple-inheritance`, `__super()__`, class mix-ins\r\n- `class-composition`\r\n- `dataclasses`\r\n- performance considerations\r\n\r\n## Concepts\r\n\r\n- `attributes`\r\n- `classes`\r\n- `methods`\r\n- `objects`\r\n- `OOP`\r\n\r\n## Prerequisites\r\n\r\nThese are the concepts/concept exercises the student needs to complete/understand before solving this concept exercise.\r\n\r\n- `basics`\r\n- `bools`\r\n- `comparisons`\r\n- `dicts`\r\n- `iteration`\r\n- `lists`\r\n- `numbers`\r\n- `sequences`\r\n- `sets`\r\n- `strings`\r\n- `tuples`\r\n\r\n## Resources\r\n\r\n- [Classes (Python tutorial)](https://docs.python.org/3/tutorial/classes.html)\r\n- [Python Data Model - Python Docs](https://docs.python.org/3/reference/datamodel.html#the-standard-type-hierarchy)\r\n- [Real Python: Object-Oriented Programming in Python 3](https://realpython.com/python3-object-oriented-programming/)\r\n- [DigitalOcean: How To Construct Classes & Objects in Python 3](https://www.digitalocean.com/community/tutorials/how-to-construct-classes-and-define-objects-in-python-3)\r\n"
  },
  "config": {
    "authors": [
      "PaulT89",
      "BethanyG"
    ],
    "contributors": [
      "DjangoFett",
      "kotp",
      "IsaacG"
    ],
    "files": {
      "solution": [
        "classes.py"
      ],
      "test": [
        "classes_test.py"
      ],
      "exemplar": [
        ".meta/exemplar.py"
      ]
    },
    "icon": "character-study",
    "blurb": "Learn about classes by creating an Alien for Ellen's game."
  },
  "starter_code": "\"\"\"Solution to Ellen's Alien Game exercise.\"\"\"\r\n\r\n\r\nclass Alien:\r\n    \"\"\"Create an Alien object with location x_coordinate and y_coordinate.\r\n\r\n    Attributes\r\n    ----------\r\n    (class)total_aliens_created: int\r\n    x_coordinate: int - Position on the x-axis.\r\n    y_coordinate: int - Position on the y-axis.\r\n    health: int - Number of health points.\r\n\r\n    Methods\r\n    -------\r\n    hit(): Decrement Alien health by one point.\r\n    is_alive(): Return a boolean for if Alien is alive (if health is > 0).\r\n    teleport(new_x_coordinate, new_y_coordinate): Move Alien object to new coordinates.\r\n    collision_detection(other): Implementation TBD.\r\n    \"\"\"\r\n\r\n    pass\r\n\r\n\r\n#TODO:  create the new_aliens_collection() function below to call your Alien class with a list of coordinates.\r\n",
  "exemplar_code": "\"\"\"Exemplar solution to Ellen's Alien Game exercise.\"\"\"\r\n\r\n\r\nclass Alien:\r\n    \"\"\"Create an Alien object with location x_coordinate and y_coordinate.\r\n\r\n    Attributes\r\n    ----------\r\n    (class)total_aliens_created: int\r\n    x_coordinate: int - Position on the x-axis.\r\n    y_coordinate: int - Position on the y-axis.\r\n    health: int - Number of health points.\r\n\r\n    Methods\r\n    -------\r\n    hit(): Decrement Alien health by one point.\r\n    is_alive(): Return a boolean to indicate if Alien is alive (if health is > 0).\r\n    teleport(new_x_coordinate, new_y_coordinate): Move Alien object to new coordinates.\r\n    collision_detection(other): Implementation TBD.\r\n    \"\"\"\r\n\r\n    total_aliens_created = 0\r\n\r\n    def __init__(self, x_coordinate, y_coordinate):\r\n        \"\"\"Initialize a new Alien object and increment total_aliens_created by 1.\r\n\r\n        :param x_coordinate: int - Alien position on the x-axis\r\n        :param y_coordinate: int - Alien position on the y-axis\r\n\r\n        :attribute x_coordinate: int - Alien position on the x-axis\r\n        :attribute y_coordinate: int - Alien position on the y-axis\r\n        :attribute health: int (3) - Initial Alien health points.\r\n\r\n        :return: object - New Alien.\r\n        \"\"\"\r\n\r\n        Alien.total_aliens_created += 1\r\n\r\n        self.x_coordinate = x_coordinate\r\n        self.y_coordinate = y_coordinate\r\n        self.health = 3\r\n\r\n    def hit(self):\r\n        \"\"\"Decrement Alien health by 1.\r\n\r\n        :return: None\r\n        \"\"\"\r\n\r\n        #There are two valid interpretations for this method/task.\r\n        #The one below, and `self.health = max(0, self.health - 1)`\r\n        #The tests for this task reflect this ambiguity.\r\n        self.health -= 1\r\n\r\n    def is_alive(self):\r\n        \"\"\"Return if the Alien is alive.\r\n\r\n        :return: boolean\r\n        \"\"\"\r\n\r\n        return self.health > 0\r\n\r\n    def teleport(self, new_x_coordinate, new_y_coordinate):\r\n        \"\"\"Change Alien location.\r\n\r\n        :param new_x_coordinate: int - New location on x-axis.\r\n        :param new_y_coordinate: int - New location on y-axis.\r\n\r\n        :return: None\r\n        \"\"\"\r\n        self.x_coordinate = new_x_coordinate\r\n        self.y_coordinate = new_y_coordinate\r\n\r\n    def collision_detection(self, other):\r\n        \"\"\"Detect collisions with another Alien.\r\n\r\n        :param other: object - Other Alien object.\r\n\r\n        :return: None\r\n        \"\"\"\r\n\r\n        pass\r\n\r\ndef new_aliens_collection(positions):\r\n    \"\"\"Create a list of Alien instances from a list of coordinate tuples.\r\n\r\n     :param positions: list - List of tuples of (x, y) coordinates.\r\n\r\n     :return: list - List of Alien objects.\r\n     \"\"\"\r\n    return [Alien(position[0], position[1]) for position in positions]\r\n",
  "tests": "import unittest\r\nimport pytest\r\n\r\n\r\ntry:\r\n    from classes import Alien\r\nexcept ImportError as import_fail:\r\n    # pylint: disable=raise-missing-from\r\n    raise ImportError(\"\\n\\nMISSING CLASS --> We tried to import the 'Alien' class from \"\r\n                      \"your classes.py file, but could not find it.\" \r\n                      \"Did you misname or forget to create it?\") from None\r\n\r\ntry:\r\n    from classes import new_aliens_collection\r\nexcept ImportError as err:\r\n    raise ImportError(\"\\n\\nMISSING FUNCTION --> We tried to import the \"\r\n                      \"new_aliens_collection() function \"\r\n                      \"from your classes.py file, but could not find it. \"\r\n                      \"Did you misname or forget to create it?\") from None\r\n\r\n\r\nclass ClassesTest(unittest.TestCase):\r\n\r\n    @pytest.mark.task(taskno=1)\r\n    def test_alien_has_correct_initial_coordinates(self):\r\n        \"\"\"Test that the Alien class gets correctly initialised.\"\"\"\r\n\r\n        alien = Alien(2, -1)\r\n        error_message = (f'Created a new Alien by calling Alien(2, -1). '\r\n                         f'The Alien was initialized to position '\r\n                         f'{(alien.x_coordinate, alien.y_coordinate)}, but the tests expected '\r\n                         f'the object to be at position (2, -1)')\r\n\r\n        self.assertEqual((2, -1), (alien.x_coordinate, alien.y_coordinate), msg=error_message)\r\n\r\n    @pytest.mark.task(taskno=1)\r\n    def test_alien_has_health(self):\r\n        alien = Alien(0, 0)\r\n        error_message = (f'Created a new Alien by calling Alien(0, 0). '\r\n                         f'The new Alien has a health of {alien.health}, '\r\n                         f'but the tests expect health = 3')\r\n\r\n        self.assertEqual(3, alien.health, msg=error_message)\r\n\r\n    @pytest.mark.task(taskno=1)\r\n    def test_alien_instance_variables(self):\r\n        \"\"\"Test instance variables are unique to specific instances.\"\"\"\r\n\r\n        alien_one = Alien(-8, -1)\r\n        alien_two = Alien(2, 5)\r\n\r\n        coord_x_error = (f'Created two new Aliens by assigning '\r\n                         f'alien_one = Alien(-8, -1) and alien_two = Alien(2, 5). '\r\n                         f'Both Aliens x coordinates were {alien_two.x_coordinate}, '\r\n                         f'but the tests expect alien_one and alien_two to have '\r\n                         f'different x positions.')\r\n\r\n        coord_y_error = (f'Created two new Aliens by assigning '\r\n                         f'alien_one = Alien(-8, -1) and alien_two = Alien(2, 5). '\r\n                         f'Both Aliens y coordinates were {alien_two.y_coordinate}, '\r\n                         f'but the tests expect alien_one and alien_two to have '\r\n                         f'different y positions.')\r\n\r\n        self.assertFalse(alien_one.x_coordinate == alien_two.x_coordinate, msg=coord_x_error)\r\n        self.assertFalse(alien_one.y_coordinate == alien_two.y_coordinate, msg=coord_y_error)\r\n\r\n\r\n    @pytest.mark.task(taskno=2)\r\n    def test_alien_hit_method(self):\r\n        \"\"\"Test class methods work as specified.\r\n\r\n        There are two valid interpretations for this method/task.\r\n        `self.health -= 1` and `self.health = max(0, self.health - 1)`\r\n        The tests for this task reflect this ambiguity.\r\n\r\n        \"\"\"\r\n\r\n        test_data = [1, 2, 3, 4, 5, 6]\r\n        result_data = [(2,), (1,), (0,), (0, -1), (0, -2), (0, -3)]\r\n\r\n        for variant, (iterations, expected) in enumerate(zip(test_data, result_data), start=1):\r\n            alien = Alien(2, 2)\r\n\r\n            with self.subTest(f'variation #{variant}',\r\n                              iterations=iterations,\r\n                              expected=expected):\r\n\r\n                for _ in range(iterations):\r\n                    alien.hit()\r\n\r\n                error_message = (f'Called hit() {iterations} time(s) '\r\n                                 f'on a newly created Alien. The Aliens health '\r\n                                 f'is now {alien.health}, but the tests expected '\r\n                                 f'it to be in {expected} after decrementing 1 health '\r\n                                 f'point {iterations} time(s).')\r\n\r\n                self.assertIn(alien.health, expected, msg=error_message)\r\n\r\n\r\n    @pytest.mark.task(taskno=3)\r\n    def test_alien_is_alive_method(self):\r\n        alien = Alien(0, 1)\r\n\r\n        alive_error = ('Created a new Alien and called hit(). '\r\n                       'The function is_alive() is returning False (dead) '\r\n                       'while alien.health is greater than 0.')\r\n\r\n        dead_error = ('Created a new Alien and called hit(). '\r\n                       'The function is_alive() is returning True (alive) '\r\n                       'while alien.health is less than or equal to 0.')\r\n\r\n        for _ in range(5):\r\n            alien.hit()\r\n            if alien.health > 0:\r\n                self.assertTrue(alien.is_alive(), msg=alive_error)\r\n            else:\r\n                self.assertFalse(alien.is_alive(), msg=dead_error)\r\n\r\n    @pytest.mark.task(taskno=4)\r\n    def test_alien_teleport_method(self):\r\n        alien = Alien(0, 0)\r\n        alien.teleport(-1, -4)\r\n\r\n        error_message = ('Called alien.teleport(-1,-4) on a newly created Alien. '\r\n                         'The Alien was found at position '\r\n                         f'{(alien.x_coordinate, alien.y_coordinate)}, but the '\r\n                         'tests expected it at position (-1, -4).')\r\n\r\n        self.assertEqual((-1, -4), (alien.x_coordinate, alien.y_coordinate), msg=error_message)\r\n\r\n    @pytest.mark.task(taskno=5)\r\n    def test_alien_collision_detection_method(self):\r\n        alien = Alien(7, 3)\r\n        error_message = ('Created a new Alien at (7,3) and called '\r\n                         'alien.collision_detection(Alien(7, 2)). '\r\n                         f'The method returned {alien.collision_detection(Alien(7, 2))}, '\r\n                         'but the tests expected None. ')\r\n\r\n        self.assertIsNone(alien.collision_detection(Alien(7, 2)), msg=error_message)\r\n\r\n\r\n    @pytest.mark.task(taskno=6)\r\n    def test_alien_class_variable(self):\r\n        \"\"\"Test class attribute/variables are identical across instances.\"\"\"\r\n\r\n        alien_one, alien_two = Alien(0, 2), Alien(-6, -1)\r\n        Alien.health = 6\r\n\r\n        created_error_message = ('Created two new Aliens and requested the '\r\n                                 'total_aliens_created attribute for each one. '\r\n                                 f'Received {alien_one.total_aliens_created, alien_two.total_aliens_created} '\r\n                                 f'for total_aliens_created, but the tests expect '\r\n                                 f'the class attributes for each newly created Alien to be identical. ')\r\n\r\n        health_error_message = ('Created two new Aliens and requested the '\r\n                                f'health attribute for each one. Received {alien_one.health, alien_two.health} '\r\n                                'for health, but the tests expect the class '\r\n                                'attributes for each newly created Alien to be identical. ')\r\n\r\n        self.assertEqual(alien_two.total_aliens_created,\r\n                         alien_one.total_aliens_created,\r\n                         msg=created_error_message)\r\n\r\n        self.assertEqual(alien_two.health,\r\n                         alien_one.health,\r\n                         msg=health_error_message)\r\n\r\n    @pytest.mark.task(taskno=6)\r\n    def test_alien_total_aliens_created(self):\r\n        \"\"\"Test total_aliens_created class variable increments upon object instantiation.\"\"\"\r\n\r\n        Alien.total_aliens_created = 0\r\n        aliens = [Alien(-2, 6)]\r\n\r\n        error_message = ('Created a new Alien and called total_aliens_created for it. '\r\n                         f'{aliens[0].total_aliens_created} was returned, but '\r\n                         'the tests expected that total_aliens_created would equal 1.')\r\n\r\n        self.assertEqual(1, aliens[0].total_aliens_created, msg=error_message)\r\n\r\n        aliens.append(Alien(3, 5))\r\n        aliens.append(Alien(-5, -5))\r\n\r\n        def error_text(alien, variable):\r\n            return ('Created two additional Aliens for the session.'\r\n                    f\"Alien number {alien}'s total_aliens_created variable \"\r\n                    f\"is equal to {variable}, but the tests expected all \"\r\n                    'total_aliens_created variables for all instances to be '\r\n                    'equal to number of alien instances created (i.e. 3).')\r\n\r\n        self.assertEqual(3, aliens[0].total_aliens_created, msg=error_text(1, aliens[0]))\r\n        self.assertEqual(3, aliens[1].total_aliens_created, msg=error_text(2, aliens[1]))\r\n        self.assertEqual(3, aliens[2].total_aliens_created, msg=error_text(3, aliens[2]))\r\n\r\n    @pytest.mark.task(taskno=7)\r\n    def test_new_aliens_collection(self):\r\n        \"\"\"Test that the user knows how to create objects themselves.\"\"\"\r\n\r\n        test_data = [(-2, 6), (1, 5), (-4, -3)]\r\n        actual_result = new_aliens_collection(test_data)\r\n\r\n        error_message = \"new_aliens_collection() must return a list of Alien objects.\"\r\n\r\n        for obj in actual_result:\r\n            self.assertIsInstance(obj, Alien, msg=error_message)\r\n\r\n        for position, obj in zip(test_data, actual_result):\r\n            position_error = (f'After calling new_aliens_collection({test_data}), '\r\n                              f'found {obj} initialized to position {(obj.x_coordinate, obj.y_coordinate)}, '\r\n                              f'but the tests expected {obj} to be at position {position} instead.')\r\n\r\n            self.assertEqual(position, (obj.x_coordinate, obj.y_coordinate), msg=position_error)\r\n"
}