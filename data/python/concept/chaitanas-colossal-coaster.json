{
  "concept": "chaitanas-colossal-coaster",
  "docs": {
    "introduction": "# Introduction\r\n\r\nA [`list`][list] is a mutable collection of items in _sequence_.\r\n Like most collections (_see the built-ins [`tuple`][tuple], [`dict`][dict] and [`set`][set]_), lists can hold reference to any (or multiple) data type(s) - including other lists.\r\n Lists can be copied in whole or in part via [slice notation][slice notation] or through the use of `<list>.copy()`.\r\n Like any [sequence][sequence type], elements within `lists` are referenced by `0-based index` number from the left, or `-1-based index` number from the right.\r\n\r\nLists support both [common][common sequence operations] and [mutable][mutable sequence operations] sequence operations such as `min(<list>)`/`max(<list>)`, `<list>.index()`, `<list>.append()` and `<list>.reverse()`.\r\n Elements inside a `list`  can be iterated over using the `for item in <list>` construct.\r\n `for index, item in enumerate(<list>)` can be used when both the element index and element value are needed.\r\n\r\nPython also provides many useful [list-methods][list-methods] for working with lists.\r\n A selection of these `list methods` is covered below.\r\n\r\n\r\nNote that when you manipulate a `list` with a `list-method`, **you alter the list** object that has been passed.\r\n If you do not wish to mutate the original `list`, you will need to at least make a `shallow copy` of it via slice or `<list>.copy()`.\r\n\r\n\r\n## Adding Items\r\n\r\nTo add an item to the end or \"right-hand side\" of an existing list, use `<list>.append(<item>)`:\r\n\r\n```python\r\n>>> numbers = [1, 2, 3]\r\n>>> numbers.append(9)\r\n\r\n>>> numbers\r\n[1, 2, 3, 9]\r\n```\r\n\r\nRather than _appending_, `<list>.insert()` gives you the ability to add the item to a _specific index_ in the list.\r\nIt takes 2 parameters:\r\n\r\n1. the `<index>` at which you want the item to be inserted.\r\n2. the `<item>` to be inserted.\r\n\r\n**Note**: If the given `index` is 0, the item will be added to the start (\"left-hand side\") of the `list`.\r\n If the supplied `index` is greater than the final `index` on the `list`, the item will be added in the final position -- the equivalent of using `<list>.append(<item>)`.\r\n\r\n\r\n```python\r\n>>> numbers = [1, 2, 3]\r\n>>> numbers.insert(0, -2)\r\n\r\n>>> numbers\r\n[-2, 1, 2, 3]\r\n\r\n>>> numbers.insert(1, 0)\r\n\r\n>>> numbers\r\n[-2, 0, 1, 2, 3]\r\n```\r\n\r\n\r\n`<list>.extend(<item>)` can be used to combine an existing list with the elements from another iterable (for example, a `set`, `tuple`, `str`, or `list`).\r\n  The iterable is _unpacked_ and elements are appended in order (_Using `<list>.append(<item>)` in this circumstance would add the entire iterable as a **single item**._).\r\n\r\n\r\n```python\r\n>>> numbers = [1, 2, 3]\r\n>>> other_numbers = [5, 6, 7]\r\n\r\n>>> numbers.extend(other_numbers)\r\n\r\n>>> numbers\r\n[1, 2, 3, 5, 6, 7]\r\n\r\n>>> numbers.extend([8, 9])\r\n\r\n>>> numbers\r\n[1, 2, 3, 5, 6, 7, 8, 9]\r\n\r\n>>> numbers.append([8,9])\r\n\r\n>>> numbers\r\n[1, 2, 3, 5, 6, 7, 8, 9, [8, 9]]\r\n```\r\n\r\n\r\n## Removing Items\r\n\r\nTo delete an item from a list use `<list>.remove(<item>)`, passing the item to be removed as an argument.\r\n `<list>.remove(<item>)` will throw a `ValueError` if the item is not present in the `list`.\r\n\r\n\r\n```python\r\n>>> numbers = [1, 2, 3]\r\n>>> numbers.remove(2)\r\n\r\n>>> numbers\r\n[1, 3]\r\n\r\n# Trying to remove a value that is not in the list throws a ValueError\r\n>>> numbers.remove(0)\r\nValueError: list.remove(x): x not in list\r\n```\r\n\r\n\r\nAlternatively, using the `<list>.pop(<index>)` method will both remove **and** `return` an element for use.\r\n\r\n\r\n`<list>.pop(<index>)` takes one optional parameter: the `index` of the item to be removed and returned.\r\n If the (optional) `index` argument is not specified, the final element of the `list` will be removed and returned.\r\n If the `index` specified is higher than the final item `index`, an `IndexError` is raised.\r\n\r\n\r\n```python\r\n>>> numbers = [1, 2, 3]\r\n\r\n>>> numbers.pop(0)\r\n1\r\n\r\n>>> numbers\r\n[2, 3]\r\n\r\n>>> numbers.pop()\r\n3\r\n\r\n>>> numbers\r\n[2]\r\n\r\n>>> numbers.pop(1)\r\nTraceback (most recent call last):\r\n  File \"<stdin>\", line 1, in <module>\r\nIndexError: pop index out of range\r\n```\r\n\r\nAll elements can be removed from a `list` with `list.clear()`. It doesn't take any parameters.\r\n\r\n```python\r\n>>> numbers = [1, 2, 3]\r\n>>> numbers.clear()\r\n\r\n>>> numbers\r\n[]\r\n```\r\n\r\n## Reversing and reordering\r\n\r\nThe `<list>.reverse()` method will reverse the order of elements **in-place**.\r\n\r\n\r\n```python\r\n>>> numbers = [1, 2, 3]\r\n>>> numbers.reverse()\r\n\r\n>>> numbers\r\n[3, 2, 1]\r\n```\r\n\r\n\r\nA list can be re-ordered _**in place**_ with the help of [`<list>.sort()`][sort].\r\nDefault sort order is _ascending_ from the left.\r\nThe Python docs offer [additional tips and techniques for sorting][sorting how to].\r\n\r\n~~~~exercism/note\r\n From 2002 to 2022, Python used an algorithm called [`Timsort`][timsort] internally to arrange lists, but switched to [`Powersort`][powersort] from `Python 3.11` onward.\r\n\r\n[powersort]: https://www.wild-inter.net/publications/munro-wild-2018\r\n[timsort]: https://en.wikipedia.org/wiki/Timsort\r\n~~~~\r\n\r\n\r\n```python\r\n>>> names = [\"Tony\", \"Natasha\", \"Thor\", \"Bruce\"]\r\n\r\n# The default sort order is *ascending*.\r\n>>> names.sort()\r\n\r\n>>> names\r\n[\"Bruce\", \"Natasha\", \"Thor\", \"Tony\"]\r\n```\r\n\r\nIf a _descending_ order is desired, pass the `reverse=True` argument:\r\n\r\n```python\r\n>>> names = [\"Tony\", \"Natasha\", \"Thor\", \"Bruce\"]\r\n>>> names.sort(reverse=True)\r\n\r\n>>> names\r\n[\"Tony\", \"Thor\", \"Natasha\", \"Bruce\"]\r\n```\r\n\r\nFor cases where mutating the original list is undesirable, the built-in [`sorted(<iterable>)`][sorted] function can be used to return a sorted **copy**.\r\n\r\n\r\n```python\r\n>>> names = [\"Tony\", \"Natasha\", \"Thor\", \"Bruce\"]\r\n\r\n>>> sorted(names)\r\n['Bruce', 'Natasha', 'Thor', 'Tony']\r\n```\r\n\r\n\r\n## Occurrences of an item in a list\r\n\r\nThe number of occurrences of an element in a list can be calculated with the help of `list.count(<item>)`.\r\n It takes the `item` to be counted as its argument and returns the total number of times that element appears in the `list`.\r\n\r\n\r\n```python\r\n>>> items = [1, 4, 7, 8, 2, 9, 2, 1, 1, 0, 4, 3]\r\n\r\n>>> items.count(1)\r\n3\r\n```\r\n\r\n## Finding the index of items\r\n\r\n`<list>.index(<item>)` will return the `index` number of the _first occurrence_ of an item passed in.\r\n If there are no occurrences, a `ValueError` is raised.\r\n If the exact position of an item isn't needed, the built-in `in` operator is more efficient for checking if a list contains a given value.\r\n\r\n\r\nIndexing is zero-based from the left, so the position of the \"first\" item is `0`.\r\nIndexing will also work from the right, beginning with `-1`.\r\n\r\n\r\n```python\r\n>>> items = [7, 4, 1, 0, 2, 5]\r\n\r\n>>> items.index(4)\r\n1\r\n\r\n>>> items.index(10)\r\nValueError: 10 is not in list\r\n```\r\n\r\n`start` and `end` indices can also be provided to narrow the search to a specific section of the `list`:\r\n\r\n```python\r\n>>> names = [\"Tina\", \"Leo\", \"Thomas\", \"Tina\", \"Emily\", \"Justin\"]\r\n\r\n>>> names.index(\"Tina\")\r\n0\r\n\r\n>>> names.index(\"Tina\", 2, 5)\r\n3\r\n```\r\n\r\n[common sequence operations]: https://docs.python.org/3/library/stdtypes.html#common-sequence-operations\r\n[dict]: https://docs.python.org/3/library/stdtypes.html#dict\r\n[list-methods]: https://docs.python.org/3/tutorial/datastructures.html#more-on-lists\r\n[list]: https://docs.python.org/3/library/stdtypes.html#list\r\n[mutable sequence operations]: https://docs.python.org/3/library/stdtypes.html#typesseq-mutable\r\n[sequence type]: https://docs.python.org/3/library/stdtypes.html#sequence-types-list-tuple-range\r\n[set]: https://docs.python.org/3/library/stdtypes.html#set\r\n[slice notation]: https://docs.python.org/3/reference/expressions.html#slicings\r\n[sort]: https://docs.python.org/3/library/stdtypes.html#list.sort\r\n[sorted]: https://docs.python.org/3/library/functions.html#sorted\r\n[sorting how to]: https://docs.python.org/3/howto/sorting.html\r\n[tuple]: https://docs.python.org/3/library/stdtypes.html#tuple\r\n",
    "hints": "# General\r\n\r\n- Make sure you have a good understanding of how to create and update lists.\r\n- The Python [documentation on `lists`][python lists] can be really helpful.\r\n- The Python [tutorial section on `lists`][more on lists] is also a good resource.\r\n\r\n## 1. Add Me to the queue\r\n\r\n- An `if-else` statement can help you find which ticket type you are dealing with.\r\n- You can then `append()` the person to the queue based on the ticket type.\r\n\r\n## 2. Where are my friends\r\n\r\n- You need to find the `index()` of the friend name from the queue.\r\n\r\n## 3. Can I please join them?\r\n\r\n- Since you know the `index()`, you can `insert()` the friend into the queue at that point.\r\n\r\n## 4. Mean person in the queue\r\n\r\n- You know the mean persons name, so you can `remove()` them from the queue.\r\n\r\n## 5. Namefellows\r\n\r\n-  `count()`-ing the occurrences of the `name` in the queue could be a good strategy here.\r\n\r\n## 6. Remove the last person\r\n\r\n- Although you could `remove()` the person by name, `pop()`-ing them out might be quicker.\r\n\r\n## 7. Sort the Queue List\r\n\r\n- Don't forget that You need to avoid mutating the queue and losing its original order.\r\n- Once you have a `copy()`, `sort()`-ing should be straightforward.\r\n- We're looking for an _ascending_ sort, or _alphabetical from a-z_.\r\n\r\n[python lists]: https://docs.python.org/3.11/library/stdtypes.html#list\r\n[more on lists]: https://docs.python.org/3.11/tutorial/datastructures.html#more-on-lists\r\n",
    "instructions": "# Instructions\r\n\r\nChaitana owns a very popular theme park.\r\n She only has one ride in the very center of beautifully landscaped grounds: The Biggest Roller Coaster in the World(TM).\r\n Although there is only this one attraction, people travel from all over the world and stand in line for hours for the opportunity to ride Chaitana's hypercoaster.\r\n\r\nThere are two queues for this ride, each represented as a `list`:\r\n\r\n1. Normal Queue\r\n2. Express Queue (_also known as the Fast-track_) - where people pay extra for priority access.\r\n\r\n\r\nYou have been asked to write some code to better manage the guests at the park.\r\n You need to implement the following functions as soon as possible before the guests (and your boss, Chaitana!) get cranky.\r\n Make sure you read carefully.\r\n Some tasks ask that you change or update the existing queue, while others ask you to make a copy of it.\r\n\r\n\r\n## 1. Add me to the queue\r\n\r\nDefine the `add_me_to_the_queue()` function that takes 4 parameters `<express_queue>, <normal_queue>, <ticket_type>, <person_name>` and returns the appropriate queue updated with the person's name.\r\n\r\n\r\n1. `<ticket_type>` is an `int` with 1 == express_queue and 0 == normal_queue.\r\n2. `<person_name>` is the name (as a `str`) of the person to be added to the respective queue.\r\n\r\n\r\n```python\r\n>>> add_me_to_the_queue(express_queue=[\"Tony\", \"Bruce\"], normal_queue=[\"RobotGuy\", \"WW\"], ticket_type=1, person_name=\"RichieRich\")\r\n...\r\n[\"Tony\", \"Bruce\", \"RichieRich\"]\r\n\r\n>>> add_me_to_the_queue(express_queue=[\"Tony\", \"Bruce\"], normal_queue=[\"RobotGuy\", \"WW\"], ticket_type=0, person_name=\"HawkEye\")\r\n....\r\n[\"RobotGuy\", \"WW\", \"HawkEye\"]\r\n```\r\n\r\n## 2. Where are my friends?\r\n\r\nOne person arrived late at the park but wants to join the queue where their friends are waiting.\r\n But they have no idea where their friends are standing and there isn't any phone reception to call them.\r\n\r\nDefine the `find_my_friend()` function that takes 2 parameters `queue` and  `friend_name` and returns the position in the queue of the person's name.\r\n\r\n\r\n1. `<queue>` is the `list` of people standing in the queue.\r\n2. `<friend_name>` is the name of the friend whose index (place in the queue) you need to find.\r\n\r\nRemember:  Indexing starts at 0 from the left, and -1 from the right.\r\n\r\n\r\n```python\r\n>>> find_my_friend(queue=[\"Natasha\", \"Steve\", \"T'challa\", \"Wanda\", \"Rocket\"], friend_name=\"Steve\")\r\n...\r\n1\r\n```\r\n\r\n\r\n## 3. Can I please join them?\r\n\r\nNow that their friends have been found (in task #2 above), the late arriver would like to join them at their place in the queue.\r\nDefine the `add_me_with_my_friends()` function that takes 3 parameters `queue`, `index`, and  `person_name`.\r\n\r\n\r\n1. `<queue>` is the `list` of people standing in the queue.\r\n2. `<index>` is the position at which the new person should be added.\r\n3. `<person_name>` is the name of the person to add at the index position.\r\n\r\nReturn the queue updated with the late arrivals name.\r\n\r\n\r\n```python\r\n>>> add_me_with_my_friends(queue=[\"Natasha\", \"Steve\", \"T'challa\", \"Wanda\", \"Rocket\"], index=1, person_name=\"Bucky\")\r\n...\r\n[\"Natasha\", \"Bucky\", \"Steve\", \"T'challa\", \"Wanda\", \"Rocket\"]\r\n```\r\n\r\n## 4. Mean person in the queue\r\n\r\nYou just heard from the queue that there is a really mean person shoving, shouting, and making trouble.\r\n You need to throw that miscreant out for bad behavior!\r\n\r\n\r\nDefine the `remove_the_mean_person()` function that takes 2 parameters `queue` and `person_name`.\r\n\r\n\r\n1. `<queue>` is the `list` of people standing in the queue.\r\n2. `<person_name>` is the name of the person that needs to be kicked out.\r\n\r\nReturn the queue updated without the mean person's name.\r\n\r\n```python\r\n>>> remove_the_mean_person(queue=[\"Natasha\", \"Steve\", \"Eltran\", \"Wanda\", \"Rocket\"], person_name=\"Eltran\")\r\n...\r\n[\"Natasha\", \"Steve\", \"Wanda\", \"Rocket\"]\r\n```\r\n\r\n\r\n## 5. Namefellows\r\n\r\nYou may not have seen two unrelated people who look exactly the same, but you have _definitely_ seen unrelated people with the exact same name (_namefellows_)!\r\n Today, it looks like there are a lot of them in attendance.\r\n  You want to know how many times a particular name occurs in the queue.\r\n\r\nDefine the `how_many_namefellows()` function that takes 2 parameters `queue` and  `person_name`.\r\n\r\n1. `<queue>` is the `list` of people standing in the queue.\r\n2. `<person_name>` is the name you think might occur more than once in the queue.\r\n\r\n\r\nReturn the number of occurrences of `person_name`, as an `int`.\r\n\r\n\r\n```python\r\n>>> how_many_namefellows(queue=[\"Natasha\", \"Steve\", \"Eltran\", \"Natasha\", \"Rocket\"], person_name=\"Natasha\")\r\n...\r\n2\r\n```\r\n\r\n## 6. Remove the last person\r\n\r\nSadly, it's overcrowded at the park today and you need to remove the last person in the normal line (_you will give them a voucher to come back in the fast-track on another day_).\r\n You will have to define the function `remove_the_last_person()` that takes 1 parameter `queue`, which is the list of people standing in the queue.\r\n\r\nYou should update the `list` and also `return` the name of the person who was removed, so you can write them a voucher.\r\n\r\n\r\n```python\r\n>>> remove_the_last_person(queue=[\"Natasha\", \"Steve\", \"Eltran\", \"Natasha\", \"Rocket\"])\r\n...\r\n'Rocket'\r\n```\r\n\r\n## 7. Sort the Queue List\r\n\r\nFor administrative purposes, you need to get all the names in a given queue in alphabetical order.\r\n\r\n\r\nDefine the `sorted_names()` function that takes 1 argument,  `queue`, (the `list` of people standing in the queue), and returns a `sorted` copy of the `list`.\r\n\r\n\r\n```python\r\n>>> sorted_names(queue=[\"Natasha\", \"Steve\", \"Eltran\", \"Natasha\", \"Rocket\"])\r\n...\r\n['Eltran', 'Natasha', 'Natasha', 'Rocket', 'Steve']\r\n```\r\n",
    "design": "# Design\r\n\r\n## Goal\r\n\r\nThis concept exercise should make the student aware of a selection of `list methods` for modifying and manipulating `lists`.\r\n\r\n## Learning objectives\r\n\r\n- Understand when it is appropriate to use `list methods`\r\n- Understand that most `list methods` mutate the original `list` and **do not** return a new or copied list.\r\n- Use one or more of the below methods to alter a list:\r\n    - Add a single item to the end of a list with the `append()`\r\n    - Remove all items from a list with the `clear()` method\r\n    - Insert an item in a list with the `insert()` method\r\n    - Remove the item at the given index with the `pop()` method\r\n    - Remove an item from a list with the `remove()` method\r\n    - Reverse a list with the `reverse()` method\r\n    - Sort items of a list with the `sort()` method\r\n    - Return a shallow copy of a list with the `copy()` method\r\n    - Return the number of times an item occurs in a `list` with the `count()` method\r\n    - Add all items from another iterable to the end of a list with the `extend()` method\r\n    - Return the index of an item in a list with the `index()` method\r\n- Understand which data in a `list` can be sorted and/or compared\r\n\r\n## Out of scope\r\n\r\n- Performance considerations\r\n\r\n## Concepts\r\n\r\n- iterables\r\n- lists\r\n- list methods\r\n\r\n## Prerequisites\r\n\r\n- basics\r\n- booleans\r\n- methods\r\n- object\r\n- iterables\r\n\r\n## Resources\r\n\r\n- [Python list methods - Python language reference](https://docs.python.org/3/tutorial/datastructures.html#more-on-lists)\r\n- [Python list methods on python-ds](http://www.python-ds.com/python-3-list-methods)\r\n"
  },
  "config": {
    "authors": [
      "mohanrajanr",
      "BethanyG"
    ],
    "contributors": [
      "BethanyG",
      "valentin-p",
      "pranasziaukas"
    ],
    "files": {
      "solution": [
        "list_methods.py"
      ],
      "test": [
        "list_methods_test.py"
      ],
      "exemplar": [
        ".meta/exemplar.py"
      ]
    },
    "icon": "spiral-matrix",
    "blurb": "Learn useful list methods helping Chaitana manage the lines for her colossal roller coaster."
  },
  "starter_code": "\"\"\"Functions to manage and organize queues at Chaitana's roller coaster.\"\"\"\r\n\r\n\r\ndef add_me_to_the_queue(express_queue, normal_queue, ticket_type, person_name):\r\n    \"\"\"Add a person to the 'express' or 'normal' queue depending on the ticket number.\r\n\r\n    :param express_queue: list - names in the Fast-track queue.\r\n    :param normal_queue: list - names in the normal queue.\r\n    :param ticket_type: int - type of ticket. 1 = express, 0 = normal.\r\n    :param person_name: str - name of person to add to a queue.\r\n    :return: list - the (updated) queue the name was added to.\r\n    \"\"\"\r\n\r\n    pass\r\n\r\n\r\ndef find_my_friend(queue, friend_name):\r\n    \"\"\"Search the queue for a name and return their queue position (index).\r\n\r\n    :param queue: list - names in the queue.\r\n    :param friend_name: str - name of friend to find.\r\n    :return: int - index at which the friends name was found.\r\n    \"\"\"\r\n\r\n    pass\r\n\r\n\r\ndef add_me_with_my_friends(queue, index, person_name):\r\n    \"\"\"Insert the late arrival's name at a specific index of the queue.\r\n\r\n    :param queue: list - names in the queue.\r\n    :param index: int - the index at which to add the new name.\r\n    :param person_name: str - the name to add.\r\n    :return: list - queue updated with new name.\r\n    \"\"\"\r\n\r\n    pass\r\n\r\n\r\ndef remove_the_mean_person(queue, person_name):\r\n    \"\"\"Remove the mean person from the queue by the provided name.\r\n\r\n    :param queue: list - names in the queue.\r\n    :param person_name: str - name of mean person.\r\n    :return: list - queue update with the mean persons name removed.\r\n    \"\"\"\r\n\r\n    pass\r\n\r\n\r\ndef how_many_namefellows(queue, person_name):\r\n    \"\"\"Count how many times the provided name appears in the queue.\r\n\r\n    :param queue: list - names in the queue.\r\n    :param person_name: str - name you wish to count or track.\r\n    :return: int - the number of times the name appears in the queue.\r\n    \"\"\"\r\n\r\n    pass\r\n\r\n\r\ndef remove_the_last_person(queue):\r\n    \"\"\"Remove the person in the last index from the queue and return their name.\r\n\r\n    :param queue: list - names in the queue.\r\n    :return: str - name that has been removed from the end of the queue.\r\n    \"\"\"\r\n\r\n    pass\r\n\r\n\r\ndef sorted_names(queue):\r\n    \"\"\"Sort the names in the queue in alphabetical order and return the result.\r\n\r\n    :param queue: list - names in the queue.\r\n    :return: list - copy of the queue in alphabetical order.\r\n    \"\"\"\r\n\r\n    pass\r\n",
  "exemplar_code": "\"\"\"Functions to manage and organize queues at Chaitana's roller coaster.\"\"\"\r\n\r\n\r\ndef add_me_to_the_queue(express_queue, normal_queue, ticket_type, person_name):\r\n    \"\"\"Add a person to the 'express' or 'normal' queue depending on the ticket number.\r\n\r\n    :param express_queue: list - names in the Fast-track queue.\r\n    :param normal_queue: list - names in the normal queue.\r\n    :param ticket_type: int - type of ticket. 1 = express, 0 = normal.\r\n    :param person_name: str - name of person to add to a queue.\r\n    :return: list - the (updated) queue the name was added to.\r\n    \"\"\"\r\n\r\n    result = express_queue if ticket_type == 1 else normal_queue\r\n    result.append(person_name)\r\n    return result\r\n\r\n\r\ndef find_my_friend(queue, friend_name):\r\n    \"\"\"Search the queue for a name and return their queue position (index).\r\n\r\n    :param queue: list - names in the queue.\r\n    :param friend_name: str - name of friend to find.\r\n    :return: int - index at which the friends name was found.\r\n    \"\"\"\r\n\r\n    return queue.index(friend_name)\r\n\r\n\r\ndef add_me_with_my_friends(queue, index, person_name):\r\n    \"\"\"Insert the late arrival's name at a specific index of the queue.\r\n\r\n    :param queue: list - names in the queue.\r\n    :param index: int - the index at which to add the new name.\r\n    :param person_name: str - the name to add.\r\n    :return: list - queue updated with new name.\r\n    \"\"\"\r\n\r\n    queue.insert(index, person_name)\r\n    return queue\r\n\r\n\r\ndef remove_the_mean_person(queue, person_name):\r\n    \"\"\"Remove the mean person from the queue by the provided name.\r\n\r\n    :param queue: list - names in the queue.\r\n    :param person_name: str - name of mean person.\r\n    :return: list - queue update with the mean persons name removed.\r\n    \"\"\"\r\n\r\n    queue.remove(person_name)\r\n    return queue\r\n\r\n\r\ndef how_many_namefellows(queue, person_name):\r\n    \"\"\"Count how many times the provided name appears in the queue.\r\n\r\n    :param queue: list - names in the queue.\r\n    :param person_name: str - name you wish to count or track.\r\n    :return: int - the number of times the name appears in the queue.\r\n    \"\"\"\r\n\r\n    return queue.count(person_name)\r\n\r\n\r\ndef remove_the_last_person(queue):\r\n    \"\"\"Remove the person in the last index from the queue and return their name.\r\n\r\n    :param queue: list - names in the queue.\r\n    :return: str - name that has been removed from the end of the queue.\r\n    \"\"\"\r\n\r\n    return queue.pop()\r\n\r\n\r\ndef sorted_names(queue):\r\n    \"\"\"Sort the names in the queue in alphabetical order and return the result.\r\n\r\n    :param queue: list - names in the queue.\r\n    :return: list - copy of the queue in alphabetical order.\r\n    \"\"\"\r\n\r\n    new_queue = queue[:]\r\n    new_queue.sort()\r\n    return new_queue\r\n",
  "tests": "import unittest\r\nfrom copy import deepcopy\r\nimport pytest\r\n\r\n\r\nfrom list_methods import (\r\n    add_me_to_the_queue,\r\n    find_my_friend,\r\n    add_me_with_my_friends,\r\n    remove_the_mean_person,\r\n    how_many_namefellows,\r\n    remove_the_last_person,\r\n    sorted_names,\r\n)\r\n\r\n\r\nclass ListMethodsTest(unittest.TestCase):\r\n    @pytest.mark.task(taskno=1)\r\n    def test_add_me_to_the_queue(self):\r\n        test_data = [\r\n        ((['Tony', 'Bruce'], ['RobotGuy', 'WW'], 0, 'HawkEye'), ['RobotGuy', 'WW', 'HawkEye']),\r\n        ((['Tony', 'Bruce'], ['RobotGuy', 'WW'], 1, 'RichieRich'), ['Tony', 'Bruce', 'RichieRich']),\r\n        ((['Agatha', 'Pepper', 'Valkyrie'], ['Drax', 'Nebula'], 1, 'Okoye'), ['Agatha', 'Pepper', 'Valkyrie', 'Okoye']),\r\n        ((['Agatha', 'Pepper', 'Valkyrie'], ['Drax', 'Nebula'], 0, 'Gamora'), ['Drax', 'Nebula', 'Gamora']),\r\n        ]\r\n\r\n        for variant, (params, expected) in enumerate(test_data, start=1):\r\n            # Deepcopy() is needed here because the task expects the input lists to be mutated.\r\n            # That mutation wrecks havoc with the verification and error messaging.\r\n            express_queue, normal_queue, ticket_type, person_name = deepcopy(params)\r\n\r\n            with self.subTest(f'variation #{variant}', params=params, expected=expected):\r\n                actual_result = add_me_to_the_queue(*params)\r\n\r\n                error_message = (\r\n                    f'\\nCalled add_me_to_the_queue{express_queue, normal_queue, ticket_type, person_name}.\\n'\r\n                    f'The function returned {actual_result},\\n'\r\n                    f' but the tests expected {expected} after {person_name} was added.')\r\n\r\n                self.assertEqual(actual_result, expected, msg=error_message)\r\n\r\n    @pytest.mark.task(taskno=1)\r\n    def test_add_me_to_the_queue_validate_queue(self):\r\n        test_data = [\r\n        ((['Tony', 'Bruce'], ['RobotGuy', 'WW'], 0, 'HawkEye'), ['RobotGuy', 'WW', 'HawkEye']),\r\n        ((['Tony', 'Bruce'], ['RobotGuy', 'WW'], 1, 'RichieRich'), ['Tony', 'Bruce', 'RichieRich']),\r\n        ((['Agatha', 'Pepper', 'Valkyrie'], ['Drax', 'Nebula'], 1, 'Okoye'), ['Agatha', 'Pepper', 'Valkyrie', 'Okoye']),\r\n        ((['Agatha', 'Pepper', 'Valkyrie'], ['Drax', 'Nebula'], 0, 'Gamora'), ['Drax', 'Nebula', 'Gamora']),\r\n        ]\r\n\r\n        for variant, (params, expected) in enumerate(test_data, start=1):\r\n            # Deepcopy() is needed here because the task expects the input lists to be mutated.\r\n            # That mutation wrecks havoc with the verification and error messaging.\r\n            express_queue, normal_queue, ticket_type, person_name = deepcopy(params)\r\n            express, normal, ticket, name = params\r\n\r\n            with self.subTest(f'variation #{variant}',\r\n                              express=express, normal=normal,\r\n                              ticket=ticket, name=name, expected=expected):\r\n\r\n                actual_result = add_me_to_the_queue(express, normal, ticket, name)\r\n\r\n                if type == 1:\r\n                    error_message = (\r\n                            f'\\nCalled add_me_to_the_queue{express_queue, normal_queue, ticket_type, person_name}.\\n'\r\n                            f'The queue == {express}, but the tests expected\\n'\r\n                            f'queue == {expected} after {person_name} was added.'\r\n                    )\r\n\r\n                    self.assertIs(actual_result, express, msg=error_message)\r\n\r\n                if type == 0:\r\n                    error_message = (\r\n                            f'\\nCalled add_me_to_the_queue{express_queue, normal_queue, ticket_type, person_name}.\\n'\r\n                            f'The queue == {normal}, but the tests expected \\n'\r\n                            f'queue == {expected} after {person_name} was added.'\r\n                    )\r\n\r\n                    self.assertIs(actual_result, normal, msg=error_message)\r\n\r\n    @pytest.mark.task(taskno=2)\r\n    def test_find_my_friend(self):\r\n        test_data = [\r\n                (['Natasha', 'Steve', 'Tchalla', 'Wanda', 'Rocket'], 'Natasha'),\r\n                (['Natasha', 'Steve', 'Tchalla', 'Wanda', 'Rocket'], 'Steve'),\r\n                (['Natasha', 'Steve', 'Tchalla', 'Wanda', 'Rocket'], 'Rocket'),\r\n        ]\r\n\r\n        result_data = (0,1,4)\r\n\r\n        for variant, (params, expected) in enumerate(zip(test_data, result_data), start=1):\r\n            with self.subTest(f'variation #{variant}', params=params, expected=expected):\r\n                actual_result = find_my_friend(*params)\r\n                error_message = (\r\n                        f'\\nCalled find_my_friend{params}.\\n'\r\n                        f'The function returned {actual_result}, but\\n'\r\n                        f'the tests expected {expected} when looking for\\n'\r\n                        f'{params[-1]} in the queue.'\r\n                )\r\n\r\n                self.assertIs(actual_result, expected, msg=error_message)\r\n\r\n    @pytest.mark.task(taskno=3)\r\n    def test_add_me_with_my_friends(self):\r\n        test_data = [\r\n                (['Natasha', 'Steve', 'Tchalla', 'Wanda', 'Rocket'], 0, 'Bucky'),\r\n                (['Natasha', 'Steve', 'Tchalla', 'Wanda', 'Rocket'], 1, 'Bucky'),\r\n                (['Natasha', 'Steve', 'Tchalla', 'Wanda', 'Rocket'], 5, 'Bucky'),\r\n        ]\r\n\r\n        result_data = [\r\n                ['Bucky', 'Natasha', 'Steve', 'Tchalla', 'Wanda', 'Rocket'],\r\n                ['Natasha', 'Bucky', 'Steve', 'Tchalla', 'Wanda', 'Rocket'],\r\n                ['Natasha', 'Steve', 'Tchalla', 'Wanda', 'Rocket', 'Bucky'],\r\n        ]\r\n\r\n        for variant, (params, expected) in enumerate(zip(test_data, result_data), start=1):\r\n            # Deepcopy() is needed here because the task expects the input lists to be mutated.\r\n            # That mutation wrecks havoc with the verification and error messaging.\r\n            queue, index, person_name = deepcopy(params)\r\n\r\n            with self.subTest(f'variation #{variant}', params=params, expected=expected):\r\n\r\n                actual_result = add_me_with_my_friends(*params)\r\n                error_message = (\r\n                        f'\\nCalled add_me_with_my_friends{queue, index, person_name}.\\n'\r\n                        f'The function returned {actual_result}, but\\n'\r\n                        f'the tests expected {expected} when adding\\n'\r\n                        f'{person_name} to position {index} in the queue.'\r\n                )\r\n\r\n                self.assertEqual(actual_result, expected, msg=error_message)\r\n\r\n    @pytest.mark.task(taskno=3)\r\n    def test_add_me_with_my_friends_validate_queue(self):\r\n        test_data = [\r\n                (['Natasha', 'Steve', 'Tchalla', 'Wanda', 'Rocket'], 0, 'Bucky'),\r\n                (['Natasha', 'Steve', 'Tchalla', 'Wanda', 'Rocket'], 1, 'Bucky'),\r\n                (['Natasha', 'Steve', 'Tchalla', 'Wanda', 'Rocket'], 5, 'Bucky'),\r\n        ]\r\n\r\n        result_data = [\r\n                ['Bucky', 'Natasha', 'Steve', 'Tchalla', 'Wanda', 'Rocket'],\r\n                ['Natasha', 'Bucky', 'Steve', 'Tchalla', 'Wanda', 'Rocket'],\r\n                ['Natasha', 'Steve', 'Tchalla', 'Wanda', 'Rocket', 'Bucky'],\r\n        ]\r\n\r\n        for variant, (params, expected) in enumerate(zip(test_data, result_data), start=1):\r\n            # Deepcopy() is needed here because the task expects the input lists to be mutated.\r\n            # That mutation wrecks havoc with the verification and error messaging.\r\n            start_queue, add_index, person_name = deepcopy(params)\r\n            queue, _, _ = params\r\n\r\n            with self.subTest(f'variation #{variant}', params=params, expected=expected):\r\n                actual_result = add_me_with_my_friends(*params)\r\n                error_message = (\r\n                        f'\\nCalled add_me_with_my_friends{start_queue, add_index, person_name}.\\n'\r\n                        f'The function returned {actual_result},\\n'\r\n                        'but the original queue was unmodified. The tests expected the \\n'\r\n                        f'*original* queue to be modified by adding \"{person_name}\".'\r\n                )\r\n\r\n                self.assertIs(actual_result, queue, msg=error_message)\r\n\r\n    @pytest.mark.task(taskno=4)\r\n    def test_remove_the_mean_person(self):\r\n        test_data = [\r\n                (['Natasha', 'Steve', 'Ultron', 'Wanda', 'Rocket'], 'Ultron'),\r\n                (['Natasha', 'Steve', 'Wanda', 'Rocket', 'Ultron'], 'Rocket'),\r\n                (['Ultron', 'Natasha', 'Steve', 'Wanda', 'Rocket'], 'Steve'),\r\n        ]\r\n\r\n        result_data = [\r\n                ['Natasha', 'Steve', 'Wanda', 'Rocket'],\r\n                ['Natasha', 'Steve', 'Wanda', 'Ultron'],\r\n                ['Ultron', 'Natasha', 'Wanda', 'Rocket'],\r\n        ]\r\n\r\n        for variant, (params, expected) in enumerate(zip(test_data, result_data), start=1):\r\n\r\n            # Deepcopy() is needed here because the task expects the input lists to be mutated.\r\n            # That mutation wrecks havoc with the verification and error messaging.\r\n            start_queue, person_name = deepcopy(params)\r\n\r\n            with self.subTest(f'variation #{variant}', params=params, expected=expected):\r\n                actual_result = remove_the_mean_person(*params)\r\n                error_message = (\r\n                        f'\\nCalled remove_the_mean_person{start_queue, person_name}.\\n'\r\n                        f'The function returned {actual_result}, but\\n'\r\n                        f'the tests expected {expected} when removing\\n'\r\n                        f'{person_name} from the queue.'\r\n                )\r\n\r\n                self.assertEqual(actual_result, expected, msg=error_message)\r\n\r\n    @pytest.mark.task(taskno=4)\r\n    def test_remove_the_mean_person_validate_queue(self):\r\n        test_data = [\r\n                (['Natasha', 'Steve', 'Ultron', 'Wanda', 'Rocket'], 'Ultron'),\r\n                (['Natasha', 'Steve', 'Wanda', 'Rocket', 'Ultron'], 'Rocket'),\r\n                (['Ultron', 'Natasha', 'Steve', 'Wanda', 'Rocket'], 'Steve'),\r\n        ]\r\n\r\n        result_data = [\r\n                ['Natasha', 'Steve', 'Wanda', 'Rocket'],\r\n                ['Natasha', 'Steve', 'Wanda', 'Ultron'],\r\n                ['Ultron', 'Natasha', 'Wanda', 'Rocket'],\r\n        ]\r\n\r\n\r\n        for variant, (params, expected) in enumerate(zip(test_data, result_data), start=1):\r\n\r\n            # Deepcopy() is needed here because the task expects the input lists to be mutated.\r\n            # That mutation wrecks havoc with the verification and error messaging.\r\n            start_queue, person_name = deepcopy(params)\r\n            queue, _ = params\r\n\r\n            with self.subTest(f'variation #{variant}', params=params, expected=expected):\r\n                actual_result = remove_the_mean_person(*params)\r\n                error_message = (\r\n                        f'\\nCalled remove_the_mean_person{start_queue, person_name}.\\n'\r\n                        f'The function returned {actual_result}, queue == {queue}.\\n'\r\n                        f'But the tests expected queue == {expected} when removing\\n'\r\n                        f'{person_name}.'\r\n                )\r\n\r\n                self.assertIs(actual_result, queue, msg=error_message)\r\n\r\n\r\n    @pytest.mark.task(taskno=5)\r\n    def test_how_many_namefellows(self):\r\n        test_data = [(['Natasha', 'Steve', 'Ultron', 'Natasha', 'Rocket'], 'Bucky'),\r\n                     (['Natasha', 'Steve', 'Ultron', 'Rocket'], 'Natasha'),\r\n                     (['Natasha', 'Steve', 'Ultron', 'Natasha', 'Rocket'], 'Natasha')]\r\n\r\n        result_data = (0,1,2)\r\n\r\n        for variant, (params, expected) in enumerate(zip(test_data, result_data), start=1):\r\n            with self.subTest(f'variation #{variant}', params=params, expected=expected):\r\n                actual_result = how_many_namefellows(*params)\r\n\r\n                error_message = (f'Called how_many_namefellows{params}. '\r\n                                 f'The function returned {actual_result}, but '\r\n                                 f'The tests expected {expected} when counting '\r\n                                 f'namefellows in the queue for {params[-1]}.')\r\n\r\n                self.assertIs(actual_result, expected, msg=error_message)\r\n\r\n    @pytest.mark.task(taskno=6)\r\n    def test_remove_the_last_person(self):\r\n        test_data = [\r\n            (['Natasha', 'Steve', 'Ultron', 'Natasha', 'Rocket'], ['Natasha', 'Steve', 'Ultron', 'Natasha'], 'Rocket'),\r\n            (['Wanda', 'Natasha', 'Steve', 'Rocket', 'Ultron'], ['Wanda', 'Natasha', 'Steve', 'Rocket'], 'Ultron'),\r\n            (['Steve', 'Wanda', 'Rocket', 'Ultron', 'Natasha'], ['Steve', 'Wanda', 'Rocket', 'Ultron'], 'Natasha')\r\n        ]\r\n        for variant, (queue, modified, expected) in enumerate(test_data, start=1):\r\n            with self.subTest(f'variation #{variant}', queue=queue, modified=modified, expected=expected):\r\n\r\n                # Deepcopy() is needed here because the task expects the input lists to be mutated.\r\n                # That mutation wrecks havoc with the verification and error messaging.\r\n                unmodified_queue = deepcopy(queue)\r\n                expected_result = expected\r\n                actual_result = remove_the_last_person(queue)\r\n                expected_queue = modified\r\n\r\n                error_message = (f'\\nCalled remove_the_last_person({unmodified_queue}).\\n'\r\n                                 f'The function was expected to remove and return the name \"{expected_result}\" '\r\n                                 f'and change the queue to {expected_queue},\\n'\r\n                                 f'but the name \"{actual_result}\" was returned and the queue == {queue}.')\r\n\r\n                self.assertEqual((actual_result, queue), (expected_result, expected_queue), msg=error_message)\r\n\r\n\r\n    @pytest.mark.task(taskno=7)\r\n    def test_sorted_names(self):\r\n        test_data =(\r\n        (['Steve', 'Ultron', 'Natasha', 'Rocket'], ['Natasha', 'Rocket', 'Steve', 'Ultron']),\r\n        (['Agatha', 'Pepper', 'Valkyrie', 'Drax', 'Nebula'], ['Agatha', 'Drax', 'Nebula', 'Pepper', 'Valkyrie']),\r\n        (['Gamora', 'Loki', 'Tony', 'Peggy', 'Okoye'], ['Gamora', 'Loki', 'Okoye', 'Peggy', 'Tony']),\r\n        )\r\n\r\n        for variant, (queue, expected) in enumerate(test_data, start=1):\r\n            with self.subTest(f'variation #{variant}', queue=queue, expected=expected):\r\n                actual_result = sorted_names(queue)\r\n                expected_result = expected\r\n\r\n            error_message = (f'\\nCalled sorted_names({queue}).\\n'\r\n                             f'The function returned {actual_result}, but \\n'\r\n                             f'the tests expect {expected_result}.')\r\n\r\n            self.assertEqual(actual_result, expected_result, msg=error_message)\r\n\r\n    @pytest.mark.task(taskno=7)\r\n    def test_sorted_names_validate_queue(self):\r\n        test_data = (\r\n        (['Steve', 'Ultron', 'Natasha', 'Rocket'], ['Natasha', 'Rocket', 'Steve', 'Ultron']),\r\n        (['Agatha', 'Pepper', 'Valkyrie', 'Drax', 'Nebula'], ['Agatha', 'Drax', 'Nebula', 'Pepper', 'Valkyrie']),\r\n        (['Gamora', 'Loki', 'Tony', 'Peggy', 'Okoye'], ['Gamora', 'Loki', 'Okoye', 'Peggy', 'Tony']),\r\n        )\r\n\r\n        for variant, (queue, expected) in enumerate(test_data, start=1):\r\n            with self.subTest(f'variation #{variant}', queue=queue, expected=expected):\r\n\r\n                # Deepcopy() is needed here because the input lists might be mutated.\r\n                # That mutation wrecks havoc with the verification and error messaging.\r\n                original_queue = deepcopy(queue)\r\n                actual_result = sorted_names(queue)\r\n                expected_result = expected\r\n\r\n            error_message = (f'\\nCalled sorted_names({original_queue}).\\n'\r\n                             f'The function returned {actual_result}, \\n'\r\n                             f'with a queue == {queue}.\\n'\r\n                             f'The tests expect {expected_result}, \\n'\r\n                             f'with a queue == {original_queue}.')\r\n\r\n            self.assertIsNot(actual_result, queue, msg=error_message)\r\n"
}