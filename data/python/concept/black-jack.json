{
  "concept": "black-jack",
  "docs": {
    "introduction": "## Comparisons\r\n\r\nPython supports the following basic comparison operators:\r\n\r\n| Operator | Operation                  | Description                                                               |\r\n| -------- | -------------------------- | ------------------------------------------------------------------------- |\r\n| `>`      | \"greater than\"             | `a > b` is `True` if `a` is **strictly** greater in value than `b`        |\r\n| `<`      | \"less than\"                | `a < b` is `True` if `a` is **strictly** less in value than `b`           |\r\n| `==`     | \"equal to\"                 | `a == b` is `True` if `a` is **strictly** equal to `b` in value           |\r\n| `>=`     | \"greater than or equal to\" | `a >= b` is `True` if `a > b` OR `a == b` in value                        |\r\n| `<=`     | \"less than or equal to\"    | `a <= b` is `True` if `a < b` or `a == b` in value                        |\r\n| `!=`     | \"not equal to\"             | `a != b` is `True` if `a == b` is `False`                                 |\r\n| `is`     | \"identity\"                 | `a is b` is `True` if **_and only if_** `a` and `b` are the same _object_ |\r\n| `is not` | \"negated identity\"         | `a is not b` is `True` if `a` and `b` are **not** the same _object_       |\r\n| `in`     | \"containment test\"         | `a in b` is `True` if `a` is member, subset, or element of `b`            |\r\n| `not in` | \"negated containment test\" | `a not in b` is `True` if `a` is not a member, subset, or element of `b`  |\r\n\r\nThey all have the same priority (_which is higher than that of [Boolean operations][boolean operations], but lower than that of arithmetic or bitwise operations_).\r\n\r\n## Comparison between different data types\r\n\r\nObjects that are different types (_except numeric types_) never compare equal by default.\r\nNon-identical instances of a `class` will also _**not**_ compare as equal unless the `class` defines special [rich comparison][rich comparisons] methods that customize the default `object` comparison behavior.\r\nCustomizing via `rich comparisons` will be covered in a follow-on exercise.\r\nFor (much) more detail on this topic, see [Value comparisons][value comparisons] in the Python documentation.\r\n\r\nNumeric types are (mostly) an exception to this type matching rule.\r\nAn `integer` **can** be considered equal to a `float` (_or an [`octal`][octal] equal to a [`hexadecimal`][hex]_), as long as the types can be implicitly converted for comparison.\r\n\r\nFor the other numeric types in the Python standard library ([complex][complex numbers], [decimal][decimal numbers], [fractions][rational numbers]), comparison operators are defined where they \"make sense\" (_where implicit conversion does not change the outcome_), but throw a `TypeError` if the underlying objects cannot be accurately converted for comparison.\r\nFor more information on the rules that python uses for _numeric conversion_, see [arithmetic conversions][arithmetic conversions] in the Python documentation.\r\n\r\n```python\r\n>>> import fractions\r\n\r\n# A string cannot be converted to an int.\r\n>>> 17 == '17'\r\nFalse\r\n\r\n# An int can be converted to float for comparison.\r\n>>> 17 == 17.0\r\nTrue\r\n\r\n# The fraction 6/3 can be converted to the int 2\r\n# The int 2 can be converted to 0b10 in binary.\r\n>>> 6/3 == 0b10\r\nTrue\r\n\r\n# An int can be converted to a complex number with a 0 imaginary part.\r\n>>> 17 == complex(17)\r\nTrue\r\n\r\n# The fraction 2/5 can be converted to the float 0.4\r\n>>> 0.4 == 2/5\r\nTrue\r\n\r\n>>> complex(2/5, 1/2) == complex(0.4, 0.5)\r\nTrue\r\n```\r\n\r\nAny ordered comparison of a number to a `NaN` (_not a number_) type is `False`.\r\nA confusing side effect of Python's `NaN` definition is that `NaN` never compares equal to `NaN`.\r\n\r\n```python\r\n>>> x = float('NaN')\r\n\r\n>>> 3 < x\r\nFalse\r\n\r\n>>> x < 3\r\nFalse\r\n\r\n# NaN never compares equal to NaN\r\n>>> x == x\r\nFalse\r\n```\r\n\r\n## Comparing Strings\r\n\r\nUnlike numbers, strings (`str`) are compared [_lexicographically_][lexographic order], using their individual Unicode code points (_the result of passing each code point in the `str` to the built-in function [`ord()`][ord], which returns an `int`_).\r\nIf all code points in both strings match and are _**in the same order**_, the two strings are considered equal.\r\nThis comparison is done in a 'pair-wise' fashion - first-to-first, second-to-second, etc.\r\nIn Python 3.x, `str` and `bytes` cannot be directly coerced/compared.\r\n\r\n```python\r\n>>> 'Python' > 'Rust'\r\nFalse\r\n\r\n>>> 'Python' > 'JavaScript'\r\nTrue\r\n\r\n# Examples with Mandarin.\r\n# hello < goodbye\r\n>>> '你好' < '再见'\r\nTrue\r\n\r\n# ord() of first characters\r\n>>> ord('你'), ord('再')\r\n(20320, 20877)\r\n\r\n# ord() of second characters\r\n>>> ord('好'), ord('见')\r\n(22909, 35265)\r\n\r\n# And with Korean words.\r\n# Pretty < beautiful.\r\n>>> '예쁜' < '아름다운'\r\nFalse\r\n\r\n>>> ord('예'), ord('아')\r\n(50696, 50500)\r\n```\r\n\r\n## Comparison Chaining\r\n\r\nComparison operators can be chained _arbitrarily_ -- meaning that they can be used in any combination of any length.\r\nNote that the evaluation of an expression takes place from `left` to `right`.\r\n\r\nAs an example, `x < y <= z` is equivalent to `x < y` `and` `y <= z`, except that `y` is evaluated **only once**.\r\nIn both cases, `z` is _not_ evaluated **at all** when `x < y` is found to be `False`.\r\nThis is often called `short-circuit evaluation` - the evaluation stops if the truth value of the expression has already been determined.\r\n\r\n`Short circuiting` is supported by various boolean operators, functions, and also by comparison chaining in Python.\r\nUnlike many other programming languages, including `C`, `C++`, `C#`, and `Java`, chained expressions like `a < b < c` in Python have a conventional [mathematical interpretation][three way boolean comparison] and precedence.\r\n\r\n```python\r\n>>> x = 2\r\n>>> y = 5\r\n>>> z = 10\r\n\r\n>>> x < y < z\r\nTrue\r\n\r\n>>> x < y > z\r\nFalse\r\n\r\n>>> x > y < z\r\nFalse\r\n```\r\n\r\n## Comparing object identity\r\n\r\nThe operators `is` and `is not` test for object [_identity_][object identity], as opposed to object _value_.\r\nAn object's identity never changes after creation and can be found by using the [`id()`][id function] function.\r\n\r\n`<apple> is <orange>` evaluates to `True` if _**and only if**_ `id(<apple>)` == `id(<orange>)`.\r\n`<apple> is not <orange>` yields the inverse.\r\n\r\nDue to their singleton status, `None` and `NotImplemented` should always be compared to items using `is` and `is not`.\r\nSee the Python reference docs on [value comparisons][value comparisons none] and [PEP8][pep8 programming recommendations] for more details on this convention.\r\n\r\n```python\r\n>>> my_fav_numbers = [1, 2, 3]\r\n\r\n>>> your_fav_numbers = my_fav_numbers\r\n\r\n>>> my_fav_numbers is your_fav_numbers\r\nTrue\r\n\r\n# The returned id will differ by system and python version.\r\n>>> id(my_fav_numbers)\r\n4517478208\r\n\r\n# your_fav_numbers is only an alias pointing to the original my_fav_numbers object.\r\n# Assigning a new name does not create a new object.\r\n>>> id(your_fav_numbers)\r\n4517478208\r\n\r\n\r\n>>> my_fav_numbers is not your_fav_numbers\r\nFalse\r\n\r\n>>> my_fav_numbers is not None\r\nTrue\r\n\r\n>>> my_fav_numbers is NotImplemented\r\nFalse\r\n```\r\n\r\n## Membership comparisons\r\n\r\nThe operators `in` and `not in` test for _membership_.\r\n`<fish> in <soup>` evaluates to `True` if `<fish>` is a member of `<soup>` (_if `<fish>` is a subset of or is contained within `<soup>`_), and evaluates `False` otherwise.\r\n`<fish> not in <soup>` returns the negation, or _opposite of_ `<fish> in <soup>`.\r\n\r\nFor string and bytes types, `<name> in <fullname>` is `True` _**if and only if**_ `<name>` is a substring of `<fullname>`.\r\n\r\n```python\r\n# A set of lucky numbers.\r\n>>> lucky_numbers = {11, 22, 33}\r\n>>> 22 in lucky_numbers\r\nTrue\r\n\r\n>>> 44 in lucky_numbers\r\nFalse\r\n\r\n# A dictionary of employee information.\r\n>>> employee = {'name': 'John Doe', \r\n                'id': 67826, 'age': 33, \r\n                'title': 'ceo'}\r\n\r\n# Checking for the membership of certain keys.\r\n>>> 'age' in employee\r\nTrue\r\n\r\n>>> 33 in employee\r\nFalse\r\n\r\n>>> 'lastname' not in employee\r\nTrue\r\n\r\n# Checking for substring membership\r\n>>> name = 'Super Batman'\r\n>>> 'Bat' in name\r\nTrue\r\n\r\n>>> 'Batwoman' in name\r\nFalse\r\n```\r\n\r\n[arithmetic conversions]: https://docs.python.org/3/reference/expressions.html?highlight=number%20conversion#arithmetic-conversions\r\n[boolean operations]: https://docs.python.org/3/library/stdtypes.html#boolean-operations-and-or-not\r\n[complex numbers]: https://docs.python.org/3/library/functions.html#complex\r\n[decimal numbers]: https://docs.python.org/3/library/decimal.html\r\n[hex]: https://docs.python.org/3/library/functions.html?highlight=hex#hex\r\n[id function]: https://docs.python.org/3/library/functions.html#id\r\n[lexographic order]: https://en.wikipedia.org/wiki/Lexicographic_order\r\n[object identity]: https://docs.python.org/3/reference/datamodel.html\r\n[octal]: https://docs.python.org/3/library/functions.html?#oct\r\n[ord]: https://docs.python.org/3/library/functions.html#ord\r\n[pep8 programming recommendations]: https://pep8.org/#programming-recommendations\r\n[rational numbers]: https://docs.python.org/3/library/fractions.html\r\n[rich comparisons]: https://docs.python.org/3/reference/datamodel.html#object.__lt__\r\n[three way boolean comparison]: https://en.wikipedia.org/wiki/Three-way_comparison\r\n[value comparisons none]: https://docs.python.org/3/reference/expressions.html?highlight=none#value-comparisons\r\n[value comparisons]: https://docs.python.org/3/reference/expressions.html?highlight=nan#value-comparisons\r\n",
    "hints": "# General\r\n\r\n[The Python comparisons tutorial][python comparisons tutorial] and [Python comparisons examples][python comparisons examples] are a great introduction covering the content of this exercise.\r\n\r\n## 1. Calculate the value of a card\r\n\r\n- You can use the equality comparison operator `==` to determine if a card is an ace card: `card == 'A'`.\r\n- You can use the containment operator `in` to determine if a substring is contained inside a string: `'Q' in 'KJQ'`.\r\n- You can use the [`int` constructor][int constructor] to convert a `str` of an `int` to an `int`: `int('13')`.\r\n\r\n## 2. Determine which card has a higher value\r\n\r\n- Once you have defined the `value_of_card` function, you can call it from other functions.\r\n- You can use the value comparison operators `>` and `<` to determine if specific cards are _greater than_ or _less than_ a given value: `3 < 12`.\r\n- You can use the equality comparison operator `==` to determine if two values are equal to one another.\r\n\r\n## 3. Calculate the value of an ace\r\n\r\n- Once you have defined the `value_of_card` function, you can call it from other functions.\r\n- You can use the order comparison operator `>` to decide the appropriate course of action here.\r\n\r\n## 4. Determine Blackjack\r\n\r\n- Remember, you can use the [`if`/`elif`/`else` syntax][if syntax] to handle different combinations of cards.\r\n- You can chain BOTH comparison operators and boolean operators _arbitrarily_: `y < z < x` or `(y or z) and (x or z)`\r\n- You can reuse the already implemented `value_of_card` function.\r\n\r\n## 5. Splitting pairs\r\n\r\n- You can reuse the already implemented `value_of_card` function.\r\n- You can handle the `A` case (when at least one of the cards in an ace) separately.\r\n\r\n## 6. Doubling down\r\n\r\n- An `A` scored at 11 will never allow doubling down if there are two cards in the hand.\r\n- Given the first point, you _should_ be able to reuse the already implemented `value_of_card` function.\r\n- You can chain comparison operators _arbitrarily_: `y < z < x`.\r\n- You can use the [conditional expression][conditional expression] (_sometimes called a \"ternary operator\"_)\r\n  to shorten simple `if`/`else` statements: `13 if letter == 'M' else 3`.\r\n\r\n[conditional expression]: https://docs.python.org/3/reference/expressions.html#conditional-expressions\r\n[if syntax]: https://docs.python.org/3/tutorial/controlflow.html#if-statements\r\n[int constructor]: https://docs.python.org/3/library/functions.html#int\r\n[python comparisons examples]: https://www.tutorialspoint.com/python/comparison_operators_example.htm\r\n[python comparisons tutorial]: https://docs.python.org/3/reference/expressions.html#comparisons\r\n",
    "instructions": "# Instructions\r\n\r\nIn this exercise you are going to implement some rules of [Blackjack][blackjack],\r\nsuch as the way the game is played and scored.\r\n\r\n**Note** : In this exercise, _`A`_ means ace, _`J`_ means jack, _`Q`_ means queen, and _`K`_ means king.\r\nJokers are discarded.\r\nA [standard French-suited 52-card deck][standard_deck] is assumed, but in most versions, several decks are shuffled together for play.\r\n\r\n## 1. Calculate the value of a card\r\n\r\nIn Blackjack, it is up to each individual player if an ace is worth 1 or 11 points (_more on that later_).\r\nFace cards (`J`, `Q`, `K`) are scored at 10 points and any other card is worth its \"pip\" (_numerical_) value.\r\n\r\nDefine the `value_of_card(<card>)` function with parameter `card`.\r\nThe function should return the _numerical value_ of the passed-in card string.\r\nSince an ace can take on multiple values (1 **or** 11), this function should fix the value of an ace card at 1 for the time being.\r\nLater on, you will implement a function to determine the value of an ace card, given an existing hand.\r\n\r\n```python\r\n>>> value_of_card('K')\r\n10\r\n\r\n>>> value_of_card('4')\r\n4\r\n\r\n>>> value_of_card('A')\r\n1\r\n```\r\n\r\n## 2. Determine which card has a higher value\r\n\r\nDefine the `higher_card(<card_one>, <card_two>)` function having parameters `card_one` and `card_two`.\r\nFor scoring purposes, the value of `J`, `Q` or `K` is 10.\r\nThe function should return which card has the higher value for scoring.\r\nIf both cards have an equal value, return both.\r\nReturning both cards can be done by using a comma in the `return` statement:\r\n\r\n```python\r\n# Using a comma in a return creates a Tuple.  Tuples will be covered in a later exercise.\r\n>>> def returning_two_values(value_one, value_two):\r\n        return value_one, value_two\r\n\r\n>>> returning_two_values('K', '3')\r\n('K', '3')\r\n```\r\n\r\nAn ace can take on multiple values, so we will fix `A` cards to a value of 1 for this task.\r\n\r\n```python\r\n>>> higher_card('K', '10')\r\n('K', '10')\r\n\r\n>>> higher_card('4', '6')\r\n'6'\r\n\r\n>>> higher_card('K', 'A')\r\n'K'\r\n```\r\n\r\n## 3. Calculate the value of an ace\r\n\r\nAs mentioned before, an ace can be worth _either_ 1 **or** 11 points.\r\nPlayers try to get as close as possible to a score of 21, without going _over_ 21 (_going \"bust\"_).\r\n\r\nDefine the `value_of_ace(<card_one>, <card_two>)` function with parameters `card_one` and `card_two`, which are a pair of cards already in the hand _before_ getting an ace card.\r\nYour function will have to decide if the upcoming ace will get a value of 1 or a value of 11, and return that value.\r\nRemember: the value of the hand with the ace needs to be as high as possible _without_ going over 21.\r\n\r\n**Hint**: if we already have an ace in hand, then the value for the upcoming ace would be 1.\r\n\r\n```python\r\n>>> value_of_ace('6', 'K')\r\n1\r\n\r\n>>> value_of_ace('7', '3')\r\n11\r\n```\r\n\r\n## 4. Determine a \"Natural\" or \"Blackjack\" Hand\r\n\r\nIf a player is dealt an ace (`A`) and a ten-card (10, `K`, `Q`, or `J`) as their first two cards, then the player has a score of 21.\r\nThis is known as a **blackjack** hand.\r\n\r\n\r\nDefine the `is_blackjack(<card_one>, <card_two>)` function with parameters `card_one` and `card_two`, which are a pair of cards.\r\nDetermine if the two-card hand is a **blackjack**, and return the boolean `True` if it is, `False` otherwise.\r\n\r\n**Note** : The score _calculation_ can be done in many ways.\r\nBut if possible, we'd like you to check if there is an ace and a ten-card **_in_** the hand (_or at a certain position_), as opposed to _summing_ the hand values.\r\n\r\n```python\r\n>>> is_blackjack('A', 'K')\r\nTrue\r\n\r\n>>> is_blackjack('10', '9')\r\nFalse\r\n```\r\n\r\n## 5. Splitting pairs\r\n\r\nIf the players first two cards are of the same value, such as two sixes, or a `Q` and `K` a player may choose to treat them as two separate hands.\r\nThis is known as \"splitting pairs\".\r\n\r\nDefine the `can_split_pairs(<card_one>, <card_two>)` function with parameters `card_one` and `card_two`, which are a pair of cards.\r\nDetermine if this two-card hand can be split into two pairs.\r\nIf the hand can be split, return the boolean `True` otherwise, return `False`\r\n\r\n```python\r\n>>> can_split_pairs('Q', 'K')\r\nTrue\r\n\r\n>>> can_split_pairs('10', 'A')\r\nFalse\r\n```\r\n\r\n## 6. Doubling down\r\n\r\nWhen the original two cards dealt total 9, 10, or 11 points, a player can place an additional bet equal to their original bet.\r\nThis is known as \"doubling down\".\r\n\r\nDefine the `can_double_down(<card_one>, <card_two>)` function with parameters `card_one` and `card_two`, which are a pair of cards.\r\nDetermine if the two-card hand can be \"doubled down\", and return the boolean `True` if it can, `False` otherwise.\r\n\r\n```python\r\n>>> can_double_down('A', '9')\r\nTrue\r\n\r\n>>> can_double_down('10', '2')\r\nFalse\r\n```\r\n\r\n[blackjack]: https://bicyclecards.com/how-to-play/blackjack/\r\n[standard_deck]: https://en.wikipedia.org/wiki/Standard_52-card_deck\r\n",
    "design": "## Goal\r\n\r\nThis concept exercise should teach how basic _non-customized_ comparisons work in python and how to use them effectively.\r\n\r\n## Learning objectives\r\n\r\n- understand all comparison operations in Python have the same priority and are evaluated after arithmetic, shifting, or bitwise operations.\r\n- understand all comparisons yield the boolean values True and False\r\n- know that identity comparisons is and is not are for checking an objects identity only\r\n- understand that `==` and `!=` compare both the value & type of an object.\r\n- know where Python has altered the behavior of `==` and `!=` for certain `built-in` types (such as [numbers][numbers], or for standard library types like [decimals][decimals], and [fractions][fractions] to allow comparison across and within type.\r\n- know that unlike numeric types, strings (`str`) and binary sequences (`bytes` & `byte array`) **cannot** be directly compared.\r\n- understand how comparisons work within `built-in` [sequence types][sequence types](`list`, `tuple`, `range`) and `built-in` `collection types` (`set`, `[dict]`)\r\n- know about the \"special\" comparisons `None`, `NotImplemented` (comparing either should use identity operators and not equality operators because they are singleton objects) and NaN (`NaN` is **never** `==` to itself)\r\n- use the value comparison operators `==`, `>`, `<`, `!=` with numeric types\r\n- use the value comparison operators `==`, `>`, `<`, `!=` with non-numeric types\r\n- use `is` and `is not` to check/verify identity\r\n\r\n## Out of scope\r\n\r\n- rich comparison with `__lt__`, `__le__`, `__ne__`, `__ge__`, `__gt__`\r\n- understanding (_and using the concept_) that the `==` operator calls the dunder method `__eq__()` on a specific object, and uses that object's implementation for comparison. Where no implementation is present, the default `__eq__()` from generic `object` is used.\r\n- overloading the default implementation of the `__eq__()` dunder method on a specific object to customize comparison behavior.\r\n- `set operations`\r\n- performance considerations\r\n\r\n## Concepts\r\n\r\n- Comparison priority in Python\r\n- Comparison operators `==`, `>`, `<`, `!=`\r\n- Identity methods `is` and `is not`\r\n- Equality applied to `built-in` types\r\n- Equivalence vs equality\r\n- Inequality\r\n\r\n## Prerequisites\r\n\r\n- `basics`\r\n- `booleans`\r\n- `dicts`\r\n- `lists`\r\n- `sets`\r\n- `strings`\r\n- `tuples`\r\n- `numbers`\r\n- `iteration`\r\n\r\n## Resources\r\n\r\n- [Comparisons in Python (Python language reference)](https://docs.python.org/3/reference/expressions.html#comparisons)\r\n- [Value comparisons in Python (Python language reference)](https://docs.python.org/3/reference/expressions.html#value-comparisons)\r\n- [Identity comparisons in Python (Python language reference)](https://docs.python.org/3/reference/expressions.html#is-not)\r\n- [Python operators official doc](https://docs.python.org/3/library/operator.html)\r\n- [Python Object Model (Python docs)](https://docs.python.org/3/reference/datamodel.html#objects)\r\n- [Basic Customization](https://docs.python.org/3/reference/datamodel.html#customization)\r\n- [Python basic operators on tutorialspoint](https://www.tutorialspoint.com/python/python_basic_operators.htm)\r\n- [Python comparison operators on data-flair](https://data-flair.training/blogs/python-comparison-operators/)\r\n- [PEP 207 to allow Operator Overloading for Comparison](https://www.python.org/dev/peps/pep-0207/)\r\n\r\n[numbers]: https://docs.python.org/3/library/stdtypes.html#typesnumeric\r\n[decimals]: https://docs.python.org/3/library/decimal.html#decimal.Decimal\r\n[fractions]: https://docs.python.org/3/library/fractions.html#fractions.Fraction\r\n[sequence types]: https://docs.python.org/3/library/stdtypes.html#sequence-types-list-tuple-range"
  },
  "config": {
    "authors": [
      "Ticktakto",
      "Yabby1997",
      "limm-jk",
      "OMEGA-Y",
      "wnstj2007",
      "pranasziaukas",
      "bethanyG"
    ],
    "contributors": [
      "PaulT89"
    ],
    "files": {
      "solution": [
        "black_jack.py"
      ],
      "test": [
        "black_jack_test.py"
      ],
      "exemplar": [
        ".meta/exemplar.py"
      ]
    },
    "icon": "poker",
    "blurb": "Learn about comparisons by implementing some Black Jack judging rules."
  },
  "starter_code": "\"\"\"Functions to help play and score a game of blackjack.\r\n\r\nHow to play blackjack:    https://bicyclecards.com/how-to-play/blackjack/\r\n\"Standard\" playing cards: https://en.wikipedia.org/wiki/Standard_52-card_deck\r\n\"\"\"\r\n\r\n\r\ndef value_of_card(card):\r\n    \"\"\"Determine the scoring value of a card.\r\n\r\n    :param card: str - given card.\r\n    :return: int - value of a given card.  See below for values.\r\n\r\n    1.  'J', 'Q', or 'K' (otherwise known as \"face cards\") = 10\r\n    2.  'A' (ace card) = 1\r\n    3.  '2' - '10' = numerical value.\r\n    \"\"\"\r\n\r\n    pass\r\n\r\n\r\ndef higher_card(card_one, card_two):\r\n    \"\"\"Determine which card has a higher value in the hand.\r\n\r\n    :param card_one, card_two: str - cards dealt in hand.  See below for values.\r\n    :return: str or tuple - resulting Tuple contains both cards if they are of equal value.\r\n\r\n    1.  'J', 'Q', or 'K' (otherwise known as \"face cards\") = 10\r\n    2.  'A' (ace card) = 1\r\n    3.  '2' - '10' = numerical value.\r\n    \"\"\"\r\n\r\n    pass\r\n\r\n\r\ndef value_of_ace(card_one, card_two):\r\n    \"\"\"Calculate the most advantageous value for the ace card.\r\n\r\n    :param card_one, card_two: str - card dealt. See below for values.\r\n    :return: int - either 1 or 11 value of the upcoming ace card.\r\n\r\n    1.  'J', 'Q', or 'K' (otherwise known as \"face cards\") = 10\r\n    2.  'A' (ace card) = 11 (if already in hand)\r\n    3.  '2' - '10' = numerical value.\r\n    \"\"\"\r\n\r\n    pass\r\n\r\n\r\ndef is_blackjack(card_one, card_two):\r\n    \"\"\"Determine if the hand is a 'natural' or 'blackjack'.\r\n\r\n    :param card_one, card_two: str - card dealt. See below for values.\r\n    :return: bool - is the hand is a blackjack (two cards worth 21).\r\n\r\n    1.  'J', 'Q', or 'K' (otherwise known as \"face cards\") = 10\r\n    2.  'A' (ace card) = 11 (if already in hand)\r\n    3.  '2' - '10' = numerical value.\r\n    \"\"\"\r\n\r\n    pass\r\n\r\n\r\ndef can_split_pairs(card_one, card_two):\r\n    \"\"\"Determine if a player can split their hand into two hands.\r\n\r\n    :param card_one, card_two: str - cards dealt.\r\n    :return: bool - can the hand be split into two pairs? (i.e. cards are of the same value).\r\n    \"\"\"\r\n\r\n    pass\r\n\r\n\r\ndef can_double_down(card_one, card_two):\r\n    \"\"\"Determine if a blackjack player can place a double down bet.\r\n\r\n    :param card_one, card_two: str - first and second cards in hand.\r\n    :return: bool - can the hand can be doubled down? (i.e. totals 9, 10 or 11 points).\r\n    \"\"\"\r\n\r\n    pass\r\n",
  "exemplar_code": "\"\"\"Functions to help play and score a game of blackjack.\r\n\r\nHow to play blackjack:    https://bicyclecards.com/how-to-play/blackjack/\r\n\"Standard\" playing cards: https://en.wikipedia.org/wiki/Standard_52-card_deck\r\n\"\"\"\r\n\r\n\r\ndef value_of_card(card):\r\n    \"\"\"Determine the scoring value of a card.\r\n\r\n    :param card: str - given card.\r\n    :return: int - value of a given card.  See below for values.\r\n\r\n    1.  'J', 'Q', or 'K' (otherwise known as \"face cards\") = 10\r\n    2.  'A' (ace card) = 1\r\n    3.  '2' - '10' = numerical value.\r\n    \"\"\"\r\n\r\n    if card in ('JQK'):\r\n        value = 10\r\n\r\n    elif card == 'A':\r\n        value = 1\r\n\r\n    else:\r\n        value = int(card)\r\n\r\n    return value\r\n\r\n\r\ndef higher_card(card_one, card_two):\r\n    \"\"\"Determine which card has a higher value in the hand.\r\n\r\n    :param card_one, card_two: str - cards dealt in hand.  See below for values.\r\n    :return: str or tuple - resulting Tuple contains both cards if they are of equal value.\r\n\r\n    1.  'J', 'Q', or 'K' (otherwise known as \"face cards\") = 10\r\n    2.  'A' (ace card) = 1\r\n    3.  '2' - '10' = numerical value.\r\n    \"\"\"\r\n\r\n    card_one_value = value_of_card(card_one)\r\n    card_two_value = value_of_card(card_two)\r\n\r\n    if card_one_value == card_two_value:\r\n        result = card_one, card_two\r\n\r\n    elif card_one_value > card_two_value:\r\n        result = card_one\r\n\r\n    else:\r\n        result = card_two\r\n\r\n    return result\r\n\r\n\r\ndef value_of_ace(card_one, card_two):\r\n    \"\"\"Calculate the most advantageous value for the ace card.\r\n\r\n    :param card_one, card_two: str - card dealt. See below for values.\r\n    :return: int - either 1 or 11 value of the upcoming ace card.\r\n\r\n    1.  'J', 'Q', or 'K' (otherwise known as \"face cards\") = 10\r\n    2.  'A' (ace card) = 11 (if already in hand)\r\n    3.  '2' - '10' = numerical value.\r\n    \"\"\"\r\n\r\n    card_one_value = 11 if card_one == 'A' else value_of_card(card_one)\r\n    card_two_value = 11 if card_two == 'A' else value_of_card(card_two)\r\n\r\n    ace_value = 1 if 11 + (card_one_value + card_two_value) > 21 else 11\r\n\r\n    return ace_value\r\n\r\n\r\ndef is_blackjack(card_one, card_two):\r\n    \"\"\"Determine if the hand is a 'natural' or 'blackjack'.\r\n\r\n    :param card_one, card_two: str - card dealt. See below for values.\r\n    :return: bool - is the hand is a blackjack (two cards worth 21).\r\n\r\n    1.  'J', 'Q', or 'K' (otherwise known as \"face cards\") = 10\r\n    2.  'A' (ace card) = 11 (if already in hand)\r\n    3.  '2' - '10' = numerical value.\r\n    \"\"\"\r\n\r\n    return (card_one == 'A' or card_two == 'A') and (value_of_card(card_one) == 10 or value_of_card(card_two) == 10)\r\n\r\n\r\ndef can_split_pairs(card_one, card_two):\r\n    \"\"\"Determine if a player can split their hand into two hands.\r\n\r\n    :param card_one, card_two: str - cards dealt.\r\n    :return: bool - can the hand be split into two pairs? (i.e. cards are of the same value).\r\n    \"\"\"\r\n\r\n    return value_of_card(card_one) == value_of_card(card_two)\r\n\r\n\r\ndef can_double_down(card_one, card_two):\r\n    \"\"\"Determine if a blackjack player can place a double down bet.\r\n\r\n    :param card_one, card_two: str - first and second cards in hand.\r\n    :return: bool - can the hand can be doubled down? (i.e. totals 9, 10 or 11 points).\r\n    \"\"\"\r\n\r\n    return 8 < value_of_card(card_one) + value_of_card(card_two) < 12\r\n",
  "tests": "import unittest\r\nimport pytest\r\n\r\nfrom black_jack import (\r\n                        value_of_card,\r\n                        higher_card,\r\n                        value_of_ace,\r\n                        is_blackjack,\r\n                        can_split_pairs,\r\n                        can_double_down\r\n                        )\r\n\r\n\r\nclass BlackJackTest(unittest.TestCase):\r\n\r\n    @pytest.mark.task(taskno=1)\r\n    def test_value_of_card(self):\r\n        test_data = [('2', 2), ('5', 5), ('8', 8),\r\n                     ('A', 1), ('10', 10), ('J', 10),\r\n                     ('Q', 10), ('K', 10)]\r\n\r\n        for variant, (card, expected) in enumerate(test_data, 1):\r\n            with self.subTest(f'variation #{variant}', card=card, expected=expected):\r\n                actual_result = value_of_card(card)\r\n                error_msg = (f'Called value_of_card({card}). '\r\n                             f'The function returned {actual_result} as the value of the {card} card, '\r\n                             f'but the test expected {expected} as the {card} card value.')\r\n\r\n                self.assertEqual(actual_result, expected, msg=error_msg)\r\n\r\n\r\n    @pytest.mark.task(taskno=2)\r\n    def test_higher_card(self):\r\n        test_data = [('A', 'A', ('A', 'A')),\r\n                     ('10', 'J', ('10', 'J')),\r\n                     ('3', 'A', '3'),\r\n                     ('3', '6', '6'),\r\n                     ('Q', '10', ('Q', '10')),\r\n                     ('4', '4', ('4', '4')),\r\n                     ('9',  '10', '10'),\r\n                     ('6', '9', '9'),\r\n                     ('4', '8', '8')]\r\n\r\n        for variant, (card_one, card_two, expected) in enumerate(test_data, 1):\r\n            with self.subTest(f'variation #{variant}', card_one=card_one, card_two=card_two, expected=expected):\r\n                actual_result = higher_card(card_one, card_two)\r\n                error_msg = (f'Called higher_card({card_one}, {card_two}). '\r\n                             f'The function returned {actual_result}, '\r\n                             f'but the test expected {expected} as the result for the cards {card_one, card_two}.')\r\n\r\n                self.assertEqual(actual_result, expected, msg=error_msg)\r\n\r\n    @pytest.mark.task(taskno=3)\r\n    def test_value_of_ace(self):\r\n        test_data = [('2', '3', 11), ('3', '6', 11), ('5', '2', 11),\r\n                     ('8', '2', 11), ('5', '5', 11), ('Q', 'A', 1),\r\n                     ('10', '2', 1), ('7', '8', 1), ('J', '9', 1),\r\n                     ('K', 'K', 1), ('2', 'A', 1), ('A', '2', 1)]\r\n\r\n        for variant, (card_one, card_two, ace_value) in enumerate(test_data, 1):\r\n            with self.subTest(f'variation #{variant}', card_one=card_one, card_two=card_two, ace_value=ace_value):\r\n                actual_result = value_of_ace(card_one, card_two)\r\n                error_msg = (f'Called value_of_ace({card_one}, {card_two}). '\r\n                             f'The function returned {actual_result}, '\r\n                             f'but the test expected {ace_value} as the value of an ace card '\r\n                             f'when the hand includes {card_one, card_two}.')\r\n\r\n                self.assertEqual(value_of_ace(card_one, card_two), ace_value, msg=error_msg)\r\n\r\n    @pytest.mark.task(taskno=4)\r\n    def test_is_blackjack(self):\r\n        test_data = [(('A', 'K'), True), (('10', 'A'), True),\r\n                     (('10', '9'), False), (('A', 'A'), False),\r\n                     (('4', '7'), False), (('9', '2'), False),\r\n                     (('Q', 'K'), False)]\r\n\r\n        for variant, (hand, expected) in enumerate(test_data, 1):\r\n            with self.subTest(f'variation #{variant}', hand=hand, expected=expected):\r\n                actual_result = is_blackjack(*hand)\r\n                error_msg = (f'Called is_blackjack({hand[0]}, {hand[1]}). '\r\n                             f'The function returned {actual_result}, '             \r\n                             f'but hand {hand} {\"is\" if expected else \"is not\"} a blackjack.')\r\n\r\n                self.assertEqual(actual_result, expected, msg=error_msg)\r\n\r\n    @pytest.mark.task(taskno=5)\r\n    def test_can_split_pairs(self):\r\n        test_data = [(('Q', 'K'), True), (('6', '6'), True),\r\n                     (('A', 'A'), True),(('10', 'A'), False),\r\n                     (('10', '9'), False)]\r\n\r\n        for variant, (hand, expected) in enumerate(test_data, 1):\r\n            with self.subTest(f'variation #{variant}', input=hand, expected=expected):\r\n                actual_result = can_split_pairs(*hand)\r\n                error_msg = (f'Called can_split_pairs({hand[0]}, {hand[1]}). '\r\n                             f'The function returned {actual_result}, '\r\n                             f'but hand {hand} {\"can\" if expected else \"cannot\"} be split into pairs.')\r\n\r\n                self.assertEqual(actual_result, expected, msg=error_msg)\r\n\r\n    @pytest.mark.task(taskno=6)\r\n    def test_can_double_down(self):\r\n        test_data = [(('A', '9'), True), (('K', 'A'), True),\r\n                     (('4', '5'), True),(('A', 'A'), False),\r\n                     (('10', '2'), False), (('10', '9'), False)]\r\n\r\n        for variant, (hand, expected) in enumerate(test_data, 1):\r\n            with self.subTest(f'variation #{variant}', hand=hand, expected=expected):\r\n                actual_result = can_double_down(*hand)\r\n                error_msg = (f'Called can_double_down({hand[0]}, {hand[1]}). '\r\n                             f'The function returned {actual_result}, '\r\n                             f'but hand {hand} {\"can\" if expected else \"cannot\"} be doubled down.')\r\n\r\n                self.assertEqual(actual_result, expected, msg=error_msg)\r\n"
}