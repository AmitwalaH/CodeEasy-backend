{
  "concept": "cater-waiter",
  "docs": {
    "introduction": "# Sets\r\n\r\n\r\nA [set][type-set] is a _mutable_ and _unordered_ collection of [_hashable_][hashable] objects.\r\nSet members must be distinct ‚Äî duplicate items are not allowed.\r\nThey can hold multiple different data types and even nested structures like a `tuple` of `tuples` ‚Äî as long as all elements can be _hashed_.\r\nSets also come in an immutable [`frozensets`][type-frozenset] flavor.\r\n\r\nSets are most commonly used to quickly remove duplicates from other data structures or item groupings.\r\nThey are also used for efficient comparisons when sequencing and duplicate tracking are not needed.\r\n\r\nLike other collection types (_dictionaries, lists, tuples_), `sets` support:\r\n- Iteration via `for item in <set>`\r\n- Membership checking via `in` and `not in`,\r\n- Length calculation through `len()`, and\r\n- Shallow copies through `copy()`\r\n\r\n`sets` do not support:\r\n- Indexing of any kind\r\n- Ordering via sorting or insertion\r\n- Slicing\r\n- Concatenation via `+`\r\n\r\n\r\nChecking membership in a `set` has constant time complexity (on average) versus checking membership in a `list` or `string`, where the time complexity grows as the length of the data increases.\r\nMethods such as `<set>.union()`, `<set>.intersection()`, or `<set>.difference()` also have constant time complexity (on average).\r\n\r\n\r\n## Set Literals\r\n\r\nA `set` can be directly entered as a _set literal_ with curly `{}` brackets and commas between elements.\r\nDuplicates are silently omitted:\r\n\r\n```python\r\n>>> one_element = {'‚ûï'}\r\n{'‚ûï'}\r\n\r\n>>> multiple_elements = {'‚ûï', 'üîª', 'üîπ', 'üîÜ'}\r\n{'‚ûï', 'üîª', 'üîπ', 'üîÜ'}\r\n\r\n>>> multiple_duplicates =  {'Hello!', 'Hello!', 'Hello!', \r\n                            '¬°Hola!','–ü—Ä–∏–≤—ñ—Ç!', '„Åì„Çì„Å´„Å°„ÅØÔºÅ', \r\n                            '¬°Hola!','–ü—Ä–∏–≤—ñ—Ç!', '„Åì„Çì„Å´„Å°„ÅØÔºÅ'}\r\n{'„Åì„Çì„Å´„Å°„ÅØÔºÅ', '¬°Hola!', 'Hello!', '–ü—Ä–∏–≤—ñ—Ç!'}\r\n```\r\n\r\nSet literals use the same curly braces as `dict` literals, which means you need to use `set()` to create an empty `set`.\r\n\r\n\r\n## The Set Constructor\r\n\r\n`set()` (_the constructor for the `set` class_) can be used with any `iterable` passed as an argument.\r\nElements of the `iterable` are cycled through and added to the `set` individually.\r\nElement order is not preserved and duplicates are silently omitted:\r\n\r\n```python\r\n# To create an empty set, the constructor must be used.\r\n>>> no_elements = set()\r\nset()\r\n\r\n# The tuple is unpacked & each element is added.  \r\n# Duplicates are removed.\r\n>>> elements_from_tuple = set((\"Parrot\", \"Bird\", \r\n                               334782, \"Bird\", \"Parrot\"))\r\n{334782, 'Bird', 'Parrot'}\r\n\r\n# The list is unpacked & each element is added.\r\n# Duplicates are removed.\r\n>>> elements_from_list = set([2, 3, 2, 3, 3, 3, 5, \r\n                              7, 11, 7, 11, 13, 13])\r\n{2, 3, 5, 7, 11, 13}\r\n```\r\n\r\n### Gotchas when Creating Sets\r\n\r\nDue to its \"unpacking\" behavior, using `set()` with a string might be surprising:\r\n\r\n```python\r\n# String elements (Unicode code points) are \r\n# iterated through and added *individually*.\r\n>>> elements_string = set(\"Timbuktu\")\r\n{'T', 'b', 'i', 'k', 'm', 't', 'u'}\r\n\r\n# Unicode separators and positioning code points \r\n# are also added *individually*.\r\n>>> multiple_code_points_string = set('‡§Ö‡§≠‡•ç‡§Ø‡§æ‡§∏')\r\n{'‡§Ö', '‡§≠', '‡§Ø', '‡§∏', '‡§æ', '‡•ç'}\r\n```\r\n\r\nSets can hold different datatypes and _nested_ datatypes, but all `set` elements must be _hashable_:\r\n\r\n```python\r\n# Attempting to use a list for a set member throws a TypeError\r\n>>> lists_as_elements = {['üåà','üí¶'], \r\n                        ['‚òÅÔ∏è','‚≠êÔ∏è','üåç'], \r\n                        ['‚õµÔ∏è', 'üö≤', 'üöÄ']}\r\n\r\nTraceback (most recent call last):\r\n  File \"<stdin>\", line 1, in <module>\r\nTypeError: unhashable type: 'list'\r\n\r\n\r\n# Standard sets are mutable, so they cannot be hashed.\r\n>>> sets_as_elements = {{'üåà','üí¶'}, \r\n                        {'‚òÅÔ∏è','‚≠êÔ∏è','üåç'}, \r\n                        {'‚õµÔ∏è', 'üö≤', 'üöÄ'}}\r\n\r\nTraceback (most recent call last):\r\n  File \"<stdin>\", line 1, in <module>\r\nTypeError: unhashable type: 'set'\r\n```\r\n\r\n\r\n## Working with Sets\r\n\r\nSets have methods that generally mimic [mathematical set operations][mathematical-sets].\r\nMost (_not all_) of these methods have an [operator][operator] equivalent.\r\nMethods generally take any `iterable` as an argument, while operators require that both sides of the operation are `sets` or `frozensets`.\r\n\r\n\r\n### Disjoint Sets\r\n\r\nThe `<set>.isdisjoint(<other_collection>)` method is used to test if a `sets` elements have any overlap with the elements of another `set`.\r\nThe method will accept any `iterable` or `set` as an argument.\r\nIt will return `True` if the two sets have **no elements in common**, `False` if elements are **shared**.\r\nThere is no operator equivalent:\r\n\r\n\r\n```python\r\n# Both mammals and additional_animals are lists.\r\n>>> mammals = ['squirrel','dog','cat','cow', 'tiger', 'elephant']\r\n>>> additional_animals = ['pangolin', 'panda', 'parrot', \r\n                          'lemur', 'tiger', 'pangolin']\r\n\r\n# Animals is a dict.\r\n>>> animals = {'chicken': 'white',\r\n               'sparrow': 'grey',\r\n               'eagle': 'brown and white',\r\n               'albatross': 'grey and white',\r\n               'crow': 'black',\r\n               'elephant': 'grey', \r\n               'dog': 'rust',\r\n               'cow': 'black and white',\r\n               'tiger': 'orange and black',\r\n               'cat': 'grey',\r\n               'squirrel': 'black'}\r\n               \r\n# Birds is a set.\r\n>>> birds = {'crow','sparrow','eagle','chicken', 'albatross'}\r\n\r\n# Mammals and birds don't share any elements.\r\n>>> birds.isdisjoint(mammals)\r\nTrue\r\n\r\n# There are also no shared elements between \r\n# additional_animals and birds.\r\n>>> birds.isdisjoint(additional_animals)\r\nTrue\r\n\r\n# Animals and mammals have shared elements.\r\n# **Note** The first object needs to be a set or converted to a set\r\n# since .isdisjoint() is a set method.\r\n>>> set(animals).isdisjoint(mammals)\r\nFalse\r\n```\r\n\r\n\r\n### Subsets and Supersets\r\n\r\n`<set>.issubset(<other_collection>)` is used to check if every element in `<set>` is also in `<other_collection>`.\r\nThe operator form is `<set> <= <other_set>`:\r\n\r\n\r\n```python\r\n# Both mammals and additional_animals are lists.\r\n>>> mammals = ['squirrel','dog','cat','cow', 'tiger', 'elephant']\r\n>>> additional_animals = ['pangolin', 'panda', 'parrot', \r\n                          'lemur', 'tiger', 'pangolin']\r\n\r\n# Animals is a dict.\r\n>>> animals = {'chicken': 'white',\r\n               'sparrow': 'grey',\r\n               'eagle': 'brown and white',\r\n               'albatross': 'grey and white',\r\n               'crow': 'black',\r\n               'elephant': 'grey', \r\n               'dog': 'rust',\r\n               'cow': 'black and white',\r\n               'tiger': 'orange and black',\r\n               'cat': 'grey',\r\n               'squirrel': 'black'}\r\n\r\n# Birds is a set.\r\n>>> birds = {'crow','sparrow','eagle','chicken', 'albatross'}\r\n\r\n# Set methods will take any iterable as an argument.\r\n# All members of birds are also members of animals.\r\n>>> birds.issubset(animals)\r\nTrue\r\n\r\n# All members of mammals also appear in animals.\r\n# **Note** The first object needs to be a set or converted to a set\r\n# since .issubset() is a set method.\r\n>>> set(mammals).issubset(animals)\r\nTrue\r\n\r\n# Both objects need to be sets to use a set operator\r\n>>> birds <= set(mammals)\r\nFalse\r\n\r\n# A set is always a loose subset of itself.\r\n>>> set(additional_animals) <= set(additional_animals)\r\nTrue\r\n```\r\n\r\n`<set>.issuperset(<other_collection>)` is the inverse of `.issubset()`.\r\nIt is used to check if every element in `<other_collection>` is also in `<set>`.\r\nThe operator form is `<set> >= <other_set>`:\r\n\r\n\r\n```python\r\n# All members of mammals also appear in animals.\r\n# **Note** The first object needs to be a set or converted to a set\r\n# since .issuperset() is a set method.\r\n>>> set(animals).issuperset(mammals)\r\nTrue\r\n\r\n# All members of animals do not show up as members of birds.\r\n>>> birds.issuperset(animals)\r\nFalse\r\n\r\n# Both objects need to be sets to use a set operator\r\n>>> birds >= set(mammals)\r\nFalse\r\n\r\n# A set is always a loose superset of itself.\r\n>>> set(animals) >= set(animals)\r\nTrue\r\n```\r\n\r\n\r\n### Set Intersections\r\n\r\n`<set>.intersection(*<other iterables>)` returns a new `set` with elements common to the original `set` and all `<others>` (_in other words, the `set` where everything [intersects][intersection]_).\r\nThe operator version of this method is `<set> & <other set> & <other set 2> & ... <other set n>`:\r\n\r\n\r\n```python\r\n>>> perennials = {'Annatto','Asafetida','Asparagus','Azalea',\r\n                 'Winter Savory', 'Broccoli','Curry Leaf','Fennel', \r\n                 'Kaffir Lime','Kale','Lavender','Mint','Oranges',\r\n                 'Oregano', 'Tarragon', 'Wild Bergamot'}\r\n\r\n>>> annuals = {'Corn', 'Zucchini', 'Sweet Peas', 'Marjoram', \r\n              'Summer Squash', 'Okra','Shallots', 'Basil', \r\n              'Cilantro', 'Cumin', 'Sunflower', 'Chervil', \r\n              'Summer Savory'}\r\n\r\n>>> herbs = ['Annatto','Asafetida','Basil','Chervil','Cilantro',\r\n            'Curry Leaf','Fennel','Kaffir Lime','Lavender',\r\n            'Marjoram','Mint','Oregano','Summer Savory' \r\n            'Tarragon','Wild Bergamot','Wild Celery',\r\n            'Winter Savory']\r\n\r\n\r\n# Methods will take any iterable as an argument.\r\n>>> perennial_herbs = perennials.intersection(herbs)\r\n{'Annatto', 'Asafetida', 'Curry Leaf', 'Fennel', 'Kaffir Lime',\r\n 'Lavender', 'Mint', 'Oregano', 'Wild Bergamot','Winter Savory'}\r\n\r\n# Operators require both groups be sets.\r\n>>> annuals & set(herbs)\r\n {'Basil', 'Chervil', 'Marjoram', 'Cilantro'}\r\n```\r\n\r\n\r\n### Set Unions\r\n\r\n`<set>.union(*<other iterables>)` returns a new `set` with elements from `<set>` and all `<other iterables>`.\r\nThe operator form of this method is `<set> | <other set 1> | <other set 2> | ... | <other set n>`:\r\n\r\n\r\n```python\r\n>>> perennials = {'Asparagus', 'Broccoli', 'Sweet Potato', 'Kale'}\r\n>>> annuals = {'Corn', 'Zucchini', 'Sweet Peas', 'Summer Squash'}\r\n>>> more_perennials = ['Radicchio', 'Rhubarb', \r\n                      'Spinach', 'Watercress']\r\n\r\n# Methods will take any iterable as an argument.\r\n>>> perennials.union(more_perennials)\r\n{'Asparagus','Broccoli','Kale','Radicchio','Rhubarb',\r\n'Spinach','Sweet Potato','Watercress'}\r\n\r\n# Operators require sets.\r\n>>> set(more_perennials) | perennials\r\n{'Asparagus',\r\n 'Broccoli',\r\n 'Kale',\r\n 'Radicchio',\r\n 'Rhubarb',\r\n 'Spinach',\r\n 'Sweet Potato',\r\n 'Watercress'}\r\n```\r\n\r\n\r\n### Set Differences\r\n\r\n`<set>.difference(*<other iterables>)` returns a new `set` with elements from the original `<set>` that are not in `<others>`.\r\nThe operator version of this method is `<set> - <other set 1> - <other set 2> - ...<other set n>`.\r\n\r\n```python\r\n>>> berries_and_veggies = {'Asparagus', \r\n                          'Broccoli', \r\n                          'Watercress', \r\n                          'Goji Berries', \r\n                          'Goose Berries', \r\n                          'Ramps', \r\n                          'Walking Onions', \r\n                          'Blackberries', \r\n                          'Strawberries', \r\n                          'Rhubarb', \r\n                          'Kale', \r\n                          'Artichokes', \r\n                          'Currants'}\r\n\r\n>>> veggies = ('Asparagus', 'Broccoli', 'Watercress', 'Ramps',\r\n               'Walking Onions', 'Rhubarb', 'Kale', 'Artichokes')\r\n\r\n# Methods will take any iterable as an argument.\r\n>>> berries = berries_and_veggies.difference(veggies)\r\n{'Blackberries','Currants','Goji Berries',\r\n 'Goose Berries', 'Strawberries'}\r\n\r\n# Operators require sets.\r\n>>> berries_and_veggies - berries\r\n{'Artichokes','Asparagus','Broccoli','Kale',\r\n'Ramps','Rhubarb','Walking Onions','Watercress'}\r\n```\r\n\r\n\r\n# Set Symmetric Difference\r\n\r\n`<set>.symmetric_difference(<other iterable>)` returns a new `set` that contains elements that are in `<set>` OR `<other>`, **but not in both**.\r\nThe operator version of this method is  `<set> ^ <other set>`:\r\n\r\n\r\n```python\r\n>>> plants_1 = {'üå≤','üçà','üåµ', 'ü•ë','üå¥', 'ü•≠'}\r\n>>> plants_2 = ('üå∏','üå¥', 'üå∫', 'üå≤', 'üåª', 'üåµ')\r\n\r\n\r\n# Methods will take any iterable as an argument.\r\n>>> fruit_and_flowers = plants_1.symmetric_difference(plants_2)\r\n>>> fruit_and_flowers\r\n{'üå∏', 'üå∫', 'üçà', 'ü•ë', 'ü•≠','üåª' }\r\n\r\n\r\n# Operators require both groups be sets.\r\n>>> fruit_and_flowers ^ plants_1\r\n{'üå≤',  'üå∏', 'üå¥', 'üåµ','üå∫', 'üåª'}\r\n\r\n>>> fruit_and_flowers ^ plants_2\r\n{ 'ü•ë', 'üå¥','üå≤', 'üåµ', 'üçà', 'ü•≠'}\r\n```\r\n\r\n~~~~exercism/note\r\n\r\nA symmetric difference of more than two sets will result in a `set` that includes both the elements unique to each `set` AND elements shared between more than two sets in the series (_details in the Wikipedia article on [symmetric difference][symmetric_difference]_).  \r\n\r\nTo obtain only items unique to each `set` in the series, intersections between all 2-set combinations need to be aggregated in a separate step, and removed:  \r\n\r\n\r\n```python\r\n>>> one = {'black pepper','breadcrumbs','celeriac','chickpea flour',\r\n           'flour','lemon','parsley','salt','soy sauce',\r\n           'sunflower oil','water'}\r\n\r\n>>> two = {'black pepper','cornstarch','garlic','ginger',\r\n           'lemon juice','lemon zest','salt','soy sauce','sugar',\r\n           'tofu','vegetable oil','vegetable stock','water'}\r\n\r\n>>> three = {'black pepper','garlic','lemon juice','mixed herbs',\r\n             'nutritional yeast', 'olive oil','salt','silken tofu',\r\n             'smoked tofu','soy sauce','spaghetti','turmeric'}\r\n\r\n>>> four = {'barley malt','bell pepper','cashews','flour',\r\n            'fresh basil','garlic','garlic powder', 'honey',\r\n            'mushrooms','nutritional yeast','olive oil','oregano',\r\n            'red onion', 'red pepper flakes','rosemary','salt',\r\n            'sugar','tomatoes','water','yeast'}\r\n\r\n>>> intersections = (one & two | one & three | one & four | \r\n                     two & three | two & four | three & four)\r\n...\r\n{'black pepper','flour','garlic','lemon juice','nutritional yeast', \r\n'olive oil','salt','soy sauce', 'sugar','water'}\r\n\r\n# The ^ operation will include some of the items in intersections, \r\n# which means it is not a \"clean\" symmetric difference - there\r\n# are overlapping members.\r\n>>> (one ^ two ^ three ^ four) & intersections\r\n{'black pepper', 'garlic', 'soy sauce', 'water'}\r\n\r\n# Overlapping members need to be removed in a separate step\r\n# when there are more than two sets that need symmetric difference.\r\n>>> (one ^ two ^ three ^ four) - intersections\r\n...\r\n{'barley malt','bell pepper','breadcrumbs', 'cashews','celeriac',\r\n  'chickpea flour','cornstarch','fresh basil', 'garlic powder',\r\n  'ginger','honey','lemon','lemon zest','mixed herbs','mushrooms',\r\n  'oregano','parsley','red onion','red pepper flakes','rosemary',\r\n  'silken tofu','smoked tofu','spaghetti','sunflower oil', 'tofu', \r\n  'tomatoes','turmeric','vegetable oil','vegetable stock','yeast'}\r\n```\r\n\r\n[symmetric_difference]: https://en.wikipedia.org/wiki/Symmetric_difference\r\n~~~~\r\n\r\n[hashable]: https://docs.python.org/3.7/glossary.html#term-hashable\r\n[intersection]: https://www.mathgoodies.com/lessons/sets/intersection\r\n[mathematical-sets]: https://en.wikipedia.org/wiki/Set_theory#Basic_concepts_and_notation\r\n[operator]: https://www.computerhope.com/jargon/o/operator.htm\r\n[type-frozenset]: https://docs.python.org/3/library/stdtypes.html#frozenset\r\n[type-set]: https://docs.python.org/3/library/stdtypes.html#set\r\n",
    "hints": "# Hints\r\n\r\n## General\r\n\r\n- [Sets][sets] are mutable, unordered collections with no duplicate elements.\r\n- Sets can contain any data type, as long as all elements are [hashable][hashable].\r\n- Sets are [iterable][iterable].\r\n- Sets are most often used to quickly dedupe other collections or for membership testing.\r\n- Sets also support mathematical operations like `union`, `intersection`, `difference`, and `symmetric difference`\r\n\r\n## 1. Clean up Dish Ingredients\r\n\r\n- The `set()` constructor can take any [iterable][iterable] as an argument. [concept: lists](/tracks/python/concepts/lists) are iterable.\r\n- Remember: [concept: tuples](/tracks/python/concepts/tuples) can be formed using `(<element_1>, <element_2>)` or via the `tuple()` constructor.\r\n\r\n## 2. Cocktails and Mocktails\r\n\r\n- A `set` is _disjoint_ from another set if the two sets share no elements.\r\n- The `set()` constructor can take any [iterable][iterable] as an argument. [concept: lists](/tracks/python/concepts/lists) are iterable.\r\n- In Python, [concept: strings](/tracks/python/concepts/strings) can be concatenated with the `+` sign.\r\n\r\n## 3. Categorize Dishes\r\n\r\n- Using [concept: loops](/tracks/python/concepts/loops) to iterate through the available meal categories might be useful here.\r\n- If all the elements of `<set_1>` are contained within `<set_2>`, then `<set_1> <= <set_2>`.\r\n- The method equivalent of `<=` is `<set>.issubset(<iterable>)`\r\n- [concept: tuples](/tracks/python/concepts/tuples) can contain any data type, including other tuples.  Tuples can be formed using `(<element_1>, <element_2>)` or via the `tuple()` constructor.\r\n- Elements within [concept: tuples](/tracks/python/concepts/tuples) can be accessed from the left using a 0-based index number, or from the right using a -1-based index number.\r\n- The `set()` constructor can take any [iterable][iterable] as an argument. [concept: lists](/tracks/python/concepts/lists) are iterable.\r\n- [concept: strings](/tracks/python/concepts/strings) can be concatenated with the `+` sign.\r\n\r\n## 4. Label Allergens and Restricted Foods\r\n\r\n- A set _intersection_ are the elements shared between `<set_1>` and `<set_2>`.\r\n- The set method equivalent of `&` is `<set>.intersection(<iterable>)`\r\n- Elements within [concept: tuples](/tracks/python/concepts/tuples) can be accessed from the left using a 0-based index number, or from the right using a -1-based index number.\r\n- The `set()` constructor can take any [iterable][iterable] as an argument.  [concept: lists](/tracks/python/concepts/lists) are iterable.\r\n- [concept: tuples](/tracks/python/concepts/tuples) can be formed using `(<element_1>, <element_2>)` or via the `tuple()` constructor.\r\n\r\n## 5. Compile a \"Master List\" of Ingredients\r\n\r\n- A set _union_ is where `<set_1`> and `<set_2>`  are combined into a single `set`\r\n- The set method equivalent of `|` is `<set>.union(<iterable>)`\r\n- Using [concept: loops](/tracks/python/concepts/loops) to iterate through the various dishes might be useful here.\r\n\r\n## 6. Pull out Appetizers for Passing on Trays\r\n\r\n- A set _difference_ is where the elements of  `<set_2>`  are removed from `<set_1>`, e.g. `<set_1> - <set_2>`.\r\n- The set method equivalent of `-` is `<set>.difference(<iterable>)`\r\n- The `set()` constructor can take any [iterable][iterable] as an argument. [concept: lists](/tracks/python/concepts/lists) are iterable.\r\n- The [concept: list](/tracks/python/concepts/lists) constructor can take any [iterable][iterable] as an argument. Sets are iterable.\r\n\r\n## 7. Find Ingredients Used in Only One Recipe\r\n\r\n- A set _symmetric difference_ is where  elements appear in `<set_1>` or `<set_2>`, but not **_both_** sets.\r\n- A set _symmetric difference_ is the same as subtracting the `set` _intersection_ from the `set` _union_, e.g. `(<set_1> | <set_2>) - (<set_1> & <set_2>)`\r\n- A _symmetric difference_ of more than two `sets` will include elements that are repeated more than two times across the input `sets`.  To remove these cross-set repeated elements, the _intersections_ between set pairs needs to be subtracted from the symmetric difference.\r\n- Using [concept: loops](/tracks/python/concepts/loops) to iterate through the various dishes might be useful here.\r\n\r\n\r\n[hashable]: https://docs.python.org/3.7/glossary.html#term-hashable\r\n[iterable]: https://docs.python.org/3/glossary.html#term-iterable\r\n[sets]: https://docs.python.org/3/tutorial/datastructures.html#sets",
    "instructions": "# Instructions\r\n\r\nYou and your business partners operate a small catering company. You've just agreed to run an event for a local cooking club that features \"club favorite\" dishes. The club is inexperienced in hosting large events, and needs help with organizing, shopping, prepping and serving. You've decided to write some small Python scripts to speed the whole planning process along.\r\n\r\n## 1. Clean up Dish Ingredients\r\n\r\nThe event recipes were added from various sources and their ingredients appear to have duplicate (_or more_) entries ‚Äî you don't want to end up purchasing excess items!\r\n Before the shopping and cooking can commence, each dish's ingredient list needs to be \"cleaned\".\r\n\r\nImplement the `clean_ingredients(<dish_name>, <dish_ingredients>)` function that takes the name of a dish and a `list` of ingredients.\r\n This function should return a `tuple` with the name of the dish as the first item, followed by the de-duped `set` of ingredients.\r\n\r\n\r\n```python\r\n>>> clean_ingredients('Punjabi-Style Chole', ['onions', 'tomatoes', 'ginger paste', 'garlic paste', 'ginger paste', 'vegetable oil', 'bay leaves', 'cloves', 'cardamom', 'cilantro', 'peppercorns', 'cumin powder', 'chickpeas', 'coriander powder', 'red chili powder', 'ground turmeric', 'garam masala', 'chickpeas', 'ginger', 'cilantro'])\r\n\r\n>>> ('Punjabi-Style Chole', {'garam masala', 'bay leaves', 'ground turmeric', 'ginger', 'garlic paste', 'peppercorns', 'ginger paste', 'red chili powder', 'cardamom', 'chickpeas', 'cumin powder', 'vegetable oil', 'tomatoes', 'coriander powder', 'onions', 'cilantro', 'cloves'})\r\n```\r\n\r\n## 2. Cocktails and Mocktails\r\n\r\nThe event is going to include both cocktails and \"mocktails\" - mixed drinks _without_ the alcohol.\r\n You need to ensure that \"mocktail\" drinks are truly non-alcoholic and the cocktails do indeed _include_ alcohol.\r\n\r\nImplement the `check_drinks(<drink_name>, <drink_ingredients>)` function that takes the name of a drink and a `list` of ingredients.\r\n The function should return the name of the drink followed by \"Mocktail\" if the drink has no alcoholic ingredients, and drink name followed by \"Cocktail\" if the drink includes alcohol.\r\n  For the purposes of this exercise, cocktails will only include alcohols from the ALCOHOLS constant in `sets_categories_data.py`:\r\n\r\n```python\r\n>>> from sets_categories_data import ALCOHOLS \r\n\r\n>>> check_drinks('Honeydew Cucumber', ['honeydew', 'coconut water', 'mint leaves', 'lime juice', 'salt', 'english cucumber'])\r\n...\r\n'Honeydew Cucumber Mocktail'\r\n\r\n>>> check_drinks('Shirley Tonic', ['cinnamon stick', 'scotch', 'whole cloves', 'ginger', 'pomegranate juice', 'sugar', 'club soda'])\r\n...\r\n'Shirley Tonic Cocktail'\r\n```\r\n\r\n## 3. Categorize Dishes\r\n\r\nThe guest list includes diners with different dietary needs, and your staff will need to separate the dishes into Vegan, Vegetarian, Paleo, Keto, and Omnivore.\r\n\r\nImplement the `categorize_dish(<dish_name>, <dish_ingredients>)` function that takes a dish name and a `set` of that dish's ingredients.\r\nThe function should return a string with the `dish name: <CATEGORY>` (_which meal category the dish belongs to_).\r\nAll dishes will \"fit\" into one of the categories imported from `sets_categories_data.py` (VEGAN, VEGETARIAN, PALEO, KETO, or OMNIVORE).\r\n\r\n```python\r\n>>> from sets_categories_data import VEGAN, VEGETARIAN, PALEO, KETO, OMNIVORE\r\n\r\n\r\n>>> categorize_dish('Sticky Lemon Tofu', {'tofu', 'soy sauce', 'salt', 'black pepper', 'cornstarch', 'vegetable oil', 'garlic', 'ginger', 'water', 'vegetable stock', 'lemon juice', 'lemon zest', 'sugar'})\r\n...\r\n'Sticky Lemon Tofu: VEGAN'\r\n\r\n>>> categorize_dish('Shrimp Bacon and Crispy Chickpea Tacos with Salsa de Guacamole', {'shrimp', 'bacon', 'avocado', 'chickpeas', 'fresh tortillas', 'sea salt', 'guajillo chile', 'slivered almonds', 'olive oil', 'butter', 'black pepper', 'garlic', 'onion'})\r\n...\r\n'Shrimp Bacon and Crispy Chickpea Tacos with Salsa de Guacamole: OMNIVORE'\r\n```\r\n\r\n## 4. Label Allergens and Restricted Foods\r\n\r\nSome guests have allergies and additional dietary restrictions.\r\nThese ingredients need to be tagged/annotated for each dish so that they don't cause issues.\r\n\r\nImplement the `tag_special_ingredients(<dish>)` function that takes a `tuple` with the dish name in the first position, and a `list` or `set` of ingredients for that dish in the second position.\r\nReturn the dish name followed by the `set` of ingredients that require a special note on the dish description.\r\nDish ingredients inside a `list` may or may not have duplicates.\r\n For the purposes of this exercise, all allergens or special ingredients that need to be labeled are in the SPECIAL_INGREDIENTS constant imported from `sets_categories_data.py`.\r\n\r\n```python\r\n>>> from sets_categories_data import SPECIAL_INGREDIENTS\r\n\r\n>>> tag_special_ingredients(('Ginger Glazed Tofu Cutlets', ['tofu', 'soy sauce', 'ginger', 'corn starch', 'garlic', 'brown sugar', 'sesame seeds', 'lemon juice']))\r\n...\r\n('Ginger Glazed Tofu Cutlets', {'garlic','soy sauce','tofu'})\r\n\r\n>>> tag_special_ingredients(('Arugula and Roasted Pork Salad', ['pork tenderloin', 'arugula', 'pears', 'blue cheese', 'pine nuts', 'balsamic vinegar', 'onions', 'black pepper']))\r\n...\r\n('Arugula and Roasted Pork Salad', {'pork tenderloin', 'blue cheese', 'pine nuts', 'onions'})\r\n```\r\n\r\n## 5. Compile a \"Master List\" of Ingredients\r\n\r\nIn preparation for ordering and shopping, you'll need to compile a \"master list\" of ingredients for everything on the menu (_quantities to be filled in later_).\r\n\r\nImplement the `compile_ingredients(<dishes>)` function that takes a `list` of dishes and returns a set of all ingredients in all listed dishes.\r\nEach individual dish is represented by its `set` of ingredients.\r\n\r\n```python\r\ndishes = [ {'tofu', 'soy sauce', 'ginger', 'corn starch', 'garlic', 'brown sugar', 'sesame seeds', 'lemon juice'},\r\n           {'pork tenderloin', 'arugula', 'pears', 'blue cheese', 'pine nuts',\r\n           'balsamic vinegar', 'onions', 'black pepper'},\r\n           {'honeydew', 'coconut water', 'mint leaves', 'lime juice', 'salt', 'english cucumber'}]\r\n\r\n>>> compile_ingredients(dishes)\r\n...\r\n{'arugula', 'brown sugar', 'honeydew', 'coconut water', 'english cucumber', 'balsamic vinegar', 'mint leaves', 'pears', 'pork tenderloin', 'ginger', 'blue cheese', 'soy sauce', 'sesame seeds', 'black pepper', 'garlic', 'lime juice', 'corn starch', 'pine nuts', 'lemon juice', 'onions', 'salt', 'tofu'}\r\n```\r\n\r\n## 6. Pull out Appetizers for Passing on Trays\r\n\r\nThe hosts have given you a list of dishes they'd like prepped as \"bite-sized\" appetizers to be served on trays.\r\n You need to pull these from the main list of dishes being prepared as larger servings.\r\n\r\nImplement the `separate_appetizers(<dishes>, <appetizers>)` function that takes a `list` of dish names and a `list` of appetizer names.\r\nThe function should return the `list` of dish names with appetizer names removed.\r\nEither the `<dishes>` or `<appetizers>` `list` could contain duplicates and may require de-duping.\r\n\r\n```python\r\ndishes =    ['Avocado Deviled Eggs','Flank Steak with Chimichurri and Asparagus', 'Kingfish Lettuce Cups',\r\n             'Grilled Flank Steak with Caesar Salad','Vegetarian Khoresh Bademjan','Avocado Deviled Eggs',\r\n             'Barley Risotto','Kingfish Lettuce Cups']\r\n          \r\nappetizers = ['Kingfish Lettuce Cups','Avocado Deviled Eggs','Satay Steak Skewers',\r\n              'Dahi Puri with Black Chickpeas','Avocado Deviled Eggs','Asparagus Puffs',\r\n              'Asparagus Puffs']\r\n              \r\n>>> separate_appetizers(dishes, appetizers)\r\n...\r\n['Vegetarian Khoresh Bademjan', 'Barley Risotto', 'Flank Steak with Chimichurri and Asparagus', \r\n 'Grilled Flank Steak with Caesar Salad']\r\n```\r\n\r\n## 7. Find Ingredients Used in Only One Recipe\r\n\r\nWithin each category (_Vegan, Vegetarian, Paleo, Keto, Omnivore_), you're going to pull out ingredients that appear in only one dish.\r\nThese \"singleton\" ingredients will be assigned a special shopper to ensure they're not forgotten in the rush to get everything else done.\r\n\r\nImplement the `singleton_ingredients(<dishes>, <INTERSECTIONS>)` function that takes a `list` of dishes and a `<CATEGORY>_INTERSECTIONS` constant for the same category.\r\nEach dish is represented by a `set` of its ingredients.\r\nEach `<CATEGORY>_INTERSECTIONS` is a `set` of ingredients that appear in more than one dish in the category.\r\nUsing set operations, your function should return a `set` of \"singleton\" ingredients (_ingredients appearing in only one dish in the category_).\r\n\r\n```python\r\nfrom sets_categories_data import example_dishes, EXAMPLE_INTERSECTION\r\n\r\n>>> singleton_ingredients(example_dishes, EXAMPLE_INTERSECTION)\r\n...\r\n{'garlic powder', 'sunflower oil', 'mixed herbs', 'cornstarch', 'celeriac', 'honey', 'mushrooms', 'bell pepper', 'rosemary', 'parsley', 'lemon', 'yeast', 'vegetable oil', 'vegetable stock', 'silken tofu', 'tofu', 'cashews', 'lemon zest', 'smoked tofu', 'spaghetti', 'ginger', 'breadcrumbs', 'tomatoes', 'barley malt', 'red pepper flakes', 'oregano', 'red onion', 'fresh basil'}\r\n```\r\n",
    "design": "## Goal\r\n\r\nThe goal of this exercise is to teach the basics of [`sets`][set type] (_set type_) in Python.\r\n\r\n\r\n## Learning objectives\r\n\r\n*  understand that a set is an **unordered collection of distinct hashable objects**\r\n*  create a `set` via constructor (`set()`) and  literal (`{}`)\r\n*  de-dupe a list of elements by converting a sequence type such as a `list` to a `set` type\r\n*  check for a membership of an element in a given set via `in`\r\n*  set comparison functions and set comparison operators (`=<`, `>=`, `issubset()`, `issuperset()`, etc.)\r\n*  additional set operators (`union`, `intersection`, `difference`, and `symmetric_difference`)\r\n*  add values to a given set via `add()`\r\n*  remove values from a given set via `discard()`\r\n*  iterate through a given set by using `for item in <set>` and `for index, item in enumerate(<set>)`\r\n*  understand that iterating through a set twince may result in a different iteration order (_sets are unordered_)\r\n\r\n## Out of scope\r\n\r\n*  `frozenset()`\r\n*  `clear()` to delete all elements of a set\r\n*  check the length of a given set via `len()`\r\n*  `remove` as opposed to `discard` (_`remove` tosses a `keyerror` if the element is not present_)\r\n*   all forms/variants of `update()`\r\n*  remove (and use) a value from a given set via `pop()`\r\n*  make shallow copy(s) of a given set via `copy()`\r\n*  using additional builtins such as `sorted()`, `min()`, or `map()` with a set\r\n*  set comprehensions\r\n\r\n## Concepts\r\n\r\n*  `sets`\r\n*  [`hashable`][term-hashable] objects\r\n* `set` comparisons\r\n* `set` operations\r\n\r\n## Prerequisites\r\n\r\n* `basics`\r\n* `booleans`\r\n* `comparisons`\r\n* `dicts`\r\n* `lists`\r\n* `loops`\r\n\r\n## Resources to refer to\r\n\r\n*  [Set Types (Python Official Docs)][set types](https://docs.python.org/3/library/stdtypes.html#set-types-set-frozenset)\r\n*   [Hashable (Python Official Docs Glossary)][term-hashable]\r\n*  [immutable (Python Official Docs Glossary)][term-immutable]\r\n\r\n### Hints\r\n\r\nHints should link to the `Sets` section of the Python docs tutorial: [Sets][sets-tutorial], or equivelent resources.\r\n\r\n\r\n### After\r\n\r\nAfter, the student can explore comprehension syntax, although it will be taught in separate exercises. This would also be a good time to explore set comparisons via function &/or operator, or experimenting with the `issuperset()` & `issubset()` functions.\r\n\r\n\r\n\r\n[set type]: https://github.com/exercism/v3/blob/master/languages/python/reference/concepts/builtin_types/set.md\r\n[set types]: https://docs.python.org/3/library/stdtypes.html#set-types-set-frozenset\r\n[sets-tutorial]: https://docs.python.org/3/tutorial/datastructures.html#sets\r\n[term-hashable]: https://docs.python.org/3/glossary.html#term-hashable\r\n[term-immutable]: https://docs.python.org/3/glossary.html#term-immutable"
  },
  "config": {
    "authors": [
      "bethanyg"
    ],
    "contributors": [
      "zepam"
    ],
    "files": {
      "solution": [
        "sets.py"
      ],
      "test": [
        "sets_test.py"
      ],
      "exemplar": [
        ".meta/exemplar.py"
      ],
      "editor": [
        "sets_test_data.py",
        "sets_categories_data.py"
      ]
    },
    "icon": "meetup",
    "blurb": "Learn about sets by managing the menus and ingredients for your catering company's event."
  },
  "starter_code": "\"\"\"Functions for compiling dishes and ingredients for a catering company.\"\"\"\r\n\r\n\r\nfrom sets_categories_data import (VEGAN,\r\n                                  VEGETARIAN,\r\n                                  KETO,\r\n                                  PALEO,\r\n                                  OMNIVORE,\r\n                                  ALCOHOLS,\r\n                                  SPECIAL_INGREDIENTS)\r\n\r\n\r\ndef clean_ingredients(dish_name, dish_ingredients):\r\n    \"\"\"Remove duplicates from `dish_ingredients`.\r\n\r\n    :param dish_name: str - containing the dish name.\r\n    :param dish_ingredients: list - dish ingredients.\r\n    :return: tuple - containing (dish_name, ingredient set).\r\n\r\n    This function should return a `tuple` with the name of the dish as the first item,\r\n    followed by the de-duped `set` of ingredients as the second item.\r\n    \"\"\"\r\n\r\n    pass\r\n\r\n\r\ndef check_drinks(drink_name, drink_ingredients):\r\n    \"\"\"Append \"Cocktail\" (alcohol)  or \"Mocktail\" (no alcohol) to `drink_name`, based on `drink_ingredients`.\r\n\r\n    :param drink_name: str - name of the drink.\r\n    :param drink_ingredients: list - ingredients in the drink.\r\n    :return: str - drink_name appended with \"Mocktail\" or \"Cocktail\".\r\n\r\n    The function should return the name of the drink followed by \"Mocktail\" (non-alcoholic) and drink\r\n    name followed by \"Cocktail\" (includes alcohol).\r\n\r\n    \"\"\"\r\n\r\n    pass\r\n\r\n\r\ndef categorize_dish(dish_name, dish_ingredients):\r\n    \"\"\"Categorize `dish_name` based on `dish_ingredients`.\r\n\r\n    :param dish_name: str - dish to be categorized.\r\n    :param dish_ingredients: set - ingredients for the dish.\r\n    :return: str - the dish name appended with \": <CATEGORY>\".\r\n\r\n    This function should return a string with the `dish name: <CATEGORY>` (which meal category the dish belongs to).\r\n    `<CATEGORY>` can be any one of  (VEGAN, VEGETARIAN, PALEO, KETO, or OMNIVORE).\r\n    All dishes will \"fit\" into one of the categories imported from `sets_categories_data.py`\r\n\r\n    \"\"\"\r\n\r\n    pass\r\n\r\n\r\ndef tag_special_ingredients(dish):\r\n    \"\"\"Compare `dish` ingredients to `SPECIAL_INGREDIENTS`.\r\n\r\n    :param dish: tuple - of (dish name, list of dish ingredients).\r\n    :return: tuple - containing (dish name, dish special ingredients).\r\n\r\n    Return the dish name followed by the `set` of ingredients that require a special note on the dish description.\r\n    For the purposes of this exercise, all allergens or special ingredients that need to be tracked are in the\r\n    SPECIAL_INGREDIENTS constant imported from `sets_categories_data.py`.\r\n    \"\"\"\r\n\r\n    pass\r\n\r\n\r\ndef compile_ingredients(dishes):\r\n    \"\"\"Create a master list of ingredients.\r\n\r\n    :param dishes: list - of dish ingredient sets.\r\n    :return: set - of ingredients compiled from `dishes`.\r\n\r\n    This function should return a `set` of all ingredients from all listed dishes.\r\n    \"\"\"\r\n\r\n    pass\r\n\r\n\r\ndef separate_appetizers(dishes, appetizers):\r\n    \"\"\"Determine which `dishes` are designated `appetizers` and remove them.\r\n\r\n    :param dishes: list - of dish names.\r\n    :param appetizers: list - of appetizer names.\r\n    :return: list - of dish names that do not appear on appetizer list.\r\n\r\n    The function should return the list of dish names with appetizer names removed.\r\n    Either list could contain duplicates and may require de-duping.\r\n    \"\"\"\r\n\r\n    pass\r\n\r\n\r\ndef singleton_ingredients(dishes, intersection):\r\n    \"\"\"Determine which `dishes` have a singleton ingredient (an ingredient that only appears once across dishes).\r\n\r\n    :param dishes: list - of ingredient sets.\r\n    :param intersection: constant - can be one of `<CATEGORY>_INTERSECTIONS` constants imported from `sets_categories_data.py`.\r\n    :return: set - containing singleton ingredients.\r\n\r\n    Each dish is represented by a `set` of its ingredients.\r\n\r\n    Each `<CATEGORY>_INTERSECTIONS` is an `intersection` of all dishes in the category. `<CATEGORY>` can be any one of:\r\n        (VEGAN, VEGETARIAN, PALEO, KETO, or OMNIVORE).\r\n\r\n    The function should return a `set` of ingredients that only appear in a single dish.\r\n    \"\"\"\r\n\r\n    pass\r\n",
  "exemplar_code": "\"\"\"Functions for compiling dishes and ingredients for a catering company.\"\"\"\r\n\r\n\r\nfrom sets_categories_data import (VEGAN,\r\n                                  VEGETARIAN,\r\n                                  KETO,\r\n                                  PALEO,\r\n                                  OMNIVORE,\r\n                                  ALCOHOLS,\r\n                                  SPECIAL_INGREDIENTS)\r\n\r\n\r\ndef clean_ingredients(dish_name, dish_ingredients):\r\n    \"\"\"Remove duplicates from `dish_ingredients`.\r\n\r\n    :param dish_name: str - containing the dish name.\r\n    :param dish_ingredients: list - dish ingredients.\r\n    :return: tuple - containing (dish_name, ingredient set).\r\n\r\n    This function should return a `tuple` with the name of the dish as the first item,\r\n    followed by the de-duped `set` of ingredients as the second item.\r\n    \"\"\"\r\n\r\n    return dish_name, set(dish_ingredients)\r\n\r\n\r\ndef check_drinks(drink_name, drink_ingredients):\r\n    \"\"\"Append \"Cocktail\" (alcohol)  or \"Mocktail\" (no alcohol) to `drink_name`, based on `drink_ingredients`.\r\n\r\n    :param drink_name: str - name of the drink.\r\n    :param drink_ingredients: list - ingredients in the drink.\r\n    :return: str - drink_name appended with \"Mocktail\" or \"Cocktail\".\r\n\r\n    The function should return the name of the drink followed by \"Mocktail\" (non-alcoholic) and drink\r\n    name followed by \"Cocktail\" (includes alcohol).\r\n    \"\"\"\r\n\r\n    if not ALCOHOLS.isdisjoint(drink_ingredients):\r\n        return drink_name + ' Cocktail'\r\n\r\n    return drink_name + ' Mocktail'\r\n\r\n\r\ndef categorize_dish(dish_name, dish_ingredients):\r\n    \"\"\"Categorize `dish_name` based on `dish_ingredients`.\r\n\r\n    :param dish_name: str - dish to be categorized.\r\n    :param dish_ingredients: list - ingredients for the dish.\r\n    :return: str - the dish name appended with \": <CATEGORY>\".\r\n\r\n    This function should return a string with the `dish name: <CATEGORY>` (which meal category the dish belongs to).\r\n    `<CATEGORY>` can be any one of  (VEGAN, VEGETARIAN, PALEO, KETO, or OMNIVORE).\r\n    All dishes will \"fit\" into one of the categories imported from `sets_categories_data.py`\r\n\r\n    \"\"\"\r\n\r\n    categories = ((VEGAN, 'VEGAN'),\r\n                  (VEGETARIAN, 'VEGETARIAN'),\r\n                  (KETO, 'KETO'),\r\n                  (PALEO, 'PALEO'),\r\n                  (OMNIVORE, 'OMNIVORE'))\r\n\r\n    for category in categories:\r\n        if set(dish_ingredients) <= category[0]:\r\n            return dish_name + ': ' + category[1]\r\n    return None\r\n\r\n\r\ndef tag_special_ingredients(dish):\r\n    \"\"\"Compare `dish` ingredients to `SPECIAL_INGREDIENTS`.\r\n\r\n    :param dish: tuple - of (dish name, list of dish ingredients).\r\n    :return: tuple - containing (dish name, dish special ingredients).\r\n\r\n    Return the dish name followed by the `set` of ingredients that require a special note on the dish description.\r\n    For the purposes of this exercise, all allergens or special ingredients that need to be tracked are in the\r\n    SPECIAL_INGREDIENTS constant imported from `sets_categories_data.py`.\r\n    \"\"\"\r\n\r\n    return dish[0], (SPECIAL_INGREDIENTS & set(dish[1]))\r\n\r\n\r\ndef compile_ingredients(dishes):\r\n    \"\"\"Create a master list of ingredients.\r\n\r\n    :param dishes: list - of dish ingredient sets.\r\n    :return: set - of ingredients compiled from `dishes`.\r\n\r\n    This function should return a `set` of all ingredients from all listed dishes.\r\n    \"\"\"\r\n\r\n    combined_ingredients = set()\r\n\r\n    for ingredients in dishes:\r\n        combined_ingredients = combined_ingredients.union(ingredients)\r\n\r\n    return combined_ingredients\r\n\r\n\r\ndef separate_appetizers(dishes, appetizers):\r\n    \"\"\"Determine which `dishes` are designated `appetizers` and remove them.\r\n\r\n    :param dishes: list - of dish names.\r\n    :param appetizers: list - of appetizer names.\r\n    :return: list - of dish names that do not appear on appetizer list.\r\n\r\n    The function should return the list of dish names with appetizer names removed.\r\n    Either list could contain duplicates and may require de-duping.\r\n    \"\"\"\r\n\r\n    return list(set(dishes) - set(appetizers))\r\n\r\n\r\ndef singleton_ingredients(dishes, intersection):\r\n    \"\"\"Determine which `dishes` have a singleton ingredient (an ingredient that only appears once across dishes).\r\n\r\n    :param dishes: list - of ingredient sets.\r\n    :param intersection: constant - can be one of `<CATEGORY>_INTERSECTION` constants imported from `sets_categories_data.py`.\r\n    :return: set - containing singleton ingredients.\r\n\r\n    Each dish is represented by a `set` of its ingredients.\r\n\r\n    Each `<CATEGORY>_INTERSECTION` is an `intersection` of all dishes in the category. `<CATEGORY>` can be any one of:\r\n        (VEGAN, VEGETARIAN, PALEO, KETO, or OMNIVORE).\r\n\r\n    The function should return a `set` of ingredients that only appear in a single dish.\r\n    \"\"\"\r\n\r\n    all_ingredients = set()\r\n\r\n    for ingredients in dishes:\r\n        all_ingredients = all_ingredients ^ ingredients\r\n\r\n    return all_ingredients - intersection\r\n",
  "tests": "import unittest\r\nimport pytest\r\n\r\n# pylint: disable=deprecated-module\r\nfrom sets import (clean_ingredients,\r\n                  check_drinks,\r\n                  categorize_dish,\r\n                  tag_special_ingredients,\r\n                  compile_ingredients,\r\n                  separate_appetizers,\r\n                  singleton_ingredients)\r\n\r\n\r\nfrom sets_categories_data import (VEGAN,\r\n                                  VEGETARIAN,\r\n                                  KETO,\r\n                                  PALEO,\r\n                                  OMNIVORE,\r\n                                  ALCOHOLS,\r\n                                  SPECIAL_INGREDIENTS,\r\n                                  VEGAN_INTERSECTIONS,\r\n                                  VEGETARIAN_INTERSECTIONS,\r\n                                  PALEO_INTERSECTIONS,\r\n                                  KETO_INTERSECTIONS,\r\n                                  OMNIVORE_INTERSECTIONS)\r\n\r\nfrom sets_test_data import (recipes_with_duplicates,\r\n                            recipes_without_duplicates,\r\n                            all_drinks,\r\n                            drink_names,\r\n                            dishes_categorized,\r\n                            dishes_to_special_label,\r\n                            dishes_labeled,\r\n                            ingredients_only,\r\n                            dishes_and_appetizers,\r\n                            dishes_cleaned,\r\n                            dishes_and_overlap,\r\n                            singletons)\r\n\r\n\r\nclass SetsTest(unittest.TestCase):\r\n\r\n    @pytest.mark.task(taskno=1)\r\n    def test_clean_ingredients(self):\r\n        test_data = zip(recipes_with_duplicates[::3], recipes_without_duplicates[::3])\r\n\r\n        for variant, (item, result) in enumerate(test_data, start=1):\r\n            with self.subTest(f\"variation #{variant}\", inputs=\"recipes with duplicated ingredients\",\r\n                              result=\"recipe ingredients de-duped\"):\r\n\r\n                error_msg = (f\"Expected the ingredient list for {item[0]} to be de-duplicated, \"\r\n                            \"but the ingredients were not cleaned as expected.\")\r\n\r\n                self.assertEqual(clean_ingredients(item[0], item[1]), (result[1], result[2]), msg=error_msg)\r\n\r\n    @pytest.mark.task(taskno=2)\r\n    def test_check_drinks(self):\r\n        test_data = zip(all_drinks[::2], drink_names[::2])\r\n\r\n        for variant, (item, result) in enumerate(test_data, start=1):\r\n            with self.subTest(f\"variation #{variant}\", iputs=\"all drinks\", results=\"drinks classified\"):\r\n\r\n                error_msg = f\"Expected {result} for {item}, but got something else instead.\"\r\n                self.assertEqual(check_drinks(item[0], item[1]), (result), msg=error_msg)\r\n\r\n    @pytest.mark.task(taskno=3)\r\n    def test_categorize_dish(self):\r\n        test_data = zip(sorted(recipes_without_duplicates, reverse=True)[::3], dishes_categorized[::3])\r\n\r\n        for variant, (item, result) in enumerate(test_data, start=1):\r\n            with self.subTest(f\"variation #{variant}\", inputs=\"all recipes list\", results=\"categorized dishes\"):\r\n\r\n                error_message = f\"Expected category {result} for {item[0]}, but got a different category instead.\"\r\n                self.assertEqual(categorize_dish(item[1], item[2]), (result), msg=error_message)\r\n\r\n    @pytest.mark.task(taskno=4)\r\n    def test_tag_special_ingredients(self):\r\n        test_data = zip(dishes_to_special_label[::3], dishes_labeled[::3])\r\n\r\n        for variant, (item, result)  in enumerate(test_data, start=1):\r\n            with self.subTest(f\"variation #{variant}\", inputs=\"all recipes list\", results=\"special ingredients tagged\"):\r\n\r\n                error_message = f\"Expected {result} for {item}, but got something else instead.\"\r\n                self.assertEqual(tag_special_ingredients(item), (result), msg=error_message)\r\n\r\n    @pytest.mark.task(taskno=5)\r\n    def test_compile_ingredients(self):\r\n        test_data = zip(ingredients_only, [VEGAN, VEGETARIAN, PALEO, KETO, OMNIVORE])\r\n\r\n        for variant, (item, result) in enumerate(test_data, start=1):\r\n            with self.subTest(f\"variation #{variant}\", inputs=\"all ingredients for all recipes\",\r\n                              result=\"combined list of ingredients for all dishes\"):\r\n\r\n                error_message = \"Expected a proper set of combined ingredients, but something went wrong.\"\r\n                self.assertEqual(compile_ingredients(item), (result), msg=error_message)\r\n\r\n    @pytest.mark.task(taskno=6)\r\n    def test_separate_appetizers(self):\r\n        test_data = zip(dishes_and_appetizers, dishes_cleaned)\r\n\r\n        for variant, (item, result) in enumerate(test_data, start=1):\r\n            with self.subTest(f\"variation #{variant}\", inputs=\"dishes with appetizers\", results=\"appetizers only\"):\r\n\r\n                error_message = \"Expected only appetizers returned, but some dishes remain in the group.\"\r\n                result_type_error = f\"You returned {type(separate_appetizers(item[0], item[1]))}, but a list was expected.\"\r\n                self.assertIsInstance(separate_appetizers(item[0], item[1]), list, msg=result_type_error)\r\n                self.assertEqual(sorted(separate_appetizers(item[0], item[1])), (sorted(result)), msg=error_message)\r\n\r\n    @pytest.mark.task(taskno=7)\r\n    def test_singleton_ingredients(self):\r\n        test_data = zip(dishes_and_overlap, singletons)\r\n\r\n        for variant, (item, result) in enumerate(test_data, start=1):\r\n            with self.subTest(f\"variation #{variant}\", inputs=\"overlapping ingredients\",\r\n                              results=\"ingredients in only one dish\"):\r\n\r\n                error_message = (\"Expected only ingredients that belong to exactly \"\r\n                                \"one dish, but got multi-dish ingredients instead.\")\r\n                self.assertEqual(singleton_ingredients(item[0], item[1]), (result), msg=error_message)\r\n"
}