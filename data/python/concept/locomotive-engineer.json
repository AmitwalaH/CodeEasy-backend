{
  "concept": "locomotive-engineer",
  "docs": {
    "introduction": "# Unpacking and Multiple Assignment\r\n\r\nUnpacking refers to the act of extracting the elements of a collection, such as a `list`, `tuple`, or `dict`, using iteration.\r\nUnpacked values can then be assigned to variables within the same statement, which is commonly referred to as [Multiple assignment][multiple assignment].\r\n\r\nThe special operators `*` and `**` are often used in unpacking contexts and with multiple assignment.\r\n\r\n~~~~exercism/caution\r\n`*<variable_name>` and `**<variable_name>` should not be confused with `*` and `**`. While `*` and `**` are used for multiplication and exponentiation respectively, `*<variable_name>` and `**<variable_name>` are used as packing and unpacking operators.\r\n~~~~\r\n\r\n\r\n## Multiple assignment\r\n\r\nIn multiple assignment, the number of variables on the left side of the assignment operator (`=`) must match the number of values on the right side.\r\nTo separate the values, use a comma `,`:\r\n\r\n```python\r\n>>> a, b = 1, 2\r\n>>> a\r\n1\r\n```\r\n\r\nIf the multiple assignment gets an incorrect number of variables for the values given, a `ValueError` will be thrown:\r\n\r\n```python\r\n>>> x, y, z = 1, 2\r\n\r\nValueError: too many values to unpack (expected 3, got 2)\r\n```\r\n\r\nMultiple assignment is not limited to one data type:\r\n\r\n```python\r\n>>> x, y, z = 1, \"Hello\", True\r\n>>> x\r\n1\r\n\r\n>>> y\r\n'Hello'\r\n\r\n>>> z\r\nTrue\r\n```\r\n\r\nMultiple assignment can be used to swap elements in `lists`.\r\nThis practice is pretty common in [sorting algorithms][sorting algorithms].\r\nFor example:\r\n\r\n```python\r\n>>> numbers = [1, 2]\r\n>>> numbers[0], numbers[1] = numbers[1], numbers[0]\r\n>>> numbers\r\n[2, 1]\r\n```\r\n\r\nSince `tuples` are immutable, you can't swap elements in a `tuple`.\r\n\r\n\r\n## Unpacking\r\n\r\n~~~~exercism/note\r\nThe examples below use `lists` but the same concepts apply to `tuples`.\r\n~~~~\r\n\r\nIn Python, it is possible to [unpack the elements of `list`/`tuple`/`dictionary`][unpacking] into distinct variables.\r\nSince values appear within `lists`/`tuples` in a specific order, they are unpacked into variables in the same order:\r\n\r\n```python\r\n>>> fruits = [\"apple\", \"banana\", \"cherry\"]\r\n>>> x, y, z = fruits\r\n>>> x\r\n\"apple\"\r\n```\r\n\r\nIf there are values that are not needed then you can use `_` to flag them:\r\n\r\n```python\r\n>>> fruits = [\"apple\", \"banana\", \"cherry\"]\r\n>>> _, _, z = fruits\r\n>>> z\r\n\"cherry\"\r\n```\r\n\r\n\r\n### Deep unpacking\r\n\r\nUnpacking and assigning values from a `list`/`tuple` enclosed inside a `list` or `tuple` (_also known as nested lists/tuples_) works in the same way a shallow unpacking does â€” but often needs qualifiers to clarify the context or position:\r\n\r\n```python\r\n>>> fruits_vegetables = [[\"apple\", \"banana\"], [\"carrot\", \"potato\"]]\r\n>>> [[a, b], [c, d]] = fruits_vegetables\r\n>>> a\r\n\"apple\"\r\n\r\n>>> d\r\n\"potato\"\r\n```\r\n\r\nYou can also deeply unpack just a portion of a nested `list`/`tuple`:\r\n\r\n```python\r\n>>> fruits_vegetables = [[\"apple\", \"banana\"], [\"carrot\", \"potato\"]]\r\n>>> [a, [c, d]] = fruits_vegetables\r\n>>> a\r\n[\"apple\", \"banana\"]\r\n\r\n>>> c\r\n\"carrot\"\r\n```\r\n\r\nIf the unpacking has variables with incorrect placement and/or an incorrect number of values, you will get a `ValueError`:\r\n\r\n```python\r\n>>> fruits_vegetables = [[\"apple\", \"banana\"], [\"carrot\", \"potato\"]]\r\n>>> [[a, b], [d]] = fruits_vegetables\r\n\r\nValueError: too many values to unpack (expected 1)\r\n```\r\n\r\n### Unpacking a list/tuple with `*`\r\n\r\nWhen [unpacking a `list`/`tuple`][packing and unpacking] you can use the `*` operator to capture the \"leftover\" values.\r\nThis is clearer than slicing the `list`/`tuple` (_which in some situations is less readable_).\r\nFor example, the first element can be extracted and then the remaining values can be placed into a new `list` without the first element:\r\n\r\n```python\r\n>>> fruits = [\"apple\", \"banana\", \"cherry\", \"orange\", \"kiwi\", \"melon\", \"mango\"]\r\n>>> x, *last = fruits\r\n>>> x\r\n\"apple\"\r\n\r\n>>> last\r\n[\"banana\", \"cherry\", \"orange\", \"kiwi\", \"melon\", \"mango\"]\r\n```\r\n\r\nWe can also extract the values at the beginning and end of the `list` while grouping all the values in the middle:\r\n\r\n```python\r\n>>> fruits = [\"apple\", \"banana\", \"cherry\", \"orange\", \"kiwi\", \"melon\", \"mango\"]\r\n>>> x, *middle, y, z = fruits\r\n>>> y\r\n\"melon\"\r\n\r\n>>> middle\r\n[\"banana\", \"cherry\", \"orange\", \"kiwi\"]\r\n```\r\n\r\nWe can also use `*` in deep unpacking:\r\n\r\n```python\r\n>>> fruits_vegetables = [[\"apple\", \"banana\", \"melon\"], [\"carrot\", \"potato\", \"tomato\"]]\r\n>>> [[a, *rest], b] = fruits_vegetables\r\n>>> a\r\n\"apple\"\r\n\r\n>>> rest\r\n[\"banana\", \"melon\"]\r\n```\r\n\r\n### Unpacking a dictionary\r\n\r\n[Unpacking a dictionary][packing and unpacking] is a bit different from unpacking a `list`/`tuple`.\r\nIteration over dictionaries defaults to the **keys**.\r\nSo when unpacking a `dict`, you can only unpack the **keys** and not the **values**:\r\n\r\n```python\r\n>>> fruits_inventory = {\"apple\": 6, \"banana\": 2, \"cherry\": 3}\r\n>>> x, y, z = fruits_inventory\r\n>>> x\r\n\"apple\"\r\n```\r\n\r\nIf you want to unpack the values then you can use the `<dict>.values()` method:\r\n\r\n```python\r\n>>> fruits_inventory = {\"apple\": 6, \"banana\": 2, \"cherry\": 3}\r\n>>> x, y, z = fruits_inventory.values()\r\n>>> x\r\n6\r\n```\r\n\r\nIf both **keys** and **values** are needed, use the [`<dict>.items()`][items] method.\r\n`<dict>.items()` generates an [iterable view][view-objects] containing **key-value** pairs.\r\nThese can be unpacked into a `tuple`:\r\n\r\n```python\r\n>>> fruits_inventory = {\"apple\": 6, \"banana\": 2, \"cherry\": 3}\r\n>>> x, y, z = fruits_inventory.items()\r\n>>> x\r\n(\"apple\", 6)\r\n```\r\n\r\n## Packing\r\n\r\n[Packing][packing and unpacking] is the ability to group multiple values into one `list` that is assigned to a variable.\r\nThis is useful when you want to _unpack_ values, make changes, and then _pack_ the results back into a variable.\r\nIt also makes it possible to perform merges on 2 or more `lists`/`tuples`/`dicts`.\r\n\r\n### Packing a list/tuple with `*`\r\n\r\nPacking a `list`/`tuple` can be done using the `*` operator.\r\nThis will pack all the values into a `list`/`tuple`.\r\n\r\n```python\r\n>>> fruits = (\"apple\", \"banana\", \"cherry\")\r\n>>> more_fruits = [\"orange\", \"kiwi\", \"melon\", \"mango\"]\r\n\r\n# fruits and more_fruits are unpacked and then their elements are packed into combined_fruits\r\n>>> combined_fruits = *fruits, *more_fruits\r\n\r\n# If there is no * on to the left of the \"=\" the result is a tuple\r\n>>> combined_fruits\r\n(\"apple\", \"banana\", \"cherry\", \"orange\", \"kiwi\", \"melon\", \"mango\")\r\n\r\n# If the * operator is used on the left side of \"=\" the result is a list.\r\n# Note the trailing comma.\r\n>>> *combined_fruits_too, = *fruits, *more_fruits\r\n>>> combined_fruits_too\r\n['apple', 'banana', 'cherry', 'orange', 'kiwi', 'melon', 'mango']\r\n```\r\n\r\nFor more background on using `*` on the left-hand side, see [PEP 3132][pep-3132].\r\n\r\n\r\n### Packing a dictionary with `**`\r\n\r\nPacking a dictionary is done by using the `**` operator.\r\nThis will pack all **key**-**value** pairs from one dictionary into another dictionary, or combine two dictionaries together.\r\n\r\n```python\r\n>>> fruits_inventory = {\"apple\": 6, \"banana\": 2, \"cherry\": 3}\r\n>>> more_fruits_inventory = {\"orange\": 4, \"kiwi\": 1, \"melon\": 2, \"mango\": 3}\r\n\r\n# fruits_inventory and more_fruits_inventory are unpacked into key-values pairs and combined.\r\n>>> combined_fruits_inventory = {**fruits_inventory, **more_fruits_inventory}\r\n\r\n# then the pairs are packed into combined_fruits_inventory\r\n>>> combined_fruits_inventory\r\n{\"apple\": 6, \"banana\": 2, \"cherry\": 3, \"orange\": 4, \"kiwi\": 1, \"melon\": 2, \"mango\": 3}\r\n```\r\n\r\n## Usage of `*` and `**` with functions\r\n\r\n### Packing with function parameters\r\n\r\nWhen you create a function that accepts an arbitrary number of arguments, you can use [`*args` or `**kwargs`][args and kwargs] in the function definition.\r\n`*args` is used to pack an arbitrary number of positional (_non-keyword_) arguments as a `tuple` and\r\n`**kwargs` is used to pack an arbitrary number of keyword arguments as a dictionary.\r\n\r\nUsage of `*args`:\r\n\r\n```python\r\n# This function is defined to take any number of positional arguments\r\n\r\n>>> def my_function(*args):\r\n...     print(args)\r\n\r\n# Arguments given to the function are packed into a tuple\r\n\r\n>>> my_function(1, 2, 3)\r\n(1, 2, 3)\r\n\r\n>>> my_function(\"Hello\")\r\n(\"Hello\")\r\n\r\n>>> my_function(1, 2, 3, \"Hello\", \"Mars\")\r\n(1, 2, 3, \"Hello\", \"Mars\")\r\n```\r\n\r\nUsage of `**kwargs`:\r\n\r\n```python\r\n# This function is defined to take any number of keyword arguments\r\n\r\n>>> def my_function(**kwargs):\r\n...   print(kwargs)\r\n\r\n# Arguments given to the function are packed into a dictionary\r\n\r\n>>> my_function(a=1, b=2, c=3)\r\n{\"a\": 1, \"b\": 2, \"c\": 3}\r\n```\r\n\r\n`*args` and `**kwargs` can also be used in combination with one another:\r\n\r\n```python\r\n>>> def my_function(*args, **kwargs):\r\n...   print(sum(args))\r\n...   for key, value in kwargs.items():\r\n...       print(str(key) + \" = \" + str(value))\r\n\r\n>>> my_function(1, 2, 3, a=1, b=2, c=3)\r\n6\r\na = 1\r\nb = 2\r\nc = 3\r\n```\r\n\r\nYou can also write parameters before `*args` to allow for specific positional arguments.\r\nIndividual keyword arguments then have to appear before `**kwargs`.\r\n\r\n~~~~exercism/caution\r\n[Arguments have to be structured](https://www.python-engineer.com/courses/advancedpython/18-function-arguments/) like this:\r\n\r\n`def my_function(<positional_args>, *args, <key-word_args>, **kwargs)`\r\n\r\nIf you don't follow this order then you will get an error.\r\n~~~~\r\n\r\n```python\r\n>>> def my_function(a, b, *args):\r\n...   print(a)\r\n...   print(b)\r\n...   print(args)\r\n\r\n>>> my_function(1, 2, 3, 4, 5)\r\n1\r\n2\r\n(3, 4, 5)\r\n```\r\n\r\nWriting arguments in an incorrect order will result in an error:\r\n\r\n```python\r\n>>>def my_function(*args, a, b):\r\n... print(args)\r\n\r\n>>>my_function(1, 2, 3, 4, 5)\r\nTraceback (most recent call last):\r\n  File \"c:\\something.py\", line 3, in <module>\r\n    my_function(1, 2, 3, 4, 5)\r\nTypeError: my_function() missing 2 required keyword-only arguments: 'a' and 'b'\r\n```\r\n\r\n### Unpacking into function calls\r\n\r\nYou can use `*` to unpack a `list`/`tuple` of arguments into a function call.\r\nThis is very useful for functions that don't accept an `iterable`:\r\n\r\n```python\r\n>>> def my_function(a, b, c):\r\n...   print(c)\r\n...   print(b)\r\n...   print(a)\r\n\r\nnumbers = [1, 2, 3]\r\n>>> my_function(*numbers)\r\n3\r\n2\r\n1\r\n```\r\n\r\nUsing `*` unpacking with the [`zip()` built-in][zip] is another common use case.\r\nThe `zip()` function takes multiple iterables and returns a `list` of `tuples` with the values from each `iterable` grouped:\r\n\r\n```python\r\n>>> values = (['x', 'y', 'z'], [1, 2, 3], [True, False, True])\r\n>>> a, *rest = zip(*values)\r\n>>> rest\r\n[('y', 2, False), ('z', 3, True)]\r\n```\r\n\r\n[args and kwargs]: https://www.geeksforgeeks.org/args-kwargs-python/\r\n[items]: https://docs.python.org/3/library/stdtypes.html#dict.items\r\n[multiple assignment]: https://www.geeksforgeeks.org/assigning-multiple-variables-in-one-line-in-python/\r\n[packing and unpacking]: https://www.geeksforgeeks.org/packing-and-unpacking-arguments-in-python/\r\n[pep-3132]: https://peps.python.org/pep-3132/\r\n[sorting algorithms]: https://realpython.com/sorting-algorithms-python/\r\n[unpacking]: https://www.geeksforgeeks.org/unpacking-arguments-in-python/?ref=rp\r\n[view-objects]: https://docs.python.org/3/library/stdtypes.html#dict-views\r\n[zip]: https://docs.python.org/3/library/functions.html#zip\r\n",
    "hints": "# Hints\r\n\r\n## General\r\n\r\n- To extract multiple arguments in the function parameters so can you pack them with the `*args` operator for `list` or `tuples` or `**kwargs` for keyword-based arguments.\r\n- To pack or unpack use the `*` or `**` operator.\r\n\r\n## 1. Create a list of all wagons\r\n\r\n- Multiple arguments in the function parameters can be packed with the `*args` operator.\r\n\r\n## 2. Fix list of wagons\r\n\r\n- Using unpacking with the `*` operator, lets you extract the first two elements of a `list` while keeping the rest intact.\r\n- To add another `list` into an existing `list`, you can use the `*` operator to \"spread\" the `list`.\r\n\r\n## 3. Add missing stops\r\n\r\n- Using `**kwargs` as a function parameter will allow an arbitrary number of keyword arguments to be passed.\r\n- Using `**<dict>` as an argument will unpack a dictionary into keyword arguments.\r\n- You can put keyword arguments in a `{}` or `dict()`.\r\n- To get the values out of a dictionary, you can use the `<dict>.values()` method.\r\n\r\n## 4. Extend routing information\r\n\r\n- Using `**<dict>` as an argument will unpack a dictionary into keyword arguments.\r\n- You can put keyword arguments in a `{}` or `dict()`.\r\n\r\n## 5. Fix the wagon depot\r\n\r\n- `zip(*iterators)` can use used to transpose a nested `list`.\r\n- To extract data from zipped iterators, you can use a for loop.\r\n- you can also unpack zipped iterators using `*`.  \r\n  `[*content] = zip(iterator_1, iterator_2)` will unzip the `tuple` produced by `zip()` into a `list`.\r\n",
    "instructions": "# Instructions\r\n\r\nYour friend Linus is a Locomotive Engineer who drives cargo trains between cities.\r\nAlthough they are amazing at handling trains, they are not amazing at handling logistics or computers.\r\nThey would like to enlist your programming help organizing train details and correcting mistakes in route data.\r\n\r\n~~~~exercism/note\r\nThis exercise could easily be solved using slicing, indexing, and various `dict` methods.\r\nHowever, we would like you to practice packing, unpacking, and multiple assignment in solving each of the tasks below.\r\n~~~~\r\n\r\n## 1. Create a list of all wagons\r\n\r\nYour friend has been keeping track of each wagon identifier (ID), but they are never sure how many wagons the system is going to have to process at any given time. It would be much easier for the rest of the logistics program to have this data packaged into a unified `list`.\r\n\r\nImplement a function `get_list_of_wagons()` that accepts an arbitrary number of wagon IDs.\r\nEach ID will be a positive integer.\r\nThe function should then `return` the given IDs as a single `list`.\r\n\r\n```python\r\n>>> get_list_of_wagons(1, 7, 12, 3, 14, 8, 5)\r\n[1, 7, 12, 3, 14, 8, 5]\r\n```\r\n\r\n## 2. Fix the list of wagons\r\n\r\nAt this point, you are starting to get a feel for the data and how it's used in the logistics program.\r\nThe ID system always assigns the locomotive an ID of **1**, with the remainder of the wagons in the train assigned a randomly chosen ID greater than **1**.\r\n\r\nYour friend had to connect two new wagons to the train and forgot to update the system!\r\nNow, the first two wagons in the train `list` have to be moved to the end, or everything will be out of order.\r\n\r\nTo make matters more complicated, your friend just uncovered a second `list` that appears to contain missing wagon IDs.\r\nAll they can remember is that once the new wagons are moved, the IDs from this second `list` should be placed directly after the designated locomotive.\r\n\r\nLinus would be really grateful to you for fixing their mistakes and consolidating the data.\r\n\r\nImplement a function `fix_list_of_wagons()` that takes two `lists` containing wagon IDs.\r\nIt should reposition the first two items of the first `list` to the end, and insert the values from the second `list` behind (_on the right hand side of_) the locomotive ID (**1**).\r\nThe function should then `return` a `list` with the modifications.\r\n\r\n```python\r\n>>> fix_list_of_wagons([2, 5, 1, 7, 4, 12, 6, 3, 13], [3, 17, 6, 15])\r\n[1, 3, 17, 6, 15, 7, 4, 12, 6, 3, 13, 2, 5]\r\n```\r\n\r\n## 3. Add missing stops\r\n\r\nNow that all the wagon data is correct, Linus would like you to update the system's routing information.\r\nAlong a transport route, a train might make stops at a few different stations to pick up and/or drop off cargo.\r\nEach journey could have a different number of these intermediary delivery points.\r\nYour friend would like you to update the systems routing `dict` with any missing/additional delivery information.\r\n\r\nImplement a function `add_missing_stops()` that accepts a routing `dict` followed by a variable number of keyword arguments.\r\nThese arguments could be in the form of a `dict` holding one or more stops, or any number of `stop_number=city` keyword pairs.\r\nYour function should then return the routing `dict` updated with an additional `key` that holds a `list` of all the added stops in order.\r\n\r\n```python\r\n>>> add_missing_stops({\"from\": \"New York\", \"to\": \"Miami\"},\r\n                      stop_1=\"Washington, DC\", stop_2=\"Charlotte\", stop_3=\"Atlanta\",\r\n                      stop_4=\"Jacksonville\", stop_5=\"Orlando\")\r\n\r\n{\"from\": \"New York\", \"to\": \"Miami\", \"stops\": [\"Washington, DC\", \"Charlotte\", \"Atlanta\", \"Jacksonville\", \"Orlando\"]}\r\n```\r\n\r\n## 4. Extend routing information\r\n\r\nLinus has been working on the routing program and has noticed that certain routes are missing some important details.\r\nInitial route information has been constructed as a `dict` and your friend would like you to update that `dict` with whatever might be missing.\r\nEvery route in the system requires slightly different details, so Linus would really prefer a generic solution.\r\n\r\nImplement a function called `extend_route_information()` that accepts two `dicts`.\r\nThe first `dict` contains the origin and destination cities the train route runs between.\r\n\r\nThe second `dict` contains other routing details such as train speed, length, or temperature.\r\nThe function should return a consolidated `dict` with all routing information.\r\n\r\n~~~~exercism/note\r\nThe second `dict` can contain different/more properties than the ones shown in the example.\r\n~~~~\r\n\r\n```python\r\n>>> extend_route_information({\"from\": \"Berlin\", \"to\": \"Hamburg\"}, {\"length\": \"100\", \"speed\": \"50\"})\r\n{\"from\": \"Berlin\", \"to\": \"Hamburg\", \"length\": \"100\", \"speed\": \"50\"}\r\n```\r\n\r\n## 5. Fix the wagon depot\r\n\r\nWhen Linus was surveying the wagon depot they noticed that the wagons were not getting stored in the correct order.\r\nIn addition to an ID, each wagon has a color that corresponds to the type of cargo it carries.\r\nWagons are stored in the depot in grids, where each column in the grid has wagons of the same color.\r\n\r\nHowever, the logistics system shows `lists` of wagons to be stored in the depot have their _rows_ grouped by color.\r\nBut for the storage grid to work correctly, each _row_ should have three different colors so that the _columns_ align by color.\r\nYour friend would like you to sort out the wagon depot `lists`, so that the wagons get stored correctly.\r\n\r\nImplement a function called `fix_wagon_depot()` that accepts a `list` of three items.\r\nEach `list` item is a sublist (or \"row\") that contains three `tuples`.\r\nEach `tuple` is a `(<wagon ID>, <wagon color>)` pair.\r\n\r\nYour function should return a `list` with the three \"row\" `lists` reordered to have the wagons swapped into their correct positions.\r\n\r\n```python\r\n>>> fix_wagon_depot([\r\n                    [(2, \"red\"), (4, \"red\"), (8, \"red\")],\r\n                    [(5, \"blue\"), (9, \"blue\"), (13,\"blue\")],\r\n                    [(3, \"orange\"), (7, \"orange\"), (11, \"orange\")],\r\n                    ])\r\n\r\n[\r\n[(2, \"red\"), (5, \"blue\"), (3, \"orange\")],\r\n[(4, \"red\"), (9, \"blue\"), (7, \"orange\")],\r\n[(8, \"red\"), (13,\"blue\"), (11, \"orange\")]\r\n]\r\n```\r\n",
    "design": "# Design\r\n\r\n## Goal\r\n\r\nThis concept exercise is meant to teach an understanding/use of `unpacking` and the `*` (splat) and `**` (double splat) operators in Python.\r\n\r\n<br>\r\n\r\n## Learning objectives\r\n\r\n- Understand/use `unpacking` through the use of `*` and `**` _prefix_ operators in various scenarios\r\n  - `*` and `**` as _prefixes_ ..... not to be confused with `*` (_multiply_) and `**` (_exponentiation_) as _infix_, or mathematical operators (**consider a link in the links doc or a mention in dig deeper.**)\r\n  - use in arguments to `functions`\r\n  - use in argument _capture_ for `functions` (_aka passing an arbitrary number of arguments -- *args * & \\*\\*kwargs_)\r\n  - use in iterable (_mainly `tuple` and `list`_) unpacking & packing\r\n  - use in `dict` unpacking & packing\r\n- Understand/use `unpacking` via `multiple assignment`\r\n  - using `multiple assignment ` in place of `indexing`\r\n  - using `multiple assignment` + `*` in place of `slicing`\r\n  - unpacking plus \"leftovers\" via `*`\r\n- Differences between straight `multiple assignment` and `*` & `**`\r\n- Deep unpacking\r\n\r\n## Concepts\r\n\r\n- `unpacking`\r\n- `unpacking generalizations`\r\n- `multiple assignment`\r\n\r\n## Topics that are Out of scope\r\n\r\n- `classes`\r\n- `comprehensions`\r\n- `comprehensions` in `lambdas`\r\n- `map()`, `filter()` or `functools.reduce()` in a `comprehension`\r\n- `function-arguments` beyond explaining briefly how `*`, `**` work in function arguments.\r\n- `functools` beyond `functools.reduce()`(_this will get its own exercise_)\r\n- `generators`\r\n- using an `assignment expression` or \"walrus\" operator (`:=`) alone or in a `lambda`\r\n\r\n## Prerequisites\r\n\r\n- `basics`\r\n- `bools`\r\n- `comparisons`\r\n- `dicts`\r\n- `lists`\r\n- `numbers`\r\n- `strings`\r\n- `tuples`\r\n- `loops`\r\n\r\n## Representer\r\n\r\nThis exercise does not require any specific logic to be added to the [representer][representer]\r\n\r\n## Analyzer\r\n\r\nThis exercise does not require any specific logic to be added to the [analyzer][analyzer].\r\n\r\n[analyzer]: https://github.com/exercism/python-analyzer\r\n[representer]: https://github.com/exercism/python-representer\r\n"
  },
  "config": {
    "authors": [
      "meatball133",
      "BethanyG"
    ],
    "contributors": [
      "IsaacG"
    ],
    "files": {
      "solution": [
        "locomotive_engineer.py"
      ],
      "test": [
        "locomotive_engineer_test.py"
      ],
      "exemplar": [
        ".meta/exemplar.py"
      ]
    },
    "forked_from": [
      "javascript/train-driver"
    ],
    "icon": "tracks-on-tracks-on-tracks",
    "blurb": "Learn about unpacking and multiple assignment in Python while helping Linus with his train control system."
  },
  "starter_code": "\"\"\"Functions which helps the locomotive engineer to keep track of the train.\"\"\"\r\n\r\n\r\ndef get_list_of_wagons():\r\n    \"\"\"Return a list of wagons.\r\n\r\n    :param: arbitrary number of wagons.\r\n    :return: list - list of wagons.\r\n    \"\"\"\r\n    pass\r\n\r\n\r\ndef fix_list_of_wagons(each_wagons_id, missing_wagons):\r\n    \"\"\"Fix the list of wagons.\r\n\r\n    :param each_wagons_id: list - the list of wagons.\r\n    :param missing_wagons: list - the list of missing wagons.\r\n    :return: list - list of wagons.\r\n    \"\"\"\r\n    pass\r\n\r\n\r\ndef add_missing_stops():\r\n    \"\"\"Add missing stops to route dict.\r\n\r\n    :param route: dict - the dict of routing information.\r\n    :param: arbitrary number of stops.\r\n    :return: dict - updated route dictionary.\r\n    \"\"\"\r\n    pass\r\n\r\n\r\ndef extend_route_information(route, more_route_information):\r\n    \"\"\"Extend route information with more_route_information.\r\n\r\n    :param route: dict - the route information.\r\n    :param more_route_information: dict -  extra route information.\r\n    :return: dict - extended route information.\r\n    \"\"\"\r\n    pass\r\n\r\n\r\ndef fix_wagon_depot(wagons_rows):\r\n    \"\"\"Fix the list of rows of wagons.\r\n\r\n    :param wagons_rows: list[list[tuple]] - the list of rows of wagons.\r\n    :return: list[list[tuple]] - list of rows of wagons.\r\n    \"\"\"\r\n    pass\r\n",
  "exemplar_code": "\"\"\"Functions which helps the locomotive engineer to keep track of the train.\"\"\"\r\n\r\n\r\ndef get_list_of_wagons(*args):\r\n    \"\"\"Return a list of wagons.\r\n\r\n    :param *args: arbitrary number of wagons.\r\n    :return: list - list of wagons.\r\n    \"\"\"\r\n\r\n    return list(args)\r\n\r\n\r\ndef fix_list_of_wagons(each_wagons_id, missing_wagons):\r\n    \"\"\"Fix the list of wagons.\r\n\r\n    :param each_wagons_id: list - the list of wagons.\r\n    :param missing_wagons: list - the list of missing wagons.\r\n    :return: list - list of wagons.\r\n    \"\"\"\r\n\r\n    first, second, locomotive, *rest = each_wagons_id\r\n\r\n    return [locomotive, *missing_wagons, *rest, first, second]\r\n\r\n\r\ndef add_missing_stops(route, **kwargs):\r\n    \"\"\"Add missing stops to route dict.\r\n\r\n    :param route: dict - the dict of routing information.\r\n    :param **kwargs: arbitrary number of stops.\r\n    :return: dict - updated route dictionary.\r\n    \"\"\"\r\n\r\n    return {**route, \"stops\": list(kwargs.values())}\r\n\r\n\r\ndef extend_route_information(route, more_route_information):\r\n    \"\"\"Extend route information with more_route_information.\r\n\r\n    :param route: dict - the route information.\r\n    :param more_route_information: dict - extra route information.\r\n    :return: dict - extended route information.\r\n    \"\"\"\r\n\r\n    return {**route, **more_route_information}\r\n\r\n\r\ndef fix_wagon_depot(wagons_rows):\r\n    \"\"\"Fix the list of rows of wagons.\r\n\r\n    :param wagons_rows: list[tuple] - the list of rows of wagons.\r\n    :return: list[tuple] - list of rows of wagons.\r\n    \"\"\"\r\n\r\n    [*row_one], [*row_two], [*row_three] = zip(*wagons_rows)\r\n\r\n    return [row_one, row_two, row_three]\r\n",
  "tests": "import unittest\r\nimport pytest\r\nfrom locomotive_engineer import (get_list_of_wagons,\r\n                                 fix_list_of_wagons,\r\n                                 add_missing_stops,\r\n                                 extend_route_information,\r\n                                 fix_wagon_depot)\r\n\r\n\r\nclass LocomotiveEngineerTest(unittest.TestCase):\r\n\r\n    @pytest.mark.task(taskno=1)\r\n    def test_get_list_of_wagons(self):\r\n        input_data = [(1,5,2,7,4), (1,5), (1,), (1,9,3), (1,10,6,3,9,8,4,14,24,7)]\r\n        output_data = [[1,5,2,7,4], [1,5], [1], [1,9,3], [1,10,6,3,9,8,4,14,24,7]]\r\n\r\n        for variant, (input_data, expected) in enumerate(zip(input_data, output_data), start=1):\r\n            with self.subTest(f'variation #{variant}', input_data=input_data, expected=expected):\r\n\r\n                actual_result = get_list_of_wagons(*input_data)\r\n                error_msg= (f'Called get_list_of_wagons{input_data}. '\r\n                            f'The function returned {actual_result}, but the '\r\n                            f'tests expected: {expected} as the wagon list instead.')\r\n\r\n                self.assertEqual(actual_result, expected, msg=error_msg)\r\n\r\n    @pytest.mark.task(taskno=2)\r\n    def test_fix_list_of_wagons(self):\r\n        input_data = [([2, 5, 1, 7, 4, 12, 6, 3, 13], [3, 17, 6, 15]),\r\n                     ([3, 27, 1, 14, 10, 4, 12, 6, 23, 17, 13, 22, 28, 19], [8, 10, 5, 9, 36, 7, 20]),\r\n                     ([4, 2, 1], [8, 6, 15]), \r\n                     ([3, 14, 1, 25, 7, 19, 10], [8, 6, 4, 5, 9, 21, 2, 13])\r\n                     ]\r\n        output_data = [[1, 3, 17, 6, 15, 7, 4,  12, 6, 3, 13, 2, 5],\r\n                        [1, 8, 10, 5, 9, 36, 7, 20, 14, 10, 4, 12, 6, 23, 17, 13, 22, 28, 19, 3, 27], \r\n                        [1, 8, 6, 15, 4, 2], \r\n                        [1, 8, 6, 4, 5, 9, 21, 2, 13, 25, 7, 19, 10, 3, 14]\r\n                    ]\r\n        for variant, (input_data, expected) in enumerate(zip(input_data, output_data), start=1):\r\n            with self.subTest(f'variation #{variant}', input_data=input_data, expected=expected):\r\n\r\n                actual_result = fix_list_of_wagons(input_data[0], input_data[1])\r\n                error_msg= (f'Called fix_list_of_wagons({input_data[0]}, {input_data[1]}). '\r\n                            f'The function returned {actual_result}, but the '\r\n                            f'tests expected: {expected} as the wagon list instead.')\r\n\r\n                self.assertEqual(actual_result, expected, msg=error_msg)\r\n\r\n    @pytest.mark.task(taskno=3)\r\n    def test_add_missing_stops(self): \r\n        input_data = (({'from': 'Berlin', 'to': 'Hamburg'}, {'stop_1': 'Lepzig', 'stop_2': 'Hannover', 'stop_3': 'Frankfurt'}), \r\n                        ({'from': 'Paris', 'to': 'London'}, {'stop_1': 'Lille'}),\r\n                      ({'from': 'New York', 'to': 'Philadelphia'},{}),\r\n                        ({'from': 'Gothenburg', 'to': 'Copenhagen'}, {'stop_1': 'Kungsbacka', 'stop_2': 'Varberg', 'stop_3': 'Halmstad', 'stop_4': 'Angelholm', 'stop_5': 'Lund', 'stop_6': 'Malmo'})\r\n                    )\r\n        output_data = [{'from': 'Berlin', 'to': 'Hamburg', 'stops': ['Lepzig', 'Hannover', 'Frankfurt']}, \r\n                        {'from': 'Paris', 'to': 'London', 'stops': ['Lille']},\r\n                        {'from': 'New York', 'to': 'Philadelphia', 'stops': []},\r\n                        {'from': 'Gothenburg', 'to': 'Copenhagen', 'stops': ['Kungsbacka', 'Varberg', 'Halmstad', 'Angelholm', 'Lund', 'Malmo']}\r\n                    ]\r\n        for variant, (input_data, expected) in enumerate(zip(input_data, output_data), start=1):\r\n            with self.subTest(f'variation #{variant}', input_data=input_data, expected=expected):\r\n\r\n                actual_result = add_missing_stops(input_data[0], **input_data[1])\r\n                error_msg= (f'Called add_missing_stops({input_data[0]}, {input_data[1]}). '\r\n                            f'The function returned {actual_result}, but the '\r\n                            f'tests expected: {expected} as the set of stops.')\r\n\r\n                self.assertEqual(actual_result, expected, msg=error_msg)\r\n\r\n    @pytest.mark.task(taskno=4)\r\n    def test_extend_route_information(self): \r\n        input_data = [({'from': 'Berlin', 'to': 'Hamburg'}, {'timeOfArrival': '12:00', 'precipitation': '10', 'temperature': '5', 'caboose': 'yes'}),\r\n                        ({'from': 'Paris', 'to': 'London'}, {'timeOfArrival': '10:30', 'temperature': '20', 'length': '15'}),\r\n                        ({'from': 'Gothenburg', 'to': 'Copenhagen'}, {'precipitation': '1', 'timeOfArrival': '21:20', 'temperature': '-6'})]\r\n        output_data = [{'from': 'Berlin', 'to': 'Hamburg', 'timeOfArrival': '12:00', 'precipitation': '10', 'temperature': '5', 'caboose': 'yes'},\r\n                        {'from': 'Paris', 'to': 'London', 'timeOfArrival': '10:30', 'temperature': '20', 'length': '15'},\r\n                        {'from': 'Gothenburg', 'to': 'Copenhagen', 'precipitation': '1', 'timeOfArrival': '21:20', 'temperature': '-6'}\r\n                    ]\r\n\r\n        for variant, (input_data, expected) in enumerate(zip(input_data, output_data), start=1):\r\n            with self.subTest(f'variation #{variant}', input_data=input_data, expected=expected):\r\n\r\n                actual_result = extend_route_information(input_data[0], input_data[1])\r\n                error_msg= (f'Called extend_route_information({input_data[0]}, {input_data[1]}). '\r\n                            f'The function returned {actual_result}, but the '\r\n                            f'tests expected: {expected} as the route dictionary.')\r\n\r\n                self.assertEqual(actual_result, expected, msg=error_msg)\r\n\r\n    @pytest.mark.task(taskno=5)\r\n    def test_fix_wagon_depot(self):\r\n        input_data = (\r\n            [[(2, 'red'), (4, 'red'), (8, 'red')], [(5, 'blue'), (9, 'blue'), (13, 'blue')], [(3, 'orange'), (7, 'orange'), (11, 'orange')]],\r\n            [[(6, 'blue'), (10, 'blue'), (14, 'blue')], [(7, 'red'), (4, 'red'), (2, 'red')], [(3, 'orange'), (11, 'orange'), (15, 'orange')]],\r\n            [[(7, 'pink'), (4, 'pink'), (2, 'pink')], [(10, 'green'), (6, 'green'), (14, 'green')], [(9, 'yellow'), (5, 'yellow'), (13, 'yellow')]],\r\n            [[(3, 'purple'), (11, 'purple'), (15, 'purple')], [(20, 'black'), (16, 'black'), (12, 'black')], [(19, 'white'), (17, 'white'), (18, 'white')]]\r\n        )\r\n\r\n        output_data = (\r\n            [[(2, 'red'), (5, 'blue'), (3, 'orange')], [(4, 'red'), (9, 'blue'), (7, 'orange')], [(8, 'red'), (13, 'blue'), (11, 'orange')]],\r\n            [[(6, 'blue'), (7, 'red'), (3, 'orange')], [(10, 'blue'), (4, 'red'), (11, 'orange')], [(14, 'blue'), (2, 'red'), (15, 'orange')]],\r\n            [[(7, 'pink'), (10, 'green'), (9, 'yellow')], [(4, 'pink'), (6, 'green'), (5, 'yellow')], [(2, 'pink'), (14, 'green'), (13, 'yellow')]],\r\n            [[(3, 'purple'), (20, 'black'), (19, 'white')], [(11, 'purple'), (16, 'black'), (17, 'white')], [(15, 'purple'), (12, 'black'), (18, 'white')]]\r\n        )\r\n\r\n        for variant, (input_data, expected) in enumerate(zip(input_data, output_data), start=1):\r\n            with self.subTest(f'variation #{variant}', input_data=input_data, expected=expected):\r\n\r\n                actual_result = fix_wagon_depot(input_data)\r\n                error_msg= (f'Called fix_wagon_depot({input_data}). '\r\n                            f'The function returned {actual_result}, but the '\r\n                            f'tests expected: {expected} as the wagon depot list.')\r\n\r\n                self.assertEqual(actual_result, expected, msg=error_msg)\r\n"
}