{
  "concept": "currency-exchange",
  "docs": {
    "introduction": "# Introduction\r\n\r\n## Numbers\r\n\r\nThere are three different kinds of built-in numbers in Python : `ints`, `floats`, and `complex`. However, in this exercise you'll be dealing only with `ints` and `floats`.\r\n\r\n### ints\r\n\r\n`ints` are whole numbers. e.g. `1234`, `-10`, `20201278`.\r\n\r\nIntegers in Python have [arbitrary precision][arbitrary-precision] -- the number of digits is limited only by the available memory of the host system.\r\n\r\n### floats\r\n\r\n`floats` are numbers containing a decimal point. e.g. `0.0`,`3.14`,`-9.01`.\r\n\r\nFloating point numbers are usually implemented in Python using a `double` in C (_15 decimal places of precision_), but will vary in representation based on the host system and other implementation details. This can create some surprises when working with floats, but is \"good enough\" for most situations.\r\n\r\nYou can see more details and discussions in the following resources:\r\n\r\n- [Python numeric type documentation][numeric-type-docs]\r\n- [The Python Tutorial][floating point math]\r\n- [Documentation for `int()` built in][`int()` built in]\r\n- [Documentation for `float()` built in][`float()` built in]\r\n- [0.30000000000000004.com][0.30000000000000004.com]\r\n\r\n## Arithmetic\r\n\r\nPython fully supports arithmetic between `ints` and `floats`. It will convert narrower numbers to match their less narrow counterparts when used with the binary arithmetic operators (`+`, `-`, `*`, `/`, `//`, and `%`). When division with `/`, `//` returns the quotient and `%` returns the remainder.\r\n\r\nPython considers `ints` narrower than `floats`. So, using a float in an expression ensures the result will be a float too. However, when doing division, the result will always be a float, even if only integers are used.\r\n\r\n```python\r\n# The int is widened to a float here, and a float type is returned.\r\n>>> 3 + 4.0\r\n7.0\r\n>>> 3 * 4.0\r\n12.0\r\n>>> 3 - 2.0\r\n1.0\r\n# Division always returns a float.\r\n>>> 6 / 2\r\n3.0\r\n>>> 7 / 4\r\n1.75\r\n# Calculating remainders.\r\n>>> 7 % 4\r\n3\r\n>>> 2 % 4\r\n2\r\n>>> 12.75 % 3\r\n0.75\r\n```\r\n\r\nIf an int result is needed, you can use `//` to truncate the result.\r\n\r\n```python\r\n>>> 6 // 2\r\n3\r\n>>> 7 // 4\r\n1\r\n```\r\n\r\nTo convert a float to an integer, you can use `int()`. Also, to convert an integer to a float, you can use `float()`.\r\n\r\n```python\r\n>>> int(6 / 2)\r\n3\r\n>>> float(1 + 2)\r\n3.0\r\n```\r\n\r\n[0.30000000000000004.com]: https://0.30000000000000004.com/\r\n[`float()` built in]: https://docs.python.org/3/library/functions.html#float\r\n[`int()` built in]: https://docs.python.org/3/library/functions.html#int\r\n[arbitrary-precision]: https://en.wikipedia.org/wiki/Arbitrary-precision_arithmetic#:~:text=In%20computer%20science%2C%20arbitrary%2Dprecision,memory%20of%20the%20host%20system.\r\n[floating point math]: https://docs.python.org/3.9/tutorial/floatingpoint.html\r\n[numeric-type-docs]: https://docs.python.org/3/library/stdtypes.html#typesnumeric\r\n",
    "hints": "# Hints\r\n\r\n## General\r\n\r\n- [The Python Numbers Tutorial][python-numbers-tutorial] and [Python numeric types][python-numeric-types] can be a great introduction.\r\n\r\n## 1. Estimate value after exchange\r\n\r\n- You can use the [division operator][division-operator] to get the value of exchanged currency.\r\n\r\n## 2. Calculate currency left after an exchange\r\n\r\n- You can use the [subtraction operator][subtraction-operator] to get the amount of change.\r\n\r\n## 3. Calculate value of bills\r\n\r\n- You can use the [multiplication operator][multiplication-operator] to get the value of bills.\r\n\r\n## 4. Calculate number of bills\r\n\r\n- You need to divide `amount` into `denomination`.\r\n- You need to use type casting to `int` to get the exact number of bills.\r\n- To remove decimal places from a `float`, you can convert it to `int`.\r\n\r\n  **Note:** The `//` operator also does floor division. But, if the operand has `float`, the result is still `float`.\r\n\r\n## 5. Calculate leftover after exchanging into bills\r\n\r\n- You need to find the remainder of `amount` that does not equal a whole `denomination`.\r\n- The Modulo operator `%` can help find the remainder.\r\n\r\n## 6. Calculate value after exchange\r\n\r\n- You need to calculate `spread` percent of `exchange_rate` using multiplication operator and add it to `exchange_rate` to get the exchanged currency.\r\n- The actual rate needs to be computed. Remember to add exchange _rate_ and exchange _fee_.\r\n- You can get exchanged money affected by commission by using divide operation and type casting to `int`.\r\n\r\n\r\n[division-operator]: https://docs.python.org/3/tutorial/introduction.html#numbers\r\n[multiplication-operator]: https://docs.python.org/3/tutorial/introduction.html#numbers\r\n[python-numbers-tutorial]: https://docs.python.org/3/tutorial/introduction.html#numbers\r\n[python-numeric-types]: https://docs.python.org/3.9/library/stdtypes.html#numeric-types-int-float-complex\r\n[subtraction-operator]: https://docs.python.org/3/tutorial/introduction.html#numbers\r\n",
    "instructions": "# Instructions\r\n\r\nYour friend Chandler plans to visit exotic countries all around the world. Sadly, Chandler's math skills aren't good. He's pretty worried about being scammed by currency exchanges during his trip - and he wants you to make a currency calculator for him. Here are his specifications for the app:\r\n\r\n## 1. Estimate value after exchange\r\n\r\nCreate the `exchange_money()` function, taking 2 parameters:\r\n\r\n1. `budget` : The amount of money you are planning to exchange.\r\n2. `exchange_rate` : The amount of domestic currency equal to one unit of foreign currency.\r\n\r\nThis function should return the value of the exchanged currency.\r\n\r\n**Note:** If your currency is USD and you want to exchange USD for EUR with an exchange rate of `1.20`, then `1.20 USD == 1 EUR`.\r\n\r\n```python\r\n>>> exchange_money(127.5, 1.2)\r\n106.25\r\n```\r\n\r\n## 2. Calculate currency left after an exchange\r\n\r\nCreate the `get_change()` function, taking 2 parameters:\r\n\r\n1. `budget` : Amount of money before exchange.\r\n2. `exchanging_value` : Amount of money that is *taken* from the budget to be exchanged.\r\n\r\nThis function should return the amount of money that *is left* from the budget.\r\n\r\n```python\r\n>>> get_change(127.5, 120)\r\n7.5\r\n```\r\n\r\n## 3. Calculate value of bills\r\n\r\nCreate the `get_value_of_bills()` function, taking 2 parameters:\r\n\r\n1. `denomination` : The value of a single bill.\r\n2. `number_of_bills` : The total number of bills.\r\n\r\nThis exchanging booth only deals in cash of certain increments.\r\nThe total you receive must be divisible by the value of one \"bill\" or unit, which can leave behind a fraction or remainder.\r\nYour function should return only the total value of the bills (_excluding fractional amounts_) the booth would give back.\r\nUnfortunately, the booth gets to keep the remainder/change as an added bonus.\r\n\r\n```python\r\n>>> get_value_of_bills(5, 128)\r\n640\r\n```\r\n\r\n## 4. Calculate number of bills\r\n\r\nCreate the `get_number_of_bills()` function, taking `amount` and `denomination`.\r\n\r\nThis function should return the _number of currency bills_ that you can receive within the given _amount_.\r\nIn other words:  How many _whole bills_ of currency fit into the starting amount?\r\nRemember -- you can only receive _whole bills_, not fractions of bills, so remember to divide accordingly.\r\nEffectively, you are rounding _down_ to the nearest whole bill/denomination.\r\n\r\n```python\r\n>>> get_number_of_bills(127.5, 5)\r\n25\r\n```\r\n\r\n## 5. Calculate leftover after exchanging into bills\r\n\r\nCreate the `get_leftover_of_bills()` function, taking `amount` and `denomination`.\r\n\r\nThis function should return the _leftover amount_ that cannot be returned from your starting _amount_ given the denomination of bills.\r\nIt is very important to know exactly how much the booth gets to keep.\r\n\r\n```python\r\n>>> get_leftover_of_bills(127.5, 20)\r\n7.5\r\n```\r\n\r\n## 6. Calculate value after exchange\r\n\r\nCreate the `exchangeable_value()` function, taking `budget`, `exchange_rate`, `spread`, and `denomination`.\r\n\r\nParameter `spread` is the *percentage taken* as an exchange fee, written as an integer.\r\nIt needs to be converted to decimal by dividing it by 100.\r\nIf `1.00 EUR == 1.20 USD` and the *spread* is `10`, the actual exchange rate will be: `1.00 EUR == 1.32 USD` because 10% of 1.20 is 0.12, and this additional fee is added to the exchange.\r\n\r\nThis function should return the maximum value of the new currency after calculating the *exchange rate* plus the *spread*.\r\nRemember that the currency *denomination* is a whole number, and cannot be sub-divided.\r\n\r\n**Note:** Returned value should be `int` type.\r\n\r\n```python\r\n>>> exchangeable_value(127.25, 1.20, 10, 20)\r\n80\r\n>>> exchangeable_value(127.25, 1.20, 10, 5)\r\n95\r\n```\r\n",
    "design": "# Design\r\n\r\n## Goal\r\n\r\nThe goal of this exercise is to teach the student how to use arithmetic operators and type casting between `int` and `float` in Python\r\n\r\n## Learning objectives\r\n\r\n- use `+`, `-`, `*`, `/` to add, subtract, multiply, divide numbers(`int` and `float`).\r\n- use `int()` to cast `float` to `int`.\r\n- use `%` to calculate remainders.\r\n"
  },
  "config": {
    "authors": [
      "Ticktakto",
      "Yabby1997",
      "limm-jk",
      "OMEGA-Y",
      "wnstj2007",
      "J08K"
    ],
    "contributors": [
      "BethanyG",
      "kytrinyx",
      "pranasziaukas"
    ],
    "files": {
      "solution": [
        "exchange.py"
      ],
      "test": [
        "exchange_test.py"
      ],
      "exemplar": [
        ".meta/exemplar.py"
      ]
    },
    "icon": "hyperia-forex",
    "blurb": "Learn about numbers by solving Chandler's currency exchange conundrums."
  },
  "starter_code": "\"\"\"Functions for calculating steps in exchanging currency.\r\n\r\nPython numbers documentation: https://docs.python.org/3/library/stdtypes.html#numeric-types-int-float-complex\r\n\r\nOverview of exchanging currency when travelling: https://www.compareremit.com/money-transfer-tips/guide-to-exchanging-currency-for-overseas-travel/\r\n\"\"\"\r\n\r\n\r\n\r\ndef exchange_money(budget, exchange_rate):\r\n    \"\"\"\r\n\r\n    :param budget: float - amount of money you are planning to exchange.\r\n    :param exchange_rate: float - unit value of the foreign currency.\r\n    :return: float - exchanged value of the foreign currency you can receive.\r\n    \"\"\"\r\n\r\n    pass\r\n\r\n\r\ndef get_change(budget, exchanging_value):\r\n    \"\"\"\r\n\r\n    :param budget: float - amount of money you own.\r\n    :param exchanging_value: float - amount of your money you want to exchange now.\r\n    :return: float - amount left of your starting currency after exchanging.\r\n    \"\"\"\r\n\r\n    pass\r\n\r\n\r\ndef get_value_of_bills(denomination, number_of_bills):\r\n    \"\"\"\r\n\r\n    :param denomination: int - the value of a bill.\r\n    :param number_of_bills: int - total number of bills.\r\n    :return: int - calculated value of the bills.\r\n    \"\"\"\r\n\r\n    pass\r\n\r\n\r\ndef get_number_of_bills(amount, denomination):\r\n    \"\"\"\r\n\r\n    :param amount: float - the total starting value.\r\n    :param denomination: int - the value of a single bill.\r\n    :return: int - number of bills that can be obtained from the amount.\r\n    \"\"\"\r\n\r\n    pass\r\n\r\n\r\ndef get_leftover_of_bills(amount, denomination):\r\n    \"\"\"\r\n\r\n    :param amount: float - the total starting value.\r\n    :param denomination: int - the value of a single bill.\r\n    :return: float - the amount that is \"leftover\", given the current denomination.\r\n    \"\"\"\r\n\r\n    pass\r\n\r\n\r\ndef exchangeable_value(budget, exchange_rate, spread, denomination):\r\n    \"\"\"\r\n\r\n    :param budget: float - the amount of your money you are planning to exchange.\r\n    :param exchange_rate: float - the unit value of the foreign currency.\r\n    :param spread: int - percentage that is taken as an exchange fee.\r\n    :param denomination: int - the value of a single bill.\r\n    :return: int - maximum value you can get.\r\n    \"\"\"\r\n\r\n    pass\r\n",
  "exemplar_code": "\"\"\"Functions for calculating steps in exchaning currency.\r\n\r\nPython numbers documentation: https://docs.python.org/3/library/stdtypes.html#numeric-types-int-float-complex\r\n\r\nOverview of exchanging currency when travelling: https://www.compareremit.com/money-transfer-tips/guide-to-exchanging-currency-for-overseas-travel/\r\n\"\"\"\r\n\r\ndef exchange_money(budget, exchange_rate):\r\n    \"\"\"\r\n\r\n    :param budget: float - amount of money you are planning to exchange.\r\n    :param exchange_rate: float - unit value of the foreign currency.\r\n    :return: float - exchanged value of the foreign currency you can receive.\r\n    \"\"\"\r\n\r\n    return budget / exchange_rate\r\n\r\n\r\ndef get_change(budget, exchanging_value):\r\n    \"\"\"\r\n\r\n    :param budget: float - amount of money you own.\r\n    :param exchanging_value: float - amount of your money you want to exchange now.\r\n    :return: float - amount left of your starting currency after exchanging.\r\n    \"\"\"\r\n\r\n    return budget - exchanging_value\r\n\r\n\r\ndef get_value_of_bills(denomination, number_of_bills):\r\n    \"\"\"\r\n\r\n    :param denomination: int - the value of a bill.\r\n    :param number_of_bills: int - total number of bills.\r\n    :return: int - calculated value of the bills.\r\n    \"\"\"\r\n\r\n    return denomination * number_of_bills\r\n\r\n\r\ndef get_number_of_bills(amount, denomination):\r\n    \"\"\"\r\n\r\n    :param amount: float - the total starting value.\r\n    :param denomination: int - the value of a single bill.\r\n    :return: int - number of bills that can be obtained from the amount.\r\n    \"\"\"\r\n\r\n    return int(amount) // denomination\r\n\r\n\r\ndef get_leftover_of_bills(amount, denomination):\r\n    \"\"\"\r\n\r\n    :param amount: float - the total starting value.\r\n    :param denomination: int - the value of a single bill.\r\n    :return: float - the amount that is \"leftover\", given the current denomination.\r\n    \"\"\"\r\n\r\n    return amount % denomination\r\n\r\n\r\ndef exchangeable_value(budget, exchange_rate, spread, denomination):\r\n    \"\"\"\r\n\r\n    :param budget: float - the amount of your money you are planning to exchange.\r\n    :param exchange_rate: float - the unit value of the foreign currency.\r\n    :param spread: int - percentage that is taken as an exchange fee.\r\n    :param denomination: int - the value of a single bill.\r\n    :return: int - maximum value you can get.\r\n    \"\"\"\r\n\r\n    exchange_fee = (exchange_rate / 100) * spread\r\n    exchange_value = exchange_money(budget, exchange_rate + exchange_fee)\r\n    number_of_bills = get_number_of_bills(exchange_value, denomination)\r\n    value_of_bills = get_value_of_bills(denomination, number_of_bills)\r\n    return value_of_bills\r\n",
  "tests": "import unittest\r\nimport pytest\r\n\r\nfrom exchange import (\r\n    exchange_money,\r\n    get_change,\r\n    get_value_of_bills,\r\n    get_number_of_bills,\r\n    get_leftover_of_bills,\r\n    exchangeable_value)\r\n\r\n\r\nclass CurrencyExchangeTest(unittest.TestCase):\r\n    @pytest.mark.task(taskno=1)\r\n    def test_exchange_money(self):\r\n        test_data = [(100000, 0.8), (700000, 10.0)]\r\n        result_data = [125000, 70000]\r\n\r\n        for variant, (params, expected) in enumerate(zip(test_data, result_data), start=1):\r\n            budget, exchange_rate = params\r\n\r\n            with self.subTest(f\"variation #{variant}\",\r\n                              budget=budget,\r\n                              exchange_rate=exchange_rate,\r\n                              expected=expected):\r\n\r\n                actual_result = exchange_money(*params)\r\n                error_message = (f'Called exchange_money{budget, exchange_rate}. '\r\n                                 f'The function returned {actual_result}, but '\r\n                                 f'The tests expected {expected} when exchanging'\r\n                                 f' {budget} at a rate of {exchange_rate}.')\r\n\r\n                self.assertAlmostEqual(actual_result, expected, msg=error_message)\r\n\r\n    @pytest.mark.task(taskno=2)\r\n    def test_get_change(self):\r\n        test_data = [(463000, 5000), (1250, 120), (15000, 1380)]\r\n        result_data = [458000, 1130, 13620]\r\n\r\n        for variant, (params, expected) in enumerate(zip(test_data, result_data), start=1):\r\n            budget, exchanging_value = params\r\n\r\n            with self.subTest(f\"variation #{variant}\",\r\n                              budget=budget,\r\n                              exchanging_value=exchanging_value,\r\n                              expected=expected):\r\n\r\n                actual_result = get_change(*params)\r\n                error_message = (f'Called get_change{budget, exchanging_value}. '\r\n                                 f'The function returned {actual_result}, but '\r\n                                 f'The tests expected {expected} left in your budget.')\r\n\r\n                self.assertAlmostEqual(actual_result, expected, msg=error_message)\r\n\r\n    @pytest.mark.task(taskno=3)\r\n    def test_get_value_of_bills(self):\r\n        test_data = [(10000, 128), (50, 360), (200, 200)]\r\n        result_data = [1280000, 18000, 40000]\r\n\r\n        for variant, (params, expected) in enumerate(zip(test_data, result_data), start=1):\r\n            denomination, number_of_bills = params\r\n\r\n            with self.subTest(f\"variation #{variant}\",\r\n                              denomination=denomination,\r\n                              number_of_bills=number_of_bills,\r\n                              expected=expected):\r\n\r\n                actual_result = get_value_of_bills(*params)\r\n                error_message = (f'Called get_value_of_bills{denomination, number_of_bills}. '\r\n                                 f'The function returned {actual_result}, but '\r\n                                 f'The tests expected {expected} for the bills value.')\r\n\r\n                self.assertEqual(actual_result, expected, msg=error_message)\r\n\r\n    @pytest.mark.task(taskno=4)\r\n    def test_get_number_of_bills(self):\r\n        test_data = [(163270, 50000), (54361, 1000)]\r\n        result_data = [3, 54]\r\n\r\n        for variant, (params, expected) in enumerate(zip(test_data, result_data), start=1):\r\n            amount, denomination = params\r\n\r\n            with self.subTest(f\"variation #{variant}\",\r\n                              amount=amount,\r\n                              denomination=denomination,\r\n                              expected=expected):\r\n\r\n                actual_result = get_number_of_bills(amount, denomination)\r\n                error_message = (f'Called get_number_of_bills{amount, denomination}. '\r\n                                 f'The function returned {actual_result} bills, but '\r\n                                 f'The tests expected {expected} bills.')\r\n\r\n                self.assertEqual(actual_result, expected, msg=error_message)\r\n\r\n    @pytest.mark.task(taskno=5)\r\n    def test_get_leftover_of_bills(self):\r\n        test_data = [(10.1, 10), (654321.0, 5), (3.14, 2)]\r\n        result_data = [0.1, 1.0, 1.14]\r\n\r\n        for variant, (params, expected) in enumerate(zip(test_data, result_data), start=1):\r\n            amount, denomination = params\r\n\r\n            with self.subTest(f\"variation #{variant}\",\r\n                              amount=amount,\r\n                              denomination=denomination,\r\n                              expected=expected):\r\n\r\n                actual_result = get_leftover_of_bills(*params)\r\n                error_message = (f'Called get_leftover_of_bills{amount, denomination}. '\r\n                                 f'The function returned {actual_result}, but '\r\n                                 f'The tests expected {expected} as the leftover amount.')\r\n\r\n                self.assertAlmostEqual(actual_result, expected, msg=error_message)\r\n\r\n    @pytest.mark.task(taskno=6)\r\n    def test_exchangeable_value(self):\r\n        test_data = [(100000, 10.61, 10, 1),\r\n                     (1500, 0.84, 25, 40),\r\n                     (470000, 1050, 30, 10000000000),\r\n                     (470000, 0.00000009, 30, 700),\r\n                     (425.33, 0.0009, 30, 700)]\r\n\r\n        result_data = [8568, 1400, 0, 4017094016600, 363300]\r\n\r\n        for variant, (params, expected) in enumerate(zip(test_data, result_data), start=1):\r\n            budget, exchange_rate, spread, denomination = params\r\n\r\n            with self.subTest(f\"variation #{variant}\",\r\n                              budget=budget,\r\n                              exchange_rate=exchange_rate,\r\n                              spread=spread,\r\n                              denomination=denomination,\r\n                              expected=expected):\r\n\r\n                actual_result = exchangeable_value(budget, exchange_rate, spread, denomination)\r\n                error_message = (f'Called exchangeable_value{budget, exchange_rate, spread, denomination}. '\r\n                                 f'The function returned {actual_result}, but '\r\n                                 f'The tests expected {expected} as the maximum '\r\n                                 f'value of the new currency .')\r\n\r\n                self.assertEqual(actual_result, expected, msg=error_message)\r\n"
}