{
  "concept": "log-levels",
  "docs": {
    "introduction": "# Introduction\r\n\r\nIn Python, [an enum](https://docs.python.org/3/library/enum.html) is a set of names that are bound to unique `literal`, or `constant` values. Enums are defined by inheriting an `Enum` class. Built-in enum types are available in the module `enum` and the class `Enum` can be imported using `from enum import Enum`.\r\n\r\n```python\r\nclass Color(Enum):\r\n    RED = 1\r\n    GREEN = 2\r\n```\r\n\r\nNote that the values of the enum members can be any data types such as str, tuple, float, etc.\r\n\r\n```python\r\nclass Color(Enum):\r\n    RED = 'red'\r\n    GREEN = 'green'\r\n```\r\n\r\nWhen assigning the same value to two members in an enum, the latter assigned member will be an alias to the formed one. It is not allowed to use the same name for two members of an enum.\r\n\r\n```python\r\nclass Color(Enum):\r\n    RED = 1\r\n    GREEN = 2\r\n    ALIAS_OF_RED = 1\r\n\r\nColor.ALIAS_OF_RED\r\n#=> <Color.RED: 1>\r\n\r\nColor.ALIAS_OF_RED.value\r\n#=> 1\r\n```\r\n\r\nIterating through the members of the enum can be done with the standard `for member in` syntax:\r\n\r\n```python\r\nfor member in Color:\r\n    print((member.name, member.value))\r\n#=> (RED, 1)\r\n#=> (GREEN, 2)\r\n```\r\n\r\nEnum members can be compared using [`is` (_identity operator_)](https://www.w3schools.com/python/ref_keyword_is.asp) or `is not`. The `==` or `!=` (_equality_operators_) work likewise.\r\n\r\n```python\r\na = Color.RED\r\n\r\na is Color.RED\r\n#=> True\r\n\r\na == Color.RED\r\n#=> True\r\n```\r\n\r\nTo access an enum member for a given value, `EnumName(value)` can be used:\r\n\r\n```python\r\ng = Color(2)\r\n\r\ng is Color.GREEN\r\n#=> True\r\n\r\ng\r\n#=> <Color.GREEN: 2>\r\n```\r\n",
    "hints": "# Hints\r\n\r\n## General\r\n\r\n- [Python Docs: Enum](https://docs.python.org/3/library/enum.html)\r\n\r\n## 1. Parse log level\r\n\r\n- Use [`str.split`](https://www.w3schools.com/python/ref_string_split.asp) to extract the log level from the message.\r\n- With the extracted part of the string, access and return the enum member using `LogLevel(string)`.\r\n\r\n## 2. Support unknown log level\r\n\r\n- Create a new Unknown log level member in the existing enum.\r\n- Check if the extracted part of the string is a value of the enum `LogLevel`.\r\n- If the value does not match any of the enum member values, then return the Unknown member of `LogLevel`.\r\n\r\n## 3. Convert log line to short format\r\n\r\n- Find the code (an integer) of the log level based on the log level, multiple solutions are possible: if statements, another enum or any other solution.\r\n- Use string formatting to return a properly formatted code level and message.\r\n\r\n## 4. Create an Alias\r\n\r\n- Create the new alias member named Warn in the existing enum.\r\n- Return the newly created member.\r\n\r\n## 5. All Member Names and Values\r\n\r\n- Iterate on all the members of the enum and return a list of tuple.\r\n- The tuple can be constructed with `(item1, item2)`.\r\n- The name and value of the enum can be accessed with `member.name` and `member.value`.\r\n- Return the list containing all the tuples.\r\n",
    "instructions": "# Instructions\r\n\r\nIn this exercise, you'll be processing log messages with six severity levels.\r\n\r\nEach log line is a string formatted as follows: `\"[<LVL>]: <MESSAGE>\"`.\r\n\r\nThese are the different log levels:\r\n\r\n| LEVEL     | LVL   |\r\n| --------- | ----- |\r\n| `Trace`   | `TRC` |\r\n| `Debug`   | `DBG` |\r\n| `Info`    | `INF` |\r\n| `Warning` | `WRN` |\r\n| `Error`   | `ERR` |\r\n| `Fatal`   | `FTL` |\r\n\r\n## 1. Parse log level\r\n\r\nDefine a `LogLevel` enum that has six elements corresponding to the log levels defined above.\r\nNext, define the `parse_log_level` function which takes the log message as parameter and returns the enum member of its level.\r\n\r\n```python\r\nparse_log_level(\"[INF]: File deleted\")\r\n#=> LogLevel.Info\r\n```\r\n\r\n## 2. Support unknown log level\r\n\r\nUnfortunately, some log messages occasionally appear with an _unknown_ severity. To gracefully handle these 'mysterious' log messages in the function `parse_log_level`, add an `Unknown` member to the `LogLevel` enum which is returned when parsing an unknown log level:\r\n\r\n```python\r\nparse_log_level(\"[XYZ]: Overly specific, out of context message\")\r\n#=> LogLevel.Unknown\r\n```\r\n\r\n## 3. Convert a log message to the short format\r\n\r\nThe log level of a log line is quite verbose. To reduce the disk space needed to store the log messages, a short format is defined: `\"[<CODE_LEVEL>]:<MESSAGE>\"`.\r\n\r\nThe log level codes follow a straightforward mapping:\r\n\r\n| LEVEL     | CODE |\r\n| --------- | ---- |\r\n| `Trace`   | `0`  |\r\n| `Debug`   | `1`  |\r\n| `Info`    | `4`  |\r\n| `Warning` | `5`  |\r\n| `Error`   | `6`  |\r\n| `Fatal`   | `7`  |\r\n| `Unknown` | `42` |\r\n\r\nDefine the `convert_to_short_log()` function, which takes two parameters:\r\n\r\n1. Log level - The Log level of the log sent. ex: `LogLevel.Error`.\r\n2. Log Message - The message of type `str`.\r\n\r\n```python\r\nconvert_to_short_log(LogLevel.Error, \"Stack overflow\")\r\n# => \"6:Stack overflow\"\r\n```\r\n\r\n## 4. Create an Alias\r\n\r\nIt looks like the user has created logs for `LogLevel.Warn` instead of `LogLevel.Warning`. Create an `alias` for `LogLevel.Warning` and return the new alias member in the function `get_warn_alias`.\r\n\r\nThis can be done on the same enum class `LogLevel` already defined at the top of the file. Both the LogLevels should point to same value: `\"WRN\"`.\r\n\r\n```python\r\nget_warn_alias()\r\n#=> LogLevel.Warn\r\n\r\nget_warn_alias() == LogLevel.Warning\r\n#=> True\r\n```\r\n\r\n## 5. All Member Names and Values\r\n\r\nDefine the function `get_members()`.\r\n\r\nThis function should return a list of tuples `(name, value)` containing all the members of the enum `LogLevel`.\r\n\r\n```python\r\nget_members()\r\n#=> [('Trace', 'TRC'), ('Debug', 'DBG'), ('Info', 'INF'), ('Warning', 'WRN'),\r\n# ('Error', 'ERR'), ('Fatal', 'FTL'), ('Unknown', 'UKN')]\r\n```\r\n",
    "design": "# Design\r\n\r\n## Goal\r\n\r\nThe goal of this exercise is to teach the student how Enums ([Enumerations](https://en.wikipedia.org/wiki/Enumerated_type)) are implemented & used in Python. We will teach this through Pythons Enum class/type.\r\n\r\n## Learning objectives\r\n\r\n- What is an enumeration / enum is, and why they are needed/wanted in Python?\r\n- Understand the nomenclature (naming) used in reference to enums (e.g. enumeration/enum, enum members, enum member names, and enum member values)\r\n- Understand that enumeration members are functionally constants (and therefore should be formatted as such)\r\n- How Enums are different from other, more generic Python classes.\r\n- How to create various Enums\r\n  - By using the class syntax by importing & subclassing Enum.\r\n  - By using the Enum Functional API\r\n  - By defining enum members with values that include non-int types (like str, tuple, float etc.)\r\n  - Using the auto() function to automatically assign integer values to members when exact value types are unimportant/not needed.\r\n  - Creating member aliases by assigning the same value to different names (two different names can have the same value; the second name defined becomes an alias of the first)\r\n  - Using the class decorator @enum.unique to prevent member aliases and enforce that member values be unique.\r\n- How to use an enumeration and enumeration members in other functions/code\r\n  - Enum members are iterable in member definition order, but iteration will not include aliases.\r\n  - An ordered mapping of names to members can be retrieved via **members**.items()\r\n  - enumeration members are compared by identity, using the is/is not keywords\r\n  - Ordered comparison (<, >, <=, '>=) between enumeration values is not supported, and will throw aTypeError`.\r\n  - Equality/inequality comparison is defined, and == and != can be used.\r\n  - Comparisons between enumeration values and non-enumeration values will always return False\r\n\r\n## Out of scope\r\n\r\n- Flag enum subtype (perhaps better as an advanced exercise that includes bitwise operations)\r\n- IntEnum and IntFlag subtypes (since they break the semantic promises of an enum by being comparable to int)\r\n- mixins & multiple inheritance for the creation of Enums\r\n- using **new**() to customize the value of an enum member (better for an advanced/extended enum exercise)\r\n- omitting values\r\n- subclassing an \"empty\" pre-defined enum\r\n- customization of auto()\r\n- Pickling\r\n\r\n## Concepts\r\n\r\n- enumeration, enums\r\n\r\n## Prerequisites\r\n\r\n- `decorators, @`\r\n- `__init__()`\r\n- `classes, OOP`\r\n- `inheritance`\r\n- `iteration`\r\n- `iterables`\r\n- `dunder methods`\r\n- `comparisons`\r\n- `rich comparisons`\r\n- `class attributes`\r\n- `importing`\r\n- `aliasing`\r\n- `dicts, dict methods (specifically dict.items())`\r\n- `mapping types`\r\n- `immutable, immutability`\r\n- `class properties`\r\n\r\n## Resources\r\n\r\n- [Exercism v3 C# Enums concept exercise](https://github.com/exercism/v3/tree/master/languages/csharp/exercises/concept/enums)\r\n- [Python Docs: Enum](https://docs.python.org/3/library/enum.html)\r\n- [Enum - Mouse vs. Python](https://www.blog.pythonlibrary.org/2018/03/20/python-3-an-intro-to-enumerations/)\r\n- [Why you should use more enums in Python - Florian Dahlitz](https://florian-dahlitz.de/blog/why-you-should-use-more-enums-in-python)\r\n- [Python Docs: How are Enums Different?](https://docs.python.org/3/library/enum.html#how-are-enums-different)\r\n- [Python Docs: The Enum Functional API](https://docs.python.org/3/library/enum.html#functional-api)\r\n- [Stack Overflow: Python enum, when and where to use?](https://stackoverflow.com/questions/22586895/python-enum-when-and-where-to-use)\r\n- [PEP435: Adding an Enum Type to the Python Standard Library](https://www.python.org/dev/peps/pep-0435/)\r\n- [Using Enums and Django model Choices - Ben Cleary](https://medium.com/@bencleary/using-enums-as-django-model-choices-96c4cbb78b2e)\r\n"
  },
  "config": {
    "authors": [
      "mohanrajanr"
    ],
    "contributors": [
      "valentin-p"
    ],
    "files": {
      "solution": [
        "enums.py"
      ],
      "test": [
        "enums_test.py"
      ],
      "exemplar": [
        ".meta/exemplar.py"
      ]
    },
    "forked_from": [
      "csharp/logs-logs-logs"
    ],
    "icon": "log-levels",
    "blurb": "Learn about enums by automating your tedious logging-level tasks."
  },
  "starter_code": "from enum import Enum\r\n\r\n\r\nclass LogLevel(Enum):\r\n    \"\"\"Represent different log levels by their verbose codes.\"\"\"\r\n\r\n    pass\r\n\r\n\r\ndef parse_log_level(message):\r\n    \"\"\"Returns level enum for log message.\r\n\r\n    :param message: log message (string)\r\n    :return: enum - 'LogLevel.<level>'.  Return 'LogLevel.Unknown' if an unknown severity is passed.\r\n    \"\"\"\r\n\r\n    pass\r\n\r\n\r\ndef convert_to_short_log(log_level, message):\r\n    \"\"\"Convert a log message to its shorter format.\r\n\r\n    :param log_level: enum - 'LogLevel.<level>'  e.g.  'LogLevel.Error'\r\n    :param message: str - log message\r\n    :return: enum -  'LogLevelInt.<value>` e.g. 'LogLevelInt.5'\r\n    \"\"\"\r\n\r\n    pass\r\n\r\n\r\ndef get_warn_alias():\r\n    \"\"\"Return the enum for LogLevel.Warning.\r\n\r\n    :return: enum - 'LogLevel'.<alias>'\r\n    \"\"\"\r\n\r\n    pass\r\n\r\n\r\ndef get_members():\r\n    \"\"\"Return all members of the enum.\r\n\r\n    :return: list of tuples -  [(name1, value1), (name2, value2)]\r\n    \"\"\"\r\n\r\n    pass\r\n",
  "exemplar_code": "from enum import Enum\r\n\r\n\r\nclass LogLevel(Enum):\r\n    \"\"\"Represent different log levels by their verbose codes.\"\"\"\r\n\r\n    TRACE = 'TRC'\r\n    DEBUG = 'DBG'\r\n    INFO = 'INF'\r\n    WARNING = 'WRN'\r\n    WARN = 'WRN'\r\n    ERROR = 'ERR'\r\n    FATAL = 'FTL'\r\n    UNKNOWN = 'UKN'\r\n\r\n\r\nclass LogLevelInt(Enum):\r\n    \"\"\"Represent different log levels by their short codes.\"\"\"\r\n\r\n    TRACE = 0\r\n    DEBUG = 1\r\n    INFO = 4\r\n    WARNING = 5\r\n    WARN = 5\r\n    ERROR = 6\r\n    FATAL = 7\r\n    UNKNOWN = 42\r\n\r\n\r\ndef parse_log_level(message):\r\n    \"\"\"Return level enum for log message.\r\n\r\n    :param message: log message (string)\r\n    :return: enum - 'LogLevel.<level>'.  Return 'LogLevel.Unknown' if an unknown severity is passed.\r\n    \"\"\"\r\n\r\n    str_split = message.split(':')\r\n    lvl = str_split[0][1:-1]\r\n    if lvl in [level.value for level in LogLevel]:\r\n        return LogLevel(lvl)\r\n    return LogLevel('UKN')\r\n\r\n\r\ndef convert_to_short_log(log_level, message):\r\n    \"\"\"Convert a log message to its shorter format.\r\n\r\n    :param log_level: enum - 'LogLevel.<level>'  e.g.  'LogLevel.Error'\r\n    :param message: str - log message\r\n    :return: enum -  'LogLevelInt.<value>` e.g. 'LogLevelInt.5'\r\n    \"\"\"\r\n\r\n    return f'{LogLevelInt[log_level.name].value}:{message}'\r\n\r\n\r\ndef get_warn_alias():\r\n    \"\"\"Returns the enum for LogLevel.Warning.\r\n\r\n    :return: enum - 'LogLevel'.<alias>'\r\n    \"\"\"\r\n\r\n    return LogLevel('WRN')\r\n\r\n\r\ndef get_members():\r\n    \"\"\"Return all members of the enum.\r\n\r\n    :return: list of tuples -  [(name1, value1), (name2, value2)]\r\n    \"\"\"\r\n\r\n    out_list = []\r\n    for member in LogLevel:\r\n        out_list.append((member.name, member.value))\r\n    return out_list\r\n",
  "tests": "import unittest\r\nimport pytest\r\nfrom enums import (\r\n    LogLevel,\r\n    LogLevelInt,\r\n    parse_log_level,\r\n    convert_to_short_log,\r\n    get_warn_alias,\r\n    get_members\r\n)\r\n\r\n\r\nclass EnumsTest(unittest.TestCase):\r\n    @pytest.mark.task(taskno=1)\r\n    def test_parse_log_level_set_ing(self):\r\n        self.assertIs(\r\n            parse_log_level('[INF]: File deleted'),\r\n            LogLevel.INFO,\r\n            msg='The Log level is incorrect'\r\n        )\r\n\r\n    @pytest.mark.task(taskno=1)\r\n    def test_parse_log_level_set_wrn(self):\r\n        self.assertIs(\r\n            parse_log_level('[WRN]: File is being overwritten'),\r\n            LogLevel.WARNING,\r\n            msg='The Log level is incorrect'\r\n        )\r\n\r\n    @pytest.mark.task(taskno=1)\r\n    def test_parse_log_level_set_err(self):\r\n        self.assertIs(\r\n            parse_log_level('[ERR]: Some Random Log'),\r\n            LogLevel.ERROR,\r\n            msg='The Log level is incorrect'\r\n        )\r\n\r\n    @pytest.mark.task(taskno=2)\r\n    def test_parse_log_level_set_xyz(self):\r\n        self.assertIs(\r\n            parse_log_level('[XYZ]: Some Random Log'),\r\n            LogLevel.UNKNOWN,\r\n            msg='The Log level is incorrect'\r\n        )\r\n\r\n    @pytest.mark.task(taskno=3)\r\n    def test_convert_to_short_log_set1(self):\r\n        self.assertEqual(\r\n            convert_to_short_log(LogLevel.ERROR, 'Stack overflow'),\r\n            '6:Stack overflow',\r\n            msg='The converted short log is incorrect'\r\n        )\r\n\r\n    @pytest.mark.task(taskno=3)\r\n    def test_convert_to_short_log_set2(self):\r\n        self.assertEqual(\r\n            convert_to_short_log(LogLevel.WARNING, 'This is a warning'),\r\n            '5:This is a warning',\r\n            msg='The converted short log is incorrect'\r\n        )\r\n\r\n    @pytest.mark.task(taskno=4)\r\n    def test_get_warn_alias(self):\r\n        self.assertIs(\r\n            get_warn_alias(),\r\n            LogLevel.WARN,\r\n            msg='The warn alias returned is incorrect'\r\n        )\r\n\r\n    @pytest.mark.task(taskno=5)\r\n    def test_get_members(self):\r\n        self.assertListEqual(\r\n            get_members(),\r\n            [('TRACE', 'TRC'), ('DEBUG', 'DBG'), ('INFO', 'INF'),\r\n                ('WARNING', 'WRN'), ('ERROR', 'ERR'), ('FATAL', 'FTL'), ('UNKNOWN', 'UKN')],\r\n            msg='The Members list of the enum is incorrect'\r\n        )\r\n"
}