{
  "concept": "card-games",
  "docs": {
    "introduction": "# Introduction\r\n\r\nA [`list`][list] is a mutable collection of items in _sequence_.\r\nLike most collections (_see the built-ins [`tuple`][tuple], [`dict`][dict] and [`set`][set]_), lists can hold reference to any (or multiple) data type(s) - including other lists.\r\nLike any [sequence][sequence type], items can be accessed via `0-based index` number from the left and `-1-based index` from the right.\r\nLists can be copied in whole or in part via [slice notation][slice notation] or `<list>.copy()`.\r\n\r\nLists support both [common][common sequence operations] and [mutable][mutable sequence operations] sequence operations such as `min()`/`max()`, `<list>.index()`, `<list>.append()` and `<list>.reverse()`.\r\nList elements can be iterated over using the `for item in <list>` construct.\r\n `for index, item in enumerate(<list>)` can be used when both the element index and the element value are needed.\r\n\r\nUnder the hood, `lists` are implemented as [dynamic arrays][dynamic array] -- similar to Java's [`ArrayList`][arraylist] type, and are most often used to store groups of similar data (_strings, numbers, sets etc._) of unknown length.\r\nLists are an extremely flexible and useful data structure and many built-in methods and operations in Python produce lists as their output.\r\n\r\n\r\n## Construction\r\n\r\nA `list` can be declared as a _literal_ with square `[]` brackets and commas between elements:\r\n\r\n\r\n```python\r\n>>> no_elements = []\r\n\r\n>>> no_elements\r\n[]\r\n\r\n>>> one_element = [\"Guava\"]\r\n\r\n>>> one_element\r\n['Guava']\r\n\r\n>>> elements_separated_with_commas = [\"Parrot\", \"Bird\", 334782]\r\n\r\n>>> elements_separated_with_commas\r\n['Parrot', 'Bird', 334782]\r\n```\r\n\r\nFor readability, line breaks can be used when there are many elements or nested data structures within a `list`:\r\n\r\n\r\n```python\r\n>>> lots_of_entries = [\r\n      \"Rose\",\r\n      \"Sunflower\",\r\n      \"Poppy\",\r\n      \"Pansy\",\r\n      \"Tulip\",\r\n      \"Fuchsia\",\r\n      \"Cyclamen\",\r\n      \"Lavender\"\r\n   ]\r\n   \r\n>>> lots_of_entries\r\n['Rose', 'Sunflower', 'Poppy', 'Pansy', 'Tulip', 'Fuchsia', 'Cyclamen', 'Lavender']\r\n\r\n# Each data structure is on its own line to help clarify what they are.\r\n>>> nested_data_structures = [\r\n      {\"fish\": \"gold\", \"monkey\": \"brown\", \"parrot\": \"grey\"},\r\n      (\"fish\", \"mammal\", \"bird\"),\r\n      ['water', 'jungle', 'sky']\r\n   ]\r\n   \r\n>>> nested_data_structures\r\n[{'fish': 'gold', 'monkey': 'brown', 'parrot': 'grey'}, ('fish', 'mammal', 'bird'), ['water', 'jungle', 'sky']]\r\n```\r\n\r\nThe `list()` constructor can be used empty or with an _iterable_ as an argument.\r\n Elements in the iterable are cycled through by the constructor and added to the `list` in order:\r\n\r\n\r\n```python\r\n>>> no_elements = list()\r\n\r\n>>> no_elements\r\n[]\r\n\r\n# The tuple is unpacked and each element is added.\r\n>>> multiple_elements_from_tuple = list((\"Parrot\", \"Bird\", 334782))\r\n\r\n>>> multiple_elements_from_tuple\r\n['Parrot', 'Bird', 334782]\r\n\r\n# The set is unpacked and each element is added.\r\n>>> multiple_elements_from_set = list({2, 3, 5, 7, 11})\r\n\r\n>>> multiple_elements_from_set\r\n[2, 3, 5, 7, 11]\r\n```\r\n\r\nResults when using a `list` constructor with a `string` or a `dict` may be surprising:\r\n\r\n\r\n```python\r\n# String elements (Unicode code points) are iterated through and added *individually*.\r\n>>> multiple_elements_string = list(\"Timbuktu\")\r\n\r\n>>> multiple_elements_string\r\n['T', 'i', 'm', 'b', 'u', 'k', 't', 'u']\r\n\r\n# Unicode separators and positioning code points are also added *individually*.\r\n>>> multiple_code_points_string = list('à¤…à¤­à¥à¤¯à¤¾à¤¸')\r\n\r\n>>> multiple_code_points_string\r\n['à¤…', 'à¤­', 'à¥', 'à¤¯', 'à¤¾', 'à¤¸']\r\n\r\n# The iteration default for dictionaries is over the keys, so only key data is inserted into the list.\r\n>>> source_data = {\"fish\": \"gold\", \"monkey\": \"brown\"}\r\n\r\n>>> multiple_elements_dict_1 = list(source_data)\r\n['fish', 'monkey']\r\n```\r\n\r\nBecause the `list` constructor will only take _iterables_ (or nothing) as arguments, objects that are _not_ iterable will throw a type error.\r\n Consequently, it is much easier to create a one-item `list` via the literal method.\r\n\r\n```python\r\n# Numbers are not iterable, and so attempting to create a list with a number passed to the constructor fails.\r\n>>> one_element = list(16)\r\nTraceback (most recent call last):\r\n  File \"<stdin>\", line 1, in <module>\r\nTypeError: 'int' object is not iterable\r\n\r\n# Tuples *are* iterable, so passing a one-element tuple to the constructor does work, but it's awkward\r\n>>> one_element_from_iterable = list((16,))\r\n\r\n>>> one_element_from_iterable\r\n[16]\r\n```\r\n\r\n## Accessing elements\r\n\r\nItems inside lists (_as well as items in other sequence types `str` & `tuple`_) can be accessed via `0-based index` and _bracket notation_.\r\n Indexes can be from **`left`** --> **`right`** (_starting at zero_) or **`right`** --> **`left`** (_starting at -1_).\r\n\r\n\r\n<table>\r\n<tr>\r\n  <td style=\"vertical-align: top\"> index from left âŸ¹<br><br><br><br><br><br><br></td><td style=\"vertical-align: middle\">\r\n\r\n|  0<br>ğŸ‘‡ğŸ¾ \t|  1<br>ğŸ‘‡ğŸ¾ \t|  2<br>ğŸ‘‡ğŸ¾ \t|  3<br>ğŸ‘‡ğŸ¾ \t|  4<br>ğŸ‘‡ğŸ¾ \t|  5<br>ğŸ‘‡ğŸ¾ \t|\r\n|:--------:\t|:--------:\t|:--------:\t|:--------:\t|:--------:\t|:--------:\t|\r\n|     P    \t|     y    \t|     t    \t|     h    \t|     o    \t|     n    \t|\r\n| ğŸ‘†ğŸ¾<br>-6 \t| ğŸ‘†ğŸ¾<br>-5 \t| ğŸ‘†ğŸ¾<br>-4 \t| ğŸ‘†ğŸ¾<br>-3 \t| ğŸ‘†ğŸ¾<br>-2 \t| ğŸ‘†ğŸ¾<br>-1 \t|\r\n</td><td style=\"vertical-align: bottom\"><br><br><br><br><br>âŸ¸ index from right</td>\r\n</tr>\r\n</table>\r\n\r\n\r\n```python\r\n>>> breakfast_foods = [\"Oatmeal\", \"Fruit Salad\", \"Eggs\", \"Toast\"]\r\n\r\n# Oatmeal is at index 0 or index -4.\r\n>>> breakfast_foods[0]\r\n'Oatmeal'\r\n\r\n>>> breakfast_foods[-4]\r\n'Oatmeal'\r\n\r\n# Eggs are at index -2 or 2\r\n>>> breakfast_foods[-2]\r\n'Eggs'\r\n\r\n>>> breakfast_foods[2]\r\n'Eggs'\r\n\r\n# Toast is at -1\r\n>>> breakfast_foods[-1]\r\n'Toast'\r\n```\r\n\r\nA section of the elements inside a `list` can be accessed via _slice notation_ (`<list>[start:stop]`).\r\n A _slice_ is defined as an element sequence at position `index`, such that `start <= index < stop`.\r\n _Slicing_ returns a copy of the \"sliced\" items and does not modify the original `list`.\r\n\r\n\r\nA `step` parameter can also be used `[start:stop:step]` to \"skip over\" or filter the `list` elements (_for example, a `step` of 2 will select every other element in the range_):\r\n\r\n\r\n```python\r\n>>> colors = [\"Red\", \"Purple\", \"Green\", \"Yellow\", \"Orange\", \"Pink\", \"Blue\", \"Grey\"]\r\n\r\n# If there is no step parameter, the step is assumed to be 1.\r\n>>> middle_colors = colors[2:6]\r\n\r\n>>> middle_colors\r\n['Green', 'Yellow', 'Orange', 'Pink']\r\n\r\n# If the start or stop parameters are omitted, the slice will\r\n# start at index zero, and will stop at the end of the list.\r\n>>> primary_colors = colors[::3]\r\n\r\n>>> primary_colors\r\n['Red', 'Yellow', 'Blue']\r\n```\r\n\r\n## Working with lists\r\n\r\nThe usage of the built-in `sum()` function on a list will return the sum of all the numbers in the list:\r\n\r\n```python\r\n>>> number_list = [1, 2, 3, 4]\r\n>>> sum(number_list)\r\n10\r\n```\r\n\r\nYou can also get the _length_ of a list by using the `len()` function:\r\n\r\n```python\r\n>>> long_list = [\"A\", \"B\", \"C\", \"D\", \"E\", \"F\", \"G\", \"H\", \"I\", \"J\"]\r\n>>> len(long_list)\r\n10\r\n```\r\n\r\nLists can be also combined in various ways:\r\n\r\n```python\r\n# Using the plus + operator unpacks each list and creates a new list, but it is not efficient.\r\n>>> new_via_concatenate = [\"George\", 5] + [\"cat\", \"Tabby\"]\r\n\r\n>>> new_via_concatenate\r\n['George', 5, 'cat', 'Tabby']\r\n\r\n# Likewise, using the multiplication operator * is the equivalent of using + n times.\r\n>>> first_group = [\"cat\", \"dog\", \"elephant\"]\r\n>>> multiplied_group = first_group * 3\r\n\r\n>>> multiplied_group\r\n['cat', 'dog', 'elephant', 'cat', 'dog', 'elephant', 'cat', 'dog', 'elephant']\r\n```\r\n\r\nLists supply an _iterator_, and can be looped through/over in the same manner as other _sequence types_.\r\n\r\n```python\r\n#  Looping through the list and printing out each element.\r\n>>> colors = [\"Orange\", \"Green\", \"Grey\", \"Blue\"]\r\n\r\n>>> for item in colors:\r\n...     print(item)\r\n...\r\nOrange\r\nGreen\r\nGrey\r\nBlue\r\n```\r\n\r\n_For a more in-depth explanation, of `loops` and `iterators`, complete the `loops` concept._\r\n\r\n[arraylist]: https://beginnersbook.com/2013/12/java-arraylist/\r\n[common sequence operations]: https://docs.python.org/3/library/stdtypes.html#common-sequence-operations\r\n[dict]: https://docs.python.org/3/library/stdtypes.html#dict\r\n[dynamic array]: https://en.wikipedia.org/wiki/Dynamic_array\r\n[list]: https://docs.python.org/3/library/stdtypes.html#list\r\n[mutable sequence operations]: https://docs.python.org/3/library/stdtypes.html#typesseq-mutable\r\n[sequence type]: https://docs.python.org/3/library/stdtypes.html#sequence-types-list-tuple-range\r\n[set]: https://docs.python.org/3/library/stdtypes.html#set\r\n[slice notation]: https://docs.python.org/3/reference/expressions.html#slicings\r\n[tuple]: https://docs.python.org/3/library/stdtypes.html#tuple\r\n",
    "hints": "# Hints\r\n\r\n## General\r\n\r\n## 1. Tracking Poker Rounds\r\n\r\n- Lists in Python may be [constructed][constructed] in multiple ways.\r\n- This function should [return][return] a `list`.\r\n\r\n## 2. Keeping all Rounds in the Same Place\r\n\r\n- Sequence types such as `list` support [common operations][common sequence operations].\r\n- This function should [return][return] a `list`.\r\n\r\n## 3. Finding Prior Rounds\r\n\r\n- Sequence types such as `list` support a few [common operations][common sequence operations].\r\n- This function should [return][return] a `bool`.\r\n\r\n## 4. Averaging Card Values\r\n\r\n- To get the average, this function should count how many items are in the `list` and sum up their values. Then, return the sum divided by the count.\r\n\r\n## 5. Alternate Averages\r\n\r\n- Sequence types such as `list` support a few [common operations][common sequence operations].\r\n- To access an element, use the square brackets (`<list>[]`) notation.\r\n- Remember that the first element of the `list` is at index 0 from the **left-hand** side.\r\n- In Python, negative indexing starts at -1 from the **right-hand** side. This means that you can find the last element of a `list` by using `<list>[-1]`.\r\n- Think about how you could reuse the code from the functions that you have already implemented.\r\n\r\n## 6. More Averaging Techniques\r\n\r\n- Sequence types such as `list` already support a few [common operations][common sequence operations].\r\n- Think about reusing the code from the functions that you just implemented.\r\n- The slice syntax supports a _step value_ (`<list>[<start>:<stop>:<step>]`).\r\n\r\n## 7. Bonus Round Rules\r\n\r\n- Lists are _mutable_. Once a `list` is created, you can modify, delete or add any type of element you wish.\r\n- Python provides a wide range of [ways to modify `lists`][ways to modify `lists`].\r\n\r\n\r\n[common sequence operations]: https://docs.python.org/3/library/stdtypes.html#sequence-types-list-tuple-range\r\n[constructed]: https://docs.python.org/3/library/stdtypes.html#list\r\n[return]: https://www.w3schools.com/python/ref_keyword_return.asp\r\n[ways to modify `lists`]: https://realpython.com/python-lists-tuples/#lists-are-mutable\r\n",
    "instructions": "# Instructions\r\n\r\nElyse is really looking forward to playing some poker (and other card games) during her upcoming trip to Vegas.\r\n Being a big fan of \"self-tracking\" she wants to put together some small functions that will help her with tracking tasks and has asked for your help thinking them through.\r\n\r\n## 1. Tracking Poker Rounds\r\n\r\nElyse is especially fond of poker, and wants to track how many rounds she plays - and _which rounds_ those are.\r\n Every round has its own number, and every table shows the round number currently being played.\r\n Elyse chooses a table and sits down to play her first round. She plans on playing three rounds.\r\n\r\nImplement a function `get_rounds(<round_number>)` that takes the current round number and returns a single `list` with that round and the _next two_ that are coming up:\r\n\r\n```python\r\n>>> get_rounds(27)\r\n[27, 28, 29]\r\n```\r\n\r\n## 2. Keeping all Rounds in the Same Place\r\n\r\nElyse played a few rounds at the first table, then took a break and played some more rounds at a second table ... but ended up with a different list for each table!\r\n She wants to put the two lists together, so she can track all of the poker rounds in the same place.\r\n\r\nImplement a function `concatenate_rounds(<rounds_1>, <rounds_2>)` that takes two lists and returns a single `list` consisting of all the rounds in the first `list`, followed by all the rounds in the second `list`:\r\n\r\n```python\r\n>>> concatenate_rounds([27, 28, 29], [35, 36])\r\n[27, 28, 29, 35, 36]\r\n```\r\n\r\n## 3. Finding Prior Rounds\r\n\r\nTalking about some of the prior Poker rounds, another player remarks how similarly two of them played out.\r\n Elyse is not sure if she played those rounds or not.\r\n\r\nImplement a function `list_contains_round(<rounds>, <round_number>)` that takes two arguments, a list of rounds played and a round number.\r\n The function will return `True` if the round is in the list of rounds played, `False` if not:\r\n\r\n```python\r\n>>> list_contains_round([27, 28, 29, 35, 36], 29)\r\nTrue\r\n\r\n>>> list_contains_round([27, 28, 29, 35, 36], 30)\r\nFalse\r\n```\r\n\r\n## 4. Averaging Card Values\r\n\r\nElyse wants to try out a new game called Black Joe.\r\n It's similar to Black Jack - where your goal is to have the cards in your hand add up to a target value - but in Black Joe the goal is to get the _average_ of the card values to be 7.\r\n The average can be found by summing up all the card values and then dividing that sum by the number of cards in the hand.\r\n\r\nImplement a function `card_average(<hand>)` that will return the average value of a hand of Black Joe.\r\n\r\n```python\r\n>>> card_average([5, 6, 7])\r\n6.0\r\n```\r\n\r\n## 5. Alternate Averages\r\n\r\nIn Black Joe, speed is important. Elyse is going to try and find a faster way of finding the average.\r\n\r\nShe has thought of two ways of getting an _average-like_ number:\r\n\r\n- Take the average of the _first_ and _last_ number in the hand.\r\n- Using the median (middle card) of the hand.\r\n  \r\nImplement the function `approx_average_is_average(<hand>)`, given `hand`, a list containing the values of the cards in your hand.\r\n\r\nReturn `True` if either _one_ `or` _both_ of the, above named, strategies result in a number _equal_ to the _actual average_.\r\n\r\nNote: _The length of all hands are odd, to make finding a median easier._\r\n\r\n```python\r\n>>> approx_average_is_average([1, 2, 3])\r\nTrue\r\n\r\n>>> approx_average_is_average([2, 3, 4, 8, 8])\r\nTrue\r\n\r\n>>> approx_average_is_average([1, 2, 3, 5, 9])\r\nFalse\r\n```\r\n\r\n## 6. More Averaging Techniques\r\n\r\nIntrigued by the results of her averaging experiment, Elyse is wondering if taking the average of the cards at the _even_ positions versus the average of the cards at the _odd_ positions would give the same results.\r\n Time for another test function!\r\n\r\nImplement a function `average_even_is_average_odd(<hand>)` that returns a Boolean indicating if the average of the cards at even indexes is the same as the average of the cards at odd indexes.\r\n\r\n```python\r\n>>> average_even_is_average_odd([1, 2, 3])\r\nTrue\r\n\r\n>>> average_even_is_average_odd([1, 2, 3, 4])\r\nFalse\r\n```\r\n\r\n## 7. Bonus Round Rules\r\n\r\nEvery 11th hand in Black Joe is a bonus hand with a bonus rule: if the last card you draw is a Jack, you double its value.\r\n\r\nImplement a function `maybe_double_last(<hand>)` that takes a hand and checks if the last card is a Jack (11).\r\n If the last card **is** a Jack (11), double its value before returning the hand.\r\n\r\n```python\r\n>>> hand = [5, 9, 11]\r\n>>> maybe_double_last(hand)\r\n[5, 9, 22]\r\n\r\n>>> hand = [5, 9, 10]\r\n>>> maybe_double_last(hand)\r\n[5, 9, 10]\r\n```\r\n",
    "design": "# Design\r\n\r\n## Goal\r\n\r\nThe goal of this exercise is to teach the basics of the `list` data type in Python. The exercise will walk the student through how to create lists via various methods, iterate through lists via looping, and access items in various lists through indexing and forming/accessing list slices.\r\n\r\n## Learning objectives\r\n\r\n- Create a `list` via constructor (`list()`) & literal (`[]`)\r\n- Combine two or more lists by concatenation via `+`\r\n- Check for an items membership/absence in a list using `in`\r\n- Access items in a list via index (`bracket notation`)\r\n- Access a range of items in a list via list slicing (`[start:stop:step]`)\r\n- Usage of `sum()` on a list with numbers\r\n- Usage of `len()` to get the length of a list\r\n\r\n## Out of scope\r\n\r\n- List Comprehensions (these will be covered in their own concept exercise)\r\n- List methods (`copy()`, `append()`, `sort()` etc)\r\n- How builtin functions relate to lists (`len()`, `max()`, `min()`, `count()`, `sorted()`)\r\n- Construction of complex or nested `lists` (i.e a `list` of `dicts`, a `list` of `lists`, a `list` of `tuples`)\r\n- Consequences and considerations of mutability\r\n\r\n## Concepts\r\n\r\n- `lists`\r\n- indexing\r\n- slicing\r\n- concatenation\r\n\r\n## Prerequisites\r\n\r\n- `basics`\r\n- `str`\r\n- `comparisons`\r\n- `conditionals`\r\n"
  },
  "config": {
    "authors": [
      "itamargal",
      "isaacg",
      "bethanyg"
    ],
    "contributors": [
      "valentin-p",
      "pranasziaukas"
    ],
    "files": {
      "solution": [
        "lists.py"
      ],
      "test": [
        "lists_test.py"
      ],
      "exemplar": [
        ".meta/exemplar.py"
      ]
    },
    "icon": "poker",
    "blurb": "Learn about lists by tracking hands in card games."
  },
  "starter_code": "\"\"\"Functions for tracking poker hands and assorted card tasks.\r\n\r\nPython list documentation: https://docs.python.org/3/tutorial/datastructures.html\r\n\"\"\"\r\n\r\n\r\ndef get_rounds(number):\r\n    \"\"\"Create a list containing the current and next two round numbers.\r\n\r\n    :param number: int - current round number.\r\n    :return: list - current round and the two that follow.\r\n    \"\"\"\r\n\r\n    pass\r\n\r\n\r\ndef concatenate_rounds(rounds_1, rounds_2):\r\n    \"\"\"Concatenate two lists of round numbers.\r\n\r\n    :param rounds_1: list - first rounds played.\r\n    :param rounds_2: list - second set of rounds played.\r\n    :return: list - all rounds played.\r\n    \"\"\"\r\n\r\n    pass\r\n\r\n\r\ndef list_contains_round(rounds, number):\r\n    \"\"\"Check if the list of rounds contains the specified number.\r\n\r\n    :param rounds: list - rounds played.\r\n    :param number: int - round number.\r\n    :return: bool - was the round played?\r\n    \"\"\"\r\n\r\n    pass\r\n\r\n\r\ndef card_average(hand):\r\n    \"\"\"Calculate and returns the average card value from the list.\r\n\r\n    :param hand: list - cards in hand.\r\n    :return: float - average value of the cards in the hand.\r\n    \"\"\"\r\n\r\n    pass\r\n\r\n\r\ndef approx_average_is_average(hand):\r\n    \"\"\"Return if the (average of first and last card values) OR ('middle' card) == calculated average.\r\n\r\n    :param hand: list - cards in hand.\r\n    :return: bool - does one of the approximate averages equal the `true average`?\r\n    \"\"\"\r\n\r\n    pass\r\n\r\n\r\ndef average_even_is_average_odd(hand):\r\n    \"\"\"Return if the (average of even indexed card values) == (average of odd indexed card values).\r\n\r\n    :param hand: list - cards in hand.\r\n    :return: bool - are even and odd averages equal?\r\n    \"\"\"\r\n\r\n    pass\r\n\r\n\r\ndef maybe_double_last(hand):\r\n    \"\"\"Multiply a Jack card value in the last index position by 2.\r\n\r\n    :param hand: list - cards in hand.\r\n    :return: list - hand with Jacks (if present) value doubled.\r\n    \"\"\"\r\n\r\n    pass\r\n",
  "exemplar_code": "\"\"\"Functions for tracking poker hands and assorted card tasks.\r\n\r\nPython list documentation: https://docs.python.org/3/tutorial/datastructures.html\r\n\"\"\"\r\n\r\n\r\ndef get_rounds(number):\r\n    \"\"\"Create a list containing the current and next two round numbers.\r\n\r\n    :param number: int - current round number.\r\n    :return: list - current round and the two that follow.\r\n    \"\"\"\r\n\r\n    return [number, number + 1, number + 2]\r\n\r\n\r\ndef concatenate_rounds(rounds_1, rounds_2):\r\n    \"\"\"Concatenate two lists of round numbers.\r\n\r\n    :param rounds_1: list - first rounds played.\r\n    :param rounds_2: list - second set of rounds played.\r\n    :return: list - all rounds played.\r\n    \"\"\"\r\n\r\n    return rounds_1 + rounds_2\r\n\r\n\r\ndef list_contains_round(rounds, number):\r\n    \"\"\"Check if the list of rounds contains the specified number.\r\n\r\n    :param rounds: list - rounds played.\r\n    :param number: int - round number.\r\n    :return: bool - was the round played?\r\n    \"\"\"\r\n\r\n    return number in rounds\r\n\r\n\r\ndef card_average(hand):\r\n    \"\"\"Calculate and returns the average card value from the list.\r\n\r\n    :param hand: list - cards in hand.\r\n    :return: float - average value of the cards in the hand.\r\n    \"\"\"\r\n\r\n    return sum(hand) / len(hand)\r\n\r\n\r\ndef approx_average_is_average(hand):\r\n    \"\"\"Return if the (average of first and last card values) OR ('middle' card) == calculated average.\r\n\r\n    :param hand: list - cards in hand.\r\n    :return: bool - does one of the approximate averages equal the `true average`?\r\n    \"\"\"\r\n\r\n    real_average = card_average(hand)\r\n\r\n    if card_average([hand[0], hand[-1]]) == real_average:\r\n        is_same = True\r\n    elif hand[len(hand) // 2] == real_average:\r\n        is_same = True\r\n    else:\r\n        is_same = False\r\n\r\n    return is_same\r\n\r\n\r\ndef average_even_is_average_odd(hand):\r\n    \"\"\"Return if the (average of even indexed card values) == (average of odd indexed card values).\r\n\r\n    :param hand: list - cards in hand.\r\n    :return: bool - are even and odd averages equal?\r\n    \"\"\"\r\n\r\n    return card_average(hand[::2]) == card_average(hand[1::2])\r\n\r\n\r\ndef maybe_double_last(hand):\r\n    \"\"\"Multiply a Jack card value in the last index position by 2.\r\n\r\n    :param hand: list - cards in hand.\r\n    :return: list - hand with Jacks (if present) value doubled.\r\n    \"\"\"\r\n\r\n    if hand[-1] == 11:\r\n        hand[-1] *= 2\r\n\r\n    return hand\r\n",
  "tests": "import unittest\r\nimport pytest\r\n\r\nfrom lists import (\r\n    get_rounds,\r\n    concatenate_rounds,\r\n    list_contains_round,\r\n    card_average,\r\n    approx_average_is_average,\r\n    average_even_is_average_odd,\r\n    maybe_double_last,\r\n)\r\n\r\n\r\nclass CardGamesTest(unittest.TestCase):\r\n\r\n    @pytest.mark.task(taskno=1)\r\n    def test_get_rounds(self):\r\n\r\n        input_data = [0, 1, 10, 27, 99, 666]\r\n        result_data = [[0, 1, 2], [1, 2, 3],\r\n                       [10, 11, 12], [27, 28, 29],\r\n                       [99, 100, 101], [666, 667, 668]]\r\n\r\n        for variant, (number, expected) in enumerate(zip(input_data, result_data), start=1):\r\n            with self.subTest(f'variation #{variant}', number=number, expected=expected):\r\n                actual_result = get_rounds(number)\r\n                error_message = (f'Called get_rounds({number}). '\r\n                                 f'The function returned {actual_result}, '\r\n                                 f'but the tests expected rounds {expected} '\r\n                                 f'given the current round {number}.')\r\n\r\n                self.assertEqual(actual_result, expected, msg=error_message)\r\n\r\n    @pytest.mark.task(taskno=2)\r\n    def test_concatenate_rounds(self):\r\n\r\n        input_data = [([], []), ([0, 1], []), ([], [1, 2]),\r\n                      ([1], [2]), ([27, 28, 29], [35, 36]),\r\n                      ([1, 2, 3], [4, 5, 6])]\r\n\r\n        result_data = [[], [0, 1], [1, 2], [1, 2],\r\n                       [27, 28, 29, 35, 36],\r\n                       [1, 2, 3, 4, 5, 6]]\r\n\r\n        for variant, ((rounds_1, rounds_2), expected) in enumerate(zip(input_data, result_data), start=1):\r\n            with self.subTest(f'variation #{variant}', rounds_1=rounds_1, rounds_2=rounds_2, expected=expected):\r\n                actual_result = concatenate_rounds(rounds_1, rounds_2)\r\n                error_message = (f'Called concatenate_rounds({rounds_1}, {rounds_2}). '\r\n                                 f'The function returned {actual_result}, but the tests '\r\n                                 f'expected {expected} as the concatenation '\r\n                                 f'of {rounds_1} and {rounds_2}.')\r\n\r\n                self.assertEqual(actual_result, expected, msg=error_message)\r\n\r\n    @pytest.mark.task(taskno=3)\r\n    def test_list_contains_round(self):\r\n\r\n        input_data = [([], 1), ([1, 2, 3], 0),\r\n                      ([27, 28, 29, 35, 36], 30),\r\n                      ([1], 1), ([1, 2, 3], 1),\r\n                      ([27, 28, 29, 35, 36], 29)]\r\n        result_data = [False, False, False, True, True, True]\r\n\r\n        for variant, ((rounds, round_number), expected) in enumerate(zip(input_data, result_data), start=1):\r\n            with self.subTest(f'variation #{variant}', rounds=rounds, round_number=round_number, expected=expected):\r\n                actual_result = list_contains_round(rounds, round_number)\r\n                error_message = (f'Called list_contains_round({rounds}, {round_number}). '\r\n                                 f'The function returned {actual_result}, but round {round_number} '\r\n                                 f'{\"is\" if expected else \"is not\"} in {rounds}.')\r\n\r\n                self.assertEqual(actual_result, expected, msg=error_message)\r\n\r\n    @pytest.mark.task(taskno=4)\r\n    def test_card_average(self):\r\n\r\n        input_data = [[1], [5, 6, 7], [1, 2, 3, 4], [1, 10, 100]]\r\n        result_data = [1.0, 6.0, 2.5, 37.0]\r\n\r\n        for variant, (hand, expected) in enumerate(zip(input_data, result_data), start=1):\r\n            with self.subTest(f'variation #{variant}', hand=hand, expected=expected):\r\n                actual_result = card_average(hand)\r\n                error_message = (f'Called card_average({hand}). '\r\n                                 f'The function returned {actual_result}, but '\r\n                                 f'the tests expected {expected} as the average of {hand}.')\r\n\r\n                self.assertEqual(actual_result, expected, msg=error_message)\r\n\r\n    @pytest.mark.task(taskno=5)\r\n    def test_approx_average_is_average(self):\r\n\r\n        input_data = [[0, 1, 5], [3, 6, 9, 12, 150], [1, 2, 3, 5, 9],\r\n                      [2, 3, 4, 7, 8], [1, 2, 3], [2, 3, 4],\r\n                      [2, 3, 4, 8, 8], [1, 2, 4, 5, 8]]\r\n\r\n        result_data = [False, False, False, False, True, True, True, True]\r\n\r\n        for variant, (hand, expected) in enumerate(zip(input_data, result_data), start=1):\r\n            with self.subTest(f'variation #{variant}', hand=hand, expected=expected):\r\n                actual_result = approx_average_is_average(hand)\r\n                error_message = (f'Called approx_average_is_average({hand}). '\r\n                                 f'The function returned {actual_result}, but '\r\n                                 f'the hand {hand} {\"does\" if expected else \"does not\"} '\r\n                                 f'yield the same approximate average.')\r\n\r\n                self.assertEqual(actual_result, expected, msg=error_message)\r\n\r\n    @pytest.mark.task(taskno=6)\r\n    def test_average_even_is_average_odd(self):\r\n\r\n        input_data = [[5, 6, 8], [1, 2, 3, 4], [1, 2, 3], [5, 6, 7], [1, 3, 5, 7, 9]]\r\n        result_data = [False, False, True, True, True]\r\n\r\n        for variant, (input_hand, expected) in enumerate(zip(input_data, result_data), start=1):\r\n            with self.subTest(f'variation #{variant}', input_hand=input_hand, expected=expected):\r\n                actual_result = average_even_is_average_odd(input_hand)\r\n                error_message = (f'Called average_even_is_average_odd({input_hand}). '\r\n                                 f'The function returned {actual_result}, but '\r\n                                 f'the hand {\"does\" if expected else \"does not\"} '\r\n                                 f'yield the same odd-even average.')\r\n\r\n                self.assertEqual(actual_result, expected, msg=error_message)\r\n\r\n    @pytest.mark.task(taskno=7)\r\n    def test_maybe_double_last(self):\r\n\r\n        input_data = [(1, 2, 11), (5, 9, 11), (5, 9, 10), (1, 2, 3), (1, 11, 8)]\r\n        result_data = [[1, 2, 22], [5, 9, 22], [5, 9, 10], [1, 2, 3], [1, 11, 8]]\r\n\r\n        for variant, (hand, expected) in enumerate(zip(input_data, result_data), start=1):\r\n            with self.subTest(f'variation #{variant}', hand=list(hand), expected=expected):\r\n                actual_result = maybe_double_last(list(hand))\r\n                error_message = (f'Called maybe_double_last({list(hand)}). '\r\n                                 f'The function returned {actual_result}, but '\r\n                                 f'the tests expected {expected} as the maybe-doubled version of {list(hand)}.')\r\n\r\n                self.assertEqual(actual_result, expected, msg=error_message)\r\n"
}