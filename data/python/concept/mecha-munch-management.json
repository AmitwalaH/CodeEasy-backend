{
  "concept": "mecha-munch-management",
  "docs": {
    "introduction": "# Dictionary Methods in Python\r\n\r\nThe `dict` class in Python provides many useful [methods][dict-methods] for working with dictionaries.\r\nSome were introduced in the concept for `dicts`.\r\nHere we cover a few more - along with some techniques for iterating through and manipulating dictionaries.\r\n\r\n### Use `setdefault()` for Error-Free Insertion\r\n\r\nThe dictionary concept previously covered that `.get(key, <default value>)` returns an existing `value` or the `default value` if a `key` is not found in a dictionary, thereby avoiding a `KeyError`.\r\nThis works well in situations where you would rather not have extra error handling but cannot trust that a looked-for `key` will be present.\r\n\r\nFor a similarly \"safe\" (_without KeyError_) insertion operation, there is the `.setdefault(key, <default value>)` method.\r\n`setdefault(key, <default value>)` will return the `value` if the `key` is found in the dictionary.\r\nIf the key is **not** found, it will _insert_ the (`key`, `default value`) pair and return the `default value` for use.\r\n\r\n```python\r\n>>> palette_I = {'Grassy Green': '#9bc400', 'Purple Mountains Majesty': '#8076a3', 'Misty Mountain Pink': '#f9c5bd'}\r\n\r\n# Looking for the value associated with key \"Rock Brown\".\r\n# The key does not exist, so it is added with the default value, and the value is returned.\r\n>>> palette_I.setdefault('Rock Brown', '#694605')\r\n'#694605'\r\n\r\n# The (key, default value) pair has now been added to the dictionary.\r\n>>> palette_I\r\n{'Grassy Green': '#9bc400', 'Purple Mountains Majesty': '#8076a3', 'Misty Mountain Pink': '#f9c5bd', 'Rock Brown': '#694605'}\r\n```\r\n\r\n## Use `fromkeys()` to Populate a Dictionary from an Iterable\r\n\r\nTo quickly populate a dictionary with various `keys` and default values, the _class method_ [`fromkeys(iterable, <default value>)`][fromkeys] will iterate through an iterable of `keys` and create a new `dict`.\r\nAll `values` will be set to the `default value` provided:\r\n\r\n```python\r\n>>> new_dict = dict.fromkeys(['Grassy Green', 'Purple Mountains Majesty', 'Misty Mountain Pink'], 'fill in hex color here')\r\n\r\n{'Grassy Green': 'fill in hex color here',\r\n 'Purple Mountains Majesty': 'fill in hex color here',\r\n 'Misty Mountain Pink': 'fill in hex color here'}\r\n```\r\n\r\n## Iterating Over Entries in a Dictionary Via Views\r\n\r\nThe `.keys()`, `.values()`, and `.items()` methods return [_iterable views_][dict-views] of a dictionary.\r\n\r\nThese views can be used to easily loop over entries without altering them.\r\nViews are also _dynamic_ -- when underlying dictionary data changes, the associated `view object` will reflect the change:\r\n\r\n```python\r\n>>> palette_I = {'Grassy Green': '#9bc400',\r\n                 'Purple Mountains Majesty': '#8076a3',\r\n                  'Misty Mountain Pink': '#f9c5bd'}\r\n\r\n# Using .keys() returns a list of keys.\r\n>>> palette_I.keys()\r\ndict_keys(['Grassy Green', 'Purple Mountains Majesty', 'Misty Mountain Pink'])\r\n\r\n# Using .values() returns a list of values.\r\n>>> palette_I.values()\r\ndict_values(['#9bc400', '#8076a3', '#f9c5bd'])\r\n\r\n# Using .items() returns a list of (key, value) tuples.\r\n>>> palette_I.items()\r\ndict_items([('Grassy Green', '#9bc400'), ('Purple Mountains Majesty', '#8076a3'), ('Misty Mountain Pink', '#f9c5bd')])\r\n\r\n# Views are dynamic.  Changing values in the dict changes all of the associated views.\r\n>>> palette_I['Purple Mountains Majesty'] = (128, 118, 163)\r\n>>> palette_I['Deep Red'] = '#932432'\r\n\r\n>>> palette_I.values()\r\ndict_values(['#9bc400', (128, 118, 163), '#f9c5bd', '#932432'])\r\n\r\n>>> palette_I.keys()\r\ndict_keys(['Grassy Green', 'Purple Mountains Majesty', 'Misty Mountain Pink', 'Deep Red'])\r\n\r\n>>> palette_I.items()\r\ndict_items([('Grassy Green', '#9bc400'), ('Purple Mountains Majesty', (128, 118, 163)), ('Misty Mountain Pink', '#f9c5bd'), ('Deep Red', '#932432')])\r\n```\r\n\r\n## More on `.keys()`, `.values()`, and `.items()`\r\n\r\nIn Python 3.7+, `dicts` preserve the order in which entries are inserted allowing First-in, First-out (_`FIFO`_),  iteration when using `.keys()`, `.values()`, or `.items()`.\r\n\r\nIn Python 3.8+, views are also _reversible_.\r\nThis allows keys, values, or (`key`, `value`) pairs to be iterated over in Last-in, First-out (`LIFO`) order by using `reversed(<dict>.keys())`, `reversed(<dict>.values())`, or `reversed(<dict>.items())`:\r\n\r\n```python\r\n>>> palette_II = {'Factory Stone Purple': '#7c677f', 'Green Treeline': '#478559', 'Purple baseline': '#161748'}\r\n\r\n# Iterating in insertion order (First in, first out)\r\n>>> for item in palette_II.items():\r\n...     print(item)\r\n...\r\n('Factory Stone Purple', '#7c677f')\r\n('Green Treeline', '#478559')\r\n('Purple baseline', '#161748')\r\n\r\n\r\n# Iterating in the reverse direction. (Last in, first out)\r\n>>> for item in reversed(palette_II.items()):\r\n...    print (item)\r\n...\r\n('Purple baseline', '#161748')\r\n('Green Treeline', '#478559')\r\n('Factory Stone Purple', '#7c677f')\r\n```\r\n\r\n## Sorting a Dictionary\r\n\r\nDictionaries do not have a built-in sorting method.\r\nHowever, it is possible to sort a `dict` _view_ using the built-in function `sorted()` with `dict.items()`.\r\nThe sorted view can then be used to create a new dictionary.\r\nLike iteration, the default sort is over the dictionary `keys`.\r\n\r\n```python\r\n# Default ordering for a dictionary is insertion order (First in, first out).\r\n>>> color_palette = {'Grassy Green': '#9bc400', \r\n                    'Purple Mountains Majesty': '#8076a3', \r\n                    'Misty Mountain Pink': '#f9c5bd', \r\n                    'Factory Stone Purple': '#7c677f', \r\n                    'Green Treeline': '#478559', \r\n                    'Purple baseline': '#161748'}\r\n \r\n \r\n# The default sort order for a dictionary uses the keys.\r\n>>> sorted_palette = dict(sorted(color_palette.items()))\r\n>>> sorted_palette\r\n{'Factory Stone Purple': '#7c677f',\r\n 'Grassy Green': '#9bc400',\r\n 'Green Treeline': '#478559',\r\n 'Misty Mountain Pink': '#f9c5bd',\r\n 'Purple Mountains Majesty': '#8076a3',\r\n 'Purple baseline': '#161748'}\r\n```\r\n\r\n## Combining Dictionaries with `.update()`\r\n\r\n`<dict_one>.update(<dict_two>)` can be used to _combine_ two dictionaries.\r\nThis method will take the (`key`,`value`) pairs of `<dict_two>` and write them into `<dict_one>`:\r\n\r\n```python\r\n>>> palette_I = {'Grassy Green': '#9bc400',\r\n                 'Purple Mountains Majesty': '#8076a3',\r\n                  'Misty Mountain Pink': '#f9c5bd'}\r\n>>> palette_II = {'Factory Stone Purple': '#7c677f',\r\n                  'Green Treeline': '#478559',\r\n                  'Purple Baseline': '#161748'}\r\n\r\n>>> palette_I.update(palette_II)\r\n\r\n# Note that new items from palette_II are added.\r\n>>> palette_I\r\n{'Grassy Green': '#9bc400', 'Purple Mountains Majesty': '#8076a3', 'Misty Mountain Pink': '#f9c5bd', 'Factory Stone Purple': '#7c677f', 'Green Treeline': '#478559', 'Purple Baseline': '#161748'}\r\n```\r\n\r\nWhere keys in the two dictionaries _overlap_, the `value` in `dict_one` will be _overwritten_ by the corresponding `value` from `dict_two`:\r\n\r\n```python\r\n>>> palette_I =   {'Grassy Green': '#9bc400', 'Purple Mountains Majesty': '#8076a3', 'Misty Mountain Pink': '#f9c5bd', \r\n                   'Factory Stone Purple': '#7c677f', 'Green Treeline': '#478559', 'Purple baseline': '#161748'}\r\n>>> palette_III = {'Grassy Green': (155, 196, 0), 'Purple Mountains Majesty': (128, 118, 163),\r\n                   'Misty Mountain Pink': (249, 197, 189)}\r\n>>> palette_I.update(palette_III)\r\n\r\n# Overlapping values in palette_I are replaced with values from palette_III\r\n>>> palette_I\r\n{'Grassy Green': (155, 196, 0),\r\n  'Purple Mountains Majesty': (128, 118, 163), \r\n  'Misty Mountain Pink': (249, 197, 189), \r\n  'Factory Stone Purple': '#7c677f', \r\n  'Green Treeline': '#478559', 'Purple baseline': '#161748'}\r\n```\r\n\r\n## Merge or Update Dictionaries Via the Union (`|`) Operators\r\n\r\nPython 3.9 introduces a different means of merging `dicts`: the `union` operators.\r\n`dict_one | dict_two` will create a **new dictionary**, made up of the (`key`, `value`) pairs of `dict_one` and `dict_two`.\r\nWhen both dictionaries share keys, `dict_two` values take precedence.\r\n\r\n```python\r\n>>> palette_I = {'Grassy Green': '#9bc400', 'Purple Mountains Majesty': '#8076a3', 'Misty Mountain Pink': '#f9c5bd'}\r\n>>> palette_II = {'Factory Stone Purple': '#7c677f', 'Green Treeline': '#478559', 'Purple baseline': '#161748'}\r\n>>> new_dict = palette_I | palette_II\r\n>>> new_dict\r\n...\r\n{'Grassy Green': '#9bc400',\r\n 'Purple Mountains Majesty': '#8076a3',\r\n 'Misty Mountain Pink': '#f9c5bd',\r\n 'Factory Stone Purple': '#7c677f',\r\n 'Green Treeline': '#478559',\r\n 'Purple baseline': '#161748'}\r\n```\r\n\r\n`dict_one |= other` behaves similar to `<dict_one>.update(<other>)`, but in this case, `other` can be either a `dict` or an iterable of (`key`, `value`) pairs:\r\n\r\n```python\r\n>>> palette_III = {'Grassy Green': (155, 196, 0),\r\n                   'Purple Mountains Majesty': (128, 118, 163),\r\n                   'Misty Mountain Pink': (249, 197, 189)}\r\n>>> new_dict |= palette_III\r\n>>> new_dict\r\n...\r\n{'Grassy Green': (155, 196, 0),\r\n'Purple Mountains Majesty': (128, 118, 163),\r\n'Misty Mountain Pink': (249, 197, 189),\r\n'Factory Stone Purple': '#7c677f',\r\n'Green Treeline': '#478559',\r\n'Purple baseline': '#161748'}\r\n```\r\n\r\nFor a detailed explanation of dictionaries and methods for working with them, the [official tutorial][dicts-docs] and the [official library reference][mapping-types-dict] are excellent starting places.\r\n\r\n[Real Python][how-to-dicts] and [Finxter][fi-dict-guide] also have very thorough articles on Python dictionaries.\r\n\r\n[dict-methods]: https://docs.python.org/3/library/stdtypes.html#dict\r\n[dict-views]: https://docs.python.org/3/library/stdtypes.html#dict-views\r\n[dicts-docs]: https://docs.python.org/3/tutorial/datastructures.html#dictionaries\r\n[fi-dict-guide]: https://blog.finxter.com/python-dictionary\r\n[fromkeys]: https://docs.python.org/3/library/stdtypes.html#dict.fromkeys\r\n[how-to-dicts]: https://realpython.com/python-dicts/\r\n[mapping-types-dict]: https://docs.python.org/3/library/stdtypes.html#mapping-types-dict\r\n",
    "hints": "# Hints\r\n\r\n## General\r\n\r\nRemember, this is an [MVP][mvp].\r\nThat means you don't need to get too fancy with error handling or different \"edge case\" scenarios.\r\nIt's OK to be simple and direct with the functions you are writing.\r\n\r\nThe dictionary section of the [official tutorial][dicts-docs] and the mapping type [official library reference][mapping-types-dict] are excellent places to look for more help with all these methods.\r\n\r\n\r\n## 1. Add Item(s) to the Users Shopping Cart\r\n\r\n- You will need to iterate through each item in `items_to_add`.\r\n- You can avoid a `KeyError` when a key is missing by using a `dict` [method][set-default] that takes a _default value_ as one of its arguments.\r\n- It is also possible to accomplish the same thing manually in the `loop` by using some checking and error handling, but the `dict` method is easier.\r\n\r\n## 2. Read in Items Listed in the Users Notes App\r\n\r\n- Remember, Python's got a method for _everything_. This one is a _classmethod_ that's an easy way to [populate a `dict`][fromkeys] with keys.\r\n- This `dict` method returns a _new dictionary_, populated with default values. If no value is given, the default value will become `None`\r\n\r\n## 3. Update Recipe \"Ideas\" Section\r\n\r\n- Don't overthink this one!  This can be solved in **one** `dict` method call.\r\n- The key word here is .... [_update_][update].\r\n\r\n## 4. Sort the Items in the User Cart\r\n\r\n- What method would you call to get an [iterable view of items][items] in the dictionary?\r\n- If you had a `list` or a `tuple`, what [`built-in`][builtins] function might you use to sort them?\r\n- The built-in function you want is the one that returns a _copy_, and doesn't mutate the original.\r\n\r\n## 5. Send User Shopping Cart to Store for Fulfillment\r\n\r\n- Having a fresh, empty dictionary here as the `fulfillment_cart` might be handy for adding in items.\r\n- `Looping` through the members of the cart might be the most direct way of accessing things here.\r\n- What method would you call to get an [iterable view of just the keys][keys] of the dictionary?\r\n- Remember that you can get the `value` of a given key by using `<dict name>[<key_name>]` syntax.\r\n- If you had a `list` or a `tuple`, what [`built-in`][builtins] function might you use to sort them?\r\n- Remember that the `built-in` function can take an optional `reverse=True` argument.\r\n\r\n## 6. Update the Store Inventory to Reflect what a User Has Ordered.\r\n\r\n- There is a method that will give you an iterable view of (`key`, `value`) pairs from the dictionary.\r\n- You can access an item in a _nested tuple_ using _bracket notation_:  `<tuple>[<nested_tuple>][<index_of_value>]`\r\n- Don't forget to check if an inventory count falls to zero, you'll need to add in the \"Out of Stock\" message.\r\n\r\n[builtins]: https://docs.python.org/3/library/functions.html\r\n[dicts-docs]: https://docs.python.org/3/tutorial/datastructures.html#dictionaries\r\n[fromkeys]: https://docs.python.org/3/library/stdtypes.html#dict.fromkeys\r\n[items]: https://docs.python.org/3/library/stdtypes.html#dict.items\r\n[keys]: https://docs.python.org/3/library/stdtypes.html#dict.keys\r\n[mapping-types-dict]: https://docs.python.org/3/library/stdtypes.html#mapping-types-dict\r\n[mvp]: https://en.wikipedia.org/wiki/Minimum_viable_product\r\n[set-default]: https://docs.python.org/3/library/stdtypes.html#dict.setdefault\r\n[update]: https://docs.python.org/3/library/stdtypes.html#dict.update\r\n",
    "instructions": "# Instructions\r\n\r\nMecha Munchâ„¢, a grocery shopping automation company has just hired you to work on their ordering app.\r\nYour team is tasked with building an MVP (_[minimum viable product][mvp]_) that manages all the basic shopping cart activities, allowing users to add, remove, and sort their grocery orders.\r\nThankfully, a different team is handling all the money and check-out functions!\r\n\r\n## 1. Add Item(s) to the Users Shopping Cart\r\n\r\nThe MVP should allow the user to add items to their shopping cart.\r\nThis could be a single item or multiple items at once.\r\nSince this is an MVP, item quantity is indicated by _repeats_.\r\nIf a user wants to add 2 Oranges, 'Oranges' will appear twice in the input iterable.\r\nIf the user already has the item in their cart, the cart quantity should be increased by 1.\r\nIf the item is _new_ to the cart, it should be added with a quantity of 1.\r\n\r\nCreate the function `add_item(<current_cart>, <items_to_add>)` that takes a cart dictionary and any list-like iterable of items to add as arguments.\r\nIt should return a new/updated shopping cart dictionary for the user.\r\n\r\n```python\r\n>>> add_item({'Banana': 3, 'Apple': 2, 'Orange': 1},\r\n              ('Apple', 'Apple', 'Orange', 'Apple', 'Banana'))\r\n{'Banana': 4, 'Apple': 5, 'Orange': 2}\r\n\r\n>>> add_item({'Banana': 3, 'Apple': 2, 'Orange': 1},\r\n              ['Banana', 'Orange', 'Blueberries', 'Banana'])\r\n{'Banana': 5, 'Apple': 2, 'Orange': 2, 'Blueberries': 1}\r\n```\r\n\r\n## 2. Read in Items Listed in the Users Notes App\r\n\r\nUh-oh.\r\nLooks like the product team is engaging in [feature creep][feature creep].\r\nThey want to add extra functionality to the MVP.\r\nThe application now has to create a shopping cart by reading items off a users notes app.\r\nConvenient for the users, but slightly more work for the team.\r\n\r\nCreate the function `read_notes(<notes>)` that can take any list-like iterable as an argument.\r\nThe function should parse the items and create a user shopping cart/dictionary.\r\nEach item should be added with a quantity of 1.\r\nThe new user cart should then be returned.\r\n\r\n```python\r\n>>> read_notes(('Banana','Apple', 'Orange'))\r\n{'Banana': 1, 'Apple': 1, 'Orange': 1}\r\n\r\n>>> read_notes(['Blueberries', 'Pear', 'Orange', 'Banana', 'Apple'])\r\n{'Blueberries' : 1, 'Pear' : 1, 'Orange' : 1, 'Banana' : 1, 'Apple' : 1}\r\n```\r\n\r\n## 3. Update Recipe \"Ideas\" Section\r\n\r\nThe app has an \"ideas\" section that's filled with finished recipes from various cuisines.\r\nThe user can select any one of these recipes and have all its ingredients added to their shopping cart automatically.\r\nThe project manager has asked you create a way to edit these \"ideas\" recipes, since the content team keeps changing around ingredients and quantities.\r\n\r\nCreate the function `update_recipes(<ideas>, <recipe_updates>)` that takes an \"ideas\" dictionary and an iterable of recipe updates as arguments.\r\nThe function should return the new/updated \"ideas\" dictionary.\r\n\r\n```python\r\n>>>update_recipes(\r\n    {'Banana Bread' : {'Banana': 1, 'Apple': 1, 'Walnuts': 1, 'Flour': 1, 'Eggs': 2, 'Butter': 1},\r\n     'Raspberry Pie' : {'Raspberry': 1, 'Orange': 1, 'Pie Crust': 1, 'Cream Custard': 1}},\r\n    (('Banana Bread', {'Banana': 4,  'Walnuts': 2, 'Flour': 1, 'Butter': 1, 'Milk': 2, 'Eggs': 3}),)\r\n    )\r\n...\r\n\r\n{'Banana Bread': {'Banana': 4, 'Walnuts': 2, 'Flour': 1, 'Butter': 1, 'Milk': 2, 'Eggs': 3}, \r\n 'Raspberry Pie': {'Raspberry': 1, 'Orange': 1, 'Pie Crust': 1, 'Cream Custard': 1}}\r\n\r\n>>> update_recipes(\r\n    {'Banana Bread' : {'Banana': 1, 'Apple': 1, 'Walnuts': 1, 'Flour': 1, 'Eggs': 2, 'Butter': 1},\r\n    'Raspberry Pie' : {'Raspberry': 1, 'Orange': 1, 'Pie Crust': 1, 'Cream Custard': 1},\r\n    'Pasta Primavera': {'Eggs': 1, 'Carrots': 1, 'Spinach': 2, 'Tomatoes': 3, 'Parmesan': 2, 'Milk': 1, 'Onion': 1}},\r\n    [('Raspberry Pie', {'Raspberry': 3, 'Orange': 1, 'Pie Crust': 1, 'Cream Custard': 1, 'Whipped Cream': 2}),\r\n    ('Pasta Primavera', {'Eggs': 1, 'Mixed Veggies': 2, 'Parmesan': 2, 'Milk': 1, 'Spinach': 1, 'Bread Crumbs': 1}),\r\n    ('Blueberry Crumble', {'Blueberries': 2, 'Whipped Creme': 2, 'Granola Topping': 2, 'Yogurt': 3})]\r\n    )\r\n...\r\n\r\n{'Banana Bread': {'Banana': 1, 'Apple': 1, 'Walnuts': 1, 'Flour': 1, 'Eggs': 2, 'Butter': 1}, \r\n 'Raspberry Pie': {'Raspberry': 3, 'Orange': 1, 'Pie Crust': 1, 'Cream Custard': 1, 'Whipped Cream': 2}, \r\n 'Pasta Primavera': {'Eggs': 1, 'Mixed Veggies': 2, 'Parmesan': 2, 'Milk': 1, 'Spinach': 1, 'Bread Crumbs': 1},\r\n 'Blueberry Crumble': {'Blueberries': 2, 'Whipped Creme': 2, 'Granola Topping': 2, 'Yogurt': 3}}\r\n```\r\n\r\n## 4. Sort the Items in the User Cart\r\n\r\nOnce a user has started a cart, the app allows them to sort their items alphabetically.\r\nThis makes things easier to find, and helps when there are data-entry errors like having 'potatoes' and 'Potato' in the database.\r\n\r\nCreate the function `sort_entries(<cart>)` that takes a shopping cart/dictionary as an argument and returns a new, alphabetically sorted one.\r\n\r\n```python\r\n>>> sort_entries({'Banana': 3, 'Apple': 2, 'Orange': 1})\r\n{'Apple': 2, 'Banana':3, 'Orange': 1}\r\n```\r\n\r\n## 5. Send User Shopping Cart to Store for Fulfillment\r\n\r\nThe app needs to send a given users cart to the store for fulfillment.\r\nHowever, the shoppers in the store need to know which store aisle the item can be found in and if the item needs refrigeration.\r\nSo (_rather arbitrarily_) the \"fulfillment cart\" needs to be sorted in reverse alphabetical order with item quantities combined with location and refrigeration information.\r\n\r\nCreate the function `send_to_store(<cart>, <aisle_mapping>)` that takes a user shopping cart and a dictionary that has store aisle number and a `True`/`False` for refrigeration needed for each item.\r\nThe function should `return` a combined \"fulfillment cart\" that has (quantity, aisle, and refrigeration) for each item the customer is ordering.\r\nItems should appear in _reverse_ alphabetical order.\r\n\r\n```python\r\n>>> send_to_store({'Banana': 3, 'Apple': 2, 'Orange': 1, 'Milk': 2},\r\n                  {'Banana': ['Aisle 5', False], 'Apple': ['Aisle 4', False], 'Orange': ['Aisle 4', False], 'Milk': ['Aisle 2', True]})\r\n{'Orange': [1, 'Aisle 4', False], 'Milk': [2, 'Aisle 2', True], 'Banana': [3, 'Aisle 5', False], 'Apple': [2, 'Aisle 4', False]}\r\n```\r\n\r\n## 6. Update the Store Inventory to Reflect what a User Has Ordered.\r\n\r\nThe app can't just place customer orders endlessly.\r\nEventually, the store is going to run out of various products.\r\nSo your app MVP needs to update the store inventory every time a user sends their order to the store.\r\nOtherwise, customers will order products that aren't actually available.\r\n\r\nCreate the function `update_store_inventory(<fulfillment_cart>, <store_inventory>)` that takes a \"fulfillment cart\" and a store inventory.\r\nThe function should reduce the store inventory amounts by the number \"ordered\" in the \"fulfillment cart\" and then return the updated store inventory.\r\nWhere a store item count falls to 0, the count should be replaced by the message 'Out of Stock'.\r\n\r\n```python\r\n>>> update_store_inventory({'Orange': [1, 'Aisle 4', False], 'Milk': [2, 'Aisle 2', True], 'Banana': [3, 'Aisle 5', False], 'Apple': [2, 'Aisle 4', False]},\r\n{'Banana': [15, 'Aisle 5', False], 'Apple': [12, 'Aisle 4', False], 'Orange': [1, 'Aisle 4', False], 'Milk': [4, 'Aisle 2', True]})\r\n\r\n{'Banana': [12, 'Aisle 5', False], 'Apple': [10, 'Aisle 4', False], 'Orange': ['Out of Stock', 'Aisle 4', False], 'Milk': [2, 'Aisle 2', True]}\r\n```\r\n\r\n[feature creep]: https://en.wikipedia.org/wiki/Feature_creep\r\n[mvp]: https://en.wikipedia.org/wiki/Minimum_viable_product\r\n",
    "design": "## Learning objectives\r\n\r\nCover useful `dict` methods and a few techniques for operating on/manipulating `dicts`.\r\n\r\n- `dict.setdefault()` for automatically adding keys when needed.\r\n- `dict.fromkeys(iterable, <default value>)` for creating a new `dict` from any number of iterables.\r\n- `dict.keys()`, `dict.values()`, and `dict.items()` for convenient iterators.\r\n- `reversed(dict.keys())`, `reversed(dict.values())`, or `reversed(dict.items())` for reversed views.\r\n- `sorted()` with `dict.items()`. for re-ordering entries in a `dict`.\r\n- `dict_one.update(<dict_two>)` for updating one `dict` with overlapping values from another `dict`.\r\n- `dict | other_dict` and `dict |= other_dict` for merging or updating two `dict`s via operators.\r\n- `dict.popitem()` for removing and returning a key, value pair.\r\n\r\n- Working more with  the `dict` views `items()` , `keys()` or `values()`.  (e.g, by sorting information using `sorted()` or by swapping `keys` and `values`, etc.)\r\n- Knowing that Dictionaries can be _nested_, _-- e.g._ ' a dictionary of dictionaries'.\r\n- Considerations when `updating()` or using `union` with dictionaries.\r\n\r\n## Out of scope\r\n\r\nPlease take a look at the `dicts` concept exercise [design.md file](https://github.com/exercism/python/edit/main/exercises/concept/inventory-management/.meta/design.md) for `dict` features  taught thus far.\r\nWhile those methods can be used for solutions to this exercise, it  isn't necessary to cover them again in detail.  Additionally, the following is out of scope:\r\n\r\n- Dictionary comprehensions\r\n- Built-in functions as they relate to this data structure (*e.g.* `len()`, or `enumerate()`\r\n- Considerations of Mutability\r\n- `copy()` vs `deepcopy()`\r\n- Memory and performance characteristics.\r\n- Related `collections` module with `Counter()` and `defaultdict()`\r\n\r\n## Concepts\r\n\r\n- `dicts`\r\n- `dict-methods`\r\n\r\n## Prerequisites\r\n\r\nThese are the concepts/concept exercises the student needs to complete/understand before solving this concept exercise.\r\n\r\n- `basics`\r\n- `bools`\r\n- `conditionals`\r\n- `comparisons`\r\n- `dicts`\r\n- `lists`\r\n- `loops`\r\n- `numbers`\r\n- `strings`\r\n- `tuples`\r\n\r\n\r\n## Resources to refer to\r\n\r\n- [Python docs:  Tutorial - Dictionaries](https://docs.python.org/3/tutorial/datastructures.html#dictionaries)\r\n- [Python docs:  Mapping Type `dict`](https://docs.python.org/3/library/stdtypes.html#mapping-types-dict)\r\n- [Real Python:  Dicts](https://realpython.com/python-dicts/)\r\n- [Digital Ocean:  Understanding dictionaries in python 3](https://www.digitalocean.com/community/tutorials/understanding-dictionaries-in-python-3)\r\n- [Stack Overflow: exchanging keys with values in a `dict` in Python](https://stackoverflow.com/questions/1031851/how-do-i-exchange-keys-with-values-in-a-dictionary)\r\n- [kite:  how to sort a dictionary by key in python](https://www.kite.com/python/answers/how-to-sort-a-dictionary-by-key-in-python)\r\n- [medium:  16 Python Dictionary Tips](https://medium.com/python-in-plain-english/16-intermediate-level-python-dictionary-tips-tricks-and-shortcuts-1376859e1adc)  _**note:** this is a good resource for ideas and writing this exericse, but is a subscription-based service, so not the best for linking to_"
  },
  "config": {
    "authors": [
      "meatball133",
      "BethanyG"
    ],
    "contributors": [],
    "files": {
      "solution": [
        "dict_methods.py"
      ],
      "test": [
        "dict_methods_test.py"
      ],
      "exemplar": [
        ".meta/exemplar.py"
      ],
      "editor": [
        "dict_methods_test_data.py"
      ]
    },
    "icon": "gross-store",
    "blurb": "Learn about dictionary methods by building a shopping cart MVP for the Mecha Munch grocery app."
  },
  "starter_code": "\"\"\"Functions to manage a users shopping cart items.\"\"\"\r\n\r\n\r\ndef add_item(current_cart, items_to_add):\r\n    \"\"\"Add items to shopping cart.\r\n\r\n    :param current_cart: dict - the current shopping cart.\r\n    :param items_to_add: iterable - items to add to the cart.\r\n    :return: dict - the updated user cart dictionary.\r\n    \"\"\"\r\n\r\n    pass\r\n\r\n\r\ndef read_notes(notes):\r\n    \"\"\"Create user cart from an iterable notes entry.\r\n\r\n    :param notes: iterable of items to add to cart.\r\n    :return: dict - a user shopping cart dictionary.\r\n    \"\"\"\r\n\r\n    pass\r\n\r\n\r\ndef update_recipes(ideas, recipe_updates):\r\n    \"\"\"Update the recipe ideas dictionary.\r\n\r\n    :param ideas: dict - The \"recipe ideas\" dict.\r\n    :param recipe_updates: iterable -  with updates for the ideas section.\r\n    :return: dict - updated \"recipe ideas\" dict.\r\n    \"\"\"\r\n\r\n    pass\r\n\r\n\r\ndef sort_entries(cart):\r\n    \"\"\"Sort a users shopping cart in alphabetically order.\r\n\r\n    :param cart: dict - a users shopping cart dictionary.\r\n    :return: dict - users shopping cart sorted in alphabetical order.\r\n    \"\"\"\r\n\r\n    pass\r\n\r\n\r\ndef send_to_store(cart, aisle_mapping):\r\n    \"\"\"Combine users order to aisle and refrigeration information.\r\n\r\n    :param cart: dict - users shopping cart dictionary.\r\n    :param aisle_mapping: dict - aisle and refrigeration information dictionary.\r\n    :return: dict - fulfillment dictionary ready to send to store.\r\n    \"\"\"\r\n\r\n    pass\r\n\r\n\r\ndef update_store_inventory(fulfillment_cart, store_inventory):\r\n    \"\"\"Update store inventory levels with user order.\r\n\r\n    :param fulfillment cart: dict - fulfillment cart to send to store.\r\n    :param store_inventory: dict - store available inventory\r\n    :return: dict - store_inventory updated.\r\n    \"\"\"\r\n\r\n    pass\r\n",
  "exemplar_code": "\"\"\"Functions to manage a users shopping cart items.\"\"\"\r\n\r\n\r\ndef add_item(current_cart, items_to_add):\r\n    \"\"\"Add items to shopping cart.\r\n\r\n    :param current_cart: dict - the current shopping cart.\r\n    :param items_to_add: iterable - items to add to the cart.\r\n    :return: dict - the updated user cart dictionary.\r\n    \"\"\"\r\n\r\n    for item in items_to_add:\r\n        current_cart.setdefault(item, 0)\r\n        current_cart[item] += 1\r\n\r\n    return current_cart\r\n\r\n\r\ndef read_notes(notes):\r\n    \"\"\"Create user cart from an iterable notes entry.\r\n\r\n    :param notes: iterable of items to add to cart.\r\n    :return: dict - a user shopping cart dictionary.\r\n    \"\"\"\r\n\r\n    return dict.fromkeys(notes, 1)\r\n\r\n\r\ndef update_recipes(ideas, recipe_updates):\r\n    \"\"\"Update the recipe ideas dictionary.\r\n\r\n    :param ideas: dict - The \"recipe ideas\" dict.\r\n    :param recipe_updates: dict - dictionary with updates for the ideas section.\r\n    :return: dict - updated \"recipe ideas\" dict.\r\n    \"\"\"\r\n\r\n    ideas.update(recipe_updates)\r\n    return ideas\r\n\r\n\r\ndef sort_entries(cart):\r\n    \"\"\"Sort a users shopping cart in alphabetically order.\r\n\r\n    :param cart: dict - a users shopping cart dictionary.\r\n    :return: dict - users shopping cart sorted in alphabetical order.\r\n    \"\"\"\r\n\r\n    return dict(sorted(cart.items()))\r\n\r\n\r\ndef send_to_store(cart, aisle_mapping):\r\n    \"\"\"Combine users order to aisle and refrigeration information.\r\n\r\n    :param cart: dict - users shopping cart dictionary.\r\n    :param aisle_mapping: dict - aisle and refrigeration information dictionary.\r\n    :return: dict - fulfillment dictionary ready to send to store.\r\n    \"\"\"\r\n    fulfillment_cart = {}\r\n\r\n    for key in cart.keys():\r\n        fulfillment_cart[key] = [cart[key]] + aisle_mapping[key]\r\n\r\n    return dict(sorted(fulfillment_cart.items(), reverse=True))\r\n\r\n\r\ndef update_store_inventory(fulfillment_cart, store_inventory):\r\n    \"\"\"Update store inventory levels with user order.\r\n\r\n    :param fulfillment cart: dict - fulfillment cart to send to store.\r\n    :param store_inventory: dict - store available inventory\r\n    :return: dict - store_inventory updated.\r\n    \"\"\"\r\n\r\n    for key, values in fulfillment_cart.items():\r\n        store_inventory[key][0] = store_inventory[key][0] - values[0]\r\n        if store_inventory[key][0] == 0:\r\n            store_inventory[key][0] = 'Out of Stock'\r\n\r\n    return store_inventory\r\n",
  "tests": "import unittest\r\nimport pytest\r\nfrom collections import OrderedDict\r\nfrom dict_methods import (\r\n    add_item,\r\n    read_notes,\r\n    update_recipes,\r\n    sort_entries,\r\n    send_to_store,\r\n    update_store_inventory,\r\n)\r\n\r\nfrom dict_methods_test_data import (\r\n    add_item_data,\r\n    read_notes_data,\r\n    update_recipes_data,\r\n    sort_entries_data,\r\n    send_to_store_data,\r\n    update_store_inventory_data,\r\n)\r\n\r\nclass MechaMunchManagementTest(unittest.TestCase):\r\n\r\n    @pytest.mark.task(taskno=1)\r\n    def test_add_item(self):\r\n        for variant, (input_data, expected) in enumerate(add_item_data, start=1):\r\n            with self.subTest(f'variation #{variant}', input_data=input_data, expected=expected):\r\n                actual_result = add_item(input_data[0], input_data[1])\r\n                error_msg= (f'Called add_item({input_data[0]}, {input_data[1]}). '\r\n                            f'The function returned {actual_result}, but the tests '\r\n                            f'expected: {expected} once the item was added.')\r\n\r\n                self.assertEqual(actual_result, expected, msg=error_msg)\r\n\r\n    @pytest.mark.task(taskno=2)\r\n    def test_read_notes(self):\r\n        for variant, (input_data, expected) in enumerate(read_notes_data, start=1):\r\n            with self.subTest(f'variation #{variant}', input_data=input_data, expected=expected):\r\n                actual_result = read_notes(input_data)\r\n                error_msg = (f'Called read_notes({input_data}). '\r\n                             f'The function returned {actual_result}, but the tests '\r\n                             f'expected: {expected} once the notes were read.')\r\n\r\n                self.assertEqual(actual_result, expected, msg=error_msg)\r\n\r\n    @pytest.mark.task(taskno=3)\r\n    def test_update_recipes(self):\r\n        for variant, (input_data, expected) in enumerate(update_recipes_data, start=1):\r\n            with self.subTest(f'variation #{variant}', input_data=input_data, expected=expected):\r\n                actual_result = update_recipes(input_data[0], input_data[1])\r\n                error_msg = (f'Called update_recipes({input_data[0]}, {input_data[1]}). '\r\n                             f'The function returned {actual_result}, but the tests '\r\n                             f'expected: {expected} once the recipes were updated.')\r\n\r\n                self.assertEqual(actual_result, expected, msg=error_msg)\r\n\r\n    @pytest.mark.task(taskno=4)\r\n    def test_sort_entries(self):\r\n        for variant, (input_data, expected) in enumerate(sort_entries_data, start=1):\r\n            with self.subTest(f'variation #{variant}', input_data=input_data, expecred=expected):\r\n                actual_result = sort_entries(input_data)\r\n                error_msg = (f'Called sort_entries({input_data}). '\r\n                             f'The function returned {actual_result}, but the tests '\r\n                             f'expected: {expected} for the sorted entries.')\r\n\r\n                # Because we are asserting equal, we need to convert to an OrderedDict.\r\n                # Regular dictionaries will compare equal even when they are ordered\r\n                # differently from one another. See https://stackoverflow.com/a/58961124\r\n                self.assertEqual(OrderedDict(actual_result), OrderedDict(expected), msg=error_msg)\r\n\r\n    @pytest.mark.task(taskno=5)\r\n    def test_send_to_store(self):\r\n        for variant, (input_data, expected) in enumerate(send_to_store_data, start=1):\r\n            with self.subTest(f'variation #{variant}', input_data=input_data, expected=expected):\r\n                actual_result = send_to_store(input_data[0], input_data[1])\r\n                error_msg = (f'Called send_to_store({input_data[0]}, {input_data[1]}). '\r\n                             f'The function returned {actual_result}, but the tests '\r\n                             f'expected: {expected} as the fulfillment cart.')\r\n\r\n                # Because we are asserting equal, we need to convert to an OrderedDict.\r\n                # Regular dictionaries will compare equal even when they are ordered\r\n                # differently from one another. See https://stackoverflow.com/a/58961124\r\n                self.assertEqual(OrderedDict(actual_result), OrderedDict(expected), msg=error_msg)\r\n\r\n    @pytest.mark.task(taskno=6)\r\n    def test_update_store_inventory(self):\r\n        for variant, (input_data, expected) in enumerate(update_store_inventory_data, start=1):\r\n            with self.subTest(f'variation #{variant}', input_data=input_data, expected=expected):\r\n                actual_result = update_store_inventory(input_data[0], input_data[1])\r\n                error_msg = (f'Called update_store_inventory({input_data[0]}, {input_data[1]}). '\r\n                             f'The function returned {actual_result}, but the tests '\r\n                             f'expected: {expected} as the store inventory.')\r\n\r\n                self.assertEqual(actual_result, expected, msg=error_msg)\r\n"
}