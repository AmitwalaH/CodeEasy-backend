{
  "concept": "guidos-gorgeous-lasagna",
  "docs": {
    "introduction": "# Introduction\r\n\r\nPython is a [dynamic and strongly][dynamic typing in python] typed programming language.\r\nIt employs both [duck typing][duck typing] and [gradual typing][gradual typing] via [type hints][type hints].\r\n\r\nWhile Python supports many different programming _styles_, internally **everything in Python is an [object][everythings an object]**.\r\nThis includes numbers, strings, lists, and even functions.\r\n\r\nWe'll dig more into what all of that means as we continue through the track.\r\n\r\nThis first exercise introduces 4 major Python language features:\r\n1.  Name Assignment (_variables and constants_),\r\n2.  Functions (_the `def` keyword and the `return` keyword_),\r\n3.  Comments, and\r\n4.  Docstrings.\r\n\r\n<br>\r\n\r\n~~~~exercism/note\r\n\r\nIn general, content, tests, and analyzer tooling for the Python track follow the style conventions outlined in [PEP 8](https://www.python.org/dev/peps/pep-0008/) and [PEP 257](https://www.python.org/dev/peps/pep-0257/) for Python code style, with the additional (strong) suggestion that there be no single letter variable names.\r\n\r\nOn the Python track, [variables][variables] are always written in [`snake_case`][snake case], and constants in `SCREAMING_SNAKE_CASE`.\r\n\r\n[variables]: https://realpython.com/python-variables/\r\n[snake case]: https://en.wikipedia.org/wiki/Snake_case\r\n~~~~\r\n\r\n<br>\r\n\r\n## Name Assignment (Variables & Constants)\r\n\r\nProgrammers can bind [_names_][facts-and-myths-about-python-names] (also called _variables_) to any type of object using the assignment `=` operator: `<name> = <value>`.\r\nA name can be reassigned (or re-bound) to different values (different object types) over its lifetime.\r\n\r\n\r\n```python\r\n>>> my_first_variable = 1  #<-- my_first_variable bound to an integer object of value one.\r\n>>> my_first_variable = 2  #<-- my_first_variable re-assigned to integer value 2.\r\n\r\n>>> print(type(my_first_variable))\r\n<class 'int'>\r\n\r\n>>> print(my_first_variable)\r\n2\r\n\r\n>>> my_first_variable = \"Now, I'm a string.\" #<-- You may re-bind a name to a different object type and value.\r\n>>> print(type(my_first_variable))\r\n<class 'str'>\r\n\r\n>>> print(my_first_variable)\r\n\"Now, I'm a string.\"  #<-- Strings can be declared using single or double quote marks.\r\n```\r\n\r\n\r\n### Constants\r\n\r\nConstants are names meant to be assigned only once in a program.\r\nThey should be defined at a [module][module] (file) level, and are typically visible to all functions and classes in the program.\r\nUsing `SCREAMING_SNAKE_CASE` signals that the name should not be re-assigned, or its value mutated.\r\n\r\n\r\n## Functions\r\n\r\nThe `def` keyword begins a [function definition][function definition].\r\nEach function can have zero or more formal [parameters][parameters] in `()` parenthesis, followed by a `:` colon.\r\nStatements for the _body_ of the function begin on the line following `def` and must be _indented in a block_.\r\n\r\n\r\n```python\r\n# The body of a function is indented by 2 spaces, & prints the sum of the numbers.\r\ndef add_two_numbers(number_one, number_two):\r\n  total = number_one + number_two\r\n  print(total)  \r\n\r\n>>> add_two_numbers(3, 4)\r\n7\r\n\r\n\r\n# Inconsistent indentation in your code blocks will raise an error.\r\n>>> def add_three_numbers_misformatted(number_one, number_two, number_three):\r\n...     result = number_one + number_two + number_three   # This was indented by 4 spaces.\r\n...    print(result)     #this was only indented by 3 spaces\r\n...\r\n...\r\n  File \"<stdin>\", line 3\r\n    print(result)\r\n    ^\r\nIndentationError: unindent does not match any outer indentation level\r\n```\r\n\r\n\r\nFunctions _explicitly_ return a value or object via the [`return`][return] keyword:\r\n\r\n\r\n```python\r\n# Function definition on first line, explicit return used on final line.\r\n>>> def add_two_numbers(number_one, number_two):\r\n        return number_one + number_two   \r\n\r\n\r\n# Calling the function in the Python terminal returns the sum of the numbers.\r\n>>> add_two_numbers(3, 4)\r\n7\r\n\r\n# Assigning the function call to a variable and printing it \r\n# will also return the value.\r\n>>> sum_with_return = add_two_numbers(5, 6)\r\n>>> print(sum_with_return)\r\n11\r\n```\r\n\r\n\r\nFunctions that do not have an _explicit_ `return` expression will _implicitly_ return the [`None`][none] object.\r\nThis means that if you do not use `return` in a function, Python will return the `None` object for you.\r\nThe details of `None` will be covered in a later exercise.\r\nFor the purposes of this exercise and explanation, `None` is a placeholder that represents nothing, or null:\r\n\r\n\r\n```python\r\n# This function does not have an explicit return.\r\ndef add_two_numbers(number_one, number_two):\r\n  result = number_one + number_two\r\n\r\n\r\n# Calling the function in the Python terminal appears \r\n# to not return anything at all.\r\n>>> add_two_numbers(5, 7)\r\n>>>\r\n\r\n\r\n# Using print() with the function call shows that \r\n# the function is actually returning the **None** object.\r\n>>> print(add_two_numbers(5, 7))\r\nNone\r\n\r\n\r\n# Assigning the function call to a variable and printing \r\n# the variable will also show None.\r\n>>> sum_without_return = add_two_numbers(5, 6)\r\n>>> print(sum_without_return)\r\nNone\r\n```\r\n\r\n\r\n### Calling Functions\r\n\r\nFunctions are [_called_][calls] or invoked using their name followed by `()`.\r\nDot (`.`) notation is used for calling functions defined inside a class or module.\r\n\r\n```python\r\n>>> def number_to_the_power_of(number_one, number_two):\r\n        return number_one ** number_two\r\n...\r\n\r\n>>> number_to_the_power_of(3,3) # Invoking the function with the arguments 3 and 3.\r\n27\r\n\r\n\r\n# A mismatch between the number of parameters and the number of arguments will raise an error.\r\n>>> number_to_the_power_of(4,)\r\n...\r\nTraceback (most recent call last):\r\n  File \"<stdin>\", line 1, in <module>\r\nTypeError: number_to_the_power_of() missing 1 required positional argument: 'number_two'\r\n\r\n\r\n# Calling methods or functions in classes and modules.\r\n>>> start_text = \"my silly sentence for examples.\"\r\n>>> str.upper(start_text)  # Calling the upper() method for the built-in str class.\r\n\"MY SILLY SENTENCE FOR EXAMPLES.\"\r\n\r\n# Importing the math module\r\nimport math\r\n\r\n>>> math.pow(2,4)  # Calling the pow() function from the math module\r\n>>> 16.0\r\n```\r\n\r\n\r\n## Comments\r\n\r\n[Comments][comments] in Python start with a `#` that is not part of a string, and end at line termination.\r\nUnlike many other programming languages, Python **does not support** multi-line comment marks.\r\nEach line of a comment block must start with the `#` character.\r\n\r\n\r\n## Docstrings\r\n\r\nThe first statement of a function body can optionally be a [_docstring_][docstring], which concisely summarizes the function or object's purpose.\r\nDocstrings are declared using triple double quotes (\"\"\") indented at the same level as the code block:\r\n\r\n\r\n```python\r\n\r\n# An example from PEP257 of a multi-line docstring.\r\ndef complex(real=0.0, imag=0.0):\r\n    \"\"\"Form a complex number.\r\n\r\n    Keyword arguments:\r\n    real -- the real part (default 0.0)\r\n    imag -- the imaginary part (default 0.0)\r\n    \"\"\"\r\n\r\n    if imag == 0.0 and real == 0.0:\r\n        return complex_zero\r\n\r\n```\r\n\r\n\r\nDocstrings are read by automated documentation tools and are returned by calling the special attribute `.__doc__` on the function, method, or class name.\r\nDocstring conventions are laid out in [PEP257][pep257].\r\n\r\nDocstrings can also function as [lightweight unit tests][doctests], which will be covered in a later exercise.\r\n\r\n\r\n```python\r\n# An example on a user-defined function.\r\n>>> def number_to_the_power_of(number_one, number_two):\r\n        \"\"\"Raise a number to an arbitrary power.\r\n\r\n        :param number_one: int the base number.\r\n        :param number_two: int the power to raise the base number to.\r\n        :return: int - number raised to power of second number\r\n\r\n        Takes number_one and raises it to the power of number_two, returning the result.\r\n        \"\"\"\r\n\r\n        return number_one ** number_two\r\n...\r\n\r\n# Calling the .__doc__ attribute of the function and printing the result.\r\n>>> print(number_to_the_power_of.__doc__)\r\nRaise a number to an arbitrary power.\r\n\r\n    :param number_one: int the base number.\r\n    :param number_two: int the power to raise the base number to.\r\n    :return: int - number raised to power of second number\r\n\r\n    Takes number_one and raises it to the power of number_two, returning the result.\r\n```\r\n\r\n[calls]: https://docs.python.org/3/reference/expressions.html#calls\r\n[comments]: https://realpython.com/python-comments-guide/#python-commenting-basics\r\n[docstring]: https://docs.python.org/3/tutorial/controlflow.html#tut-docstrings\r\n[doctests]: https://docs.python.org/3/library/doctest.html\r\n[duck typing]: https://en.wikipedia.org/wiki/Duck_typing\r\n[dynamic typing in python]: https://stackoverflow.com/questions/11328920/is-python-strongly-typed\r\n[everythings an object]: https://docs.python.org/3/reference/datamodel.html\r\n[facts-and-myths-about-python-names]: https://nedbatchelder.com/text/names.html\r\n[function definition]: https://docs.python.org/3/tutorial/controlflow.html#defining-functions\r\n[gradual typing]: https://en.wikipedia.org/wiki/Gradual_typing\r\n[module]: https://docs.python.org/3/tutorial/modules.html\r\n[none]: https://docs.python.org/3/library/constants.html\r\n[parameters]: https://docs.python.org/3/glossary.html#term-parameter\r\n[pep257]: https://www.python.org/dev/peps/pep-0257/\r\n[return]: https://docs.python.org/3/reference/simple_stmts.html#return\r\n[type hints]: https://docs.python.org/3/library/typing.html\r\n",
    "hints": "# Hints\r\n\r\n## General\r\n\r\n- [The Python Tutorial][the python tutorial] can be a great introduction.\r\n- [PEP 8][pep8] is the Python code style guide.\r\n- [PEP 257][PEP257] details Python docstring conventions.\r\n- [Numbers][numbers] in Python can be integers, floats, or complex.\r\n\r\n\r\n## 1. Define expected bake time in minutes\r\n\r\n- You need to [name][naming] a [constant][constants], and [assign][assignment] it an [integer][numbers] value.\r\n  This constant should be the first thing after the docstring that is at the top of the file.\r\n  Remember to remove the #TODO comment after defining the constant.\r\n\r\n## 2. Calculate remaining bake time in minutes\r\n\r\n- You need to define a [function][defining functions] with a single parameter representing the time elapsed so far.\r\n- Use the [mathematical operator for subtraction][numbers] to subtract values.\r\n- This function should [return a value][return].\r\n\r\n## 3. Calculate preparation time in minutes\r\n\r\n- You need to define a [function][defining functions] with a single parameter representing the number of layers.\r\n- Use the [mathematical operator for multiplication][numbers] to multiply values.\r\n- You can define a PREPARATION_TIME _constant_ for the time in minutes per layer rather than using a [\"magic\r\n  number\"][magic-numbers] in your code.\r\n- This function should [return a value][return].\r\n\r\n## 4. Calculate total elapsed cooking time (prep + bake) in minutes\r\n\r\n- You need to define a [function][defining functions] with two parameters.\r\n- Remember: you can always _call_ a function you've defined previously.\r\n- You can use the [mathematical operator for addition][python as a calculator] to sum values.\r\n- This function should [return a value][return].\r\n\r\n## 5. Update the recipe with notes\r\n\r\n- Clearly [commenting][comments] and [documenting][docstrings] your code according to [PEP257][pep257] is always recommended.\r\n\r\n[assignment]: https://docs.python.org/3/reference/simple_stmts.html#grammar-token-assignment-stmt\r\n[comments]: https://realpython.com/python-comments-guide/\r\n[constants]: https://stackoverflow.com/a/2682752\r\n[defining functions]: https://docs.python.org/3/tutorial/controlflow.html#defining-functions\r\n[docstrings]: https://docs.python.org/3/tutorial/controlflow.html#tut-docstrings\r\n[magic-numbers]: https://en.wikipedia.org/wiki/Magic_number_(programming)\r\n[naming]: https://realpython.com/python-variables/\r\n[numbers]: https://docs.python.org/3/tutorial/introduction.html#numbers\r\n[pep257]: https://www.python.org/dev/peps/pep-0257/\r\n[python as a calculator]: https://docs.python.org/3/tutorial/introduction.html#using-python-as-a-calculator\r\n[return]: https://docs.python.org/3/reference/simple_stmts.html#return\r\n[the python tutorial]: https://docs.python.org/3/tutorial/introduction.html\r\n",
    "instructions": "# Instructions\r\n\r\nYou're going to write some code to help you cook a gorgeous lasagna from your favorite cookbook.\r\n\r\nYou have five tasks, all related to cooking your recipe.\r\n\r\n<br>\r\n\r\n~~~~exercism/note\r\nWe have started the first function definition for you in the stub file, but you will need to write the remaining function definitions yourself.\r\nYou will also need to define any constants yourself.\r\nRead the #TODO comment lines in the stub file carefully.\r\nOnce you are done with a task, remove the TODO comment.\r\n~~~~\r\n\r\n<br>\r\n\r\n## 1. Define expected bake time in minutes as a constant\r\n\r\nDefine the `EXPECTED_BAKE_TIME` [constant][constants] that represents how many minutes the lasagna should bake in the oven.\r\nAccording to your cookbook, the Lasagna should be in the oven for 40 minutes:\r\n\r\n```python\r\n>>> print(EXPECTED_BAKE_TIME)\r\n40\r\n```\r\n\r\n## 2. Calculate remaining bake time in minutes\r\n\r\nComplete the `bake_time_remaining()` function that takes the actual minutes the lasagna has been in the oven as an argument and returns how many minutes the lasagna still needs to bake based on the `EXPECTED_BAKE_TIME` constant.\r\n\r\n```python\r\n>>> bake_time_remaining(30)\r\n10\r\n```\r\n\r\n\r\n## 3. Calculate preparation time in minutes\r\n\r\nDefine the `preparation_time_in_minutes()` [function][functions] that takes the `number_of_layers` you want to add to the lasagna as an argument and returns how many minutes you would spend making them.\r\nAssume each layer takes 2 minutes to prepare.\r\n\r\n```python\r\n>>> def preparation_time_in_minutes(number_of_layers):\r\n        ...\r\n        ...\r\n        \r\n>>> preparation_time_in_minutes(2)\r\n4\r\n```\r\n\r\n\r\n## 4. Calculate total elapsed time (prepping + baking) in minutes\r\n\r\nDefine the `elapsed_time_in_minutes()` function that takes two parameters as arguments:\r\n\r\n- `number_of_layers` (_the number of layers added to the lasagna_)\r\n- `elapsed_bake_time` (_the number of minutes the lasagna has spent baking in the oven already_).\r\n\r\nThis function should return the total minutes you have been in the kitchen cooking â€” your preparation time layering +\r\nthe time the lasagna has spent baking in the oven.\r\n\r\n\r\n```python\r\n>>> def elapsed_time_in_minutes(number_of_layers, elapsed_bake_time):\r\n        ...\r\n        ...\r\n        \r\n>>> elapsed_time_in_minutes(3, 20)\r\n26\r\n```\r\n\r\n\r\n## 5. Update the recipe with notes\r\n\r\nGo back through the recipe, adding \"notes\" in the form of [function docstrings][function-docstrings].\r\n\r\n```python\r\ndef elapsed_time_in_minutes(number_of_layers, elapsed_bake_time):\r\n    \"\"\"Calculate the elapsed cooking time.\r\n\r\n    :param number_of_layers: int - the number of layers in the lasagna.\r\n    :param elapsed_bake_time: int - elapsed cooking time.\r\n    :return: int - total time elapsed (in minutes) preparing and cooking.\r\n\r\n    This function takes two integers representing the number of lasagna layers and the\r\n    time already spent baking and calculates the total elapsed minutes spent cooking the\r\n    lasagna.\r\n    \"\"\"\r\n```\r\n\r\n[constants]: https://stackoverflow.com/a/2682752\r\n[functions]: https://docs.python.org/3/tutorial/controlflow.html#defining-functions\r\n[function-docstrings]: https://docs.python.org/3/tutorial/controlflow.html#documentation-strings\r\n",
    "design": "# Design\r\n\r\n## Goal\r\n\r\nThe goal of this exercise is to teach the student the basics of programming in Python.\r\n\r\n## Learning objectives\r\n\r\n- Know what a variable (_name_) is.\r\n- Know how to name a variable.\r\n- Know how to bind and re-bind a _name_ to a value (_assign or re-assign a value to a variable or assign a value to a constant_).\r\n- Know what a `function` is and how to define one via `def`.\r\n- Know how to add one or more `parameters` to a function definition.\r\n- Know what the `return` keyword is, and how to use it to return a value from a function.\r\n- Know how to call a function with zero or more arguments.\r\n- Know how to declare an integer and/or float.\r\n- Know how to use mathematical operators `+` and `*` on integers and/or floats.\r\n- Know how to define single- and multi-line comments.\r\n- Know how to define docstrings.\r\n\r\n## Out of scope\r\n\r\n- built-in types\r\n- built-in data structures\r\n- Classes\r\n- Lambdas\r\n- Methods and other function usages (_functions bound to classes, functions as arguments, nested functions_).\r\n- Memory and performance characteristics.\r\n- Default function parameters.\r\n- Variadic function parameters. (_\\*args and \\*\\*kwargs_)\r\n\r\n## Concepts\r\n\r\n`basics`:\r\n\r\n- function definition & `return` keyword\r\n- integers & floats,\r\n- mathematical operators `+` and `*`\r\n- single and muliti-line comments.\r\n- updating variable values\r\n- using functions\r\n- variables, variable assignment, & variable naming\r\n\r\n## Prerequisites\r\n\r\nThere are no prerequisites for this exercise.\r\n\r\n## Representer\r\n\r\nThis exercise does not require any specific representation logic to be added to the representer.\r\n\r\n## Analyzer\r\n\r\nThis exercise does not require any specific representation logic to be added to the analyzer.\r\n"
  },
  "config": {
    "authors": [
      "BethanyG"
    ],
    "files": {
      "solution": [
        "lasagna.py"
      ],
      "test": [
        "lasagna_test.py"
      ],
      "exemplar": [
        ".meta/exemplar.py"
      ]
    },
    "forked_from": [
      "csharp/lucians-luscious-lasagna",
      "ruby/lasagna"
    ],
    "icon": "lasagna",
    "blurb": "Learn the basics of Python by cooking Guido's Gorgeous Lasagna."
  },
  "starter_code": "\"\"\"Functions used in preparing Guido's gorgeous lasagna.\r\n\r\nLearn about Guido, the creator of the Python language:\r\nhttps://en.wikipedia.org/wiki/Guido_van_Rossum\r\n\r\nThis is a module docstring, used to describe the functionality\r\nof a module and its functions and/or classes.\r\n\"\"\"\r\n\r\n\r\n#TODO: define your EXPECTED_BAKE_TIME (required) and PREPARATION_TIME (optional) constants below.\r\n\r\n\r\n#TODO: Remove 'pass' and complete the 'bake_time_remaining()' function below.\r\ndef bake_time_remaining():\r\n    \"\"\"Calculate the bake time remaining.\r\n\r\n    :param elapsed_bake_time: int - baking time already elapsed.\r\n    :return: int - remaining bake time (in minutes) derived from 'EXPECTED_BAKE_TIME'.\r\n\r\n    Function that takes the actual minutes the lasagna has been in the oven as\r\n    an argument and returns how many minutes the lasagna still needs to bake\r\n    based on the `EXPECTED_BAKE_TIME`.\r\n    \"\"\"\r\n\r\n    pass\r\n\r\n\r\n#TODO: Define the 'preparation_time_in_minutes()' function below.\r\n# To avoid the use of magic numbers (see: https://en.wikipedia.org/wiki/Magic_number_(programming)), you should define a PREPARATION_TIME constant.\r\n# You can do that on the line below the 'EXPECTED_BAKE_TIME' constant.\r\n# This will make it easier to do calculations, and make changes to your code.\r\n\r\n\r\n\r\n#TODO: define the 'elapsed_time_in_minutes()' function below.\r\n\r\n\r\n\r\n# TODO: Remember to go back and add docstrings to all your functions\r\n#  (you can copy and then alter the one from bake_time_remaining.)\r\n",
  "exemplar_code": "\"\"\"Functions used in preparing Guido's gorgeous lasagna.\r\n\r\nLearn about Guido, the creator of the Python language: https://en.wikipedia.org/wiki/Guido_van_Rossum\r\n\"\"\"\r\n\r\n# time the lasagna should be in the oven according to the cookbook.\r\nEXPECTED_BAKE_TIME = 40\r\nPREPARATION_TIME = 2\r\n\r\n\r\ndef bake_time_remaining(elapsed_bake_time):\r\n    \"\"\"Calculate the bake time remaining.\r\n\r\n    :param elapsed_bake_time: int - baking time already elapsed.\r\n    :return: int - remaining bake time (in minutes) derived from 'EXPECTED_BAKE_TIME'.\r\n\r\n    Function that takes the actual minutes the lasagna has been in the oven as\r\n    an argument and returns how many minutes the lasagna still needs to bake\r\n    based on the `EXPECTED_BAKE_TIME`.\r\n    \"\"\"\r\n\r\n    return EXPECTED_BAKE_TIME - elapsed_bake_time\r\n\r\n\r\ndef preparation_time_in_minutes(number_of_layers):\r\n    \"\"\"Calculate the preparation time.\r\n\r\n    :param number_of_layers: int - the number of lasagna layers made.\r\n    :return: int - amount of prep time (in minutes), based on 2 minutes per layer added.\r\n\r\n    This function takes an integer representing the number of layers added to the dish,\r\n    calculating preparation time using a time of 2 minutes per layer added.\r\n    \"\"\"\r\n\r\n    return number_of_layers * PREPARATION_TIME\r\n\r\n\r\ndef elapsed_time_in_minutes(number_of_layers, elapsed_bake_time):\r\n    \"\"\"Calculate the elapsed time.\r\n\r\n    :param number_of_layers: int - the number of layers in the lasagna.\r\n    :param elapsed_bake_time: int - elapsed cooking time.\r\n    :return: int - total time elapsed (in in minutes) preparing and cooking.\r\n\r\n    This function takes two integers representing the number of lasagna layers and the\r\n    time already spent baking and calculates the total elapsed minutes spent cooking the\r\n    lasagna.\r\n    \"\"\"\r\n\r\n    return preparation_time_in_minutes(number_of_layers) + elapsed_bake_time\r\n",
  "tests": "import unittest\r\nimport pytest\r\n\r\n# For this first exercise, it is really important to be clear about how we are importing names for tests.\r\n# To that end, we are putting a try/catch around imports and throwing specific messages to help students\r\n# decode that they need to create and title their constants and functions in a specific way.\r\ntry:\r\n    from lasagna import (EXPECTED_BAKE_TIME,\r\n                         bake_time_remaining,\r\n                         preparation_time_in_minutes,\r\n                         elapsed_time_in_minutes)\r\n\r\n# Here, we are separating the constant import errors from the function name import errors\r\nexcept ImportError as import_fail:\r\n    message = import_fail.args[0].split('(', maxsplit=1)\r\n    item_name = import_fail.args[0].split()[3]\r\n\r\n    if 'EXPECTED_BAKE_TIME' in item_name:\r\n        # pylint: disable=raise-missing-from\r\n        raise ImportError(f'\\n\\nMISSING CONSTANT --> \\nWe can not find or import the constant {item_name} in your'\r\n                          \" 'lasagna.py' file.\\nDid you misname or forget to define it?\") from None\r\n    else:\r\n        item_name = item_name[:-1] + \"()'\"\r\n        # pylint: disable=raise-missing-from\r\n        raise ImportError(\"\\n\\nMISSING FUNCTION --> In your 'lasagna.py' file, we can not find or import the\"\r\n                          f' function named {item_name}. \\nDid you misname or forget to define it?') from None\r\n\r\n\r\n# Here begins the formal test cases for the exercise.\r\nclass LasagnaTest(unittest.TestCase):\r\n\r\n    @pytest.mark.task(taskno=1)\r\n    def test_EXPECTED_BAKE_TIME(self):\r\n        failure_msg = 'Expected a constant of EXPECTED_BAKE_TIME with a value of 40.'\r\n        self.assertEqual(EXPECTED_BAKE_TIME, 40, msg=failure_msg)\r\n\r\n    @pytest.mark.task(taskno=2)\r\n    def test_bake_time_remaining(self):\r\n        input_data = [1, 2, 5, 10, 15, 23, 33, 39]\r\n        result_data = [39, 38, 35, 30, 25, 17, 7, 1]\r\n\r\n        for variant, (time, expected) in enumerate(zip(input_data, result_data), start=1):\r\n            with self.subTest(f'variation #{variant}', time=time, expected=expected):\r\n                actual_result = bake_time_remaining(time)\r\n                failure_msg = (f'Called bake_time_remaining({time}). ' \r\n                               f'The function returned {actual_result}, but the tests '\r\n                               f'expected {expected} as the remaining bake time.')\r\n\r\n                self.assertEqual(actual_result, expected, msg=failure_msg)\r\n\r\n    @pytest.mark.task(taskno=3)\r\n    def test_preparation_time_in_minutes(self):\r\n        input_data = [1, 2, 5, 8, 11, 15]\r\n        result_data = [2, 4, 10, 16, 22, 30]\r\n\r\n        for variant, (layers, expected) in enumerate(zip(input_data, result_data), start=1):\r\n            with self.subTest(f'variation #{variant}', layers=layers, expected=expected):\r\n                actual_result = preparation_time_in_minutes(layers)\r\n                failure_msg = (f'Called preparation_time_in_minutes({layers}). '\r\n                               f'The function returned {actual_result}, but the tests '\r\n                               f'expected {expected} as the preparation time.')\r\n\r\n                self.assertEqual(actual_result, expected, msg=failure_msg)\r\n\r\n    @pytest.mark.task(taskno=4)\r\n    def test_elapsed_time_in_minutes(self):\r\n        layer_data = (1, 2, 5, 8, 11, 15)\r\n        time_data = (3, 7, 8, 4, 15, 20)\r\n        result_data = [5, 11, 18, 20, 37, 50]\r\n\r\n        for variant, (layers, time, expected) in enumerate(zip(layer_data, time_data, result_data), start=1):\r\n            with self.subTest(f'variation #{variant}', layers=layers, time=time, expected=expected):\r\n                actual_result = elapsed_time_in_minutes(layers, time)\r\n                failure_msg = (f'Called elapsed_time_in_minutes({layers}, {time}). '\r\n                               f'The function returned {actual_result}, but the tests '\r\n                               f'expected {expected} as the elapsed time.')\r\n\r\n                self.assertEqual(actual_result, expected, msg=failure_msg)\r\n\r\n    @pytest.mark.task(taskno=5)\r\n    def test_docstrings_were_written(self):\r\n        \"\"\"Validate function.__doc__ exists for each function.\r\n        Check the attribute dictionary of each listed function\r\n        for the presence of a __doc__ key.\r\n\r\n        :return: unexpectedly None error when __doc__ key is missing.\r\n        \"\"\"\r\n        functions = [bake_time_remaining, preparation_time_in_minutes, elapsed_time_in_minutes]\r\n\r\n        for variant, function in enumerate(functions, start=1):\r\n            with self.subTest(f'variation #{variant}', function=function):\r\n                actual_result = function.__doc__\r\n                failure_msg = (f'Called {function.__name__}.__doc__. {actual_result} was returned, '\r\n                               f'but the tests expected a docstring for the {function.__name__} function.')\r\n\r\n                # Check that the __doc__ key is populated for the function.\r\n                self.assertIsNotNone(actual_result, msg=failure_msg)\r\n"
}