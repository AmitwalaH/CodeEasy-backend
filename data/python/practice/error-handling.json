{
  "language": "python",
  "type": "practice",
  "slug": "error-handling",
  "title": "Error Handling",
  "docs": {
    "instructions": "# Instructions\r\n\r\nImplement various kinds of error handling and resource management.\r\n\r\nAn important point of programming is how to handle errors and close resources even if errors occur.\r\n\r\nThis exercise requires you to handle various errors.\r\nBecause error handling is rather programming language specific you'll have to refer to the tests for your track to see what's exactly required.\r\n",
    "hints": ""
  },
  "starter_code": "def handle_error_by_throwing_exception():\r\n    pass\r\n\r\n\r\ndef handle_error_by_returning_none(input_data):\r\n    pass\r\n\r\n\r\ndef handle_error_by_returning_tuple(input_data):\r\n    pass\r\n\r\n\r\ndef filelike_objects_are_closed_on_exception(filelike_object):\r\n    pass\r\n",
  "tests": "import unittest\r\n\r\nimport error_handling as er\r\nfrom test_utils import FileLike\r\n\r\n\r\nclass ErrorHandlingTest(unittest.TestCase):\r\n    def test_throw_exception(self):\r\n        with self.assertRaisesWithMessage(Exception):\r\n            er.handle_error_by_throwing_exception()\r\n\r\n    def test_return_none(self):\r\n        self.assertEqual(er.handle_error_by_returning_none('1'), 1,\r\n                         'Result of valid input should not be None')\r\n        self.assertIsNone(er.handle_error_by_returning_none('a'),\r\n                          'Result of invalid input should be None')\r\n\r\n    def test_return_tuple(self):\r\n        successful_result, result = er.handle_error_by_returning_tuple('1')\r\n        self.assertIs(successful_result, True,\r\n                      'Valid input should be successful')\r\n        self.assertEqual(result, 1, 'Result of valid input should not be None')\r\n\r\n        failure_result, result = er.handle_error_by_returning_tuple('a')\r\n        self.assertIs(failure_result, False,\r\n                      'Invalid input should not be successful')\r\n\r\n    def test_filelike_objects_are_closed_on_exception(self):\r\n        filelike_object = FileLike(fail_something=True)\r\n        with self.assertRaisesWithMessage(Exception):\r\n            er.filelike_objects_are_closed_on_exception(filelike_object)\r\n        self.assertIs(filelike_object.is_open, False,\r\n                      'filelike_object should be closed')\r\n        self.assertIs(filelike_object.was_open, True,\r\n                      'filelike_object should have been opened')\r\n        self.assertIs(filelike_object.did_something, True,\r\n                      'filelike_object should call do_something()')\r\n\r\n    def test_filelike_objects_are_closed_without_exception(self):\r\n        filelike_object = FileLike(fail_something=False)\r\n        er.filelike_objects_are_closed_on_exception(filelike_object)\r\n        self.assertIs(filelike_object.is_open, False,\r\n                      'filelike_object should be closed')\r\n        self.assertIs(filelike_object.was_open, True,\r\n                      'filelike_object should have been opened')\r\n        self.assertIs(filelike_object.did_something, True,\r\n                      'filelike_object should call do_something()')\r\n\r\n    # Utility functions\r\n    def assertRaisesWithMessage(self, exception):\r\n        return self.assertRaisesRegex(exception, r\".+\")\r\n\r\n\r\nif __name__ == '__main__':\r\n    unittest.main()\r\n"
}