{
  "language": "python",
  "type": "practice",
  "slug": "gigasecond",
  "title": "Gigasecond",
  "docs": {
    "instructions": "# Instructions\r\n\r\nYour task is to determine the date and time one gigasecond after a certain date.\r\n\r\nA gigasecond is one thousand million seconds.\r\nThat is a one with nine zeros after it.\r\n\r\nIf you were born on _January 24th, 2015 at 22:00 (10:00:00pm)_, then you would be a gigasecond old on _October 2nd, 2046 at 23:46:40 (11:46:40pm)_.\r\n",
    "hints": "# Hints\r\n\r\n## General\r\n\r\n- Your function should parse the passed-in [datetime object][datetime], add a gigasecond's worth of time to it, and then return the result.\r\n\r\n- If you're having trouble, remember to take a look at the provided test cases under the Tests tab. These will help you figure out what the expected inputs and outputs of your function(s) should be.\r\n\r\n- Most of the time, code is read rather than written, and a big number can be a challenge to read. Here are a couple of approaches to making big numbers in your code more readable:\r\n\r\n  - Using underscores (`_`) in numeric literals can help offset thousands, hundred-thousands, millions, etc. (_**ie:** `1_000_000` or `10_100_201_330` is far more readable than `1000000` or `10100201330`._) See [PEP-0515][underscores_notation] for more information.\r\n\r\n   - Scientific notation can be more compact and easier to scan when there are very large numbers (_**ie:** `1e6`, 1 is multiplied by 10 raised to the power of 6, which equals `1000000`_). For more information, see this reference on [scientific notation][scientific_notation].\r\n\r\n[datetime]: https://docs.python.org/3.9/library/datetime.html#datetime.datetime\r\n[scientific_notation]: https://python-reference.readthedocs.io/en/latest/docs/float/scientific.html\r\n[underscores_notation]: https://peps.python.org/pep-0515/#:~:text=The%20syntax%20would%20be%20the,width%20of%2010%20with%20*%20separator.\r\n"
  },
  "starter_code": "def add(moment):\r\n    pass\r\n",
  "tests": "# These tests are auto-generated with test data from:\r\n# https://github.com/exercism/problem-specifications/tree/main/exercises/gigasecond/canonical-data.json\r\n# File last updated on 2023-07-19\r\n\r\nfrom datetime import datetime\r\nimport unittest\r\n\r\nfrom gigasecond import (\r\n    add,\r\n)\r\n\r\n\r\nclass GigasecondTest(unittest.TestCase):\r\n    def test_date_only_specification_of_time(self):\r\n        self.assertEqual(\r\n            add(datetime(2011, 4, 25, 0, 0)), datetime(2043, 1, 1, 1, 46, 40)\r\n        )\r\n\r\n    def test_second_test_for_date_only_specification_of_time(self):\r\n        self.assertEqual(\r\n            add(datetime(1977, 6, 13, 0, 0)), datetime(2009, 2, 19, 1, 46, 40)\r\n        )\r\n\r\n    def test_third_test_for_date_only_specification_of_time(self):\r\n        self.assertEqual(\r\n            add(datetime(1959, 7, 19, 0, 0)), datetime(1991, 3, 27, 1, 46, 40)\r\n        )\r\n\r\n    def test_full_time_specified(self):\r\n        self.assertEqual(\r\n            add(datetime(2015, 1, 24, 22, 0)), datetime(2046, 10, 2, 23, 46, 40)\r\n        )\r\n\r\n    def test_full_time_with_day_roll_over(self):\r\n        self.assertEqual(\r\n            add(datetime(2015, 1, 24, 23, 59, 59)), datetime(2046, 10, 3, 1, 46, 39)\r\n        )\r\n"
}