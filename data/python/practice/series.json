{
  "language": "python",
  "type": "practice",
  "slug": "series",
  "title": "Series",
  "docs": {
    "instructions": "# Instructions\r\n\r\nGiven a string of digits, output all the contiguous substrings of length `n` in that string in the order that they appear.\r\n\r\nFor example, the string \"49142\" has the following 3-digit series:\r\n\r\n- \"491\"\r\n- \"914\"\r\n- \"142\"\r\n\r\nAnd the following 4-digit series:\r\n\r\n- \"4914\"\r\n- \"9142\"\r\n\r\nAnd if you ask for a 6-digit series from a 5-digit string, you deserve whatever you get.\r\n\r\nNote that these series are only required to occupy _adjacent positions_ in the input;\r\nthe digits need not be _numerically consecutive_.\r\n",
    "hints": ""
  },
  "starter_code": "def slices(series, length):\r\n    pass\r\n",
  "tests": "# These tests are auto-generated with test data from:\r\n# https://github.com/exercism/problem-specifications/tree/main/exercises/series/canonical-data.json\r\n# File last updated on 2023-07-19\r\n\r\nimport unittest\r\n\r\nfrom series import (\r\n    slices,\r\n)\r\n\r\n\r\nclass SeriesTest(unittest.TestCase):\r\n    def test_slices_of_one_from_one(self):\r\n        self.assertEqual(slices(\"1\", 1), [\"1\"])\r\n\r\n    def test_slices_of_one_from_two(self):\r\n        self.assertEqual(slices(\"12\", 1), [\"1\", \"2\"])\r\n\r\n    def test_slices_of_two(self):\r\n        self.assertEqual(slices(\"35\", 2), [\"35\"])\r\n\r\n    def test_slices_of_two_overlap(self):\r\n        self.assertEqual(slices(\"9142\", 2), [\"91\", \"14\", \"42\"])\r\n\r\n    def test_slices_can_include_duplicates(self):\r\n        self.assertEqual(slices(\"777777\", 3), [\"777\", \"777\", \"777\", \"777\"])\r\n\r\n    def test_slices_of_a_long_series(self):\r\n        self.assertEqual(\r\n            slices(\"918493904243\", 5),\r\n            [\"91849\", \"18493\", \"84939\", \"49390\", \"93904\", \"39042\", \"90424\", \"04243\"],\r\n        )\r\n\r\n    def test_slice_length_is_too_large(self):\r\n        with self.assertRaises(ValueError) as err:\r\n            slices(\"12345\", 6)\r\n        self.assertEqual(type(err.exception), ValueError)\r\n        self.assertEqual(\r\n            err.exception.args[0], \"slice length cannot be greater than series length\"\r\n        )\r\n\r\n    def test_slice_length_is_way_too_large(self):\r\n        with self.assertRaises(ValueError) as err:\r\n            slices(\"12345\", 42)\r\n        self.assertEqual(type(err.exception), ValueError)\r\n        self.assertEqual(\r\n            err.exception.args[0], \"slice length cannot be greater than series length\"\r\n        )\r\n\r\n    def test_slice_length_cannot_be_zero(self):\r\n        with self.assertRaises(ValueError) as err:\r\n            slices(\"12345\", 0)\r\n        self.assertEqual(type(err.exception), ValueError)\r\n        self.assertEqual(err.exception.args[0], \"slice length cannot be zero\")\r\n\r\n    def test_slice_length_cannot_be_negative(self):\r\n        with self.assertRaises(ValueError) as err:\r\n            slices(\"123\", -1)\r\n        self.assertEqual(type(err.exception), ValueError)\r\n        self.assertEqual(err.exception.args[0], \"slice length cannot be negative\")\r\n\r\n    def test_empty_series_is_invalid(self):\r\n        with self.assertRaises(ValueError) as err:\r\n            slices(\"\", 1)\r\n        self.assertEqual(type(err.exception), ValueError)\r\n        self.assertEqual(err.exception.args[0], \"series cannot be empty\")\r\n"
}