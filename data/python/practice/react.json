{
  "language": "python",
  "type": "practice",
  "slug": "react",
  "title": "React",
  "docs": {
    "instructions": "# Instructions\r\n\r\nImplement a basic reactive system.\r\n\r\nReactive programming is a programming paradigm that focuses on how values are computed in terms of each other to allow a change to one value to automatically propagate to other values, like in a spreadsheet.\r\n\r\nImplement a basic reactive system with cells with settable values (\"input\" cells) and cells with values computed in terms of other cells (\"compute\" cells).\r\nImplement updates so that when an input value is changed, values propagate to reach a new stable system state.\r\n\r\nIn addition, compute cells should allow for registering change notification callbacks.\r\nCall a cell’s callbacks when the cell’s value in a new stable state has changed from the previous stable state.\r\n",
    "hints": ""
  },
  "starter_code": "class InputCell:\r\n    def __init__(self, initial_value):\r\n        self.value = None\r\n\r\n\r\nclass ComputeCell:\r\n    def __init__(self, inputs, compute_function):\r\n        self.value = None\r\n\r\n    def add_callback(self, callback):\r\n        pass\r\n\r\n    def remove_callback(self, callback):\r\n        pass\r\n    ",
  "tests": "# These tests are auto-generated with test data from:\r\n# https://github.com/exercism/problem-specifications/tree/main/exercises/react/canonical-data.json\r\n# File last updated on 2023-07-19\r\n\r\nfrom functools import partial\r\nimport unittest\r\n\r\nfrom react import (\r\n    InputCell,\r\n    ComputeCell,\r\n)\r\n\r\n\r\nclass ReactTest(unittest.TestCase):\r\n    def test_input_cells_have_a_value(self):\r\n        input = InputCell(10)\r\n        self.assertEqual(input.value, 10)\r\n\r\n    def test_an_input_cell_s_value_can_be_set(self):\r\n        input = InputCell(4)\r\n        input.value = 20\r\n        self.assertEqual(input.value, 20)\r\n\r\n    def test_compute_cells_calculate_initial_value(self):\r\n        input = InputCell(1)\r\n        output = ComputeCell(\r\n            [\r\n                input,\r\n            ],\r\n            lambda inputs: inputs[0] + 1,\r\n        )\r\n        self.assertEqual(output.value, 2)\r\n\r\n    def test_compute_cells_take_inputs_in_the_right_order(self):\r\n        one = InputCell(1)\r\n        two = InputCell(2)\r\n        output = ComputeCell(\r\n            [\r\n                one,\r\n                two,\r\n            ],\r\n            lambda inputs: inputs[0] + inputs[1] * 10,\r\n        )\r\n        self.assertEqual(output.value, 21)\r\n\r\n    def test_compute_cells_update_value_when_dependencies_are_changed(self):\r\n        input = InputCell(1)\r\n        output = ComputeCell(\r\n            [\r\n                input,\r\n            ],\r\n            lambda inputs: inputs[0] + 1,\r\n        )\r\n        input.value = 3\r\n        self.assertEqual(output.value, 4)\r\n\r\n    def test_compute_cells_can_depend_on_other_compute_cells(self):\r\n        input = InputCell(1)\r\n        times_two = ComputeCell(\r\n            [\r\n                input,\r\n            ],\r\n            lambda inputs: inputs[0] * 2,\r\n        )\r\n        times_thirty = ComputeCell(\r\n            [\r\n                input,\r\n            ],\r\n            lambda inputs: inputs[0] * 30,\r\n        )\r\n        output = ComputeCell(\r\n            [\r\n                times_two,\r\n                times_thirty,\r\n            ],\r\n            lambda inputs: inputs[0] + inputs[1],\r\n        )\r\n        self.assertEqual(output.value, 32)\r\n        input.value = 3\r\n        self.assertEqual(output.value, 96)\r\n\r\n    def test_compute_cells_fire_callbacks(self):\r\n        input = InputCell(1)\r\n        output = ComputeCell(\r\n            [\r\n                input,\r\n            ],\r\n            lambda inputs: inputs[0] + 1,\r\n        )\r\n        cb1_observer = []\r\n        callback1 = self.callback_factory(cb1_observer)\r\n        output.add_callback(callback1)\r\n        input.value = 3\r\n        self.assertEqual(cb1_observer[-1], 4)\r\n\r\n    def test_callback_cells_only_fire_on_change(self):\r\n        input = InputCell(1)\r\n        output = ComputeCell([input], lambda inputs: 111 if inputs[0] < 3 else 222)\r\n        cb1_observer = []\r\n        callback1 = self.callback_factory(cb1_observer)\r\n        output.add_callback(callback1)\r\n        input.value = 2\r\n        self.assertEqual(cb1_observer, [])\r\n        input.value = 4\r\n        self.assertEqual(cb1_observer[-1], 222)\r\n\r\n    def test_callbacks_do_not_report_already_reported_values(self):\r\n        input = InputCell(1)\r\n        output = ComputeCell(\r\n            [\r\n                input,\r\n            ],\r\n            lambda inputs: inputs[0] + 1,\r\n        )\r\n        cb1_observer = []\r\n        callback1 = self.callback_factory(cb1_observer)\r\n        output.add_callback(callback1)\r\n        input.value = 2\r\n        self.assertEqual(cb1_observer[-1], 3)\r\n        input.value = 3\r\n        self.assertEqual(cb1_observer[-1], 4)\r\n\r\n    def test_callbacks_can_fire_from_multiple_cells(self):\r\n        input = InputCell(1)\r\n        plus_one = ComputeCell(\r\n            [\r\n                input,\r\n            ],\r\n            lambda inputs: inputs[0] + 1,\r\n        )\r\n        minus_one = ComputeCell(\r\n            [\r\n                input,\r\n            ],\r\n            lambda inputs: inputs[0] - 1,\r\n        )\r\n        cb1_observer = []\r\n        cb2_observer = []\r\n        callback1 = self.callback_factory(cb1_observer)\r\n        callback2 = self.callback_factory(cb2_observer)\r\n        plus_one.add_callback(callback1)\r\n        minus_one.add_callback(callback2)\r\n        input.value = 10\r\n        self.assertEqual(cb1_observer[-1], 11)\r\n        self.assertEqual(cb2_observer[-1], 9)\r\n\r\n    def test_callbacks_can_be_added_and_removed(self):\r\n        input = InputCell(11)\r\n        output = ComputeCell(\r\n            [\r\n                input,\r\n            ],\r\n            lambda inputs: inputs[0] + 1,\r\n        )\r\n        cb1_observer = []\r\n        cb2_observer = []\r\n        cb3_observer = []\r\n        callback1 = self.callback_factory(cb1_observer)\r\n        callback2 = self.callback_factory(cb2_observer)\r\n        callback3 = self.callback_factory(cb3_observer)\r\n        output.add_callback(callback1)\r\n        output.add_callback(callback2)\r\n        input.value = 31\r\n        self.assertEqual(cb1_observer[-1], 32)\r\n        self.assertEqual(cb2_observer[-1], 32)\r\n        output.remove_callback(callback1)\r\n        output.add_callback(callback3)\r\n        input.value = 41\r\n        self.assertEqual(len(cb1_observer), 1)\r\n        self.assertEqual(cb2_observer[-1], 42)\r\n        self.assertEqual(cb3_observer[-1], 42)\r\n\r\n    def test_removing_a_callback_multiple_times_doesn_t_interfere_with_other_callbacks(\r\n        self,\r\n    ):\r\n        input = InputCell(1)\r\n        output = ComputeCell(\r\n            [\r\n                input,\r\n            ],\r\n            lambda inputs: inputs[0] + 1,\r\n        )\r\n        cb1_observer = []\r\n        cb2_observer = []\r\n        callback1 = self.callback_factory(cb1_observer)\r\n        callback2 = self.callback_factory(cb2_observer)\r\n        output.add_callback(callback1)\r\n        output.add_callback(callback2)\r\n        output.remove_callback(callback1)\r\n        output.remove_callback(callback1)\r\n        output.remove_callback(callback1)\r\n        input.value = 2\r\n        self.assertEqual(cb1_observer, [])\r\n        self.assertEqual(cb2_observer[-1], 3)\r\n\r\n    def test_callbacks_should_only_be_called_once_even_if_multiple_dependencies_change(\r\n        self,\r\n    ):\r\n        input = InputCell(1)\r\n        plus_one = ComputeCell(\r\n            [\r\n                input,\r\n            ],\r\n            lambda inputs: inputs[0] + 1,\r\n        )\r\n        minus_one1 = ComputeCell(\r\n            [\r\n                input,\r\n            ],\r\n            lambda inputs: inputs[0] - 1,\r\n        )\r\n        minus_one2 = ComputeCell(\r\n            [\r\n                minus_one1,\r\n            ],\r\n            lambda inputs: inputs[0] - 1,\r\n        )\r\n        output = ComputeCell(\r\n            [\r\n                plus_one,\r\n                minus_one2,\r\n            ],\r\n            lambda inputs: inputs[0] * inputs[1],\r\n        )\r\n        cb1_observer = []\r\n        callback1 = self.callback_factory(cb1_observer)\r\n        output.add_callback(callback1)\r\n        input.value = 4\r\n        self.assertEqual(cb1_observer[-1], 10)\r\n\r\n    def test_callbacks_should_not_be_called_if_dependencies_change_but_output_value_doesn_t_change(\r\n        self,\r\n    ):\r\n        input = InputCell(1)\r\n        plus_one = ComputeCell(\r\n            [\r\n                input,\r\n            ],\r\n            lambda inputs: inputs[0] + 1,\r\n        )\r\n        minus_one = ComputeCell(\r\n            [\r\n                input,\r\n            ],\r\n            lambda inputs: inputs[0] - 1,\r\n        )\r\n        always_two = ComputeCell(\r\n            [\r\n                plus_one,\r\n                minus_one,\r\n            ],\r\n            lambda inputs: inputs[0] - inputs[1],\r\n        )\r\n        cb1_observer = []\r\n        callback1 = self.callback_factory(cb1_observer)\r\n        always_two.add_callback(callback1)\r\n        input.value = 2\r\n        self.assertEqual(cb1_observer, [])\r\n        input.value = 3\r\n        self.assertEqual(cb1_observer, [])\r\n        input.value = 4\r\n        self.assertEqual(cb1_observer, [])\r\n        input.value = 5\r\n        self.assertEqual(cb1_observer, [])\r\n\r\n    # Utility functions.\r\n    def callback_factory(self, observer):\r\n        def callback(observer, value):\r\n            observer.append(value)\r\n\r\n        return partial(callback, observer)\r\n"
}