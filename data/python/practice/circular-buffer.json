{
  "language": "python",
  "type": "practice",
  "slug": "circular-buffer",
  "title": "Circular Buffer",
  "docs": {
    "instructions": "# Instructions\r\n\r\nA circular buffer, cyclic buffer or ring buffer is a data structure that uses a single, fixed-size buffer as if it were connected end-to-end.\r\n\r\nA circular buffer first starts empty and of some predefined length.\r\nFor example, this is a 7-element buffer:\r\n\r\n```text\r\n[ ][ ][ ][ ][ ][ ][ ]\r\n```\r\n\r\nAssume that a 1 is written into the middle of the buffer (exact starting location does not matter in a circular buffer):\r\n\r\n```text\r\n[ ][ ][ ][1][ ][ ][ ]\r\n```\r\n\r\nThen assume that two more elements are added — 2 & 3 — which get appended after the 1:\r\n\r\n```text\r\n[ ][ ][ ][1][2][3][ ]\r\n```\r\n\r\nIf two elements are then removed from the buffer, the oldest values inside the buffer are removed.\r\nThe two elements removed, in this case, are 1 & 2, leaving the buffer with just a 3:\r\n\r\n```text\r\n[ ][ ][ ][ ][ ][3][ ]\r\n```\r\n\r\nIf the buffer has 7 elements then it is completely full:\r\n\r\n```text\r\n[5][6][7][8][9][3][4]\r\n```\r\n\r\nWhen the buffer is full an error will be raised, alerting the client that further writes are blocked until a slot becomes free.\r\n\r\nWhen the buffer is full, the client can opt to overwrite the oldest data with a forced write.\r\nIn this case, two more elements — A & B — are added and they overwrite the 3 & 4:\r\n\r\n```text\r\n[5][6][7][8][9][A][B]\r\n```\r\n\r\n3 & 4 have been replaced by A & B making 5 now the oldest data in the buffer.\r\nFinally, if two elements are removed then what would be returned is 5 & 6 yielding the buffer:\r\n\r\n```text\r\n[ ][ ][7][8][9][A][B]\r\n```\r\n\r\nBecause there is space available, if the client again uses overwrite to store C & D then the space where 5 & 6 were stored previously will be used not the location of 7 & 8.\r\n7 is still the oldest element and the buffer is once again full.\r\n\r\n```text\r\n[C][D][7][8][9][A][B]\r\n```\r\n",
    "hints": ""
  },
  "starter_code": "class BufferFullException(BufferError):\r\n    \"\"\"Exception raised when CircularBuffer is full.\r\n\r\n    message: explanation of the error.\r\n\r\n    \"\"\"\r\n    def __init__(self, message):\r\n        pass\r\n\r\n\r\nclass BufferEmptyException(BufferError):\r\n    \"\"\"Exception raised when CircularBuffer is empty.\r\n\r\n    message: explanation of the error.\r\n\r\n    \"\"\"\r\n    def __init__(self, message):\r\n        pass\r\n\r\n\r\nclass CircularBuffer:\r\n    def __init__(self, capacity):\r\n        pass\r\n\r\n    def read(self):\r\n        pass\r\n\r\n    def write(self, data):\r\n        pass\r\n\r\n    def overwrite(self, data):\r\n        pass\r\n\r\n    def clear(self):\r\n        pass\r\n",
  "tests": "# These tests are auto-generated with test data from:\r\n# https://github.com/exercism/problem-specifications/tree/main/exercises/circular-buffer/canonical-data.json\r\n# File last updated on 2023-07-20\r\n\r\nimport unittest\r\n\r\nfrom circular_buffer import (\r\n    CircularBuffer,\r\n    BufferEmptyException,\r\n    BufferFullException,\r\n)\r\n\r\n\r\nclass CircularBufferTest(unittest.TestCase):\r\n    def test_reading_empty_buffer_should_fail(self):\r\n        buf = CircularBuffer(1)\r\n        with self.assertRaises(BufferError) as err:\r\n            buf.read()\r\n\r\n        self.assertEqual(type(err.exception), BufferEmptyException)\r\n        self.assertEqual(err.exception.args[0], \"Circular buffer is empty\")\r\n\r\n    def test_can_read_an_item_just_written(self):\r\n        buf = CircularBuffer(1)\r\n        buf.write(\"1\")\r\n        self.assertEqual(buf.read(), \"1\")\r\n\r\n    def test_each_item_may_only_be_read_once(self):\r\n        buf = CircularBuffer(1)\r\n        buf.write(\"1\")\r\n        self.assertEqual(buf.read(), \"1\")\r\n        with self.assertRaises(BufferError) as err:\r\n            buf.read()\r\n\r\n        self.assertEqual(type(err.exception), BufferEmptyException)\r\n        self.assertEqual(err.exception.args[0], \"Circular buffer is empty\")\r\n\r\n    def test_items_are_read_in_the_order_they_are_written(self):\r\n        buf = CircularBuffer(2)\r\n        buf.write(\"1\")\r\n        buf.write(\"2\")\r\n        self.assertEqual(buf.read(), \"1\")\r\n        self.assertEqual(buf.read(), \"2\")\r\n\r\n    def test_full_buffer_can_t_be_written_to(self):\r\n        buf = CircularBuffer(1)\r\n        buf.write(\"1\")\r\n        with self.assertRaises(BufferError) as err:\r\n            buf.write(\"2\")\r\n\r\n        self.assertEqual(type(err.exception), BufferFullException)\r\n        self.assertEqual(err.exception.args[0], \"Circular buffer is full\")\r\n\r\n    def test_a_read_frees_up_capacity_for_another_write(self):\r\n        buf = CircularBuffer(1)\r\n        buf.write(\"1\")\r\n        self.assertEqual(buf.read(), \"1\")\r\n        buf.write(\"2\")\r\n        self.assertEqual(buf.read(), \"2\")\r\n\r\n    def test_read_position_is_maintained_even_across_multiple_writes(self):\r\n        buf = CircularBuffer(3)\r\n        buf.write(\"1\")\r\n        buf.write(\"2\")\r\n        self.assertEqual(buf.read(), \"1\")\r\n        buf.write(\"3\")\r\n        self.assertEqual(buf.read(), \"2\")\r\n        self.assertEqual(buf.read(), \"3\")\r\n\r\n    def test_items_cleared_out_of_buffer_can_t_be_read(self):\r\n        buf = CircularBuffer(1)\r\n        buf.write(\"1\")\r\n        buf.clear()\r\n        with self.assertRaises(BufferError) as err:\r\n            buf.read()\r\n\r\n        self.assertEqual(type(err.exception), BufferEmptyException)\r\n        self.assertEqual(err.exception.args[0], \"Circular buffer is empty\")\r\n\r\n    def test_clear_frees_up_capacity_for_another_write(self):\r\n        buf = CircularBuffer(1)\r\n        buf.write(\"1\")\r\n        buf.clear()\r\n        buf.write(\"2\")\r\n        self.assertEqual(buf.read(), \"2\")\r\n\r\n    def test_clear_does_nothing_on_empty_buffer(self):\r\n        buf = CircularBuffer(1)\r\n        buf.clear()\r\n        buf.write(\"1\")\r\n        self.assertEqual(buf.read(), \"1\")\r\n\r\n    def test_overwrite_acts_like_write_on_non_full_buffer(self):\r\n        buf = CircularBuffer(2)\r\n        buf.write(\"1\")\r\n        buf.overwrite(\"2\")\r\n        self.assertEqual(buf.read(), \"1\")\r\n        self.assertEqual(buf.read(), \"2\")\r\n\r\n    def test_overwrite_replaces_the_oldest_item_on_full_buffer(self):\r\n        buf = CircularBuffer(2)\r\n        buf.write(\"1\")\r\n        buf.write(\"2\")\r\n        buf.overwrite(\"3\")\r\n        self.assertEqual(buf.read(), \"2\")\r\n        self.assertEqual(buf.read(), \"3\")\r\n\r\n    def test_overwrite_replaces_the_oldest_item_remaining_in_buffer_following_a_read(\r\n        self,\r\n    ):\r\n        buf = CircularBuffer(3)\r\n        buf.write(\"1\")\r\n        buf.write(\"2\")\r\n        buf.write(\"3\")\r\n        self.assertEqual(buf.read(), \"1\")\r\n        buf.write(\"4\")\r\n        buf.overwrite(\"5\")\r\n        self.assertEqual(buf.read(), \"3\")\r\n        self.assertEqual(buf.read(), \"4\")\r\n        self.assertEqual(buf.read(), \"5\")\r\n\r\n    def test_initial_clear_does_not_affect_wrapping_around(self):\r\n        buf = CircularBuffer(2)\r\n        buf.clear()\r\n        buf.write(\"1\")\r\n        buf.write(\"2\")\r\n        buf.overwrite(\"3\")\r\n        buf.overwrite(\"4\")\r\n        self.assertEqual(buf.read(), \"3\")\r\n        self.assertEqual(buf.read(), \"4\")\r\n        with self.assertRaises(BufferError) as err:\r\n            buf.read()\r\n\r\n        self.assertEqual(type(err.exception), BufferEmptyException)\r\n        self.assertEqual(err.exception.args[0], \"Circular buffer is empty\")\r\n"
}