{
  "language": "python",
  "type": "practice",
  "slug": "sublist",
  "title": "Sublist",
  "docs": {
    "instructions": "# Instructions\r\n\r\nGiven any two lists `A` and `B`, determine if:\r\n\r\n- List `A` is equal to list `B`; or\r\n- List `A` contains list `B` (`A` is a superlist of `B`); or\r\n- List `A` is contained by list `B` (`A` is a sublist of `B`); or\r\n- None of the above is true, thus lists `A` and `B` are unequal\r\n\r\nSpecifically, list `A` is equal to list `B` if both lists have the same values in the same order.\r\nList `A` is a superlist of `B` if `A` contains a contiguous sub-sequence of values equal to `B`.\r\nList `A` is a sublist of `B` if `B` contains a contiguous sub-sequence of values equal to `A`.\r\n\r\nExamples:\r\n\r\n- If `A = []` and `B = []` (both lists are empty), then `A` and `B` are equal\r\n- If `A = [1, 2, 3]` and `B = []`, then `A` is a superlist of `B`\r\n- If `A = []` and `B = [1, 2, 3]`, then `A` is a sublist of `B`\r\n- If `A = [1, 2, 3]` and `B = [1, 2, 3, 4, 5]`, then `A` is a sublist of `B`\r\n- If `A = [3, 4, 5]` and `B = [1, 2, 3, 4, 5]`, then `A` is a sublist of `B`\r\n- If `A = [3, 4]` and `B = [1, 2, 3, 4, 5]`, then `A` is a sublist of `B`\r\n- If `A = [1, 2, 3]` and `B = [1, 2, 3]`, then `A` and `B` are equal\r\n- If `A = [1, 2, 3, 4, 5]` and `B = [2, 3, 4]`, then `A` is a superlist of `B`\r\n- If `A = [1, 2, 4]` and `B = [1, 2, 3, 4, 5]`, then `A` and `B` are unequal\r\n- If `A = [1, 2, 3]` and `B = [1, 3, 2]`, then `A` and `B` are unequal\r\n",
    "hints": ""
  },
  "starter_code": "\"\"\"\r\nThis exercise stub and the test suite contain several enumerated constants.\r\n\r\nEnumerated constants can be done with a NAME assigned to an arbitrary,\r\nbut unique value. An integer is traditionally used because itâ€™s memory\r\nefficient.\r\nIt is a common practice to export both constants and functions that work with\r\nthose constants (ex. the constants in the os, subprocess and re modules).\r\n\r\nYou can learn more here: https://en.wikipedia.org/wiki/Enumerated_type\r\n\"\"\"\r\n\r\n# Possible sublist categories.\r\n# Change the values as you see fit.\r\nSUBLIST = None\r\nSUPERLIST = None\r\nEQUAL = None\r\nUNEQUAL = None\r\n\r\n\r\ndef sublist(list_one, list_two):\r\n    pass\r\n",
  "tests": "# These tests are auto-generated with test data from:\r\n# https://github.com/exercism/problem-specifications/tree/main/exercises/sublist/canonical-data.json\r\n# File last updated on 2023-07-19\r\n\r\nimport unittest\r\n\r\nfrom sublist import (\r\n    sublist,\r\n    SUBLIST,\r\n    SUPERLIST,\r\n    EQUAL,\r\n    UNEQUAL,\r\n)\r\n\r\n\r\nclass SublistTest(unittest.TestCase):\r\n    def test_empty_lists(self):\r\n        self.assertEqual(sublist([], []), EQUAL)\r\n\r\n    def test_empty_list_within_non_empty_list(self):\r\n        self.assertEqual(sublist([], [1, 2, 3]), SUBLIST)\r\n\r\n    def test_non_empty_list_contains_empty_list(self):\r\n        self.assertEqual(sublist([1, 2, 3], []), SUPERLIST)\r\n\r\n    def test_list_equals_itself(self):\r\n        self.assertEqual(sublist([1, 2, 3], [1, 2, 3]), EQUAL)\r\n\r\n    def test_different_lists(self):\r\n        self.assertEqual(sublist([1, 2, 3], [2, 3, 4]), UNEQUAL)\r\n\r\n    def test_false_start(self):\r\n        self.assertEqual(sublist([1, 2, 5], [0, 1, 2, 3, 1, 2, 5, 6]), SUBLIST)\r\n\r\n    def test_consecutive(self):\r\n        self.assertEqual(sublist([1, 1, 2], [0, 1, 1, 1, 2, 1, 2]), SUBLIST)\r\n\r\n    def test_sublist_at_start(self):\r\n        self.assertEqual(sublist([0, 1, 2], [0, 1, 2, 3, 4, 5]), SUBLIST)\r\n\r\n    def test_sublist_in_middle(self):\r\n        self.assertEqual(sublist([2, 3, 4], [0, 1, 2, 3, 4, 5]), SUBLIST)\r\n\r\n    def test_sublist_at_end(self):\r\n        self.assertEqual(sublist([3, 4, 5], [0, 1, 2, 3, 4, 5]), SUBLIST)\r\n\r\n    def test_at_start_of_superlist(self):\r\n        self.assertEqual(sublist([0, 1, 2, 3, 4, 5], [0, 1, 2]), SUPERLIST)\r\n\r\n    def test_in_middle_of_superlist(self):\r\n        self.assertEqual(sublist([0, 1, 2, 3, 4, 5], [2, 3]), SUPERLIST)\r\n\r\n    def test_at_end_of_superlist(self):\r\n        self.assertEqual(sublist([0, 1, 2, 3, 4, 5], [3, 4, 5]), SUPERLIST)\r\n\r\n    def test_first_list_missing_element_from_second_list(self):\r\n        self.assertEqual(sublist([1, 3], [1, 2, 3]), UNEQUAL)\r\n\r\n    def test_second_list_missing_element_from_first_list(self):\r\n        self.assertEqual(sublist([1, 2, 3], [1, 3]), UNEQUAL)\r\n\r\n    def test_first_list_missing_additional_digits_from_second_list(self):\r\n        self.assertEqual(sublist([1, 2], [1, 22]), UNEQUAL)\r\n\r\n    def test_order_matters_to_a_list(self):\r\n        self.assertEqual(sublist([1, 2, 3], [3, 2, 1]), UNEQUAL)\r\n\r\n    def test_same_digits_but_different_numbers(self):\r\n        self.assertEqual(sublist([1, 0, 1], [10, 1]), UNEQUAL)\r\n\r\n    # Additional tests for this track\r\n    def test_unique_return_values(self):\r\n        self.assertEqual(len(set([SUBLIST, SUPERLIST, EQUAL, UNEQUAL])), 4)\r\n\r\n    def test_inner_spaces(self):\r\n        self.assertEqual(sublist([\"a c\"], [\"a\", \"c\"]), UNEQUAL)\r\n\r\n    def test_large_lists(self):\r\n        self.assertEqual(\r\n            sublist(\r\n                list(range(1000)) * 1000 + list(range(1000, 1100)),\r\n                list(range(900, 1050)),\r\n            ),\r\n            SUPERLIST,\r\n        )\r\n\r\n    def test_spread_sublist(self):\r\n        self.assertEqual(\r\n            sublist(list(range(3, 200, 3)), list(range(15, 200, 15))), UNEQUAL\r\n        )\r\n"
}