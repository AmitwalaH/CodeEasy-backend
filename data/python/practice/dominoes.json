{
  "language": "python",
  "type": "practice",
  "slug": "dominoes",
  "title": "Dominoes",
  "docs": {
    "instructions": "# Instructions\r\n\r\nMake a chain of dominoes.\r\n\r\nCompute a way to order a given set of domino stones so that they form a correct domino chain.\r\nIn the chain, the dots on one half of a stone must match the dots on the neighboring half of an adjacent stone.\r\nAdditionally, the dots on the halves of the stones without neighbors (the first and last stone) must match each other.\r\n\r\nFor example given the stones `[2|1]`, `[2|3]` and `[1|3]` you should compute something\r\nlike `[1|2] [2|3] [3|1]` or `[3|2] [2|1] [1|3]` or `[1|3] [3|2] [2|1]` etc, where the first and last numbers are the same.\r\n\r\nFor stones `[1|2]`, `[4|1]` and `[2|3]` the resulting chain is not valid: `[4|1] [1|2] [2|3]`'s first and last numbers are not the same.\r\n4 != 3\r\n\r\nSome test cases may use duplicate stones in a chain solution, assume that multiple Domino sets are being used.\r\n",
    "hints": ""
  },
  "starter_code": "def can_chain(dominoes):\r\n    pass\r\n",
  "tests": "# These tests are auto-generated with test data from:\r\n# https://github.com/exercism/problem-specifications/tree/main/exercises/dominoes/canonical-data.json\r\n# File last updated on 2023-07-19\r\n\r\nimport unittest\r\n\r\nfrom dominoes import (\r\n    can_chain,\r\n)\r\n\r\n\r\nclass DominoesTest(unittest.TestCase):\r\n    def test_empty_input_empty_output(self):\r\n        input_dominoes = []\r\n        output_chain = can_chain(input_dominoes)\r\n        self.assert_correct_chain(input_dominoes, output_chain)\r\n\r\n    def test_singleton_input_singleton_output(self):\r\n        input_dominoes = [(1, 1)]\r\n        output_chain = can_chain(input_dominoes)\r\n        self.assert_correct_chain(input_dominoes, output_chain)\r\n\r\n    def test_singleton_that_can_t_be_chained(self):\r\n        input_dominoes = [(1, 2)]\r\n        output_chain = can_chain(input_dominoes)\r\n        self.refute_correct_chain(input_dominoes, output_chain)\r\n\r\n    def test_three_elements(self):\r\n        input_dominoes = [(1, 2), (3, 1), (2, 3)]\r\n        output_chain = can_chain(input_dominoes)\r\n        self.assert_correct_chain(input_dominoes, output_chain)\r\n\r\n    def test_can_reverse_dominoes(self):\r\n        input_dominoes = [(1, 2), (1, 3), (2, 3)]\r\n        output_chain = can_chain(input_dominoes)\r\n        self.assert_correct_chain(input_dominoes, output_chain)\r\n\r\n    def test_can_t_be_chained(self):\r\n        input_dominoes = [(1, 2), (4, 1), (2, 3)]\r\n        output_chain = can_chain(input_dominoes)\r\n        self.refute_correct_chain(input_dominoes, output_chain)\r\n\r\n    def test_disconnected_simple(self):\r\n        input_dominoes = [(1, 1), (2, 2)]\r\n        output_chain = can_chain(input_dominoes)\r\n        self.refute_correct_chain(input_dominoes, output_chain)\r\n\r\n    def test_disconnected_double_loop(self):\r\n        input_dominoes = [(1, 2), (2, 1), (3, 4), (4, 3)]\r\n        output_chain = can_chain(input_dominoes)\r\n        self.refute_correct_chain(input_dominoes, output_chain)\r\n\r\n    def test_disconnected_single_isolated(self):\r\n        input_dominoes = [(1, 2), (2, 3), (3, 1), (4, 4)]\r\n        output_chain = can_chain(input_dominoes)\r\n        self.refute_correct_chain(input_dominoes, output_chain)\r\n\r\n    def test_need_backtrack(self):\r\n        input_dominoes = [(1, 2), (2, 3), (3, 1), (2, 4), (2, 4)]\r\n        output_chain = can_chain(input_dominoes)\r\n        self.assert_correct_chain(input_dominoes, output_chain)\r\n\r\n    def test_separate_loops(self):\r\n        input_dominoes = [(1, 2), (2, 3), (3, 1), (1, 1), (2, 2), (3, 3)]\r\n        output_chain = can_chain(input_dominoes)\r\n        self.assert_correct_chain(input_dominoes, output_chain)\r\n\r\n    def test_nine_elements(self):\r\n        input_dominoes = [\r\n            (1, 2),\r\n            (5, 3),\r\n            (3, 1),\r\n            (1, 2),\r\n            (2, 4),\r\n            (1, 6),\r\n            (2, 3),\r\n            (3, 4),\r\n            (5, 6),\r\n        ]\r\n        output_chain = can_chain(input_dominoes)\r\n        self.assert_correct_chain(input_dominoes, output_chain)\r\n\r\n    def test_separate_three_domino_loops(self):\r\n        input_dominoes = [(1, 2), (2, 3), (3, 1), (4, 5), (5, 6), (6, 4)]\r\n        output_chain = can_chain(input_dominoes)\r\n        self.refute_correct_chain(input_dominoes, output_chain)\r\n\r\n    # Utility methods\r\n\r\n    def normalize_dominoes(self, dominoes):\r\n        return list(sorted(tuple(sorted(domino)) for domino in dominoes))\r\n\r\n    def assert_same_dominoes(self, input_dominoes, output_chain):\r\n        msg = (\r\n            \"Dominoes used in the output must be the same \"\r\n            \"as the ones given in the input\"\r\n        )\r\n        input_normal = self.normalize_dominoes(input_dominoes)\r\n        output_normal = self.normalize_dominoes(output_chain)\r\n        self.assertEqual(input_normal, output_normal, msg)\r\n\r\n    def assert_consecutive_dominoes_match(self, output_chain):\r\n        for i in range(len(output_chain) - 1):\r\n            msg = (\r\n                \"In chain {}, right end of domino {} ({}) \"\r\n                \"and left end of domino {} ({}) must match\"\r\n            )\r\n            msg = msg.format(\r\n                output_chain, i, output_chain[i], i + 1, output_chain[i + 1]\r\n            )\r\n            self.assertEqual(output_chain[i][1], output_chain[i + 1][0], msg)\r\n\r\n    def assert_dominoes_at_ends_match(self, output_chain):\r\n        msg = (\r\n            \"In chain {}, left end of first domino ({}) and \"\r\n            \"right end of last domino ({}) must match\"\r\n        )\r\n        msg = msg.format(output_chain, output_chain[0], output_chain[-1])\r\n        self.assertEqual(output_chain[0][0], output_chain[-1][1], msg)\r\n\r\n    def assert_correct_chain(self, input_dominoes, output_chain):\r\n        msg = \"There should be a chain for {}\".format(input_dominoes)\r\n        self.assertIsNotNone(output_chain, msg)\r\n        self.assert_same_dominoes(input_dominoes, output_chain)\r\n        if not any(output_chain):\r\n            return\r\n        self.assert_consecutive_dominoes_match(output_chain)\r\n        self.assert_dominoes_at_ends_match(output_chain)\r\n\r\n    def refute_correct_chain(self, input_dominoes, output_chain):\r\n        msg = \"There should be no valid chain for {}\".format(input_dominoes)\r\n        self.assertIsNone(output_chain, msg)\r\n"
}