{
  "language": "python",
  "type": "practice",
  "slug": "diffie-hellman",
  "title": "Diffie Hellman",
  "docs": {
    "instructions": "# Instructions\r\n\r\nDiffie-Hellman key exchange.\r\n\r\nAlice and Bob use Diffie-Hellman key exchange to share secrets.\r\nThey start with prime numbers, pick private keys, generate and share public keys, and then generate a shared secret key.\r\n\r\n## Step 0\r\n\r\nThe test program supplies prime numbers p and g.\r\n\r\n## Step 1\r\n\r\nAlice picks a private key, a, greater than 1 and less than p.\r\nBob does the same to pick a private key b.\r\n\r\n## Step 2\r\n\r\nAlice calculates a public key A.\r\n\r\n    A = gᵃ mod p\r\n\r\nUsing the same p and g, Bob similarly calculates a public key B from his private key b.\r\n\r\n## Step 3\r\n\r\nAlice and Bob exchange public keys.\r\nAlice calculates secret key s.\r\n\r\n    s = Bᵃ mod p\r\n\r\nBob calculates\r\n\r\n    s = Aᵇ mod p\r\n\r\nThe calculations produce the same result!\r\nAlice and Bob now share secret s.\r\n",
    "hints": ""
  },
  "starter_code": "def private_key(p):\r\n    pass\r\n\r\n\r\ndef public_key(p, g, private):\r\n    pass\r\n\r\n\r\ndef secret(p, public, private):\r\n    pass\r\n",
  "tests": "# These tests are auto-generated with test data from:\r\n# https://github.com/exercism/problem-specifications/tree/main/exercises/diffie-hellman/canonical-data.json\r\n# File last updated on 2023-07-19\r\n\r\nimport unittest\r\n\r\nfrom diffie_hellman import (\r\n    private_key,\r\n    public_key,\r\n    secret,\r\n)\r\n\r\n\r\nclass DiffieHellmanTest(unittest.TestCase):\r\n    def test_private_key_is_greater_than_1_and_less_than_p(self):\r\n        for prime in [5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47]:\r\n            with self.subTest(f\"prime={prime}\"):\r\n                key = private_key(prime)\r\n                self.assertTrue(1 < key < prime, msg=f\"{key} out of range, expected to be >1 and <{prime}\")  # fmt: skip\r\n\r\n    def test_private_key_is_random(self):\r\n        \"\"\"\r\n        Can fail due to randomness, but most likely will not,\r\n        due to pseudo-randomness and the large number chosen\r\n        \"\"\"\r\n        private_keys = [private_key(2147483647) for _ in range(5)]\r\n        self.assertEqual(len(set(private_keys)), len(private_keys))\r\n\r\n    def test_can_calculate_public_key_using_private_key(self):\r\n        p = 23\r\n        g = 5\r\n        private_key = 6\r\n        self.assertEqual(8, public_key(p, g, private_key, ))  # fmt: skip\r\n\r\n    def test_can_calculate_public_key_when_given_a_different_private_key(self):\r\n        p = 23\r\n        g = 5\r\n        private_key = 15\r\n        self.assertEqual(19, public_key(p, g, private_key, ))  # fmt: skip\r\n\r\n    def test_can_calculate_secret_using_other_party_s_public_key(self):\r\n        p = 23\r\n        their_public_key = 19\r\n        my_private_key = 6\r\n        self.assertEqual(2, secret(p, their_public_key, my_private_key, ))  # fmt: skip\r\n\r\n    def test_key_exchange(self):\r\n        p = 23\r\n        g = 5\r\n        alice_private_key = private_key(p)\r\n        bob_private_key = private_key(p)\r\n        alice_public_key = public_key(p, g, alice_private_key)\r\n        bob_public_key = public_key(p, g, bob_private_key)\r\n        secret_a = secret(p, bob_public_key, alice_private_key)\r\n        secret_b = secret(p, alice_public_key, bob_private_key)\r\n        self.assertTrue(secret_a == secret_b)\r\n"
}