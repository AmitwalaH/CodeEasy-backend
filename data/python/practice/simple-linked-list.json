{
  "language": "python",
  "type": "practice",
  "slug": "simple-linked-list",
  "title": "Simple Linked List",
  "docs": {
    "instructions": "# Instructions\r\n\r\nWrite a prototype of the music player application.\r\n\r\nFor the prototype, each song will simply be represented by a number.\r\nGiven a range of numbers (the song IDs), create a singly linked list.\r\n\r\nGiven a singly linked list, you should be able to reverse the list to play the songs in the opposite order.\r\n\r\n~~~~exercism/note\r\nThe linked list is a fundamental data structure in computer science, often used in the implementation of other data structures.\r\n\r\nThe simplest kind of linked list is a **singly** linked list.\r\nThat means that each element (or \"node\") contains data, along with something that points to the next node in the list.\r\n\r\nIf you want to dig deeper into linked lists, check out [this article][intro-linked-list] that explains it using nice drawings.\r\n\r\n[intro-linked-list]: https://medium.com/basecs/whats-a-linked-list-anyway-part-1-d8b7e6508b9d\r\n~~~~\r\n",
    "hints": "# Hints\r\n\r\n## General\r\n\r\n- This challenge is about creating a [_stack_][Baeldung: The Stack Data Structure] using a [singly linked list][singly linked list].\r\n- Unlike stacks underpinned with `lists`, `collections.deque`, or `queue.LifoQueue`, we ask you create custom `Node` and `LinkedList` [`classes`][classes tutorial] to store and link elements.\r\n\r\n![Diagram representing a stack implemented with a linked list. A circle with a dashed border named New_Node is to the far left-hand side, with two dotted arrow lines pointing right-ward.  New_Node reads \"(becomes head) - New_Node - next = node_6\". The top dotted arrow line is labeled \"push\" and points to Node_6, above and to the right.  Node_6 reads \"(current) head - Node_6 - next = node_5\". The bottom dotted arrow line is labeled \"pop\" and points to a box that reads \"gets removed on pop()\". Node_6 has a solid arrow that points rightward to Node_5, which reads \"Node_5 - next = node_4\". Node_5 has a solid arrow pointing rightward to Node_4, which reads \"Node_4 - next = node_3\". This pattern continues until Node_1, which reads \"(current) tail - Node_1 - next = None\". Node_1 has a dotted arrow pointing rightward to a node that says \"None\".](https://assets.exercism.org/images/tracks/python/simple-linked-list/linked-list.svg)\r\n\r\n- [Real Python: Linked Lists][Real Python Linked Lists], [Towards Data Science: Demystifying the Linked List][towards data science demystifying the linked list], and [ADS Stack in Python][Koder Dojo Coding an ADS Stack in Python] can be helpful to review for details on implementation.\r\n- Your `LinkedList` should accept a `list` argument to its _constructor_, but should not use a `list` to store nodes or elements.\r\n- `len()` is a built-in function for most Python objects.\r\nIn order for _custom objects_ to support `len()`, the special method [`__len__`][__len__] needs to be defined.\r\n- Iteration in Python is supported for most sequence, container, or collection type objects.\r\nIn order for a _custom_ object to support looping or re-ordering, the special method `__iter__` needs to be defined.\r\n[Implementing an iterator for a class][implementing iterators] can help show you how.\r\n\r\n[Baeldung: The Stack Data Structure]: https://www.baeldung.com/cs/stack-data-structure\r\n[Koder Dojo Coding an ADS Stack in Python]: https://www.koderdojo.com/blog/coding-a-stack-abstract-data-structure-using-linked-list-in-python\r\n[Real Python Linked Lists]: https://realpython.com/linked-lists-python/\r\n[__len__]: https://docs.python.org/3/reference/datamodel.html#object.__len__]\r\n[classes tutorial]: https://docs.python.org/3/tutorial/classes.html#tut-classes\r\n[implementing iterators]: https://docs.python.org/3/tutorial/classes.html#iterators\r\n[singly linked list]: https://towardsdatascience.com/python-linked-lists-c3622205da81\r\n[towards data science demystifying the linked list]: https://towardsdatascience.com/demystifying-linked-list-258dfb9f2176\r\n"
  },
  "starter_code": "class EmptyListException(Exception):\r\n    pass\r\n\r\n\r\nclass Node:\r\n    def __init__(self, value):\r\n        pass\r\n\r\n    def value(self):\r\n        pass\r\n\r\n    def next(self):\r\n        pass\r\n\r\n\r\nclass LinkedList:\r\n    def __init__(self, values=None):\r\n        pass\r\n\r\n    def __iter__(self):\r\n        pass\r\n\r\n    def __len__(self):\r\n        pass\r\n\r\n    def head(self):\r\n        pass\r\n\r\n    def push(self, value):\r\n        pass\r\n\r\n    def pop(self):\r\n        pass\r\n\r\n    def reversed(self):\r\n        pass\r\n",
  "tests": "import unittest\r\n\r\nfrom simple_linked_list import LinkedList, EmptyListException\r\n\r\n\r\n# No canonical data available for this exercise\r\n\r\nclass SimpleLinkedListTest(unittest.TestCase):\r\n    def test_empty_list_has_len_zero(self):\r\n        sut = LinkedList()\r\n        self.assertEqual(len(sut), 0)\r\n\r\n    def test_singleton_list_has_len_one(self):\r\n        sut = LinkedList([1])\r\n        self.assertEqual(len(sut), 1)\r\n\r\n    def test_non_empty_list_has_correct_len(self):\r\n        sut = LinkedList([1, 2, 3])\r\n        self.assertEqual(len(sut), 3)\r\n\r\n    def test_error_on_empty_list_head(self):\r\n        sut = LinkedList()\r\n        with self.assertRaises(EmptyListException) as err:\r\n            sut.head()\r\n        self.assertEqual(type(err.exception), EmptyListException)\r\n        self.assertEqual(err.exception.args[0], \"The list is empty.\")\r\n\r\n    def test_singleton_list_has_head(self):\r\n        sut = LinkedList([1])\r\n        self.assertEqual(sut.head().value(), 1)\r\n\r\n    def test_non_empty_list_has_correct_head(self):\r\n        sut = LinkedList([1, 2])\r\n        self.assertEqual(sut.head().value(), 2)\r\n\r\n    def test_can_push_to_non_empty_list(self):\r\n        sut = LinkedList([1, 2, 3])\r\n        sut.push(4)\r\n        self.assertEqual(len(sut), 4)\r\n\r\n    def test_pushing_to_empty_list_changes_head(self):\r\n        sut = LinkedList()\r\n        sut.push(5)\r\n        self.assertEqual(len(sut), 1)\r\n        self.assertEqual(sut.head().value(), 5)\r\n\r\n    def test_can_pop_from_non_empty_list(self):\r\n        sut = LinkedList([3, 4, 5])\r\n        self.assertEqual(sut.pop(), 5)\r\n        self.assertEqual(len(sut), 2)\r\n        self.assertEqual(sut.head().value(), 4)\r\n\r\n    def test_pop_from_singleton_list_removes_head(self):\r\n        sut = LinkedList([1])\r\n        self.assertEqual(sut.pop(), 1)\r\n        with self.assertRaises(EmptyListException) as err:\r\n            sut.head()\r\n        self.assertEqual(type(err.exception), EmptyListException)\r\n        self.assertEqual(err.exception.args[0], \"The list is empty.\")\r\n\r\n    def test_error_on_empty_list_pop(self):\r\n        sut = LinkedList()\r\n        with self.assertRaises(EmptyListException) as err:\r\n            sut.pop()\r\n        self.assertEqual(type(err.exception), EmptyListException)\r\n        self.assertEqual(err.exception.args[0], \"The list is empty.\")\r\n\r\n    def test_push_and_pop(self):\r\n        sut = LinkedList([1, 2])\r\n        sut.push(3)\r\n        self.assertEqual(len(sut), 3)\r\n        self.assertEqual(sut.pop(), 3)\r\n        self.assertEqual(sut.pop(), 2)\r\n        self.assertEqual(sut.pop(), 1)\r\n        self.assertEqual(len(sut), 0)\r\n        sut.push(4)\r\n        self.assertEqual(len(sut), 1)\r\n        self.assertEqual(sut.head().value(), 4)\r\n\r\n    def test_singleton_list_head_has_no_next(self):\r\n        sut = LinkedList([1])\r\n        self.assertIsNone(sut.head().next())\r\n\r\n    def test_non_empty_list_traverse(self):\r\n        sut = LinkedList(range(10))\r\n        current = sut.head()\r\n        for i in range(10):\r\n            self.assertEqual(current.value(), 9 - i)\r\n            current = current.next()\r\n        self.assertIsNone(current)\r\n\r\n    def test_empty_linked_list_to_list_is_empty(self):\r\n        sut = LinkedList()\r\n        self.assertEqual(list(sut), [])\r\n\r\n    def test_singleton_linked_list_to_list_list_with_singular_element(self):\r\n        sut = LinkedList([1])\r\n        self.assertEqual(list(sut), [1])\r\n\r\n    def test_non_empty_linked_list_to_list_is_list_with_all_elements(self):\r\n        sut = LinkedList([1, 2, 3])\r\n        self.assertEqual(list(sut), [3, 2, 1])\r\n\r\n    def test_reversed_empty_list_is_empty_list(self):\r\n        sut = LinkedList([])\r\n        self.assertEqual(list(sut.reversed()), [])\r\n\r\n    def test_reversed_singleton_list_is_same_list(self):\r\n        sut = LinkedList([1])\r\n        self.assertEqual(list(sut.reversed()), [1])\r\n\r\n    def test_reverse_non_empty_list(self):\r\n        sut = LinkedList([1, 2, 3])\r\n        self.assertEqual(list(sut.reversed()), [1, 2, 3])\r\n"
}