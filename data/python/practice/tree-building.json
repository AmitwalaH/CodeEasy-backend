{
  "language": "python",
  "type": "practice",
  "slug": "tree-building",
  "title": "Tree Building",
  "docs": {
    "instructions": "# Instructions\r\n\r\nRefactor a tree building algorithm.\r\n\r\nSome web-forums have a tree layout, so posts are presented as a tree.\r\nHowever the posts are typically stored in a database as an unsorted set of records.\r\nThus when presenting the posts to the user the tree structure has to be reconstructed.\r\n\r\nYour job will be to refactor a working but slow and ugly piece of code that implements the tree building logic for highly abstracted records.\r\nThe records only contain an ID number and a parent ID number.\r\nThe ID number is always between 0 (inclusive) and the length of the record list (exclusive).\r\nAll records have a parent ID lower than their own ID, except for the root record, which has a parent ID that's equal to its own ID.\r\n\r\nAn example tree:\r\n\r\n```text\r\nroot (ID: 0, parent ID: 0)\r\n|-- child1 (ID: 1, parent ID: 0)\r\n|    |-- grandchild1 (ID: 2, parent ID: 1)\r\n|    +-- grandchild2 (ID: 4, parent ID: 1)\r\n+-- child2 (ID: 3, parent ID: 0)\r\n|    +-- grandchild3 (ID: 6, parent ID: 3)\r\n+-- child3 (ID: 5, parent ID: 0)\r\n```\r\n",
    "hints": ""
  },
  "starter_code": "class Record:\r\n    def __init__(self, record_id, parent_id):\r\n        self.record_id = record_id\r\n        self.parent_id = parent_id\r\n\r\n\r\nclass Node:\r\n    def __init__(self, node_id):\r\n        self.node_id = node_id\r\n        self.children = []\r\n\r\n\r\ndef BuildTree(records):\r\n    root = None\r\n    records.sort(key=lambda x: x.record_id)\r\n    ordered_id = [i.record_id for i in records]\r\n    if records:\r\n        if ordered_id[-1] != len(ordered_id) - 1:\r\n            raise ValueError('broken tree')\r\n        if ordered_id[0] != 0:\r\n            raise ValueError('invalid')\r\n    trees = []\r\n    parent = {}\r\n    for i in range(len(ordered_id)):\r\n        for j in records:\r\n            if ordered_id[i] == j.record_id:\r\n                if j.record_id == 0:\r\n                    if j.parent_id != 0:\r\n                        raise ValueError('error!')\r\n                if j.record_id < j.parent_id:\r\n                    raise ValueError('something went wrong!')\r\n                if j.record_id == j.parent_id:\r\n                    if j.record_id != 0:\r\n                        raise ValueError('error!')\r\n                trees.append(Node(ordered_id[i]))\r\n    for i in range(len(ordered_id)):\r\n        for j in trees:\r\n            if i == j.node_id:\r\n                parent = j\r\n        for j in records:\r\n            if j.parent_id == i:\r\n                for k in trees:\r\n                    if k.node_id == 0:\r\n                        continue\r\n                    if j.record_id == k.node_id:\r\n                        child = k\r\n                        parent.children.append(child)\r\n    if len(trees) > 0:\r\n        root = trees[0]\r\n    return root\r\n",
  "tests": "import unittest\r\n\r\nfrom tree_building import Record, BuildTree\r\n\r\n\r\nclass TreeBuildingTest(unittest.TestCase):\r\n    \"\"\"\r\n        Record(record_id, parent_id): records given to be processed\r\n        Node(node_id): Node in tree\r\n        BuildTree(records): records as argument and returns tree\r\n        BuildTree should raise ValueError if given records are invalid\r\n    \"\"\"\r\n\r\n    def test_empty_list_input(self):\r\n        records = []\r\n        root = BuildTree(records)\r\n        self.assertIsNone(root)\r\n\r\n    def test_one_node(self):\r\n        records = [\r\n            Record(0, 0)\r\n        ]\r\n        root = BuildTree(records)\r\n\r\n        self.assert_node_is_leaf(root, node_id=0)\r\n\r\n    def test_three_nodes_in_order(self):\r\n        records = [\r\n            Record(0, 0),\r\n            Record(1, 0),\r\n            Record(2, 0)\r\n        ]\r\n        root = BuildTree(records)\r\n\r\n        self.assert_node_is_branch(root, node_id=0, children_count=2)\r\n        self.assert_node_is_leaf(root.children[0], node_id=1)\r\n        self.assert_node_is_leaf(root.children[1], node_id=2)\r\n\r\n    def test_three_nodes_in_reverse_order(self):\r\n        records = [\r\n            Record(2, 0),\r\n            Record(1, 0),\r\n            Record(0, 0)\r\n        ]\r\n        root = BuildTree(records)\r\n\r\n        self.assert_node_is_branch(root, node_id=0, children_count=2)\r\n        self.assert_node_is_leaf(root.children[0], node_id=1)\r\n        self.assert_node_is_leaf(root.children[1], node_id=2)\r\n\r\n    def test_more_than_two_children(self):\r\n        records = [\r\n            Record(0, 0),\r\n            Record(1, 0),\r\n            Record(2, 0),\r\n            Record(3, 0)\r\n        ]\r\n        root = BuildTree(records)\r\n\r\n        self.assert_node_is_branch(root, node_id=0, children_count=3)\r\n        self.assert_node_is_leaf(root.children[0], node_id=1)\r\n        self.assert_node_is_leaf(root.children[1], node_id=2)\r\n        self.assert_node_is_leaf(root.children[2], node_id=3)\r\n\r\n    def test_binary_tree(self):\r\n        records = [\r\n            Record(6, 2),\r\n            Record(0, 0),\r\n            Record(3, 1),\r\n            Record(2, 0),\r\n            Record(4, 1),\r\n            Record(5, 2),\r\n            Record(1, 0)\r\n        ]\r\n        root = BuildTree(records)\r\n\r\n        self.assert_node_is_branch(root, 0, 2)\r\n        self.assert_node_is_branch(root.children[0], 1, 2)\r\n        self.assert_node_is_branch(root.children[1], 2, 2)\r\n        self.assert_node_is_leaf(root.children[0].children[0], 3)\r\n        self.assert_node_is_leaf(root.children[0].children[1], 4)\r\n        self.assert_node_is_leaf(root.children[1].children[0], 5)\r\n        self.assert_node_is_leaf(root.children[1].children[1], 6)\r\n\r\n    def test_unbalanced_tree(self):\r\n        records = [\r\n            Record(0, 0),\r\n            Record(1, 0),\r\n            Record(2, 0),\r\n            Record(3, 1),\r\n            Record(4, 1),\r\n            Record(5, 1),\r\n            Record(6, 2),\r\n        ]\r\n        root = BuildTree(records)\r\n\r\n        self.assert_node_is_branch(root, 0, 2)\r\n        self.assert_node_is_branch(root.children[0], 1, 3)\r\n        self.assert_node_is_branch(root.children[1], 2, 1)\r\n        self.assert_node_is_leaf(root.children[0].children[0], 3)\r\n        self.assert_node_is_leaf(root.children[0].children[1], 4)\r\n        self.assert_node_is_leaf(root.children[0].children[2], 5)\r\n        self.assert_node_is_leaf(root.children[1].children[0], 6)\r\n\r\n    def test_root_node_has_parent(self):\r\n        records = [\r\n            Record(0, 1),\r\n            Record(1, 0)\r\n        ]\r\n        # Root parent_id should be equal to record_id(0)\r\n        with self.assertRaises(ValueError) as err:\r\n            BuildTree(records)\r\n        self.assertEqual(type(err.exception), ValueError)\r\n        self.assertEqual(err.exception.args[0], \"Node parent_id should be smaller than its record_id.\")\r\n\r\n    def test_no_root_node(self):\r\n        records = [\r\n            Record(1, 0),\r\n            Record(2, 0)\r\n        ]\r\n        # Record with record_id 0 (root) is missing\r\n        with self.assertRaises(ValueError) as err:\r\n            BuildTree(records)\r\n        self.assertEqual(type(err.exception), ValueError)\r\n        self.assertEqual(err.exception.args[0], \"Record id is invalid or out of order.\")\r\n\r\n    def test_non_continuous(self):\r\n        records = [\r\n            Record(2, 0),\r\n            Record(4, 2),\r\n            Record(1, 0),\r\n            Record(0, 0)\r\n        ]\r\n        # Record with record_id 3 is missing\r\n        with self.assertRaises(ValueError) as err:\r\n            BuildTree(records)\r\n        self.assertEqual(type(err.exception), ValueError)\r\n        self.assertEqual(err.exception.args[0], \"Record id is invalid or out of order.\")\r\n\r\n    def test_cycle_directly(self):\r\n        records = [\r\n            Record(5, 2),\r\n            Record(3, 2),\r\n            Record(2, 2),\r\n            Record(4, 1),\r\n            Record(1, 0),\r\n            Record(0, 0),\r\n            Record(6, 3)\r\n        ]\r\n        # Cycle caused by Record 2 with parent_id pointing to itself\r\n        with self.assertRaises(ValueError) as err:\r\n            BuildTree(records)\r\n        self.assertEqual(type(err.exception), ValueError)\r\n        self.assertEqual(err.exception.args[0], \"Only root should have equal record and parent id.\")\r\n\r\n    def test_cycle_indirectly(self):\r\n        records = [\r\n            Record(5, 2),\r\n            Record(3, 2),\r\n            Record(2, 6),\r\n            Record(4, 1),\r\n            Record(1, 0),\r\n            Record(0, 0),\r\n            Record(6, 3)\r\n        ]\r\n        # Cycle caused by Record 2 with parent_id(6) greater than record_id(2)\r\n        with self.assertRaises(ValueError) as err:\r\n            BuildTree(records)\r\n        self.assertEqual(type(err.exception), ValueError)\r\n        self.assertEqual(err.exception.args[0], \"Node parent_id should be smaller than its record_id.\")\r\n\r\n    def test_higher_id_parent_of_lower_id(self):\r\n        records = [\r\n            Record(0, 0),\r\n            Record(2, 0),\r\n            Record(1, 2)\r\n        ]\r\n        # Record 1 have parent_id(2) greater than record_id(1)\r\n        with self.assertRaises(ValueError) as err:\r\n            BuildTree(records)\r\n        self.assertEqual(type(err.exception), ValueError)\r\n        self.assertEqual(err.exception.args[0], \"Node parent_id should be smaller than its record_id.\")\r\n\r\n    def assert_node_is_branch(self, node, node_id, children_count):\r\n        self.assertEqual(node.node_id, node_id)\r\n        self.assertNotEqual(len(node.children), 0)\r\n        self.assertEqual(len(node.children), children_count)\r\n\r\n    def assert_node_is_leaf(self, node, node_id):\r\n        self.assertEqual(node.node_id, node_id)\r\n        self.assertEqual(len(node.children), 0)\r\n"
}