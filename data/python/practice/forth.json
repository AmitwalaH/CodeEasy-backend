{
  "language": "python",
  "type": "practice",
  "slug": "forth",
  "title": "Forth",
  "docs": {
    "instructions": "# Instructions\r\n\r\nImplement an evaluator for a very simple subset of Forth.\r\n\r\n[Forth][forth]\r\nis a stack-based programming language.\r\nImplement a very basic evaluator for a small subset of Forth.\r\n\r\nYour evaluator has to support the following words:\r\n\r\n- `+`, `-`, `*`, `/` (integer arithmetic)\r\n- `DUP`, `DROP`, `SWAP`, `OVER` (stack manipulation)\r\n\r\nYour evaluator also has to support defining new words using the customary syntax: `: word-name definition ;`.\r\n\r\nTo keep things simple the only data type you need to support is signed integers of at least 16 bits size.\r\n\r\nYou should use the following rules for the syntax: a number is a sequence of one or more (ASCII) digits, a word is a sequence of one or more letters, digits, symbols or punctuation that is not a number.\r\n(Forth probably uses slightly different rules, but this is close enough.)\r\n\r\nWords are case-insensitive.\r\n\r\n[forth]: https://en.wikipedia.org/wiki/Forth_%28programming_language%29\r\n",
    "hints": ""
  },
  "starter_code": "class StackUnderflowError(Exception):\r\n    pass\r\n\r\n\r\ndef evaluate(input_data):\r\n    pass\r\n",
  "tests": "# These tests are auto-generated with test data from:\r\n# https://github.com/exercism/problem-specifications/tree/main/exercises/forth/canonical-data.json\r\n# File last updated on 2024-11-04\r\n\r\nimport unittest\r\n\r\nfrom forth import (\r\n    evaluate,\r\n    StackUnderflowError,\r\n)\r\n\r\n\r\nclass ForthTest(unittest.TestCase):\r\n    def test_parsing_and_numbers_numbers_just_get_pushed_onto_the_stack(self):\r\n        self.assertEqual(evaluate([\"1 2 3 4 5\"]), [1, 2, 3, 4, 5])\r\n\r\n    def test_parsing_and_numbers_pushes_negative_numbers_onto_the_stack(self):\r\n        self.assertEqual(evaluate([\"-1 -2 -3 -4 -5\"]), [-1, -2, -3, -4, -5])\r\n\r\n    def test_addition_can_add_two_numbers(self):\r\n        self.assertEqual(evaluate([\"1 2 +\"]), [3])\r\n\r\n    def test_addition_errors_if_there_is_nothing_on_the_stack(self):\r\n        with self.assertRaises(StackUnderflowError) as err:\r\n            evaluate([\"+\"])\r\n        self.assertEqual(type(err.exception), StackUnderflowError)\r\n        self.assertEqual(\r\n            str(err.exception.args[0]), \"Insufficient number of items in stack\"\r\n        )\r\n\r\n    def test_addition_errors_if_there_is_only_one_value_on_the_stack(self):\r\n        with self.assertRaises(StackUnderflowError) as err:\r\n            evaluate([\"1 +\"])\r\n        self.assertEqual(type(err.exception), StackUnderflowError)\r\n        self.assertEqual(\r\n            str(err.exception.args[0]), \"Insufficient number of items in stack\"\r\n        )\r\n\r\n    def test_addition_more_than_two_values_on_the_stack(self):\r\n        self.assertEqual(evaluate([\"1 2 3 +\"]), [1, 5])\r\n\r\n    def test_subtraction_can_subtract_two_numbers(self):\r\n        self.assertEqual(evaluate([\"3 4 -\"]), [-1])\r\n\r\n    def test_subtraction_errors_if_there_is_nothing_on_the_stack(self):\r\n        with self.assertRaises(StackUnderflowError) as err:\r\n            evaluate([\"-\"])\r\n        self.assertEqual(type(err.exception), StackUnderflowError)\r\n        self.assertEqual(\r\n            str(err.exception.args[0]), \"Insufficient number of items in stack\"\r\n        )\r\n\r\n    def test_subtraction_errors_if_there_is_only_one_value_on_the_stack(self):\r\n        with self.assertRaises(StackUnderflowError) as err:\r\n            evaluate([\"1 -\"])\r\n        self.assertEqual(type(err.exception), StackUnderflowError)\r\n        self.assertEqual(\r\n            str(err.exception.args[0]), \"Insufficient number of items in stack\"\r\n        )\r\n\r\n    def test_subtraction_more_than_two_values_on_the_stack(self):\r\n        self.assertEqual(evaluate([\"1 12 3 -\"]), [1, 9])\r\n\r\n    def test_multiplication_can_multiply_two_numbers(self):\r\n        self.assertEqual(evaluate([\"2 4 *\"]), [8])\r\n\r\n    def test_multiplication_errors_if_there_is_nothing_on_the_stack(self):\r\n        with self.assertRaises(StackUnderflowError) as err:\r\n            evaluate([\"*\"])\r\n        self.assertEqual(type(err.exception), StackUnderflowError)\r\n        self.assertEqual(\r\n            str(err.exception.args[0]), \"Insufficient number of items in stack\"\r\n        )\r\n\r\n    def test_multiplication_errors_if_there_is_only_one_value_on_the_stack(self):\r\n        with self.assertRaises(StackUnderflowError) as err:\r\n            evaluate([\"1 *\"])\r\n        self.assertEqual(type(err.exception), StackUnderflowError)\r\n        self.assertEqual(\r\n            str(err.exception.args[0]), \"Insufficient number of items in stack\"\r\n        )\r\n\r\n    def test_multiplication_more_than_two_values_on_the_stack(self):\r\n        self.assertEqual(evaluate([\"1 2 3 *\"]), [1, 6])\r\n\r\n    def test_division_can_divide_two_numbers(self):\r\n        self.assertEqual(evaluate([\"12 3 /\"]), [4])\r\n\r\n    def test_division_performs_integer_division(self):\r\n        self.assertEqual(evaluate([\"8 3 /\"]), [2])\r\n\r\n    def test_division_errors_if_dividing_by_zero(self):\r\n        # divide by zero\r\n        with self.assertRaises(ZeroDivisionError) as err:\r\n            evaluate([\"4 0 /\"])\r\n        self.assertEqual(type(err.exception), ZeroDivisionError)\r\n        self.assertEqual(str(err.exception.args[0]), \"divide by zero\")\r\n\r\n    def test_division_errors_if_there_is_nothing_on_the_stack(self):\r\n        with self.assertRaises(StackUnderflowError) as err:\r\n            evaluate([\"/\"])\r\n        self.assertEqual(type(err.exception), StackUnderflowError)\r\n        self.assertEqual(\r\n            str(err.exception.args[0]), \"Insufficient number of items in stack\"\r\n        )\r\n\r\n    def test_division_errors_if_there_is_only_one_value_on_the_stack(self):\r\n        with self.assertRaises(StackUnderflowError) as err:\r\n            evaluate([\"1 /\"])\r\n        self.assertEqual(type(err.exception), StackUnderflowError)\r\n        self.assertEqual(\r\n            str(err.exception.args[0]), \"Insufficient number of items in stack\"\r\n        )\r\n\r\n    def test_division_more_than_two_values_on_the_stack(self):\r\n        self.assertEqual(evaluate([\"1 12 3 /\"]), [1, 4])\r\n\r\n    def test_combined_arithmetic_addition_and_subtraction(self):\r\n        self.assertEqual(evaluate([\"1 2 + 4 -\"]), [-1])\r\n\r\n    def test_combined_arithmetic_multiplication_and_division(self):\r\n        self.assertEqual(evaluate([\"2 4 * 3 /\"]), [2])\r\n\r\n    def test_combined_arithmetic_multiplication_and_addition(self):\r\n        self.assertEqual(evaluate([\"1 3 4 * +\"]), [13])\r\n\r\n    def test_combined_arithmetic_addition_and_multiplication(self):\r\n        self.assertEqual(evaluate([\"1 3 4 + *\"]), [7])\r\n\r\n    def test_dup_copies_a_value_on_the_stack(self):\r\n        self.assertEqual(evaluate([\"1 dup\"]), [1, 1])\r\n\r\n    def test_dup_copies_the_top_value_on_the_stack(self):\r\n        self.assertEqual(evaluate([\"1 2 dup\"]), [1, 2, 2])\r\n\r\n    def test_dup_errors_if_there_is_nothing_on_the_stack(self):\r\n        with self.assertRaises(StackUnderflowError) as err:\r\n            evaluate([\"dup\"])\r\n        self.assertEqual(type(err.exception), StackUnderflowError)\r\n        self.assertEqual(\r\n            str(err.exception.args[0]), \"Insufficient number of items in stack\"\r\n        )\r\n\r\n    def test_drop_removes_the_top_value_on_the_stack_if_it_is_the_only_one(self):\r\n        self.assertEqual(evaluate([\"1 drop\"]), [])\r\n\r\n    def test_drop_removes_the_top_value_on_the_stack_if_it_is_not_the_only_one(self):\r\n        self.assertEqual(evaluate([\"1 2 drop\"]), [1])\r\n\r\n    def test_drop_errors_if_there_is_nothing_on_the_stack(self):\r\n        with self.assertRaises(StackUnderflowError) as err:\r\n            evaluate([\"drop\"])\r\n        self.assertEqual(type(err.exception), StackUnderflowError)\r\n        self.assertEqual(\r\n            str(err.exception.args[0]), \"Insufficient number of items in stack\"\r\n        )\r\n\r\n    def test_swap_swaps_the_top_two_values_on_the_stack_if_they_are_the_only_ones(self):\r\n        self.assertEqual(evaluate([\"1 2 swap\"]), [2, 1])\r\n\r\n    def test_swap_swaps_the_top_two_values_on_the_stack_if_they_are_not_the_only_ones(\r\n        self,\r\n    ):\r\n        self.assertEqual(evaluate([\"1 2 3 swap\"]), [1, 3, 2])\r\n\r\n    def test_swap_errors_if_there_is_nothing_on_the_stack(self):\r\n        with self.assertRaises(StackUnderflowError) as err:\r\n            evaluate([\"swap\"])\r\n        self.assertEqual(type(err.exception), StackUnderflowError)\r\n        self.assertEqual(\r\n            str(err.exception.args[0]), \"Insufficient number of items in stack\"\r\n        )\r\n\r\n    def test_swap_errors_if_there_is_only_one_value_on_the_stack(self):\r\n        with self.assertRaises(StackUnderflowError) as err:\r\n            evaluate([\"1 swap\"])\r\n        self.assertEqual(type(err.exception), StackUnderflowError)\r\n        self.assertEqual(\r\n            str(err.exception.args[0]), \"Insufficient number of items in stack\"\r\n        )\r\n\r\n    def test_over_copies_the_second_element_if_there_are_only_two(self):\r\n        self.assertEqual(evaluate([\"1 2 over\"]), [1, 2, 1])\r\n\r\n    def test_over_copies_the_second_element_if_there_are_more_than_two(self):\r\n        self.assertEqual(evaluate([\"1 2 3 over\"]), [1, 2, 3, 2])\r\n\r\n    def test_over_errors_if_there_is_nothing_on_the_stack(self):\r\n        with self.assertRaises(StackUnderflowError) as err:\r\n            evaluate([\"over\"])\r\n        self.assertEqual(type(err.exception), StackUnderflowError)\r\n        self.assertEqual(\r\n            str(err.exception.args[0]), \"Insufficient number of items in stack\"\r\n        )\r\n\r\n    def test_over_errors_if_there_is_only_one_value_on_the_stack(self):\r\n        with self.assertRaises(StackUnderflowError) as err:\r\n            evaluate([\"1 over\"])\r\n        self.assertEqual(type(err.exception), StackUnderflowError)\r\n        self.assertEqual(\r\n            str(err.exception.args[0]), \"Insufficient number of items in stack\"\r\n        )\r\n\r\n    def test_user_defined_words_can_consist_of_built_in_words(self):\r\n        self.assertEqual(evaluate([\": dup-twice dup dup ;\", \"1 dup-twice\"]), [1, 1, 1])\r\n\r\n    def test_user_defined_words_execute_in_the_right_order(self):\r\n        self.assertEqual(evaluate([\": countup 1 2 3 ;\", \"countup\"]), [1, 2, 3])\r\n\r\n    def test_user_defined_words_can_override_other_user_defined_words(self):\r\n        self.assertEqual(\r\n            evaluate([\": foo dup ;\", \": foo dup dup ;\", \"1 foo\"]), [1, 1, 1]\r\n        )\r\n\r\n    def test_user_defined_words_can_override_built_in_words(self):\r\n        self.assertEqual(evaluate([\": swap dup ;\", \"1 swap\"]), [1, 1])\r\n\r\n    def test_user_defined_words_can_override_built_in_operators(self):\r\n        self.assertEqual(evaluate([\": + * ;\", \"3 4 +\"]), [12])\r\n\r\n    def test_user_defined_words_can_use_different_words_with_the_same_name(self):\r\n        self.assertEqual(\r\n            evaluate([\": foo 5 ;\", \": bar foo ;\", \": foo 6 ;\", \"bar foo\"]), [5, 6]\r\n        )\r\n\r\n    def test_user_defined_words_can_define_word_that_uses_word_with_the_same_name(self):\r\n        self.assertEqual(evaluate([\": foo 10 ;\", \": foo foo 1 + ;\", \"foo\"]), [11])\r\n\r\n    def test_user_defined_words_cannot_redefine_non_negative_numbers(self):\r\n        with self.assertRaises(ValueError) as err:\r\n            evaluate([\": 1 2 ;\"])\r\n        self.assertEqual(type(err.exception), ValueError)\r\n        self.assertEqual(str(err.exception.args[0]), \"illegal operation\")\r\n\r\n    def test_user_defined_words_cannot_redefine_negative_numbers(self):\r\n        with self.assertRaises(ValueError) as err:\r\n            evaluate([\": -1 2 ;\"])\r\n        self.assertEqual(type(err.exception), ValueError)\r\n        self.assertEqual(str(err.exception.args[0]), \"illegal operation\")\r\n\r\n    def test_user_defined_words_errors_if_executing_a_non_existent_word(self):\r\n        with self.assertRaises(ValueError) as err:\r\n            evaluate([\"foo\"])\r\n        self.assertEqual(type(err.exception), ValueError)\r\n        self.assertEqual(str(err.exception.args[0]), \"undefined operation\")\r\n\r\n    def test_case_insensitivity_dup_is_case_insensitive(self):\r\n        self.assertEqual(evaluate([\"1 DUP Dup dup\"]), [1, 1, 1, 1])\r\n\r\n    def test_case_insensitivity_drop_is_case_insensitive(self):\r\n        self.assertEqual(evaluate([\"1 2 3 4 DROP Drop drop\"]), [1])\r\n\r\n    def test_case_insensitivity_swap_is_case_insensitive(self):\r\n        self.assertEqual(evaluate([\"1 2 SWAP 3 Swap 4 swap\"]), [2, 3, 4, 1])\r\n\r\n    def test_case_insensitivity_over_is_case_insensitive(self):\r\n        self.assertEqual(evaluate([\"1 2 OVER Over over\"]), [1, 2, 1, 2, 1])\r\n\r\n    def test_case_insensitivity_user_defined_words_are_case_insensitive(self):\r\n        self.assertEqual(evaluate([\": foo dup ;\", \"1 FOO Foo foo\"]), [1, 1, 1, 1])\r\n\r\n    def test_case_insensitivity_definitions_are_case_insensitive(self):\r\n        self.assertEqual(evaluate([\": SWAP DUP Dup dup ;\", \"1 swap\"]), [1, 1, 1, 1])\r\n"
}