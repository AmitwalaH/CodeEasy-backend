{
  "language": "python",
  "type": "practice",
  "slug": "pascals-triangle",
  "title": "Pascals Triangle",
  "docs": {
    "instructions": "# Instructions\r\n\r\nYour task is to output the first N rows of Pascal's triangle.\r\n\r\n[Pascal's triangle][wikipedia] is a triangular array of positive integers.\r\n\r\nIn Pascal's triangle, the number of values in a row is equal to its row number (which starts at one).\r\nTherefore, the first row has one value, the second row has two values, and so on.\r\n\r\nThe first (topmost) row has a single value: `1`.\r\nSubsequent rows' values are computed by adding the numbers directly to the right and left of the current position in the previous row.\r\n\r\nIf the previous row does _not_ have a value to the left or right of the current position (which only happens for the leftmost and rightmost positions), treat that position's value as zero (effectively \"ignoring\" it in the summation).\r\n\r\n## Example\r\n\r\nLet's look at the first 5 rows of Pascal's Triangle:\r\n\r\n```text\r\n    1\r\n   1 1\r\n  1 2 1\r\n 1 3 3 1\r\n1 4 6 4 1\r\n```\r\n\r\nThe topmost row has one value, which is `1`.\r\n\r\nThe leftmost and rightmost values have only one preceding position to consider, which is the position to its right respectively to its left.\r\nWith the topmost value being `1`, it follows from this that all the leftmost and rightmost values are also `1`.\r\n\r\nThe other values all have two positions to consider.\r\nFor example, the fifth row's (`1 4 6 4 1`) middle value is `6`, as the values to its left and right in the preceding row are `3` and `3`:\r\n\r\n[wikipedia]: https://en.wikipedia.org/wiki/Pascal%27s_triangle\r\n",
    "hints": "# Hints\r\n\r\n## General\r\n\r\n- A more detailed description of recursive programming can be found [here][g4g]\r\n- This exercise involves a test to ensure that you used a recursive solution\r\n- If you are having trouble completing this exercise, try [using a loop first, and then convert it into a recursive solution][educative]\r\n\r\n[g4g]: https://www.geeksforgeeks.org/recursion/\r\n[educative]: https://www.educative.io/collection/page/6151088528949248/4547996664463360/6292303276670976\r\n"
  },
  "starter_code": "def rows(row_count):\r\n    pass\r\n",
  "tests": "# These tests are auto-generated with test data from:\r\n# https://github.com/exercism/problem-specifications/tree/main/exercises/pascals-triangle/canonical-data.json\r\n# File last updated on 2023-07-19\r\n\r\nimport sys\r\nimport unittest\r\n\r\nfrom pascals_triangle import (\r\n    rows,\r\n)\r\n\r\nTRIANGLE = [\r\n    [1],\r\n    [1, 1],\r\n    [1, 2, 1],\r\n    [1, 3, 3, 1],\r\n    [1, 4, 6, 4, 1],\r\n    [1, 5, 10, 10, 5, 1],\r\n    [1, 6, 15, 20, 15, 6, 1],\r\n    [1, 7, 21, 35, 35, 21, 7, 1],\r\n    [1, 8, 28, 56, 70, 56, 28, 8, 1],\r\n    [1, 9, 36, 84, 126, 126, 84, 36, 9, 1],\r\n]\r\n\r\n\r\nclass PascalsTriangleTest(unittest.TestCase):\r\n    def test_zero_rows(self):\r\n        self.assertEqual(rows(0), TRIANGLE[:0])\r\n\r\n    def test_single_row(self):\r\n        self.assertEqual(rows(1), TRIANGLE[:1])\r\n\r\n    def test_two_rows(self):\r\n        self.assertEqual(rows(2), TRIANGLE[:2])\r\n\r\n    def test_three_rows(self):\r\n        self.assertEqual(rows(3), TRIANGLE[:3])\r\n\r\n    def test_four_rows(self):\r\n        self.assertEqual(rows(4), TRIANGLE[:4])\r\n\r\n    def test_five_rows(self):\r\n        self.assertEqual(rows(5), TRIANGLE[:5])\r\n\r\n    def test_six_rows(self):\r\n        self.assertEqual(rows(6), TRIANGLE[:6])\r\n\r\n    def test_ten_rows(self):\r\n        self.assertEqual(rows(10), TRIANGLE[:10])\r\n\r\n    # Additional tests for this track\r\n    def test_negative_rows_are_invalid(self):\r\n        with self.assertRaises(ValueError) as err:\r\n            rows(-1)\r\n            self.assertEqual(type(err.exception), ValueError)\r\n            self.assertEqual(err.exception.args[0], \"number of rows is negative\")\r\n\r\n    def test_solution_is_recursive(self):\r\n        with self.assertRaises(RecursionError) as err:\r\n            rows(sys.getrecursionlimit() + 10)\r\n            self.assertEqual(type(err.exception), RecursionError)\r\n            self.assertEqual(\r\n                err.exception.args[0][:32], \"maximum recursion depth exceeded\"\r\n            )\r\n"
}