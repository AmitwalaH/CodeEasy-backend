{
  "language": "cpp",
  "slug": "simple-linked-list",
  "docs": {
    "introduction": "# Introduction\r\n\r\nYou work for a music streaming company.\r\n\r\nYou've been tasked with creating a playlist feature for your music player application.\r\n",
    "instructions": "# Instructions\r\n\r\nWrite a prototype of the music player application.\r\n\r\nFor the prototype, each song will simply be represented by a number.\r\nGiven a range of numbers (the song IDs), create a singly linked list.\r\n\r\nGiven a singly linked list, you should be able to reverse the list to play the songs in the opposite order.\r\n\r\n~~~~exercism/note\r\nThe linked list is a fundamental data structure in computer science, often used in the implementation of other data structures.\r\n\r\nThe simplest kind of linked list is a **singly** linked list.\r\nThat means that each element (or \"node\") contains data, along with something that points to the next node in the list.\r\n\r\nIf you want to dig deeper into linked lists, check out [this article][intro-linked-list] that explains it using nice drawings.\r\n\r\n[intro-linked-list]: https://medium.com/basecs/whats-a-linked-list-anyway-part-1-d8b7e6508b9d\r\n~~~~\r\n",
    "hints": ""
  },
  "starter_code": {
    "simple_linked_list.cpp": "#include \"simple_linked_list.h\"\r\n\r\n#include <stdexcept>\r\n\r\nnamespace simple_linked_list {\r\n\r\nstd::size_t List::size() const {\r\n    // TODO: Return the correct size of the list.\r\n    return 0;\r\n}\r\n\r\nvoid List::push(int entry) {\r\n    // TODO: Implement a function that pushes an Element with `entry` as data to\r\n    // the front of the list.\r\n}\r\n\r\nint List::pop() {\r\n    // TODO: Implement a function that returns the data value of the first\r\n    // element in the list then discard that element.\r\n    return 0;\r\n}\r\n\r\nvoid List::reverse() {\r\n    // TODO: Implement a function to reverse the order of the elements in the\r\n    // list.\r\n}\r\n\r\nList::~List() {\r\n    // TODO: Ensure that all resources are freed on destruction\r\n}\r\n\r\n}  // namespace simple_linked_list\r\n",
    "simple_linked_list.h": "#pragma once\r\n\r\n#include <cstddef>\r\n\r\nnamespace simple_linked_list {\r\n\r\nclass List {\r\n   public:\r\n    List() = default;\r\n    ~List();\r\n\r\n    // Moving and copying is not needed to solve the exercise.\r\n    // If you want to change these, make sure to correctly\r\n    // free / move / copy the allocated resources.\r\n    List(const List&) = delete;\r\n    List& operator=(const List&) = delete;\r\n    List(List&&) = delete;\r\n    List& operator=(List&&) = delete;\r\n\r\n    std::size_t size() const;\r\n    void push(int entry);\r\n    int pop();\r\n    void reverse();\r\n\r\n   private:\r\n    struct Element {\r\n        Element(int data) : data{data} {};\r\n        int data{};\r\n        Element* next{nullptr};\r\n    };\r\n\r\n    Element* head{nullptr};\r\n    std::size_t current_size{0};\r\n};\r\n\r\n}  // namespace simple_linked_list\r\n"
  },
  "tests": {
    "simple_linked_list_test.cpp": "// Include the header file with the definitions of the functions you create.\r\n#include \"simple_linked_list.h\"\r\n\r\n// Include the test framework.\r\n#ifdef EXERCISM_TEST_SUITE\r\n#include <catch2/catch.hpp>\r\n#else\r\n#include \"test/catch.hpp\"\r\n#endif\r\n\r\n// Declares a single test.\r\nTEST_CASE(\"EmptyListHasSizeZero\") {\r\n    simple_linked_list::List empty{};\r\n    REQUIRE(empty.size() == 0);\r\n}\r\n\r\n#ifdef EXERCISM_RUN_ALL_TESTS\r\n\r\nTEST_CASE(\"SingletonListHasSizeOne\") {\r\n    simple_linked_list::List list{};\r\n    list.push(44);\r\n    REQUIRE(list.size() == 1);\r\n}\r\n\r\nTEST_CASE(\"NonEmptyListHasCorrectSize\") {\r\n    simple_linked_list::List list{};\r\n    list.push(44);\r\n    list.push(42);\r\n    list.push(47);\r\n    list.push(-11);\r\n    REQUIRE(list.size() == 4);\r\n}\r\n\r\nTEST_CASE(\"ListHasCorrectSizeAfterPop\") {\r\n    simple_linked_list::List list{};\r\n    list.push(24);\r\n    list.push(2);\r\n    list.push(17);\r\n    list.pop();\r\n    REQUIRE(list.size() == 2);\r\n}\r\n\r\nTEST_CASE(\"ListHasCorrectSizeAfterPopAndPush\") {\r\n    simple_linked_list::List list{};\r\n    list.push(242);\r\n    list.push(21);\r\n    list.push(-17);\r\n    list.pop();\r\n    list.push(34);\r\n    REQUIRE(list.size() == 3);\r\n}\r\n\r\nTEST_CASE(\"PopFromSize1\") {\r\n    simple_linked_list::List list{};\r\n    auto desired = 142;\r\n    list.push(desired);\r\n    auto actual = list.pop();\r\n    REQUIRE(actual == desired);\r\n}\r\n\r\nTEST_CASE(\"PopFromSizeTwo\") {\r\n    simple_linked_list::List list{};\r\n    auto desired_top = 112;\r\n    auto desired_bottom = 221;\r\n    list.push(desired_bottom);\r\n    list.push(desired_top);\r\n    auto actual_top = list.pop();\r\n    REQUIRE(actual_top == desired_top);\r\n    auto actual_bottom = list.pop();\r\n    REQUIRE(actual_bottom == desired_bottom);\r\n}\r\n\r\nTEST_CASE(\"PopAndPushList\") {\r\n    simple_linked_list::List list{};\r\n\r\n    list.push(1);\r\n    list.push(2);\r\n    list.push(3);\r\n    auto third = list.pop();\r\n    list.push(4);\r\n    list.push(5);\r\n    auto fifth = list.pop();\r\n    auto forth = list.pop();\r\n    auto second = list.pop();\r\n    list.push(6);\r\n    auto sixth = list.pop();\r\n    auto first = list.pop();\r\n    REQUIRE(first == 1);\r\n    REQUIRE(second == 2);\r\n    REQUIRE(third == 3);\r\n    REQUIRE(forth == 4);\r\n    REQUIRE(fifth == 5);\r\n    REQUIRE(sixth == 6);\r\n}\r\n\r\nTEST_CASE(\"ReverseEmptyList\") {\r\n    simple_linked_list::List empty{};\r\n    empty.reverse();\r\n    REQUIRE(empty.size() == 0);\r\n}\r\n\r\nTEST_CASE(\"ReverseNonEmptyList\") {\r\n    simple_linked_list::List list{};\r\n    for (int i = 0; i < 5; i++) {\r\n        list.push(i);\r\n    }\r\n\r\n    list.reverse();\r\n\r\n    for (int i = 0; i < 5; i++) {\r\n        REQUIRE(list.pop() == i);\r\n    }\r\n}\r\n#endif\r\n"
  }
}