{
  "language": "cpp",
  "slug": "perfect-numbers",
  "docs": {
    "introduction": "",
    "instructions": "# Instructions\r\n\r\nDetermine if a number is perfect, abundant, or deficient based on Nicomachus' (60 - 120 CE) classification scheme for positive integers.\r\n\r\nThe Greek mathematician [Nicomachus][nicomachus] devised a classification scheme for positive integers, identifying each as belonging uniquely to the categories of [perfect](#perfect), [abundant](#abundant), or [deficient](#deficient) based on their [aliquot sum][aliquot-sum].\r\nThe _aliquot sum_ is defined as the sum of the factors of a number not including the number itself.\r\nFor example, the aliquot sum of `15` is `1 + 3 + 5 = 9`.\r\n\r\n## Perfect\r\n\r\nA number is perfect when it equals its aliquot sum.\r\nFor example:\r\n\r\n- `6` is a perfect number because `1 + 2 + 3 = 6`\r\n- `28` is a perfect number because `1 + 2 + 4 + 7 + 14 = 28`\r\n\r\n## Abundant\r\n\r\nA number is abundant when it is less than its aliquot sum.\r\nFor example:\r\n\r\n- `12` is an abundant number because `1 + 2 + 3 + 4 + 6 = 16`\r\n- `24` is an abundant number because `1 + 2 + 3 + 4 + 6 + 8 + 12 = 36`\r\n\r\n## Deficient\r\n\r\nA number is deficient when it is greater than its aliquot sum.\r\nFor example:\r\n\r\n- `8` is a deficient number because `1 + 2 + 4 = 7`\r\n- Prime numbers are deficient\r\n\r\n## Task\r\n\r\nImplement a way to determine whether a given number is [perfect](#perfect).\r\nDepending on your language track, you may also need to implement a way to determine whether a given number is [abundant](#abundant) or [deficient](#deficient).\r\n\r\n[nicomachus]: https://en.wikipedia.org/wiki/Nicomachus\r\n[aliquot-sum]: https://en.wikipedia.org/wiki/Aliquot_sum\r\n",
    "hints": ""
  },
  "starter_code": {
    "perfect_numbers.cpp": "#include \"perfect_numbers.h\"\r\n\r\nnamespace perfect_numbers {}  // namespace perfect_numbers\r\n",
    "perfect_numbers.h": "#pragma once\r\n\r\nnamespace perfect_numbers {}  // namespace perfect_numbers\r\n"
  },
  "tests": {
    "perfect_numbers_test.cpp": "#include \"perfect_numbers.h\"\r\n#ifdef EXERCISM_TEST_SUITE\r\n#include <catch2/catch.hpp>\r\n#else\r\n#include \"test/catch.hpp\"\r\n#endif\r\n\r\n// improves error messages with enum text instead of integers:\r\nCATCH_REGISTER_ENUM(perfect_numbers::classification,\r\n                    perfect_numbers::classification::perfect,\r\n                    perfect_numbers::classification::abundant,\r\n                    perfect_numbers::classification::deficient)\r\n\r\nTEST_CASE(\"Smallest perfect number is classified correctly\",\r\n          \"[163e8e86-7bfd-4ee2-bd68-d083dc3381a3]\") {\r\n    REQUIRE(perfect_numbers::classification::perfect ==\r\n            perfect_numbers::classify(6));\r\n}\r\n\r\n#if defined(EXERCISM_RUN_ALL_TESTS)\r\n\r\nTEST_CASE(\"Medium perfect number is classified correctly\",\r\n          \"[169a7854-0431-4ae0-9815-c3b6d967436d]\") {\r\n    REQUIRE(perfect_numbers::classification::perfect ==\r\n            perfect_numbers::classify(28));\r\n}\r\n\r\nTEST_CASE(\"Large perfect number is classified correctly\",\r\n          \"[ee3627c4-7b36-4245-ba7c-8727d585f402]\") {\r\n    REQUIRE(perfect_numbers::classification::perfect ==\r\n            perfect_numbers::classify(33550336));\r\n}\r\n\r\nTEST_CASE(\"Smallest abundant number is classified correctly\",\r\n          \"[80ef7cf8-9ea8-49b9-8b2d-d9cb3db3ed7e]\") {\r\n    REQUIRE(perfect_numbers::classification::abundant ==\r\n            perfect_numbers::classify(12));\r\n}\r\n\r\nTEST_CASE(\"Medium abundant number is classified correctly\",\r\n          \"[3e300e0d-1a12-4f11-8c48-d1027165ab60]\") {\r\n    REQUIRE(perfect_numbers::classification::abundant ==\r\n            perfect_numbers::classify(30));\r\n}\r\n\r\nTEST_CASE(\"Large abundant number is classified correctly\",\r\n          \"[ec7792e6-8786-449c-b005-ce6dd89a772b]\") {\r\n    REQUIRE(perfect_numbers::classification::abundant ==\r\n            perfect_numbers::classify(33550335));\r\n}\r\n\r\nTEST_CASE(\"Smallest prime deficient number is classified correctly\",\r\n          \"[e610fdc7-2b6e-43c3-a51c-b70fb37413ba]\") {\r\n    REQUIRE(perfect_numbers::classification::deficient ==\r\n            perfect_numbers::classify(2));\r\n}\r\n\r\nTEST_CASE(\"Smallest non-prime deficient number is classified correctly\",\r\n          \"[0beb7f66-753a-443f-8075-ad7fbd9018f3]\") {\r\n    REQUIRE(perfect_numbers::classification::deficient ==\r\n            perfect_numbers::classify(4));\r\n}\r\n\r\nTEST_CASE(\"Medium deficient number is classified correctly\",\r\n          \"[1c802e45-b4c6-4962-93d7-1cad245821ef]\") {\r\n    REQUIRE(perfect_numbers::classification::deficient ==\r\n            perfect_numbers::classify(32));\r\n}\r\n\r\nTEST_CASE(\"Large deficient number is classified correctly\",\r\n          \"[47dd569f-9e5a-4a11-9a47-a4e91c8c28aa]\") {\r\n    REQUIRE(perfect_numbers::classification::deficient ==\r\n            perfect_numbers::classify(33550337));\r\n}\r\n\r\nTEST_CASE(\"Edge case (no factors other than itself) is classified correctly\",\r\n          \"[a696dec8-6147-4d68-afad-d38de5476a56]\") {\r\n    REQUIRE(perfect_numbers::classification::deficient ==\r\n            perfect_numbers::classify(1));\r\n}\r\n\r\nTEST_CASE(\"Zero is rejected (as it is not a positive integer)\",\r\n          \"[72445cee-660c-4d75-8506-6c40089dc302]\") {\r\n    REQUIRE_THROWS_AS(perfect_numbers::classify(0), std::domain_error);\r\n}\r\n\r\nTEST_CASE(\"Negative integer is rejected (as it is not a positive integer)\",\r\n          \"[2d72ce2c-6802-49ac-8ece-c790ba3dae13]\") {\r\n    REQUIRE_THROWS_AS(perfect_numbers::classify(-1), std::domain_error);\r\n}\r\n\r\n#endif\r\n"
  }
}