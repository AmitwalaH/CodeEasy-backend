{
  "language": "cpp",
  "slug": "circular-buffer",
  "docs": {
    "introduction": "",
    "instructions": "# Instructions\r\n\r\nA circular buffer, cyclic buffer or ring buffer is a data structure that uses a single, fixed-size buffer as if it were connected end-to-end.\r\n\r\nA circular buffer first starts empty and of some predefined length.\r\nFor example, this is a 7-element buffer:\r\n\r\n```text\r\n[ ][ ][ ][ ][ ][ ][ ]\r\n```\r\n\r\nAssume that a 1 is written into the middle of the buffer (exact starting location does not matter in a circular buffer):\r\n\r\n```text\r\n[ ][ ][ ][1][ ][ ][ ]\r\n```\r\n\r\nThen assume that two more elements are added — 2 & 3 — which get appended after the 1:\r\n\r\n```text\r\n[ ][ ][ ][1][2][3][ ]\r\n```\r\n\r\nIf two elements are then removed from the buffer, the oldest values inside the buffer are removed.\r\nThe two elements removed, in this case, are 1 & 2, leaving the buffer with just a 3:\r\n\r\n```text\r\n[ ][ ][ ][ ][ ][3][ ]\r\n```\r\n\r\nIf the buffer has 7 elements then it is completely full:\r\n\r\n```text\r\n[5][6][7][8][9][3][4]\r\n```\r\n\r\nWhen the buffer is full an error will be raised, alerting the client that further writes are blocked until a slot becomes free.\r\n\r\nWhen the buffer is full, the client can opt to overwrite the oldest data with a forced write.\r\nIn this case, two more elements — A & B — are added and they overwrite the 3 & 4:\r\n\r\n```text\r\n[5][6][7][8][9][A][B]\r\n```\r\n\r\n3 & 4 have been replaced by A & B making 5 now the oldest data in the buffer.\r\nFinally, if two elements are removed then what would be returned is 5 & 6 yielding the buffer:\r\n\r\n```text\r\n[ ][ ][7][8][9][A][B]\r\n```\r\n\r\nBecause there is space available, if the client again uses overwrite to store C & D then the space where 5 & 6 were stored previously will be used not the location of 7 & 8.\r\n7 is still the oldest element and the buffer is once again full.\r\n\r\n```text\r\n[C][D][7][8][9][A][B]\r\n```\r\n",
    "hints": ""
  },
  "starter_code": {
    "circular_buffer.cpp": "#include \"circular_buffer.h\"\r\n\r\nnamespace circular_buffer {\r\n\r\n// TODO: add your solution here\r\n\r\n}  // namespace circular_buffer\r\n",
    "circular_buffer.h": "#pragma once\r\n\r\nnamespace circular_buffer {\r\n\r\n// TODO: add your solution here\r\n\r\n}  // namespace circular_buffer\r\n"
  },
  "tests": {
    "circular_buffer_test.cpp": "#include \"circular_buffer.h\"\r\n#ifdef EXERCISM_TEST_SUITE\r\n#include <catch2/catch.hpp>\r\n#else\r\n#include \"test/catch.hpp\"\r\n#endif\r\n\r\n#include <stdexcept>\r\n\r\n// Circular-buffer exercise test case data version 1.2.0\r\n\r\nTEST_CASE(\"reading_empty_buffer_should_fail\") {\r\n    circular_buffer::circular_buffer<int> buffer(1);\r\n\r\n    REQUIRE_THROWS_AS(buffer.read(), std::domain_error);\r\n}\r\n\r\n#if defined(EXERCISM_RUN_ALL_TESTS)\r\nTEST_CASE(\"can_read_an_item_just_written\") {\r\n    circular_buffer::circular_buffer<int> buffer(1);\r\n\r\n    REQUIRE_NOTHROW(buffer.write(1));\r\n\r\n    int expected = 1;\r\n    REQUIRE(expected == buffer.read());\r\n}\r\n\r\nTEST_CASE(\"each_item_may_only_be_read_once\") {\r\n    circular_buffer::circular_buffer<int> buffer(1);\r\n\r\n    REQUIRE_NOTHROW(buffer.write(1));\r\n\r\n    int expected = 1;\r\n    REQUIRE(expected == buffer.read());\r\n\r\n    REQUIRE_THROWS_AS(buffer.read(), std::domain_error);\r\n}\r\n\r\nTEST_CASE(\"items_are_read_in_the_order_they_are_written\") {\r\n    circular_buffer::circular_buffer<int> buffer(2);\r\n\r\n    REQUIRE_NOTHROW(buffer.write(1));\r\n    REQUIRE_NOTHROW(buffer.write(2));\r\n\r\n    int expected = 1;\r\n    REQUIRE(expected == buffer.read());\r\n\r\n    expected = 2;\r\n    REQUIRE(expected == buffer.read());\r\n}\r\n\r\nTEST_CASE(\"full_buffer_cant_be_written\") {\r\n    circular_buffer::circular_buffer<int> buffer(1);\r\n\r\n    REQUIRE_NOTHROW(buffer.write(1));\r\n    REQUIRE_THROWS_AS(buffer.write(2), std::domain_error);\r\n}\r\n\r\nTEST_CASE(\"a_read_frees_up_capacity_for_another_write\") {\r\n    circular_buffer::circular_buffer<int> buffer(1);\r\n\r\n    REQUIRE_NOTHROW(buffer.write(1));\r\n\r\n    int expected = 1;\r\n    REQUIRE(expected == buffer.read());\r\n\r\n    REQUIRE_NOTHROW(buffer.write(2));\r\n\r\n    expected = 2;\r\n    REQUIRE(expected == buffer.read());\r\n}\r\n\r\nTEST_CASE(\"read_position_is_maintained_even_across_multiple_writes\") {\r\n    circular_buffer::circular_buffer<int> buffer(3);\r\n\r\n    REQUIRE_NOTHROW(buffer.write(1));\r\n    REQUIRE_NOTHROW(buffer.write(2));\r\n\r\n    int expected = 1;\r\n    REQUIRE(expected == buffer.read());\r\n\r\n    REQUIRE_NOTHROW(buffer.write(3));\r\n\r\n    expected = 2;\r\n    REQUIRE(expected == buffer.read());\r\n\r\n    expected = 3;\r\n    REQUIRE(expected == buffer.read());\r\n}\r\n\r\nTEST_CASE(\"items_cleared_out_of_buffer_cant_be_read\") {\r\n    circular_buffer::circular_buffer<int> buffer(1);\r\n\r\n    REQUIRE_NOTHROW(buffer.write(1));\r\n\r\n    buffer.clear();\r\n\r\n    REQUIRE_THROWS_AS(buffer.read(), std::domain_error);\r\n}\r\n\r\nTEST_CASE(\"clear_frees_up_capacity_for_another_write\") {\r\n    circular_buffer::circular_buffer<int> buffer(1);\r\n\r\n    REQUIRE_NOTHROW(buffer.write(1));\r\n\r\n    buffer.clear();\r\n\r\n    REQUIRE_NOTHROW(buffer.write(2));\r\n\r\n    int expected = 2;\r\n    REQUIRE(expected == buffer.read());\r\n}\r\n\r\nTEST_CASE(\"clear_does_nothing_on_empty_buffer\") {\r\n    circular_buffer::circular_buffer<int> buffer(1);\r\n\r\n    buffer.clear();\r\n\r\n    REQUIRE_NOTHROW(buffer.write(1));\r\n\r\n    int expected = 1;\r\n    REQUIRE(expected == buffer.read());\r\n}\r\n\r\nTEST_CASE(\"overwrite_acts_like_write_on_non_full_buffer\") {\r\n    circular_buffer::circular_buffer<int> buffer(2);\r\n\r\n    REQUIRE_NOTHROW(buffer.write(1));\r\n\r\n    buffer.overwrite(2);\r\n\r\n    int expected = 1;\r\n    REQUIRE(expected == buffer.read());\r\n\r\n    expected = 2;\r\n    REQUIRE(expected == buffer.read());\r\n}\r\n\r\nTEST_CASE(\"overwrite_replaces_the_oldest_item_on_full_buffer\") {\r\n    circular_buffer::circular_buffer<int> buffer(2);\r\n\r\n    REQUIRE_NOTHROW(buffer.write(1));\r\n    REQUIRE_NOTHROW(buffer.write(2));\r\n\r\n    buffer.overwrite(3);\r\n\r\n    int expected = 2;\r\n    REQUIRE(expected == buffer.read());\r\n\r\n    expected = 3;\r\n    REQUIRE(expected == buffer.read());\r\n}\r\n\r\nTEST_CASE(\r\n    \"overwrite_replaces_the_oldest_item_remaining_in_buffer_following_a_read\") {\r\n    circular_buffer::circular_buffer<int> buffer(3);\r\n\r\n    REQUIRE_NOTHROW(buffer.write(1));\r\n    REQUIRE_NOTHROW(buffer.write(2));\r\n    REQUIRE_NOTHROW(buffer.write(3));\r\n\r\n    int expected = 1;\r\n    REQUIRE(expected == buffer.read());\r\n\r\n    REQUIRE_NOTHROW(buffer.write(4));\r\n\r\n    buffer.overwrite(5);\r\n\r\n    expected = 3;\r\n    REQUIRE(expected == buffer.read());\r\n\r\n    expected = 4;\r\n    REQUIRE(expected == buffer.read());\r\n\r\n    expected = 5;\r\n    REQUIRE(expected == buffer.read());\r\n}\r\n\r\nTEST_CASE(\"full_buffer_cant_be_written_after_overwrite\") {\r\n    circular_buffer::circular_buffer<int> buffer(1);\r\n\r\n    REQUIRE_NOTHROW(buffer.write(1));\r\n    buffer.overwrite(2);\r\n    REQUIRE_THROWS_AS(buffer.write(3), std::domain_error);\r\n\r\n    int expected = 2;\r\n    REQUIRE(expected == buffer.read());\r\n}\r\n\r\nTEST_CASE(\"check_correctness_with_string_type\") {\r\n    circular_buffer::circular_buffer<std::string> buffer(3);\r\n\r\n    REQUIRE_NOTHROW(buffer.write(\"hello\"));\r\n    REQUIRE_NOTHROW(buffer.write(\"world\"));\r\n    REQUIRE_NOTHROW(buffer.write(\"zombies\"));\r\n\r\n    std::string expected = \"hello\";\r\n    REQUIRE(expected == buffer.read());\r\n\r\n    REQUIRE_NOTHROW(buffer.write(\"pants\"));\r\n\r\n    buffer.overwrite(\"banana\");\r\n\r\n    expected = \"zombies\";\r\n    REQUIRE(expected == buffer.read());\r\n\r\n    expected = \"pants\";\r\n    REQUIRE(expected == buffer.read());\r\n\r\n    expected = \"banana\";\r\n    REQUIRE(expected == buffer.read());\r\n}\r\n\r\nTEST_CASE(\"initial_clear_does_not_affect_wrapping_around\") {\r\n    circular_buffer::circular_buffer<int> buffer(2);\r\n\r\n    buffer.clear();\r\n\r\n    REQUIRE_NOTHROW(buffer.write(1));\r\n    REQUIRE_NOTHROW(buffer.write(2));\r\n\r\n    buffer.overwrite(3);\r\n    buffer.overwrite(4);\r\n\r\n    int expected = 3;\r\n    REQUIRE(expected == buffer.read());\r\n\r\n    expected = 4;\r\n    REQUIRE(expected == buffer.read());\r\n\r\n    REQUIRE_THROWS_AS(buffer.read(), std::domain_error);\r\n}\r\n#endif  // !EXERCISM_RUN_ALL_TESTS\r\n"
  }
}