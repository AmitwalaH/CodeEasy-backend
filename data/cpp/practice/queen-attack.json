{
  "language": "cpp",
  "slug": "queen-attack",
  "docs": {
    "introduction": "",
    "instructions": "# Instructions\r\n\r\nGiven the position of two queens on a chess board, indicate whether or not they are positioned so that they can attack each other.\r\n\r\nIn the game of chess, a queen can attack pieces which are on the same row, column, or diagonal.\r\n\r\nA chessboard can be represented by an 8 by 8 array.\r\n\r\nSo if you are told the white queen is at `c5` (zero-indexed at column 2, row 3) and the black queen at `f2` (zero-indexed at column 5, row 6), then you know that the set-up is like so:\r\n\r\n![A chess board with two queens. Arrows emanating from the queen at c5 indicate possible directions of capture along file, rank and diagonal.](https://assets.exercism.org/images/exercises/queen-attack/queen-capture.svg)\r\n\r\nYou are also able to answer whether the queens can attack each other.\r\nIn this case, that answer would be yes, they can, because both pieces share a diagonal.\r\n\r\n## Credit\r\n\r\nThe chessboard image was made by [habere-et-dispertire][habere-et-dispertire] using LaTeX and the [chessboard package][chessboard-package] by Ulrike Fischer.\r\n\r\n[habere-et-dispertire]: https://exercism.org/profiles/habere-et-dispertire\r\n[chessboard-package]: https://github.com/u-fischer/chessboard\r\n",
    "hints": ""
  },
  "starter_code": {
    "queen_attack.cpp": "#include \"queen_attack.h\"\r\n\r\nnamespace queen_attack {\r\n\r\n// TODO: add your solution here\r\n\r\n}  // namespace queen_attack\r\n",
    "queen_attack.h": "#pragma once\r\n\r\nnamespace queen_attack {\r\n\r\n// TODO: add your solution here\r\n\r\n}  // namespace queen_attack\r\n"
  },
  "tests": {
    "queen_attack_test.cpp": "#include \"queen_attack.h\"\r\n#ifdef EXERCISM_TEST_SUITE\r\n#include <catch2/catch.hpp>\r\n#else\r\n#include \"test/catch.hpp\"\r\n#endif\r\n\r\nTEST_CASE(\"newly_placed_queen_with_a_valid_position\") {\r\n    const auto white = std::make_pair(2, 2);\r\n    const auto black = std::make_pair(0, 3);\r\n\r\n    const queen_attack::chess_board board{white, black};\r\n\r\n    REQUIRE(white == board.white());\r\n    REQUIRE(black == board.black());\r\n}\r\n\r\n#if defined(EXERCISM_RUN_ALL_TESTS)\r\nTEST_CASE(\"newly_placed_queen_must_have_positive_row\") {\r\n    const auto white = std::make_pair(-2, 2);\r\n    const auto black = std::make_pair(0, 3);\r\n\r\n    REQUIRE_THROWS_AS((queen_attack::chess_board{white, black}),\r\n                      std::domain_error);\r\n}\r\n\r\nTEST_CASE(\"newly_placed_queen_must_have_row_on_board\") {\r\n    const auto white = std::make_pair(8, 4);\r\n    const auto black = std::make_pair(0, 3);\r\n\r\n    REQUIRE_THROWS_AS((queen_attack::chess_board{white, black}),\r\n                      std::domain_error);\r\n}\r\n\r\nTEST_CASE(\"newly_placed_queen_must_have_positive_column\") {\r\n    const auto white = std::make_pair(2, -2);\r\n    const auto black = std::make_pair(0, 3);\r\n\r\n    REQUIRE_THROWS_AS((queen_attack::chess_board{white, black}),\r\n                      std::domain_error);\r\n}\r\n\r\nTEST_CASE(\"newly_placed_queen_must_have_column_on_board\") {\r\n    const auto white = std::make_pair(4, 8);\r\n    const auto black = std::make_pair(0, 3);\r\n\r\n    REQUIRE_THROWS_AS((queen_attack::chess_board{white, black}),\r\n                      std::domain_error);\r\n}\r\n\r\nTEST_CASE(\"queen_positions_must_be_distinct\") {\r\n    const auto pos = std::make_pair(3, 7);\r\n\r\n    REQUIRE_THROWS_AS((queen_attack::chess_board{pos, pos}), std::domain_error);\r\n}\r\n\r\nTEST_CASE(\"queens_cannot_attack\") {\r\n    const queen_attack::chess_board board{std::make_pair(2, 4),\r\n                                          std::make_pair(6, 6)};\r\n\r\n    REQUIRE_FALSE(board.can_attack());\r\n}\r\n\r\nTEST_CASE(\"queens_can_attack_on_same_row\") {\r\n    const queen_attack::chess_board board{std::make_pair(2, 4),\r\n                                          std::make_pair(2, 6)};\r\n\r\n    REQUIRE(board.can_attack());\r\n}\r\n\r\nTEST_CASE(\"queens_can_attack_on_same_column\") {\r\n    const queen_attack::chess_board board{std::make_pair(4, 5),\r\n                                          std::make_pair(2, 5)};\r\n\r\n    REQUIRE(board.can_attack());\r\n}\r\n\r\nTEST_CASE(\"queens_can_attack_on_first_diagonal\") {\r\n    const queen_attack::chess_board board{std::make_pair(2, 2),\r\n                                          std::make_pair(0, 4)};\r\n\r\n    REQUIRE(board.can_attack());\r\n}\r\n\r\nTEST_CASE(\"queens_can_attack_on_second_diagonal\") {\r\n    const queen_attack::chess_board board{std::make_pair(2, 2),\r\n                                          std::make_pair(3, 1)};\r\n\r\n    REQUIRE(board.can_attack());\r\n}\r\n\r\nTEST_CASE(\"queens_can_attack_on_third_diagonal\") {\r\n    const queen_attack::chess_board board{std::make_pair(2, 2),\r\n                                          std::make_pair(1, 1)};\r\n\r\n    REQUIRE(board.can_attack());\r\n}\r\n\r\nTEST_CASE(\"queens_can_attack_on_fourth_diagonal\") {\r\n    const queen_attack::chess_board board{std::make_pair(1, 7),\r\n                                          std::make_pair(0, 6)};\r\n\r\n    REQUIRE(board.can_attack());\r\n}\r\n\r\nTEST_CASE(\r\n    // clang-format off\r\n    \"queens_cannot_attack_if_falling_diagonals_are_only_the_same_when_reflected_across_the_longest_falling_diagonal\"\r\n    // clang-format on\r\n) {\r\n    const queen_attack::chess_board board{std::make_pair(4, 1),\r\n                                          std::make_pair(2, 5)};\r\n\r\n    REQUIRE_FALSE(board.can_attack());\r\n}\r\n#endif\r\n"
  }
}