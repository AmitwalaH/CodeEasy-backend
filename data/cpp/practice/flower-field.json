{
  "language": "cpp",
  "slug": "flower-field",
  "docs": {
    "introduction": "# Introduction\r\n\r\n[Flower Field][history] is a compassionate reimagining of the popular game Minesweeper.\r\nThe object of the game is to find all the flowers in the garden using numeric hints that indicate how many flowers are directly adjacent (horizontally, vertically, diagonally) to a square.\r\n\"Flower Field\" shipped in regional versions of Microsoft Windows in Italy, Germany, South Korea, Japan and Taiwan.\r\n\r\n[history]: https://web.archive.org/web/20020409051321fw_/http://rcm.usr.dsi.unimi.it/rcmweb/fnm/\r\n",
    "instructions": "# Instructions\r\n\r\nYour task is to add flower counts to empty squares in a completed Flower Field garden.\r\nThe garden itself is a rectangle board composed of squares that are either empty (`' '`) or a flower (`'*'`).\r\n\r\nFor each empty square, count the number of flowers adjacent to it (horizontally, vertically, diagonally).\r\nIf the empty square has no adjacent flowers, leave it empty.\r\nOtherwise replace it with the count of adjacent flowers.\r\n\r\nFor example, you may receive a 5 x 4 board like this (empty spaces are represented here with the '·' character for display on screen):\r\n\r\n```text\r\n·*·*·\r\n··*··\r\n··*··\r\n·····\r\n```\r\n\r\nWhich your code should transform into this:\r\n\r\n```text\r\n1*3*1\r\n13*31\r\n·2*2·\r\n·111·\r\n```\r\n",
    "hints": ""
  },
  "starter_code": {
    "flower_field.cpp": "#include \"flower_field.h\"\r\n\r\nnamespace flower_field {\r\n\r\n// TODO: add your solution here\r\n\r\n}  // namespace flower_field\r\n",
    "flower_field.h": "#pragma once\r\n\r\nnamespace flower_field {\r\n\r\n// TODO: add your solution here\r\n\r\n}  // namespace flower_field\r\n"
  },
  "tests": {
    "flower_field_test.cpp": "#include \"flower_field.h\"\r\n#ifdef EXERCISM_TEST_SUITE\r\n#include <catch2/catch.hpp>\r\n#else\r\n#include \"test/catch.hpp\"\r\n#endif\r\n\r\n/*\r\n The expected outputs are represented as arrays of strings to\r\n improve readability in this JSON file.\r\n Your track may choose whether to present the input as a single\r\n string (concatenating all the lines) or as the list.\r\n*/\r\n\r\nTEST_CASE(\"no rows\", \"[237ff487-467a-47e1-9b01-8a891844f86c]\") {\r\n    const std::vector<std::string> expected{};\r\n    REQUIRE(expected == flower_field::annotate({}));\r\n}\r\n\r\n#if defined(EXERCISM_RUN_ALL_TESTS)\r\n\r\nTEST_CASE(\"no columns\", \"[4b4134ec-e20f-439c-a295-664c38950ba1]\") {\r\n    const std::vector<std::string> expected{\"\"};\r\n    REQUIRE(expected == flower_field::annotate({\"\"}));\r\n}\r\n\r\nTEST_CASE(\"no flowers\", \"[d774d054-bbad-4867-88ae-069cbd1c4f92]\") {\r\n    const std::vector<std::string> expected{\"   \", \"   \", \"   \"};\r\n    REQUIRE(expected == flower_field::annotate({\"   \", \"   \", \"   \"}));\r\n}\r\n\r\nTEST_CASE(\"garden full of flowers\", \"[225176a0-725e-43cd-aa13-9dced501f16e]\") {\r\n    const std::vector<std::string> expected{\"***\", \"***\", \"***\"};\r\n    REQUIRE(expected == flower_field::annotate({\"***\", \"***\", \"***\"}));\r\n}\r\n\r\nTEST_CASE(\"flower surrounded by spaces\",\r\n          \"[3f345495-f1a5-4132-8411-74bd7ca08c49]\") {\r\n    const std::vector<std::string> expected{\"111\", \"1*1\", \"111\"};\r\n    REQUIRE(expected == flower_field::annotate({\"   \", \" * \", \"   \"}));\r\n}\r\n\r\nTEST_CASE(\"space surrounded by flowers\",\r\n          \"[6cb04070-4199-4ef7-a6fa-92f68c660fca]\") {\r\n    const std::vector<std::string> expected{\"***\", \"*8*\", \"***\"};\r\n    REQUIRE(expected == flower_field::annotate({\"***\", \"* *\", \"***\"}));\r\n}\r\n\r\nTEST_CASE(\"horizontal line\", \"[272d2306-9f62-44fe-8ab5-6b0f43a26338]\") {\r\n    const std::vector<std::string> expected{\"1*2*1\"};\r\n    REQUIRE(expected == flower_field::annotate({\" * * \"}));\r\n}\r\n\r\nTEST_CASE(\"horizontal line, flowers at edges\",\r\n          \"[c6f0a4b2-58d0-4bf6-ad8d-ccf4144f1f8e]\") {\r\n    const std::vector<std::string> expected{\"*1 1*\"};\r\n    REQUIRE(expected == flower_field::annotate({\"*   *\"}));\r\n}\r\n\r\nTEST_CASE(\"vertical line\", \"[a54e84b7-3b25-44a8-b8cf-1753c8bb4cf5]\") {\r\n    const std::vector<std::string> expected{\"1\", \"*\", \"2\", \"*\", \"1\"};\r\n    REQUIRE(expected == flower_field::annotate({\" \", \"*\", \" \", \"*\", \" \"}));\r\n}\r\n\r\nTEST_CASE(\"vertical line, flowers at edges\",\r\n          \"[b40f42f5-dec5-4abc-b167-3f08195189c1]\") {\r\n    const std::vector<std::string> expected{\"*\", \"1\", \" \", \"1\", \"*\"};\r\n    REQUIRE(expected == flower_field::annotate({\"*\", \" \", \" \", \" \", \"*\"}));\r\n}\r\n\r\nTEST_CASE(\"cross\", \"[58674965-7b42-4818-b930-0215062d543c]\") {\r\n    const std::vector<std::string> expected{\" 2*2 \", \"25*52\", \"*****\", \"25*52\",\r\n                                            \" 2*2 \"};\r\n    REQUIRE(expected == flower_field::annotate(\r\n                            {\"  *  \", \"  *  \", \"*****\", \"  *  \", \"  *  \"}));\r\n}\r\n\r\nTEST_CASE(\"large garden\", \"[dd9d4ca8-9e68-4f78-a677-a2a70fd7a7b8]\") {\r\n    const std::vector<std::string> expected{\"1*22*1\", \"12*322\", \" 123*2\",\r\n                                            \"112*4*\", \"1*22*2\", \"111111\"};\r\n    REQUIRE(expected == flower_field::annotate({\" *  * \", \"  *   \", \"    * \",\r\n                                                \"   * *\", \" *  * \", \"      \"}));\r\n}\r\n\r\n#endif\r\n"
  }
}