{
  "language": "cpp",
  "slug": "complex-numbers",
  "docs": {
    "introduction": "",
    "instructions": "# Instructions\r\n\r\nA **complex number** is expressed in the form `z = a + b * i`, where:\r\n\r\n- `a` is the **real part** (a real number),\r\n\r\n- `b` is the **imaginary part** (also a real number), and\r\n\r\n- `i` is the **imaginary unit** satisfying `i^2 = -1`.\r\n\r\n## Operations on Complex Numbers\r\n\r\n### Conjugate\r\n\r\nThe conjugate of the complex number `z = a + b * i` is given by:\r\n\r\n```text\r\nzc = a - b * i\r\n```\r\n\r\n### Absolute Value\r\n\r\nThe absolute value (or modulus) of `z` is defined as:\r\n\r\n```text\r\n|z| = sqrt(a^2 + b^2)\r\n```\r\n\r\nThe square of the absolute value is computed as the product of `z` and its conjugate `zc`:\r\n\r\n```text\r\n|z|^2 = z * zc = a^2 + b^2\r\n```\r\n\r\n### Addition\r\n\r\nThe sum of two complex numbers `z1 = a + b * i` and `z2 = c + d * i` is computed by adding their real and imaginary parts separately:\r\n\r\n```text\r\nz1 + z2 = (a + b * i) + (c + d * i)\r\n        = (a + c) + (b + d) * i\r\n```\r\n\r\n### Subtraction\r\n\r\nThe difference of two complex numbers is obtained by subtracting their respective parts:\r\n\r\n```text\r\nz1 - z2 = (a + b * i) - (c + d * i)\r\n        = (a - c) + (b - d) * i\r\n```\r\n\r\n### Multiplication\r\n\r\nThe product of two complex numbers is defined as:\r\n\r\n```text\r\nz1 * z2 = (a + b * i) * (c + d * i)\r\n        = (a * c - b * d) + (b * c + a * d) * i\r\n```\r\n\r\n### Reciprocal\r\n\r\nThe reciprocal of a non-zero complex number is given by:\r\n\r\n```text\r\n1 / z = 1 / (a + b * i)\r\n      = a / (a^2 + b^2) - b / (a^2 + b^2) * i\r\n```\r\n\r\n### Division\r\n\r\nThe division of one complex number by another is given by:\r\n\r\n```text\r\nz1 / z2 = z1 * (1 / z2)\r\n        = (a + b * i) / (c + d * i)\r\n        = (a * c + b * d) / (c^2 + d^2) + (b * c - a * d) / (c^2 + d^2) * i\r\n```\r\n\r\n### Exponentiation\r\n\r\nRaising _e_ (the base of the natural logarithm) to a complex exponent can be expressed using Euler's formula:\r\n\r\n```text\r\ne^(a + b * i) = e^a * e^(b * i)\r\n              = e^a * (cos(b) + i * sin(b))\r\n```\r\n\r\n## Implementation Requirements\r\n\r\nGiven that you should not use built-in support for complex numbers, implement the following operations:\r\n\r\n- **addition** of two complex numbers\r\n- **subtraction** of two complex numbers\r\n- **multiplication** of two complex numbers\r\n- **division** of two complex numbers\r\n- **conjugate** of a complex number\r\n- **absolute value** of a complex number\r\n- **exponentiation** of _e_ (the base of the natural logarithm) to a complex number\r\n",
    "hints": ""
  },
  "starter_code": {
    "complex_numbers.cpp": "#include \"complex_numbers.h\"\r\n\r\nnamespace complex_numbers {\r\n\r\n// TODO: add your solution here\r\n\r\n}  // namespace complex_numbers\r\n",
    "complex_numbers.h": "#pragma once\r\n\r\nnamespace complex_numbers {\r\n\r\n// TODO: add your solution here\r\n\r\n}  // namespace complex_numbers\r\n"
  },
  "tests": {
    "complex_numbers_test.cpp": "#include \"complex_numbers.h\"\r\n\r\n#include <cmath>\r\n#include <sstream>\r\n\r\n#ifdef EXERCISM_TEST_SUITE\r\n#include <catch2/catch.hpp>\r\n#else\r\n#include \"test/catch_amalgamated.hpp\"\r\n#endif\r\n\r\n// Complex Numbers exercise test case data version 1.3.0\r\n\r\nusing complex_numbers::Complex;\r\n\r\n// Define constants for platforms that don't include it\r\n#ifndef M_PI\r\n#define M_PI 3.14159265358979323846\r\n#endif\r\n#ifndef M_E\r\n#define M_E 2.71828182845904523536\r\n#endif\r\n\r\n// Define a margin to use for float comparisons. Catch does not compute a good\r\n// epsilon for float values near 0.\r\nstatic constexpr double eps = 0.005;\r\n\r\n// Custom Catch2 matcher for approximate equality of Complex numbers\r\nclass ComplexApproxMatcher : public Catch::Matchers::MatcherBase<Complex> {\r\n   public:\r\n    ComplexApproxMatcher(const Complex& expected, double epsilon)\r\n        : expected{expected}, epsilon{epsilon} {}\r\n\r\n    bool match(const Complex& actual) const override {\r\n        return std::abs(actual.real() - expected.real()) <= epsilon &&\r\n               std::abs(actual.imag() - expected.imag()) <= epsilon;\r\n    }\r\n\r\n    std::string describe() const override {\r\n        std::ostringstream ss;\r\n        ss << \"is approximately equal to (\" << expected.real() << \", \"\r\n           << expected.imag() << \"i) with epsilon \" << epsilon;\r\n        return ss.str();\r\n    }\r\n\r\n   private:\r\n    Complex expected;\r\n    double epsilon;\r\n};\r\n\r\n// Helper function to create the matcher\r\ninline ComplexApproxMatcher ComplexWithinAbs(const Complex& expected,\r\n                                             double epsilon) {\r\n    return ComplexApproxMatcher{expected, epsilon};\r\n}\r\n\r\nTEST_CASE(\"Real part -> Real part of a purely real number\",\r\n          \"[9f98e133-eb7f-45b0-9676-cce001cd6f7a]\") {\r\n    const Complex c{1.0, 0.0};\r\n\r\n    REQUIRE_THAT(c.real(), Catch::Matchers::WithinAbs(1.0, eps));\r\n}\r\n\r\n#if defined(EXERCISM_RUN_ALL_TESTS)\r\nTEST_CASE(\"Real part -> Real part of a purely imaginary number\",\r\n          \"[07988e20-f287-4bb7-90cf-b32c4bffe0f3]\") {\r\n    const Complex c{0.0, 1.0};\r\n\r\n    REQUIRE_THAT(c.real(), Catch::Matchers::WithinAbs(0.0, eps));\r\n}\r\n\r\nTEST_CASE(\"Real part -> Real part of a number with real and imaginary part\",\r\n          \"[4a370e86-939e-43de-a895-a00ca32da60a]\") {\r\n    const Complex c{1.0, 2.0};\r\n\r\n    REQUIRE_THAT(c.real(), Catch::Matchers::WithinAbs(1.0, eps));\r\n}\r\n\r\nTEST_CASE(\"Imaginary part -> Imaginary part of a purely real number\",\r\n          \"[9b3fddef-4c12-4a99-b8f8-e3a42c7ccef6]\") {\r\n    const Complex c{1.0, 0.0};\r\n\r\n    REQUIRE_THAT(c.imag(), Catch::Matchers::WithinAbs(0.0, eps));\r\n}\r\n\r\nTEST_CASE(\"Imaginary part -> Imaginary part of a purely imaginary number\",\r\n          \"[a8dafedd-535a-4ed3-8a39-fda103a2b01e]\") {\r\n    const Complex c{0.0, 1.0};\r\n\r\n    REQUIRE_THAT(c.imag(), Catch::Matchers::WithinAbs(1.0, eps));\r\n}\r\n\r\nTEST_CASE(\r\n    \"Imaginary part -> Imaginary part of a number with real and imaginary part\",\r\n    \"[0f998f19-69ee-4c64-80ef-01b086feab80]\") {\r\n    const Complex c{1.0, 2.0};\r\n\r\n    REQUIRE_THAT(c.imag(), Catch::Matchers::WithinAbs(2.0, eps));\r\n}\r\n\r\nTEST_CASE(\"Imaginary unit\", \"[a39b7fd6-6527-492f-8c34-609d2c913879]\") {\r\n    const Complex c1{0.0, 1.0};\r\n    const Complex c2{0.0, 1.0};\r\n\r\n    REQUIRE_THAT(c1 * c2, ComplexWithinAbs(Complex{-1.0, 0.0}, eps));\r\n}\r\n\r\nTEST_CASE(\"Arithmetic -> Addition -> Add purely real numbers\",\r\n          \"[9a2c8de9-f068-4f6f-b41c-82232cc6c33e]\") {\r\n    const Complex c1{1.0, 0.0};\r\n    const Complex c2{2.0, 0.0};\r\n\r\n    REQUIRE_THAT(c1 + c2, ComplexWithinAbs(Complex{3.0, 0.0}, eps));\r\n}\r\n\r\nTEST_CASE(\"Arithmetic -> Addition -> Add purely imaginary numbers\",\r\n          \"[657c55e1-b14b-4ba7-bd5c-19db22b7d659]\") {\r\n    const Complex c1{0.0, 1.0};\r\n    const Complex c2{0.0, 2.0};\r\n\r\n    REQUIRE_THAT(c1 + c2, ComplexWithinAbs(Complex{0.0, 3.0}, eps));\r\n}\r\n\r\nTEST_CASE(\"Arithmetic -> Addition -> Add numbers with real and imaginary part\",\r\n          \"[4e1395f5-572b-4ce8-bfa9-9a63056888da]\") {\r\n    const Complex c1{1.0, 2.0};\r\n    const Complex c2{3.0, 4.0};\r\n\r\n    REQUIRE_THAT(c1 + c2, ComplexWithinAbs(Complex{4.0, 6.0}, eps));\r\n}\r\n\r\nTEST_CASE(\"Arithmetic -> Subtraction -> Subtract purely real numbers\",\r\n          \"[1155dc45-e4f7-44b8-af34-a91aa431475d]\") {\r\n    const Complex c1{1.0, 0.0};\r\n    const Complex c2{2.0, 0.0};\r\n\r\n    REQUIRE_THAT(c1 - c2, ComplexWithinAbs(Complex{-1.0, 0.0}, eps));\r\n}\r\n\r\nTEST_CASE(\"Arithmetic -> Subtraction -> Subtract purely imaginary numbers\",\r\n          \"[f95e9da8-acd5-4da4-ac7c-c861b02f774b]\") {\r\n    const Complex c1{0.0, 1.0};\r\n    const Complex c2{0.0, 2.0};\r\n\r\n    REQUIRE_THAT(c1 - c2, ComplexWithinAbs(Complex{0.0, -1.0}, eps));\r\n}\r\n\r\nTEST_CASE(\r\n    // clang-format off\r\n    \"Arithmetic -> Subtraction -> Subtract numbers with real and imaginary part\",\r\n    // clang-format on\r\n    \"[f876feb1-f9d1-4d34-b067-b599a8746400]\") {\r\n    const Complex c1{1.0, 2.0};\r\n    const Complex c2{3.0, 4.0};\r\n\r\n    REQUIRE_THAT(c1 - c2, ComplexWithinAbs(Complex{-2.0, -2.0}, eps));\r\n}\r\n\r\nTEST_CASE(\"Arithmetic -> Multiplication -> Multiply purely real numbers\",\r\n          \"[8a0366c0-9e16-431f-9fd7-40ac46ff4ec4]\") {\r\n    const Complex c1{1.0, 0.0};\r\n    const Complex c2{2.0, 0.0};\r\n\r\n    REQUIRE_THAT(c1 * c2, ComplexWithinAbs(Complex{2.0, 0.0}, eps));\r\n}\r\n\r\nTEST_CASE(\"Arithmetic -> Multiplication -> Multiply purely imaginary numbers\",\r\n          \"[e560ed2b-0b80-4b4f-90f2-63cefc911aaf]\") {\r\n    const Complex c1{0.0, 1.0};\r\n    const Complex c2{0.0, 2.0};\r\n\r\n    REQUIRE_THAT(c1 * c2, ComplexWithinAbs(Complex{-2.0, 0.0}, eps));\r\n}\r\n\r\nTEST_CASE(\r\n    // clang-format off\r\n    \"Arithmetic -> Multiplication -> Multiply numbers with real and imaginary part\",\r\n    // clang-format on\r\n    \"[4d1d10f0-f8d4-48a0-b1d0-f284ada567e6]\") {\r\n    const Complex c1{1.0, 2.0};\r\n    const Complex c2{3.0, 4.0};\r\n\r\n    REQUIRE_THAT(c1 * c2, ComplexWithinAbs(Complex{-5.0, 10.0}, eps));\r\n}\r\n\r\nTEST_CASE(\"Arithmetic -> Division -> Divide purely real numbers\",\r\n          \"[b0571ddb-9045-412b-9c15-cd1d816d36c1]\") {\r\n    const Complex c1{1.0, 0.0};\r\n    const Complex c2{2.0, 0.0};\r\n\r\n    REQUIRE_THAT(c1 / c2, ComplexWithinAbs(Complex{0.5, 0.0}, eps));\r\n}\r\n\r\nTEST_CASE(\"Arithmetic -> Division -> Divide purely imaginary numbers\",\r\n          \"[5bb4c7e4-9934-4237-93cc-5780764fdbdd]\") {\r\n    const Complex c1{0.0, 1.0};\r\n    const Complex c2{0.0, 2.0};\r\n\r\n    REQUIRE_THAT(c1 / c2, ComplexWithinAbs(Complex{0.5, 0.0}, eps));\r\n}\r\n\r\nTEST_CASE(\r\n    \"Arithmetic -> Division -> Divide numbers with real and imaginary part\",\r\n    \"[c4e7fef5-64ac-4537-91c2-c6529707701f]\") {\r\n    const Complex c1{1.0, 2.0};\r\n    const Complex c2{3.0, 4.0};\r\n\r\n    REQUIRE_THAT(c1 / c2, ComplexWithinAbs(Complex{0.44, 0.08}, eps));\r\n}\r\n\r\nTEST_CASE(\"Absolute value -> Absolute value of a positive purely real number\",\r\n          \"[c56a7332-aad2-4437-83a0-b3580ecee843]\") {\r\n    const Complex c{5.0, 0.0};\r\n\r\n    REQUIRE_THAT(c.abs(), Catch::Matchers::WithinAbs(5.0, eps));\r\n}\r\n\r\nTEST_CASE(\"Absolute value -> Absolute value of a negative purely real number\",\r\n          \"[cf88d7d3-ee74-4f4e-8a88-a1b0090ecb0c]\") {\r\n    const Complex c{-5.0, 0.0};\r\n\r\n    REQUIRE_THAT(c.abs(), Catch::Matchers::WithinAbs(5.0, eps));\r\n}\r\n\r\nTEST_CASE(\r\n    // clang-format off\r\n    \"Absolute value -> Absolute value of a purely imaginary number with positive imaginary part\",\r\n    // clang-format on\r\n    \"[bbe26568-86c1-4bb4-ba7a-da5697e2b994]\") {\r\n    const Complex c{0.0, 5.0};\r\n\r\n    REQUIRE_THAT(c.abs(), Catch::Matchers::WithinAbs(5.0, eps));\r\n}\r\n\r\nTEST_CASE(\r\n    // clang-format off\r\n    \"Absolute value -> Absolute value of a purely imaginary number with negative imaginary part\",\r\n    // clang-format on\r\n    \"[3b48233d-468e-4276-9f59-70f4ca1f26f3]\") {\r\n    const Complex c{0.0, -5.0};\r\n\r\n    REQUIRE_THAT(c.abs(), Catch::Matchers::WithinAbs(5.0, eps));\r\n}\r\n\r\nTEST_CASE(\r\n    \"Absolute value -> Absolute value of a number with real and imaginary part\",\r\n    \"[fe400a9f-aa22-4b49-af92-51e0f5a2a6d3]\") {\r\n    const Complex c{3.0, 4.0};\r\n\r\n    REQUIRE_THAT(c.abs(), Catch::Matchers::WithinAbs(5.0, eps));\r\n}\r\n\r\nTEST_CASE(\"Complex conjugate -> Conjugate a purely real number\",\r\n          \"[fb2d0792-e55a-4484-9443-df1eddfc84a2]\") {\r\n    const Complex c{5.0, 0.0};\r\n\r\n    REQUIRE_THAT(c.conj(), ComplexWithinAbs(Complex{5.0, 0.0}, eps));\r\n}\r\n\r\nTEST_CASE(\"Complex conjugate -> Conjugate a purely imaginary number\",\r\n          \"[e37fe7ac-a968-4694-a460-66cb605f8691]\") {\r\n    const Complex c{0.0, 5.0};\r\n\r\n    REQUIRE_THAT(c.conj(), ComplexWithinAbs(Complex{0.0, -5.0}, eps));\r\n}\r\n\r\nTEST_CASE(\r\n    \"Complex conjugate -> Conjugate a number with real and imaginary part\",\r\n    \"[f7704498-d0be-4192-aaf5-a1f3a7f43e68]\") {\r\n    const Complex c{1.0, 1.0};\r\n\r\n    REQUIRE_THAT(c.conj(), ComplexWithinAbs(Complex{1.0, -1.0}, eps));\r\n}\r\n\r\nTEST_CASE(\"Complex exponential function -> Euler's identity/formula\",\r\n          \"[6d96d4c6-2edb-445b-94a2-7de6d4caaf60]\") {\r\n    const Complex c{0.0, M_PI};\r\n\r\n    REQUIRE_THAT(c.exp(), ComplexWithinAbs(Complex{-1.0, 0.0}, eps));\r\n}\r\n\r\nTEST_CASE(\"Complex exponential function -> Exponential of 0\",\r\n          \"[2d2c05a0-4038-4427-a24d-72f6624aa45f]\") {\r\n    const Complex c{0.0, 0.0};\r\n\r\n    REQUIRE_THAT(c.exp(), ComplexWithinAbs(Complex{1.0, 0.0}, eps));\r\n}\r\n\r\nTEST_CASE(\"Complex exponential function -> Exponential of a purely real number\",\r\n          \"[ed87f1bd-b187-45d6-8ece-7e331232c809]\") {\r\n    const Complex c{1.0, 0.0};\r\n\r\n    REQUIRE_THAT(c.exp(), ComplexWithinAbs(Complex(M_E, 0.0), eps));\r\n}\r\n\r\n// Extra Credit\r\nTEST_CASE(\r\n    // clang-format off\r\n    \"Complex exponential function -> Exponential of a number with real and imaginary part\",\r\n    // clang-format on\r\n    \"[08eedacc-5a95-44fc-8789-1547b27a8702]\") {\r\n    const Complex c{std::log(2.0), M_PI};\r\n\r\n    REQUIRE_THAT(c.exp(), ComplexWithinAbs(Complex{-2.0, 0.0}, eps));\r\n}\r\n\r\nTEST_CASE(\r\n    // clang-format off\r\n    \"Complex exponential function -> Exponential resulting in a number with real and imaginary part\",\r\n    // clang-format on\r\n    \"[d2de4375-7537-479a-aa0e-d474f4f09859]\") {\r\n    const Complex c{std::log(2.0) / 2.0, M_PI / 4.0};\r\n\r\n    REQUIRE_THAT(c.exp(), ComplexWithinAbs(Complex{1.0, 1.0}, eps));\r\n}\r\n\r\nTEST_CASE(\r\n    // clang-format off\r\n    \"Operations between real numbers and complex numbers -> Add real number to complex number\",\r\n    // clang-format on\r\n    \"[06d793bf-73bd-4b02-b015-3030b2c952ec]\") {\r\n    const Complex c{1.0, 2.0};\r\n\r\n    REQUIRE_THAT(c + 5.0, ComplexWithinAbs(Complex{6.0, 2.0}, eps));\r\n}\r\n\r\nTEST_CASE(\r\n    // clang-format off\r\n    \"Operations between real numbers and complex numbers -> Add complex number to real number\",\r\n    // clang-format on\r\n    \"[d77dbbdf-b8df-43f6-a58d-3acb96765328]\") {\r\n    const Complex c{1.0, 2.0};\r\n\r\n    REQUIRE_THAT(5.0 + c, ComplexWithinAbs(Complex{6.0, 2.0}, eps));\r\n}\r\n\r\nTEST_CASE(\r\n    // clang-format off\r\n    \"Operations between real numbers and complex numbers -> Subtract real number from complex number\",\r\n    // clang-format on\r\n    \"[20432c8e-8960-4c40-ba83-c9d910ff0a0f]\") {\r\n    const Complex c{5.0, 7.0};\r\n\r\n    REQUIRE_THAT(c - 4.0, ComplexWithinAbs(Complex{1.0, 7.0}, eps));\r\n}\r\n\r\nTEST_CASE(\r\n    // clang-format off\r\n    \"Operations between real numbers and complex numbers -> Subtract complex number from real number\",\r\n    // clang-format on\r\n    \"[b4b38c85-e1bf-437d-b04d-49bba6e55000]\") {\r\n    const Complex c{5.0, 7.0};\r\n\r\n    REQUIRE_THAT(4.0 - c, ComplexWithinAbs(Complex{-1.0, -7.0}, eps));\r\n}\r\n\r\nTEST_CASE(\r\n    // clang-format off\r\n    \"Operations between real numbers and complex numbers -> Multiply complex number by real number\",\r\n    // clang-format on\r\n    \"[dabe1c8c-b8f4-44dd-879d-37d77c4d06bd]\") {\r\n    const Complex c{2.0, 5.0};\r\n\r\n    REQUIRE_THAT(c * 5.0, ComplexWithinAbs(Complex{10.0, 25.0}, eps));\r\n}\r\n\r\nTEST_CASE(\r\n    // clang-format off\r\n    \"Operations between real numbers and complex numbers -> Multiply real number by complex number\",\r\n    // clang-format on\r\n    \"[6c81b8c8-9851-46f0-9de5-d96d314c3a28]\") {\r\n    const Complex c{2.0, 5.0};\r\n\r\n    REQUIRE_THAT(5.0 * c, ComplexWithinAbs(Complex{10.0, 25.0}, eps));\r\n}\r\n\r\nTEST_CASE(\r\n    // clang-format off\r\n    \"Operations between real numbers and complex numbers -> Divide complex number by real number\",\r\n    // clang-format on\r\n    \"[8a400f75-710e-4d0c-bcb4-5e5a00c78aa0]\") {\r\n    const Complex c{10.0, 100.0};\r\n\r\n    REQUIRE_THAT(c / 10.0, ComplexWithinAbs(Complex{1.0, 10.0}, eps));\r\n}\r\n\r\nTEST_CASE(\r\n    // clang-format off\r\n    \"Operations between real numbers and complex numbers -> Divide real number by complex number\",\r\n    // clang-format on\r\n    \"[9a867d1b-d736-4c41-a41e-90bd148e9d5e]\") {\r\n    const Complex c{1.0, 1.0};\r\n\r\n    REQUIRE_THAT(5.0 / c, ComplexWithinAbs(Complex{2.5, -2.5}, eps));\r\n}\r\n\r\n#endif\r\n"
  }
}