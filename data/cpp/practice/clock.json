{
  "language": "cpp",
  "slug": "clock",
  "docs": {
    "introduction": "",
    "instructions": "# Instructions\r\n\r\nImplement a clock that handles times without dates.\r\n\r\nYou should be able to add and subtract minutes to it.\r\n\r\nTwo clocks that represent the same time should be equal to each other.\r\n",
    "hints": ""
  },
  "starter_code": {
    "clock.cpp": "#include \"clock.h\"\r\n\r\nnamespace date_independent {\r\n\r\n// TODO: add your solution here\r\n\r\n}  // namespace date_independent\r\n",
    "clock.h": "#pragma once\r\n\r\nnamespace date_independent {\r\n\r\n// TODO: add your solution here\r\n\r\n}  // namespace date_independent\r\n"
  },
  "tests": {
    "clock_test.cpp": "#include \"clock.h\"\r\n#ifdef EXERCISM_TEST_SUITE\r\n#include <catch2/catch.hpp>\r\n#else\r\n#include \"test/catch.hpp\"\r\n#endif\r\n#include <sstream>\r\n\r\nusing namespace std;\r\n\r\nstruct timeTest {\r\n    int hour;\r\n    int minute;\r\n    string expected;\r\n    string msg;\r\n};\r\n\r\nvector<timeTest> timeCases = {\r\n    {8, 0, \"08:00\", \"on the hour\"},\r\n    {11, 9, \"11:09\", \"past the hour\"},\r\n    {24, 0, \"00:00\", \"midnight is zero hours\"},\r\n    {25, 0, \"01:00\", \"hour rolls over\"},\r\n    {100, 0, \"04:00\", \"hour rolls over continuously\"},\r\n    {1, 60, \"02:00\", \"sixty minutes is next hour\"},\r\n    {0, 160, \"02:40\", \"minutes roll over\"},\r\n    {0, 1723, \"04:43\", \"minutes roll over continuously\"},\r\n    {25, 160, \"03:40\", \"hour and minutes roll over\"},\r\n    {201, 3001, \"11:01\", \"hour and minutes roll over continuously\"},\r\n    {72, 8640, \"00:00\", \"hour and minutes roll over to exactly midnight\"},\r\n    {-1, 15, \"23:15\", \"negative hour\"},\r\n    {-25, 0, \"23:00\", \"negative hour rolls over\"},\r\n    {-91, 0, \"05:00\", \"negative hour rolls over continuously\"},\r\n    {1, -40, \"00:20\", \"negative minutes\"},\r\n    {1, -160, \"22:20\", \"negative minutes roll over\"},\r\n    {1, -4820, \"16:40\", \"negative minutes roll over continuously\"},\r\n    {-25, -160, \"20:20\", \"negative hour and minutes both roll over\"},\r\n    {-121, -5810, \"22:10\",\r\n     \"negative hour and minutes both roll over continuously\"},\r\n};\r\n\r\nstruct addTest {\r\n    int hour;\r\n    int minute;\r\n    int add;\r\n    string expected;\r\n    string msg;\r\n};\r\n\r\nvector<addTest> addCases = {\r\n    {10, 0, 3, \"10:03\", \"add minutes\"},\r\n    {6, 41, 0, \"06:41\", \"add no minutes\"},\r\n    {0, 45, 40, \"01:25\", \"add to next hour\"},\r\n    {10, 0, 61, \"11:01\", \"add more than one hour\"},\r\n    {0, 45, 160, \"03:25\", \"add more than two hours with carry\"},\r\n    {23, 59, 2, \"00:01\", \"add across midnight\"},\r\n    {5, 32, 1500, \"06:32\", \"add more than one day (1500 min = 25 hrs)\"},\r\n    {1, 1, 3500, \"11:21\", \"add more than two days\"},\r\n    {10, 3, -3, \"10:00\", \"subtract minutes\"},\r\n    {10, 3, -30, \"09:33\", \"subtract to previous hour\"},\r\n    {10, 3, -70, \"08:53\", \"subtract more than an hour\"},\r\n    {0, 3, -4, \"23:59\", \"subtract across midnight\"},\r\n    {0, 0, -160, \"21:20\", \"subtract more than two hours\"},\r\n    {6, 15, -160, \"03:35\", \"subtract more than two hours with borrow\"},\r\n    {5, 32, -1500, \"04:32\", \"subtract more than one day (1500 min = 25 hrs)\"},\r\n    {2, 20, -3000, \"00:20\", \"subtract more than two days\"},\r\n};\r\n\r\n// Construct two separate clocks, set times, test if they are equal.\r\nstruct hm {\r\n    int hour;\r\n    int minute;\r\n};\r\n\r\nstruct equalTest {\r\n    string msg;\r\n    hm c1;\r\n    hm c2;\r\n    bool expected;\r\n};\r\n\r\nvector<equalTest> equalCases = {\r\n    {\r\n        \"clocks with same time\",\r\n        hm{15, 37},\r\n        hm{15, 37},\r\n        true,\r\n    },\r\n    {\r\n        \"clocks a minute apart\",\r\n        hm{15, 36},\r\n        hm{15, 37},\r\n        false,\r\n    },\r\n    {\r\n        \"clocks an hour apart\",\r\n        hm{14, 37},\r\n        hm{15, 37},\r\n        false,\r\n    },\r\n    {\r\n        \"clocks with hour overflow\",\r\n        hm{10, 37},\r\n        hm{34, 37},\r\n        true,\r\n    },\r\n    {\r\n        \"clocks with hour overflow by several days\",\r\n        hm{3, 11},\r\n        hm{99, 11},\r\n        true,\r\n    },\r\n    {\r\n        \"clocks with negative hour\",\r\n        hm{22, 40},\r\n        hm{-2, 40},\r\n        true,\r\n    },\r\n    {\r\n        \"clocks with negative hour that wraps\",\r\n        hm{17, 3},\r\n        hm{-31, 3},\r\n        true,\r\n    },\r\n    {\r\n        \"clocks with negative hour that wraps multiple times\",\r\n        hm{13, 49},\r\n        hm{-83, 49},\r\n        true,\r\n    },\r\n    {\r\n        \"clocks with minute overflow\",\r\n        hm{0, 1},\r\n        hm{0, 1441},\r\n        true,\r\n    },\r\n    {\r\n        \"clocks with minute overflow by several days\",\r\n        hm{2, 2},\r\n        hm{2, 4322},\r\n        true,\r\n    },\r\n    {\r\n        \"clocks with negative minute\",\r\n        hm{2, 40},\r\n        hm{3, -20},\r\n        true,\r\n    },\r\n    {\r\n        \"clocks with negative minute that wraps\",\r\n        hm{4, 10},\r\n        hm{5, -1490},\r\n        true,\r\n    },\r\n    {\r\n        \"clocks with negative minute that wraps multiple times\",\r\n        hm{6, 15},\r\n        hm{6, -4305},\r\n        true,\r\n    },\r\n    {\r\n        \"clocks with negative hours and minutes\",\r\n        hm{7, 32},\r\n        hm{-12, -268},\r\n        true,\r\n    },\r\n    {\r\n        \"clocks with negative hours and minutes that wrap\",\r\n        hm{18, 7},\r\n        hm{-54, -11513},\r\n        true,\r\n    },\r\n};\r\n\r\nstring errorMsg(string expected, string actual, string test) {\r\n    stringstream ret;\r\n    ret << \"[\" << expected << \" != \" << actual << \"] test case: \" << test;\r\n    return ret.str();\r\n}\r\n\r\nTEST_CASE(\"time_tests\") {\r\n    for (timeTest t : timeCases) {\r\n        const auto actual =\r\n            string(date_independent::clock::at(t.hour, t.minute));\r\n\r\n        INFO(errorMsg(t.expected, actual, t.msg));\r\n        REQUIRE(t.expected == actual);\r\n    }\r\n}\r\n\r\n#if defined(EXERCISM_RUN_ALL_TESTS)\r\nTEST_CASE(\"add_tests\") {\r\n    for (addTest a : addCases) {\r\n        const auto actual =\r\n            string(date_independent::clock::at(a.hour, a.minute).plus(a.add));\r\n\r\n        INFO(errorMsg(a.expected, actual, a.msg));\r\n        REQUIRE(a.expected == actual);\r\n    }\r\n}\r\n\r\nTEST_CASE(\"equal_tests\") {\r\n    for (equalTest e : equalCases) {\r\n        const auto clock1 = date_independent::clock::at(e.c1.hour, e.c1.minute);\r\n        const auto clock2 = date_independent::clock::at(e.c2.hour, e.c2.minute);\r\n\r\n        if (e.expected) {\r\n            INFO(errorMsg(string(clock1), string(clock2), e.msg));\r\n            REQUIRE(clock1 == clock2);\r\n        } else {\r\n            INFO(\"[\" << string(clock1) << \" == \" << string(clock2)\r\n                     << \"] test case: \" << e.msg);\r\n            REQUIRE(clock1 != clock2);\r\n        }\r\n    }\r\n}\r\n#endif\r\n"
  }
}