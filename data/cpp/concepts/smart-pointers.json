{
  "language": "cpp",
  "slug": "smart-pointers",
  "title": "Smart Pointers",
  "docs": {
    "about": "# Introduction\r\n\r\nSmart pointers are a modern C++ feature designed to provide automatic memory management, helping to prevent memory leaks and dangling pointers commonly associated with raw pointers.\r\nThey act as wrappers around raw pointers, adding additional functionality such as automatic memory deallocation when the pointer is no longer needed.\r\n\r\n## General Syntax\r\n\r\nSmart pointers are typically implemented as class templates in the C++ standard library.\r\nThe two most commonly used smart pointers are `std::unique_ptr` and `std::shared_ptr`.\r\n\r\n## Unique Pointers\r\n\r\n`std::unique_ptr` is a smart pointer that owns the object exclusively.\r\nIt ensures that at any given time, only one `std::unique_ptr` object owns the resource.\r\nWhen the owning `std::unique_ptr` is destroyed or reset, it automatically destructs the objects and releases its memory.\r\n\r\n```cpp\r\n#include <memory>\r\n// Declaring and defining a unique pointer\r\nauto rightful_king_of_england = std::make_unique<std::string>(\"Excalibur\");\r\n\r\n// Unique pointers cannot be copied or assigned\r\nauto mordred = rightful_king_of_england; // Error: Cannot copy a unique_ptr\r\n```\r\n\r\n## Advantages of `std::make_unique()`\r\n\r\nWhen creating a `std::unique_ptr`, it's preferable to use `std::make_unique()` instead of directly using `new` to allocate memory.\r\n`std::make_unique()` provides several advantages:\r\n1. **Exception Safety**: `std::make_unique()` guarantees exception safety.\r\n  If an exception is thrown during the construction of the object, memory will be automatically deallocated, preventing memory leaks.\r\n2. **Clarity**: Using `std::make_unique()` makes code clearer and more concise.\r\n  It eliminates the need to explicitly specify the type being allocated, as the template arguments are deduced automatically.\r\n3. **Optimization Opportunities**: Compilers have the opportunity to optimize `std::make_unique()` more effectively than manually allocating memory with `new`, potentially resulting in improved performance.\r\n4. **Avoiding Misuse**: Deleting the underlying resource is possible, when the `std::unique_ptr` is constructed manually.\r\n  That would lead to undefined behavior, when the `std::unique_ptr` tries to delete it at its end of scope.\r\n\r\n## Shared Pointers\r\n\r\n`std::shared_ptr` is a smart pointer that allows multiple `std::shared_ptr` objects to share ownership of the same resource.\r\nIt keeps track of how many shared pointers are referencing the resource, and deallocates the memory only when the last shared pointer owning the resource goes out of scope or is reset.\r\n\r\n```cpp\r\n// Declaring and defining a shared pointer to a dynamically allocated string\r\nauto martian_congressional_republic = std::make_shared<std::string>(\"protomolecule\");\r\n\r\n// Creating more shared pointer that shares ownership\r\nauto outer_planets_alliance = martian_congressional_republic;\r\nauto united_nations = martian_congressional_republic;\r\n```\r\n\r\n~~~~exercism/caution\r\nIn C++17 and below, using `std::shared_ptr` with arrays via `std::make_shared<T[]>` is not directly supported.\r\nWhile it's possible to allocate arrays with `std::make_shared<T[]>`, creating shared pointers directly from them may lead to undefined behavior due to differences in memory management between single objects and arrays.\r\nInstead, consider using `std::vector` or custom deletion functions to manage arrays with shared pointers effectively.\r\nAlways ensure compatibility with your compiler and standard library implementation when dealing with array allocations and shared pointers in C++17.\r\n~~~~\r\n\r\n## Advantages of `std::make_shared()`\r\n\r\nSimilar to `std::make_unique()`, `std::make_shared()` offers benefits such as improved memory efficiency, exception safety, and readability.\r\nIt combines memory allocation for the control block and the managed object into a single operation, enhancing efficiency and reducing the risk of memory leaks.\r\nAdditionally, automatic deduction of template arguments simplifies code and enhances readability.\r\nUsing `std::make_shared()` promotes cleaner, safer, and more efficient code when working with `std::shared_ptr` objects in C++.\r\n\r\n## Weak Pointers\r\n\r\n`std::weak_ptr` is a companion class to `std::shared_ptr` that provides a non-owning \"weak\" reference to an object managed by a shared pointer.\r\nIt allows access to the resource without affecting its lifetime.\r\nWeak pointers are useful in scenarios where cyclic references need to be broken to prevent memory leaks.\r\n\r\n```cpp\r\n// Creating a shared pointer\r\nauto your_account = std::make_shared<std::string>(\"secret_subscription_password\");\r\n// Creating a shared pointer that shares ownership\r\nauto your_flatmates_account = your_account;\r\n\r\n// Creating a weak pointer from the shared pointer\r\nauto your_flatmates_boyfriends_account = your_flatmates_account;\r\n// if your_account and your_flatmates_account are deleted, there is no more reference to the shared pointer.\r\n// your_flatmates_boyfriends_account will be a null pointer and cannot use the associated object any longer.\r\n```\r\n\r\n## `std::weak_ptr` and Cyclic Ownership\r\n\r\n`std::weak_ptr` was designed to address the issue of cyclic ownership, also known as circular references, that can occur when using `std::shared_ptr`.\r\n\r\nIn a cyclic ownership scenario, two or more `std::shared_ptr` objects are referencing each other, creating a cycle where none of the objects can be deleted because they have strong references to each other, leading to memory leaks.\r\n\r\n`std::weak_ptr` provides a solution to this problem by allowing weak references to shared objects without contributing to their reference count.\r\nThis means that it can observe and access the shared object but doesn't prevent it from being deleted.\r\nIf all strong references to the shared object are released, the object is destroyed, and weak pointers observing it are automatically reset to `nullptr`.\r\n\r\nHere's a short example demonstrating the use of `std::weak_ptr` to break cyclic ownership:\r\n\r\n```cpp\r\nstruct Node {\r\n    Node() { std::cout << \"Node constructed\\n\"; }\r\n    ~Node() { std::cout << \"Node destructed\\n\"; }\r\n\r\n    std::weak_ptr<Node> next;\r\n};\r\n\r\n// Creating two nodes\r\nauto node1 = std::make_shared<Node>();\r\nauto node2 = std::make_shared<Node>();\r\n\r\n// Creating a cycle by making each node point to the other\r\nnode1->next = node2;\r\nnode2->next = node1;\r\n\r\n// Release strong references to nodes\r\nnode1.reset();\r\nnode2.reset();\r\n\r\n// Nodes are automatically destructed due to weak references\r\n```\r\n\r\n\"Node constructed\" is printed twice, followed by two lines of \"Node destructed\".\r\n\r\nWhen `next` is not a weak pointer but a `std::shared_ptr`, it creates a cyclic ownership situation, leading to memory leaks because both nodes will hold strong references to each other, preventing their destruction.\r\n\r\n```cpp\r\nstruct Node {\r\n    Node() { std::cout << \"Node constructed\\n\"; }\r\n    ~Node() { std::cout << \"Node destructed\\n\"; }\r\n\r\n    std::shared_ptr<Node> next; // Change to shared_ptr\r\n};\r\n```\r\n\r\nIn this scenario, both `node1` and `node2` hold strong references to each other through `std::shared_ptr`, forming a cycle.\r\nWhen the program exits and attempts to release the strong references with `reset()`, the reference counts of both nodes remain non-zero because each node holds a strong reference to the other.\r\nTherefore, the nodes are not destructed, leading to memory leaks.\r\n\"Node constructed\" is printed twice, but it is not followed by any line of \"Node destructed\".\r\n\r\n## Dangling pointers and `std::weak_ptr`\r\n\r\nDangling pointers occur when a pointer references an object that has been deleted, leading to undefined behavior when the pointer is dereferenced.\r\n`std::weak_ptr` helps avoid dangling pointers by providing a non-owning, weak reference to an object managed by `std::shared_ptr`.\r\nHere's how to avoid dangling pointers with `std::weak_ptr`:\r\n\r\n1. **Create a `std::weak_ptr`**: Instead of directly holding a `std::shared_ptr`, create a `std::weak_ptr` to the shared object.\r\n\r\n2. **Check for Validity**: Before using the `std::weak_ptr`, check its validity using the `expired()` function.\r\n  This function returns `true` if the associated shared object has been deleted.\r\n\r\n3. **Lock the `std::weak_ptr`**: To access the shared object safely, use the `lock()` function, which returns a `std::shared_ptr` pointing to the same object if it is still valid.\r\n  If the object has been deleted, `lock()` returns an empty `std::shared_ptr`.\r\n\r\nHere's a code example demonstrating the use of `std::weak_ptr` to avoid dangling pointers:\r\n\r\n```cpp\r\nauto node1 = std::make_shared<Node>();\r\nauto node2 = std::make_shared<Node>();\r\n\r\n// Create weak pointers\r\nnode1->next = node2;\r\nnode2->next = node1;\r\n\r\n// Check validity and lock\r\nif (auto lockedNode2 = node1->next.lock()) {\r\n    // Use lockedNode2 safely\r\n} else {\r\n    // Handle case where node2 has been deleted\r\n}\r\n```\r\n\r\nIn this example, `node1->next` and `node2->next` are `std::weak_ptr` objects.\r\nBefore accessing the shared object, validity is checked using the `expired()` function.\r\nThen, `lock()` is used to safely access the shared object.\r\nThis approach ensures that dangling pointers are avoided when working with `std::weak_ptr`.\r\n\r\n## Usage advice\r\n\r\nUse smart pointers by default: `std::unique_ptr` for exclusive ownership and `std::shared_ptr` for shared ownership.\r\nReserve raw pointers for non-owning references or when interfacing with legacy code.\r\nIn most cases, `std::unique_ptr` is sufficient for exclusive ownership, as it offers lightweight memory management without the overhead of reference counting.\r\n`std::shared_ptr` should be used sparingly, as it introduces overhead and complexity unless true shared ownership is needed.\r\n`std::weak_ptr` is specialized for breaking cyclic dependencies or observing shared objects, but it's not commonly used.\r\n",
    "introduction": "# Introduction\r\n\r\nSmart pointers are a modern C++ feature designed to provide automatic memory management, helping to prevent memory leaks and dangling pointers commonly associated with raw pointers.\r\nThey act as wrappers around raw pointers, adding additional functionality such as automatic memory deallocation when the pointer is no longer needed.\r\n\r\n## General Syntax\r\n\r\nSmart pointers are typically implemented as class templates in the C++ standard library.\r\nThe two most commonly used smart pointers are `std::unique_ptr` and `std::shared_ptr`.\r\n\r\n## Unique Pointers\r\n\r\n`std::unique_ptr` is a smart pointer that owns the object exclusively.\r\nIt ensures that at any given time, only one `std::unique_ptr` object owns the resource.\r\nWhen the owning `std::unique_ptr` is destroyed or reset, it automatically destructs the objects and releases its memory.\r\n\r\n```cpp\r\n#include <memory>\r\n// Declaring and defining a unique pointer\r\nauto rightful_king_of_england = std::make_unique<std::string>(\"Excalibur\");\r\n\r\n// Unique pointers cannot be copied or assigned\r\nauto mordred = rightful_king_of_england; // Error: Cannot copy a unique_ptr\r\n```\r\n\r\n## Advantages of `std::make_unique()`\r\n\r\nWhen creating a `std::unique_ptr`, it's preferable to use `std::make_unique()` instead of directly using `new` to allocate memory.\r\n`std::make_unique()` provides several advantages:\r\n1. **Exception Safety**: `std::make_unique()` guarantees exception safety.\r\n  If an exception is thrown during the construction of the object, memory will be automatically deallocated, preventing memory leaks.\r\n2. **Clarity**: Using `std::make_unique()` makes code clearer and more concise.\r\n  It eliminates the need to explicitly specify the type being allocated, as the template arguments are deduced automatically.\r\n3. **Optimization Opportunities**: Compilers have the opportunity to optimize `std::make_unique()` more effectively than manually allocating memory with `new`, potentially resulting in improved performance.\r\n4. **Avoiding Misuse**: Deleting the underlying resource is possible, when the `std::unique_ptr` is constructed manually.\r\n  That would lead to undefined behavior, when the `std::unique_ptr` tries to delete it at its end of scope.\r\n\r\n## Shared Pointers\r\n\r\n`std::shared_ptr` is a smart pointer that allows multiple `std::shared_ptr` objects to share ownership of the same resource.\r\nIt keeps track of how many shared pointers are referencing the resource, and deallocates the memory only when the last shared pointer owning the resource goes out of scope or is reset.\r\n\r\n```cpp\r\n// Declaring and defining a shared pointer to a dynamically allocated string\r\nauto martian_congressional_republic = std::make_shared<std::string>(\"protomolecule\");\r\n\r\n// Creating more shared pointer that shares ownership\r\nauto outer_planets_alliance = martian_congressional_republic;\r\nauto united_nations = martian_congressional_republic;\r\n```\r\n\r\n~~~~exercism/caution\r\nIn C++17 and below, using `std::shared_ptr` with arrays via `std::make_shared<T[]>` is not directly supported.\r\nWhile it's possible to allocate arrays with `std::make_shared<T[]>`, creating shared pointers directly from them may lead to undefined behavior due to differences in memory management between single objects and arrays.\r\nInstead, consider using `std::vector` or custom deletion functions to manage arrays with shared pointers effectively.\r\nAlways ensure compatibility with your compiler and standard library implementation when dealing with array allocations and shared pointers in C++17.\r\n~~~~\r\n\r\n## Advantages of `std::make_shared()`\r\n\r\nSimilar to `std::make_unique()`, `std::make_shared()` offers benefits such as improved memory efficiency, exception safety, and readability.\r\nIt combines memory allocation for the control block and the managed object into a single operation, enhancing efficiency and reducing the risk of memory leaks.\r\nAdditionally, automatic deduction of template arguments simplifies code and enhances readability.\r\nUsing `std::make_shared()` promotes cleaner, safer, and more efficient code when working with `std::shared_ptr` objects in C++.\r\n\r\n\r\n~~~~exercism/advanced\r\n## Weak Pointers\r\n\r\n`std::weak_ptr` is a companion class to `std::shared_ptr` that provides a non-owning \"weak\" reference to an object managed by a shared pointer.\r\n\r\n```cpp\r\n// Creating a shared pointer\r\nauto your_account = std::make_shared<std::string>(\"secret_subscription_password\");\r\n// Creating a shared pointer that shares ownership\r\nauto your_flatmates_account = your_account;\r\n\r\n// Creating a weak pointer from the shared pointer\r\nauto your_flatmates_boyfriends_account = your_flatmates_account;\r\n// if your_account and your_flatmates_account are deleted, there is no more reference to the shared pointer.\r\n// your_flatmates_boyfriends_account will be a null pointer and cannot use the associated object any longer.\r\n```\r\n\r\nWeak pointers are useful in scenarios where cyclic references need to be broken to prevent memory leaks.\r\n`std::weak_ptr` was designed to address the issue of cyclic ownership, also known as circular references, that can occur when using `std::shared_ptr`.\r\nIn a cyclic ownership scenario, two or more `std::shared_ptr` objects are referencing each other, creating a cycle where none of the objects can be deleted because they have strong references to each other, leading to memory leaks.\r\n`std::weak_ptr` provides a solution to this problem by allowing weak references to shared objects without contributing to their reference count.\r\nThis means that it can observe and access the shared object but doesn't prevent it from being deleted.\r\n~~~~\r\n\r\n## Usage advice\r\n\r\nUse smart pointers by default: `std::unique_ptr` for exclusive ownership and `std::shared_ptr` for shared ownership.\r\nReserve raw pointers for non-owning references or when interfacing with legacy code.\r\nIn most cases, `std::unique_ptr` is sufficient for exclusive ownership, as it offers lightweight memory management without the overhead of reference counting.\r\n`std::shared_ptr` should be used sparingly, as it introduces overhead and complexity unless true shared ownership is needed.\r\n`std::weak_ptr` is specialized for breaking cyclic dependencies or observing shared objects, but it's not commonly used.\r\n"
  },
  "meta": {
    "blurb": "Smart pointers in C++ provide automatic memory management, reducing memory leaks and dangling pointers by ensuring proper allocation and deallocation.",
    "authors": [
      "vaeng"
    ]
  },
  "links": [
    {
      "url": "https://en.cppreference.com/w/cpp/memory/unique_ptr",
      "description": "C++ reference on std::unique_ptr"
    },
    {
      "url": "https://en.cppreference.com/w/cpp/memory/shared_ptr",
      "description": "C++ reference on std::shared_ptr"
    },
    {
      "url": "https://en.cppreference.com/w/cpp/memory/weak_ptr",
      "description": "C++ reference on std::weak_ptr"
    }
  ]
}