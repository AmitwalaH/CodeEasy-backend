{
  "language": "cpp",
  "slug": "headers",
  "title": "Headers",
  "docs": {
    "about": "# About\r\n\r\nIn C++, declarations are often separated from definitions.\r\nDeclarations are grouped into so-called header files, with the respective implementations placed in source files.\r\nYou can think of the header files as an API.\r\nThe header file will tell you _what_ a codebase has to offer without going into the details of _how_.\r\n\r\n## Header and Source\r\n\r\nThe most common file extension for header files is `.h`.\r\nSome projects use `.hpp` or skip the extension completely.\r\n\r\nThe definitions are located in a separate `.cpp` file.\r\nTo reunite the parts, the source file starts by _including_ the respective header file.\r\n\r\nIf you want to write a library called \"quick_math\" that offers a function \"super_root\" that you want to use often, the files would look like this:\r\n\r\n```cpp\r\n// A file named quick_math.h\r\n#pragma once\r\n\r\nnamespace quick_math {\r\n\r\ndouble super_root(double x, int n);\r\n\r\n}\r\n```\r\n\r\n```cpp\r\n// A file named quick_math.cpp\r\n#include <cmath>\r\n\r\n#include \"quick_math.h\"\r\n\r\ndouble quick_math::super_root(double x, int n) {\r\n    while (n) {\r\n        x = std::sqrt(x), --n;\r\n    }\r\n    return x;\r\n}\r\n```\r\n\r\nIf you need to include a header that is only required by the implementation, the respective `#include` line is only needed in the source file.\r\nEverything that is included in the header is also available in the `.cpp` file, like the `string` library in the example below.\r\n**Attention**: the `;` is needed after the declaration in the header file, but not after the definition in the source file.\r\n\r\n~~~~exercism/note\r\nMany C++ exercises on Exercism start with two almost empty files: header and source.\r\nYou have to check the `*_test.cpp` file to see the names and namespaces of the expected functions in order to solve the exercise.\r\n~~~~\r\n\r\n## Classes and Headers\r\n\r\nClasses can become very complex and their relation to the header / source partition might be confusing.\r\nOne possible layout is to keep all the implementation details in the source file and all the declarations and member variables in the header:\r\n\r\n```cpp\r\n// A file named robot_flower.h\r\n#if !defined(ROBOT_FLOWER_H)\r\n#define ROBOT_FLOWER_H\r\n\r\n#include <string>\r\n\r\nnamespace robots {\r\n\r\nclass Flower {\r\n   private:\r\n    bool needs_water{};\r\n    int size{};\r\n    std::string name{};\r\n\r\n   public:\r\n    Flower(std::string name, int size = 0);\r\n    void give_water();\r\n    std::string get_name();\r\n    int get_size();\r\n    void start_next_day();\r\n};\r\n}  // namespace robots\r\n#endif\r\n```\r\n\r\n```cpp\r\n// A file named robot_flower.cpp\r\n#include \"robot_flower.h\"\r\n\r\nrobots::Flower::Flower(std::string name, int size) {\r\n    this->name = \"Robotica \" + name;\r\n    this->size = size;\r\n}\r\n\r\nvoid robots::Flower::start_next_day() {\r\n    if (!needs_water) ++size;\r\n    needs_water = true;\r\n}\r\n\r\nstd::string robots::Flower::get_name() { return name; }\r\n\r\nint robots::Flower::get_size() { return size; }\r\n```\r\n\r\nWhen the header is used as an API overview, that is where a person would look for information like default values.\r\nThe `size` parameter's default of the constructor is therefore handled in the header and not in the implementation.\r\nThe definitions in the source file are prefixed with the namespace `robots` and the class type `Flower`.\r\n\r\nAnother layout option is a _header only_ library, that does not have a `.cpp` file at all:\r\n\r\n```cpp\r\n// A file named robot_flower.h\r\n#pragma once\r\n\r\n#include <string>\r\n\r\nnamespace robots {\r\n\r\nclass Flower {\r\n   private:\r\n    bool needs_water{};\r\n    int size{};\r\n    std::string name{};\r\n\r\n   public:\r\n    Flower(std::string name, int size = 0) {\r\n        this->name = \"Robotica \" + name;\r\n        this->size = size;\r\n    }\r\n    void give_water() { needs_water = false; }\r\n    std::string get_name() { return name; }\r\n    int get_size() { return size; }\r\n    void start_next_day() {\r\n        if (!needs_water) ++size;\r\n        needs_water = true;\r\n    }\r\n};\r\n}  // namespace robots\r\n```\r\n\r\nProjects might use combinations of these layouts and there is a lot of discussion as to what might be the best fit for each use case.\r\n\r\n## Include Guards\r\n\r\nYou may have noticed the `#pragma once` line in the example header file above.\r\nThis is called an include guard - and it ensures that the content of the file is included only once during the compilation to avoid errors.\r\nThere is another, more complex variation of an include guard that starts with `#ifndef` and ends with `#endif`, that is detailed below.\r\n\r\n\r\n~~~~exercism/advanced\r\n## Forward Declarations\r\nC++ code is evaluated procedurally.\r\nIf you want to use a function, it has to be known to the compiler at the moment of usage.\r\nSometimes it is not possible to find a linear fashion to lay out the definitions in the source code.\r\nTake a look at the example below:\r\n\r\n```cpp\r\nint myFunction(int n) {\r\n    if (n < 10) {\r\n        return n;\r\n    } else {\r\n        return myOtherFunction(n / 10);\r\n    }\r\n}\r\n\r\nint myOtherFunction(int m) { return myFunction(m / 2); }\r\n```\r\n\r\nWhen `myFunction` is defined, the compiler does not know about `myOtherFunction` yet.\r\nUnfortunately, the circle-reference problem cannot be solved by switching the order.\r\n\r\nC++ offers **forward declarations** to let the compiler know of `myFunction` and `myOtherFunction` before they are defined.\r\nThe compiler assumes that the definition will follow at some later point after the declaration.\r\nThe next example shows how a forward declaration is used for functions.\r\n\r\n```cpp\r\nint myFunction(int n);       // Forward declaration of myFunction\r\nint myOtherFunction(int m);  // Forward declaration of myOtherFunction\r\n\r\n// Definition of myFunction\r\nint myFunction(int n) {\r\n    if (n < 0) {\r\n        return 0;\r\n    } else {\r\n        return myOtherFunction(n - 2);\r\n    }\r\n}\r\n\r\n// Definition of myOtherFunction\r\nint myOtherFunction(int m) { return myFunction(m / 2); }\r\n```\r\n\r\n## Include Guards via ifndef\r\n\r\nIt does not matter if the same file is included multiple times within a project.\r\nHeader files should not contain definitions.\r\nThe complete project cannot have the same definition more than once.\r\nThis is called the \"One definition rule\".\r\nIt will be enforced by the compiler.\r\n\r\nIt is easy to avoid multiple unintended inclusions of the same definition with include guards.\r\nThey are formed by a special procedure during the compilation stages.\r\nThe aim is to only include a file only if a certain variable has not been set and then set it once the file is included.\r\nOften the sequence of this variable is chosen as a variation of the name of the file.\r\nAnother method is the generation of a UUID to reduce the risk of accidentally using the sequence twice.\r\nThe syntax can be seen below with `MY_HEADER_FILE_H` as a variable.\r\n\r\n```cpp\r\n#ifndef MY_HEADER_FILE_H /* any name uniquely mapped to file name */\r\n#define MY_HEADER_FILE_H\r\n\r\n// file content\r\n\r\n#endif\r\n```\r\n\r\nThe problem with `#pragma once` is, that pragmas are not an official part of the C++ language and the implementation differs from compiler to compiler.\r\nMany big projects have switched to the simpler pragma method, but a few are still cautious.\r\n~~~~\r\n",
    "introduction": "# Introduction\r\n\r\nIn C++, declarations are often separated from definitions.\r\nDeclarations are grouped into so-called header files, with the respective implementations placed in source files.\r\nYou can think of the header files as an API.\r\nThe header file will tell you _what_ a codebase has to offer without going into the details of _how_.\r\n\r\n## Header and Source\r\n\r\nThe most common file extension for header files is `.h`.\r\nSome projects use `.hpp` or skip the extension completely.\r\n\r\nThe definitions are located in a separate `.cpp` file.\r\nTo reunite the parts, the source file starts by _including_ the respective header file.\r\n\r\nIf you want to write a library called \"quick_math\" that offers a function \"super_root\" that you want to use often, the files would look like this:\r\n\r\n```cpp\r\n// A file named quick_math.h\r\n#pragma once\r\n\r\nnamespace quick_math {\r\n\r\ndouble super_root(double x, int n);\r\n\r\n}  // namespace quick_math\r\n```\r\n\r\n```cpp\r\n// A file named quick_math.cpp\r\n#include <cmath>\r\n\r\n#include \"quick_math.h\"\r\n\r\ndouble quick_math::super_root(double x, int n) {\r\n    while (n) {\r\n        x = std::sqrt(x), --n;\r\n    }\r\n    return x;\r\n}\r\n```\r\n\r\nIf you need to include a header that is only required by the implementation, the respective `#include` line is only needed in the source file.\r\nEverything that is included in the header is also available in the `.cpp` file, like the `string` library in the example below.\r\n**Attention**: the `;` is needed after the declaration in the header file, but not after the definition in the source file.\r\n\r\n~~~~exercism/note\r\nMany C++ exercises on Exercism start with two almost empty files: header and source.\r\nYou have to check the `*_test.cpp` file to see the names and namespaces of the expected functions in order to solve the exercise.\r\n~~~~\r\n\r\n## Classes and Headers\r\n\r\nClasses can become very complex and their relation to the header / source partition might be confusing.\r\nOne possible layout is to keep all the implementation details in the source file and all the declarations and member variables in the header:\r\n\r\n```cpp\r\n// A file named robot_flower.h\r\n#if !defined(ROBOT_FLOWER_H)\r\n#define ROBOT_FLOWER_H\r\n\r\n#include <string>\r\n\r\nnamespace robots {\r\n\r\nclass Flower {\r\n   private:\r\n    bool needs_water{};\r\n    int size{};\r\n    std::string name{};\r\n\r\n   public:\r\n    Flower(std::string name, int size = 0);\r\n    void give_water();\r\n    std::string get_name();\r\n    int get_size();\r\n    void start_next_day();\r\n};\r\n\r\n}  // namespace robots\r\n\r\n#endif\r\n```\r\n\r\n```cpp\r\n// A file named robot_flower.cpp\r\n#include \"robot_flower.h\"\r\n\r\nrobots::Flower::Flower(std::string name, int size) {\r\n    this->name = \"Robotica \" + name;\r\n    this->size = size;\r\n}\r\n\r\nvoid robots::Flower::start_next_day() {\r\n    if (!needs_water) {\r\n        ++size;\r\n    }\r\n    needs_water = true;\r\n}\r\n\r\nstd::string robots::Flower::get_name() { return name; }\r\n\r\nint robots::Flower::get_size() { return size; }\r\n```\r\n\r\nWhen the header is used as an API overview, that is where a person would look for information like default values.\r\nThe `size` parameter's default of the constructor is therefore handled in the header and not in the implementation.\r\nThe definitions in the source file are prefixed with the namespace `robots` and the class type `Flower`.\r\n\r\nAnother layout option is a _header only_ library, that does not have a `.cpp` file at all:\r\n\r\n```cpp\r\n// A file named robot_flower.h\r\n#pragma once\r\n\r\n#include <string>\r\n\r\nnamespace robots {\r\n\r\nclass Flower {\r\n   private:\r\n    bool needs_water{};\r\n    int size{};\r\n    std::string name{};\r\n\r\n   public:\r\n    Flower(std::string name, int size = 0) {\r\n        this->name = \"Robotica \" + name;\r\n        this->size = size;\r\n    }\r\n    void give_water() { needs_water = false; }\r\n    std::string get_name() { return name; }\r\n    int get_size() { return size; }\r\n    void start_next_day() {\r\n        if (!needs_water) {\r\n            ++size;\r\n        }\r\n        needs_water = true;\r\n    }\r\n};\r\n\r\n}  // namespace robots\r\n```\r\n\r\nProjects might use combinations of these layouts and there is a lot of discussion as to what might be the best fit for each use case.\r\n\r\n## Include Guards\r\n\r\nYou may have noticed the `#pragma once` line in the example header file above.\r\nThis is called an include guard - and it ensures that the content of the file is included only once during the compilation to avoid errors.\r\nThere is another, more complex variation of an include guard that starts with `#ifndef` and ends with `#endif`.\r\nIt serves the same purpose and its usage is shown in the `Flower` class example above.\r\n"
  },
  "meta": {
    "blurb": "In C++, header files provide definitions that can be included in other files. They can be seen as an API that decouples the interface from the implementation in the source files.",
    "authors": [
      "vaeng"
    ],
    "contributors": []
  },
  "links": [
    {
      "url": "https://learn.microsoft.com/en-us/cpp/cpp/header-files-cpp?view=msvc-170",
      "description": "Examples and information on header files and include guards"
    },
    {
      "url": "https://www.learncpp.com/cpp-tutorial/classes-and-header-files/",
      "description": "More information about classes in header files"
    }
  ]
}