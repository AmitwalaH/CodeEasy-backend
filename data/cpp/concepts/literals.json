{
  "language": "cpp",
  "slug": "literals",
  "title": "Literals",
  "docs": {
    "about": "# About\r\n\r\nLiterals are fixed values that are used directly in code.\r\nThey do not need any computation during run-time.\r\nThey come in various forms to represent different types of data efficiently.\r\nThe most frequent literals are of numeric nature, but there are also literal operators for date, time and string types.\r\nA later concept will show how user-defined literal operators can be used.\r\n\r\n## Numeric Literals\r\n\r\nNumeric literals include decimal, octal, hexadecimal, and binary representations.\r\nThese basics were already covered in the [numbers concept][numbers-concept].\r\n\r\nAll representations like `23`, `0x50f7ba11` and `0xba5eba11` are understood as `int` by the compiler.\r\nThe general `int` type is signed and ([depending on the compiler and the system][in-depth-integers]), often has a range of `-2'147'483'648` to `2'147'483'647`.\r\nThis is sufficient most of the time and you don't need to worry about the specific type.\r\n\r\nSome use-cases demand larger ranges or very small memory footprints of programs.\r\nTo be explicit one can directly state specific integer types with the numeric literal.\r\n\r\nWhen negative numbers aren't needed, but the added range is desired the `u` or `U` suffix are used for _unsigned_ integers.\r\nFor greater ranges `L` or even `LL` can be used for long and long long types.\r\n\r\n~~~~exercism/caution\r\nThe use of lower-case `l` is permitted, but it is easily confused with the number `1` and thus discouraged.\r\n~~~~\r\n\r\n```cpp\r\nauto net_worth_christian_grey{2'500'000'000U}; // out of range for 32-bit integers\r\nauto net_worth_carlisle_cullen{46'000'000'000LL}; // int and uint are not enough\r\n```\r\n\r\nFloating-point numbers usually resolve to `double` during compilation.\r\nThis is a good default case and use-cases with the narrower `float` type are less frequent than the unsigned example above.\r\n\r\n```cpp\r\nauto light_year_in_m{9.46073e+15f}; // well in the range of float\r\nauto earth_to_edge_comoving_distance_in_nm{4.32355e+32}; // needs double type for magnitude\r\nauto eulers_number{2.718281828459045}; // needs double type for precision\r\n```\r\n\r\n~~~~exercism/advanced\r\n## Character and String Literals\r\n\r\nOther concepts already used character literals with single quotes like `'}'` or `'@'`.\r\n\r\nIn C++ `char` is limited to the first 128 [ascii character codes][ascii-code].\r\nTo use several ascii chars or extended ascii characters like `‰` or even unicode characters like `麗` and `ẞ` other types are needed.\r\nIn previous concept string literals were introduced with _double quotes_: `\"一体どういう意味ですか。C++です\"`.\r\nThe actual type of this Japanese phrase is `const char (&)[46]`, a C-style string.\r\n\r\nThe use of string literals is not activated by default.\r\nTo use the _string_ literal `\"\"s` or the _string-view_ literal `\"\"sv`, the user has to specify their use by using the related namespace:\r\n\r\n```cpp\r\n#include <string>\r\n#include <string_view>\r\n\r\nusing namespace std::literals;\r\n\r\nauto green_light{\"무궁화 꽃 이 피었 습니다\"};\r\n// green_light type is const char (&)[36]\r\nauto umbrella{\"달고나\"s};\r\n// umbrella type is std::basic_string<char>, the same as std::string\r\nauto il_nam{\"보는 것이 하는 것보다 더 재미있을 수가 없지\"sv};\r\n// il_nam type is std::basic_string_view<char>\r\n```\r\n\r\nA _string_view_ can be seen as a reference to a const string.\r\n\r\n[ascii-code]: https://www.ascii-code.com/\r\n\r\n~~~~\r\n\r\n[numbers-concept]: https://exercism.org/tracks/cpp/concepts/numbers\r\n[in-depth-integers]: https://www.learncpp.com/cpp-tutorial/fixed-width-integers-and-size-t/\r\n",
    "introduction": "# Introduction\r\n\r\nLiterals are fixed values that are used directly in code.\r\nThey do not need any computation during run-time.\r\nThey come in various forms to represent different types of data efficiently.\r\nThe most frequent literals are of numeric nature, but there are also literal operators for date, time and string types.\r\nA later concept will show how user-defined literal operators can be used.\r\n\r\n## Numeric Literals\r\n\r\nNumeric literals include decimal, octal, hexadecimal, and binary representations.\r\nThese basics were already covered in the [numbers concept][numbers-concept].\r\n\r\nAll representations like `23`, `0x50f7ba11` and `0xba5eba11` are understood as `int` by the compiler.\r\nThe general `int` type is signed and ([depending on the compiler and the system][in-depth-integers]), often has a range of `-2'147'483'648` to `2'147'483'647`.\r\nThis is sufficient most of the time and you don't need to worry about the specific type.\r\n\r\nSome use-cases demand larger ranges or very small memory footprints of programs.\r\nTo be explicit one can directly state specific integer types with the numeric literal.\r\n\r\nWhen negative numbers aren't needed, but the added range is desired the `u` or `U` suffix are used for _unsigned_ integers.\r\nFor greater ranges `L` or even `LL` can be used for long and long long types.\r\n\r\n~~~~exercism/caution\r\nThe use of lower-case `l` is permitted, but it is easily confused with the number `1` and thus discouraged.\r\n~~~~\r\n\r\n```cpp\r\nauto net_worth_christian_grey{2'500'000'000U}; // out of range for 32-bit integers\r\nauto net_worth_carlisle_cullen{46'000'000'000LL}; // int and uint are not enough\r\n```\r\n\r\nFloating-point numbers usually resolve to `double` during compilation.\r\nThis is a good default case and use-cases with the narrower `float` type are less frequent than the unsigned example above.\r\n\r\n~~~~exercism/advanced\r\nThe [C++23 standard][cpp23-literals] introduces more fine grained control with literals like `f128` or `F16`.\r\nSome compilers allow their own literals.\r\nGCC permits the usage of `d` as a literal, but this is not foreseen in the standard and can hinder cross-platform compatibility.\r\n\r\n[cpp23-literals]: https://en.cppreference.com/w/cpp/language/floating_literal\r\n\r\n~~~~\r\n\r\n```cpp\r\nauto light_year_in_m{9.46073e+15f}; // well in the range of float\r\nauto earth_to_edge_comoving_distance_in_nm{4.32355e+32}; // needs double type for magnitude\r\nauto eulers_number{2.718281828459045}; // needs double type for precision\r\n```\r\n\r\n~~~~exercism/advanced\r\n## Character and String Literals\r\n\r\nOther concepts already used character literals with single quotes like `'}'` or `'@'`.\r\n\r\nIn C++ `char` is limited to the first 128 [ascii character codes][ascii-code].\r\nTo use several ascii chars or extended ascii characters like `‰` or even unicode characters like `麗` and `ẞ` other types are needed.\r\nIn previous concept string literals were introduced with _double quotes_: `\"一体どういう意味ですか。C++です\"`.\r\nThe actual type of this Japanese phrase is `const char (&)[46]`, a C-style string.\r\n\r\nThe use of string literals is not activated by default.\r\nTo use the _string_ literal `\"\"s` or the _string-view_ literal `\"\"sv`, the user has to specify their use by using the related namespace:\r\n\r\n```cpp\r\n#include <string>\r\n#include <string_view>\r\n\r\nusing namespace std::literals;\r\n\r\nauto green_light{\"무궁화 꽃 이 피었 습니다\"};\r\n// green_light type is const char (&)[36]\r\nauto umbrella{\"달고나\"s};\r\n// umbrella type is std::basic_string<char>, the same as std::string\r\nauto il_nam{\"보는 것이 하는 것보다 더 재미있을 수가 없지\"sv};\r\n// il_nam type is std::basic_string_view<char>\r\n```\r\n\r\nA _string_view_ can be seen as a reference to a const string.\r\n\r\n[ascii-code]: https://www.ascii-code.com/\r\n\r\n~~~~\r\n\r\n[numbers-concept]: https://exercism.org/tracks/cpp/concepts/numbers\r\n[in-depth-integers]: https://www.learncpp.com/cpp-tutorial/fixed-width-integers-and-size-t/\r\n"
  },
  "meta": {
    "blurb": "C++ literals represent fixed values, including strings and different numeric formats.",
    "authors": [
      "vaeng"
    ],
    "contributors": []
  },
  "links": [
    {
      "url": "https://www.learncpp.com/cpp-tutorial/literals/",
      "description": "Learn C++ overview on literals"
    }
  ]
}