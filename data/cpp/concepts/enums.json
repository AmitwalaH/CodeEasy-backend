{
  "language": "cpp",
  "slug": "enums",
  "title": "Enums",
  "docs": {
    "about": "# About\r\n\r\n## Enumerations\r\n\r\nSo far we have mostly handled numbers and strings.\r\nTo model the real world, we might want a limited number of values that a variable can take on.\r\nYou might want a dedicated type with a few distinct values with distinct names.\r\nFor example, in a skateboard factory, having the deck material be a choice of only maple, bamboo, or plastic.\r\n\r\nYou could use integers to encode those values, but you would have to use extra code to check if there is an invalid value coming from the system for the material.\r\nThe meaning of those [_magic numbers_][magic numbers] is difficult to trace over the source code and they are prone to mix-ups.\r\n`enumerations` can be used to encourage expressive code and to restrict unintentional comparison mistakes.\r\n\r\n## Example usage\r\n\r\nThe specific term for this kind of enumeration is `scoped enumeration`.\r\nThe snippet below shows how to write a `DeckMaterial` `enumeration`.\r\nNote the `enum class` keyword and the `;` at the end of the definition:\r\n\r\n```cpp\r\nenum class DeckMaterial {\r\n    maple,\r\n    bamboo,\r\n    plastic\r\n};\r\n```\r\nNow, look at a pricing function in the skate shop and take note of the scope resolution operator (`::`) specifying an `enumerator` from the `enumeration`:\r\n\r\n```cpp\r\ndouble deck_price(double base_price, DeckMaterial material) {\r\n    if(material == DeckMaterial::plastic) {\r\n        return base_price * 0.9;\r\n    }\r\n    return base_price * 1.3;\r\n}\r\n```\r\n\r\n## Scoping\r\n\r\nImagine you have a second `enumeration` for wheel material:\r\n\r\n```cpp\r\nenum class WheelMaterial {\r\n    steel,\r\n    clay,\r\n    plastic\r\n};\r\n```\r\nAlthough the wheels and the deck can both be made of _plastic_, the two cannot be confused.\r\nThey are different _types_:  `DeckMaterial` plastic and `WheelMaterial` plastic.\r\nEach `enumeration` will have its `enumerators` in its own scope - its own `namespace`.\r\nThis is the reason they are called `scoped enumerations`.\r\n\r\n~~~~exercism/advanced\r\n## Unscoped Enumerations\r\nYou might be thinking that with a name like `scoped`, there would also be  _`unscoped`_ enumerations -- and you would be correct.\r\n`Unscoped enumerations` are becoming less popular because they all share the same global namespace.\r\nBecause of the sharing, you could not have two `unscoped enumerations` with the same `enumerators` like _plastic_ in the example above.\r\n\r\nAlso, `unscoped enumerations` implicitly convert to integers.\r\nLook at the example below for a surprising result:\r\n\r\n```cpp\r\nenum CitrusFruits {\r\n    lemons,  // 0\r\n    oranges, //1\r\n};\r\n\r\nenum IceCream {\r\n    walnut,  // 0\r\n    apples,  // 1\r\n};\r\n\r\nbool comparison{apples == oranges};\r\n// => true\r\n\r\n// Example from above:\r\nbool comparison{DeckMaterial::plastic == WheelMaterial::plastic};\r\n// => Does not compile!\r\n```\r\n\r\nIf you want to convert `scoped enumerations` to integers you can use `static_cast<int>`.\r\n~~~~\r\n\r\n\r\n\r\n[magic numbers]: https://en.wikipedia.org/wiki/Magic_number_(programming)\r\n",
    "introduction": "# Introduction\r\n\r\n## Enumerations\r\n\r\nSo far we have mostly handled numbers and strings.\r\nTo model the real world, we might want a limited number of values that a variable can take on.\r\nYou might want a dedicated type with a few distinct values with distinct names.\r\nFor example, in a skateboard factory, having the deck material be a choice of only maple, bamboo, or plastic.\r\n\r\nYou could use integers to encode those values, but you would have to use extra code to check if there is an invalid value coming from the system for the material.\r\nThe meaning of those [_magic numbers_][magic numbers] is difficult to trace over the source code and they are prone to mix-ups.\r\n`enumerations` can be used to encourage expressive code and to restrict unintentional comparison mistakes.\r\n\r\n## Example usage\r\n\r\nThe specific term for this kind of enumeration is `scoped enumeration`.\r\nThe snippet below shows how to write a `DeckMaterial` `enumeration`.\r\nNote the `enum class` keyword and the `;` at the end of the definition:\r\n\r\n```cpp\r\nenum class DeckMaterial {\r\n    maple,\r\n    bamboo,\r\n    plastic\r\n};\r\n```\r\nNow, look at a pricing function in the skate shop and take note of the scope resolution operator (`::`) specifying an `enumerator` from the `enumeration`:\r\n\r\n```cpp\r\ndouble deck_price(double base_price, DeckMaterial material) {\r\n    if(material == DeckMaterial::plastic) {\r\n        return base_price * 0.9;\r\n    }\r\n    return base_price * 1.3;\r\n}\r\n```\r\n\r\n## Scoping\r\n\r\nImagine you have a second `enumeration` for wheel material:\r\n\r\n```cpp\r\nenum class WheelMaterial {\r\n    steel,\r\n    clay,\r\n    plastic\r\n};\r\n```\r\nAlthough the wheels and the deck can both be made of _plastic_, the two cannot be confused.\r\nThey are different _types_:  `DeckMaterial` plastic and `WheelMaterial` plastic.\r\nEach `enumeration` will have its `enumerators` in its own scope - its own `namespace`.\r\nThis is the reason they are called `scoped enumerations`.\r\n\r\n~~~~exercism/advanced\r\n## Unscoped Enumerations\r\nYou might be thinking that with the name `scoped`, there would also be be `unscoped` enumerations -- and you would be correct.\r\n`Unscoped enumerations` are becoming less popular because they all share the same global namespace.\r\nBecause of the sharing, you could not have two `unscoped enumerations` with the same `enumerators` like _plastic_ in the example above.\r\n\r\nAlso, `unscoped enumerations` implicitly convert to integers.\r\nLook at the example below for a surprising result:\r\n\r\n```cpp\r\nenum CitrusFruits {\r\n    lemons,  // 0\r\n    oranges, //1\r\n};\r\n\r\nenum IceCream {\r\n    walnut,  // 0\r\n    apples,  // 1\r\n};\r\n\r\nbool comparison{apples == oranges};\r\n// => true\r\n\r\n// Example from above:\r\nbool comparison{DeckMaterial::plastic == WheelMaterial::plastic};\r\n// => Does not compile!\r\n```\r\n\r\nIf you want to convert `scoped enumerations` to integers you can use `static_cast<int>`.\r\n~~~~\r\n\r\n\r\n\r\n[magic numbers]: https://en.wikipedia.org/wiki/Magic_number_(programming)\r\n"
  },
  "meta": {
    "blurb": "In C++, enumerations (enums) define custom data types with named values, ensuring variables hold specific and valid options, improving code readability and reliability.",
    "authors": [
      "vaeng"
    ],
    "contributors": []
  },
  "links": [
    {
      "url": "https://en.cppreference.com/w/cpp/language/enum",
      "description": "C++ reference on enumerations"
    }
  ]
}