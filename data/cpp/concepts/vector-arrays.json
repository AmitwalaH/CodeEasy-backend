{
  "language": "cpp",
  "slug": "vector-arrays",
  "title": "Vector Arrays",
  "docs": {
    "about": "# About\r\n\r\n## Arrays and Vectors\r\n\r\nC++ offers different containers to store elements of the same type in an ordered way.\r\nThere is `std::array` for containers of a fixed size and `std::vector`, which comes with dynamic resizing capabilities.\r\n\r\n### Construction\r\n\r\nWhen you declare an array or a vector you need to specify the type of elements, that container will hold.\r\nArrays also need a size.\r\nLook at these examples to see the two container types' initializations:\r\n\r\n```cpp\r\n#include <array>\r\n#include <string>\r\n\r\n// std::array<element_type, size> variable_name {list of elements}\r\nstd::array<std::string, 3> indie_rock {\"yeah\", \"yeah\", \"yeah\"};\r\n// indie_rock contains the elements \"yeah\" three times\r\n```\r\n\r\nVectors usually need more space, as they allocate memory for further growth.\r\nYou do not need to specify a size:\r\n\r\n```cpp\r\n#include <vector>\r\n\r\n// std::vector<element_type> variable_name {list of elements}\r\nstd::vector<int> countdown {3, 2, 1};\r\n// my_vector contains the elements 3, 2 and 1\r\n```\r\n\r\n> Note: You do not need to know the exact mechanics behind the template concept yet, it will have its own concept further down the syllabus tree.\r\n\r\n### Element access\r\n\r\nVectors and arrays share the same functions to access their elements.\r\nYou can use the member functions `front` and `back` to get the first and last elements of the container.\r\nThere is also `at` and the `[]` operator to access speficic elements.\r\n\r\n```cpp\r\ncountdown[0];\r\n// => 3\r\ncountdown.at(2);\r\n// => 1\r\ncountdown[1] = 4;\r\n// countdown now contains 3, 4 and 1\r\nindie_rock.back() = \"yeahs\";\r\n// indie_rock is now \"yeah\", \"yeah\", \"yeahs\"\r\n```\r\n\r\n> Note: If you pick a position that is not in the range of your container, `[]` might lead to undefined behavior.\r\n> The `at` function would raise an exception, which might make your life easier in the long term.\r\n\r\n### Vector modifiers\r\n\r\nAs a `vector` is not fixed in size, it is possible to add or remove elements.\r\nTwo common functions for that purpose are `emplace_back` and `pop_back`.\r\n\r\n```cpp\r\nstd::vector<std::string> witches {\"Holly\", \"Alyssa\", \"Shannen\"};\r\nwitches.pop_back();\r\n// Shannen is no longer with the witches\r\nwitches.emplace_back(\"Rose\");\r\n// Rose has joined the team\r\n```\r\n\r\n### Capacity\r\n\r\nYou can check the containers for emptiness with the member function `empty`.\r\nIf you want to know the number of elements, you can use `size`.\r\n",
    "introduction": "# Introduction\r\n\r\n## Arrays and Vectors\r\n\r\nC++ offers different containers to store elements of the same type in an ordered way.\r\nThere is `std::array` for containers of a fixed size and `std::vector`, which comes with dynamic resizing capabilities.\r\n\r\n### Construction\r\n\r\nWhen you declare an array or a vector you need to specify the type of elements, that container will hold.\r\nArrays also need a size.\r\nLook at these examples to see the two container types' initializations:\r\n\r\n```cpp\r\n#include <array>\r\n#include <string>\r\n\r\n// std::array<element_type, size> variable_name {list of elements}\r\nstd::array<std::string, 3> indie_rock {\"yeah\", \"yeah\", \"yeah\"};\r\n// indie_rock contains the elements \"yeah\" three times\r\n```\r\n\r\nVectors usually need more space, as they allocate memory for further growth.\r\nYou do not need to specify a size:\r\n\r\n```cpp\r\n#include <vector>\r\n\r\n// std::vector<element_type> variable_name {list of elements}\r\nstd::vector<int> countdown {3, 2, 1};\r\n// countdown contains the elements 3, 2 and 1\r\n```\r\n\r\n> Note: You do not need to know the exact mechanics behind the template concept yet, it will have its own concept further down the syllabus tree.\r\n\r\n### Element access\r\n\r\nVectors and arrays share the same functions to access their elements.\r\nYou can use the member functions `front` and `back` to get the first and last elements of the container.\r\nThere is also `at` and the `[]` operator to access speficic elements.\r\n\r\n```cpp\r\ncountdown[0];\r\n// => 3\r\ncountdown.at(2);\r\n// => 1\r\ncountdown[1] = 4;\r\n// countdown now contains 3, 4 and 1\r\nindie_rock.back() = \"yeahs\";\r\n// indie_rock is now \"yeah\", \"yeah\", \"yeahs\"\r\n```\r\n\r\n> Note: If you pick a position that is not in the range of your container, `[]` might lead to undefined behavior.\r\n> The `at` function would raise an exception, which might make your life easier in the long term.\r\n\r\n### Vector modifiers\r\n\r\nAs a `vector` is not fixed in size, it is possible to add or remove elements.\r\nTwo common functions for that purpose are `emplace_back` and `pop_back`.\r\n\r\n```cpp\r\nstd::vector<std::string> witches {\"Holly\", \"Alyssa\", \"Shannen\"};\r\nwitches.pop_back();\r\n// Shannen is no longer with the witches\r\nwitches.emplace_back(\"Rose\");\r\n// Rose has joined the team\r\n```\r\n\r\n### Capacity\r\n\r\nYou can check the containers for emptiness with the member function `empty`.\r\nIf you want to know the number of elements, you can use `size`.\r\n"
  },
  "meta": {
    "blurb": "In C++, the array and vector types provide flexible ways to store and access multiple elements of the same data type, with arrays offering fixed-size containers while vectors offer dynamic resizing capabilities, making them suitable for various data storage and manipulation tasks.",
    "authors": [
      "vaeng"
    ],
    "contributors": []
  },
  "links": [
    {
      "url": "https://en.cppreference.com/w/cpp/container/array",
      "description": "C++ reference on arrays"
    },
    {
      "url": "https://en.cppreference.com/w/cpp/container/vector",
      "description": "C++ reference on vectors"
    }
  ]
}