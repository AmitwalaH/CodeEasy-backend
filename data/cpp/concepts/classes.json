{
  "language": "cpp",
  "slug": "classes",
  "title": "Classes",
  "docs": {
    "about": "# About\r\n\r\n\r\nIt is time to get to one of the core paradigms of C++: object-oriented programming (OOP).\r\nOOP is centered around `classes` - user-defined types of data with their own set of related functions.\r\nWe will start with the basics and will cover more advanced topics further down the syllabus tree.\r\n\r\n## Members\r\n\r\nClasses can have **member variables** and **member functions**.\r\nThey are accessed by the **member selection** operator `.`.\r\nJust as variables outside of `classes`, it is advisable to initialize member variables with a value upon declaration.\r\nThis value will then become the default for newly created objects from this class.\r\n\r\n## Encapsulation and Information Hiding\r\n\r\nClasses offer the option to restrict access to their members.\r\nThe two basic cases are `private` and `public`.\r\n`private` members are not accessible from outside the class.\r\n`public` members can be called freely.\r\nAll members are `private` by default and need to be explicitly marked to be usable outside of the class.\r\n\r\n## Basic example\r\n\r\nThe definition of a new `class` can be seen in the following example.\r\nNotice the `;` after the definition.\r\n\r\n```cpp\r\nclass Wizzard {\r\n  public:               // from here on all members are accessible publicly\r\n    int cast_spell() {  // defines the public member function cast_spell\r\n      return damage;\r\n    }\r\n    std::string name{}; // defines the public member variable `name`\r\n  private:              // from here on all members are private\r\n    int damage{5};      // defines the private member variable `damage`\r\n};\r\n\r\n```\r\n\r\nYou can access all variables from within the class.\r\nTake a look at `damage` inside the `cast_spell` function.\r\nYou cannot read or change `private`  members outside of the class:\r\n\r\n```cpp\r\nWizzard silverhand{};\r\n// calling the `cast_spell` function is okay, it is public:\r\nsilverhand.cast_spell();\r\n// => 5\r\n\r\n// name is public and can be changed:\r\nsilverhand.name = \"Laeral\";\r\n\r\n// damage is private:\r\nsilverhand.damage = 500;\r\n // => Compilation error\r\n```\r\n\r\n## Constructors\r\n\r\nConstructors offer the possibility to assign values to member variables at object creation.\r\nThey have the same name as the `class` and do not have a return type.\r\nA class can have several constructors.\r\nThis is useful if you do not always have a need to set all variables.\r\n\r\n```cpp\r\nclass Wizzard {\r\n  public:\r\n    Wizzard(std::string new_name) {\r\n      name = new_name;\r\n    }\r\n    Wizzard(std::string new_name, int new_damage) {\r\n      name = new_name;\r\n      damage = new_damage;\r\n    }\r\n    int cast_spell() {\r\n      return damage;\r\n    }\r\n    std::string name{};\r\n  private:\r\n    int damage{5};\r\n};\r\n\r\nWizzard el{\"Eleven\"};       // deals  5 damage\r\nWizzard vecna{\"Vecna\", 50}; // deals 50 damage\r\n```\r\n\r\nConstructors are a big topic and have many nuances.\r\nIf you are not explicitly defining a `constructor` for your `class`, then - and only then - the compiler will do the job for you.\r\nThis has happened in the first example above.\r\nThe _silverhand_ object is created by calling the default constructor, no arguments were passed.\r\nAll variables are set to the value that was stated in the definition of the class.\r\nIf you had not given any values in that definition, the variables might be uninitialized, which might have unintended consequences.\r\n\r\n~~~~exercism/note\r\n## Structs\r\n\r\nStructs came from the language's original C roots and are as old as C++ itself.\r\nThey are effectively the same thing as `classes` with one important exception.\r\nBy default, everything in a `class` is `private`.\r\nStructs, on the other hand, are `public` until defined otherwise.\r\nConventionally, the `struct` keyword is often used for **data-only structures**.\r\nThe `class` keyword is preferred for objects that need to ensure certain properties.\r\nSuch an invariant could be that the `damage` of your `Wizzard` `class` cannot turn negative.\r\nThe `damage` variable is private and any function that changes the damage would ensure the invariant is preserved.\r\n~~~~\r\n",
    "introduction": "# Introduction\r\n\r\nIt is time to get to one of the core paradigms of C++: object-oriented programming (OOP).\r\nOOP is centered around `classes` - user-defined types of data with their own set of related functions.\r\nWe will start with the basics and will cover more advanced topics further down the syllabus tree.\r\n\r\n## Members\r\n\r\nClasses can have **member variables** and **member functions**.\r\nThey are accessed by the **member selection** operator `.`.\r\nJust as variables outside of `classes`, it is advisable to initialize member variables with a value upon declaration.\r\nThis value will then become the default for newly created objects from this class.\r\n\r\n## Encapsulation and Information Hiding\r\n\r\nClasses offer the option to restrict access to their members.\r\nThe two basic cases are `private` and `public`.\r\n`private` members are not accessible from outside the class.\r\n`public` members can be called freely.\r\nAll members are `private` by default and need to be explicitly marked to be usable outside of the class.\r\n\r\n## Basic example\r\n\r\nThe definition of a new `class` can be seen in the following example.\r\nNotice the `;` after the definition.\r\n\r\n```cpp\r\nclass Wizzard {\r\n  public:               // from here on all members are accessible publicly\r\n    int cast_spell() {  // defines the public member function cast_spell\r\n      return damage;\r\n    }\r\n    std::string name{}; // defines the public member variable `name`\r\n  private:              // from here on all members are private\r\n    int damage{5};      // defines the private member variable `damage`\r\n};\r\n\r\n```\r\n\r\nYou can access all variables from within the class.\r\nTake a look at `damage` inside the `cast_spell` function.\r\nYou cannot read or change `private`  members outside of the class:\r\n\r\n```cpp\r\nWizzard silverhand{};\r\n// calling the `cast_spell` function is okay, it is public:\r\nsilverhand.cast_spell();\r\n// => 5\r\n\r\n// name is public and can be changed:\r\nsilverhand.name = \"Laeral\";\r\n\r\n// damage is private:\r\nsilverhand.damage = 500;\r\n // => Compilation error\r\n```\r\n\r\n## Constructors\r\n\r\nConstructors offer the possibility to assign values to member variables at object creation.\r\nThey have the same name as the `class` and do not have a return type.\r\nA class can have several constructors.\r\nThis is useful if you do not always have a need to set all variables.\r\n\r\n```cpp\r\nclass Wizzard {\r\n  public:\r\n    Wizzard(std::string new_name) {\r\n      name = new_name;\r\n    }\r\n    Wizzard(std::string new_name, int new_damage) {\r\n      name = new_name;\r\n      damage = new_damage;\r\n    }\r\n    int cast_spell() {\r\n      return damage;\r\n    }\r\n    std::string name{};\r\n  private:\r\n    int damage{5};\r\n};\r\n\r\nWizzard el{\"Eleven\"};       // deals  5 damage\r\nWizzard vecna{\"Vecna\", 50}; // deals 50 damage\r\n```\r\n\r\nConstructors are a big topic and have many nuances.\r\nIf you are not explicitly defining a `constructor` for your `class`, then - and only then - the compiler will do the job for you.\r\nThis has happened in the first example above.\r\nThe _silverhand_ object is created by calling the default constructor, no arguments were passed.\r\nAll variables are set to the value that was stated in the definition of the class.\r\nIf you had not given any values in that definition, the variables might be uninitialized, which might have unintended consequences.\r\n\r\n~~~~exercism/note\r\n## Structs\r\n\r\nStructs came from the language's original C roots and are as old as C++ itself.\r\nThey are effectively the same thing as `classes` with one important exception.\r\nBy default, everything in a `class` is `private`.\r\nStructs, on the other hand, are `public` until defined otherwise.\r\nConventionally, the `struct` keyword is often used for **data-only structures**.\r\nThe `class` keyword is preferred for objects that need to ensure certain properties.\r\nSuch an invariant could be that the `damage` of your `Wizzard` `class` cannot turn negative.\r\nThe `damage` variable is private and any function that changes the damage would ensure the invariant is preserved.\r\n~~~~\r\n"
  },
  "meta": {
    "blurb": "In C++, classes are types with their own set of characteristics and abilities. They make it easier to organize and reuse code by grouping related data and functions together in a structured and organized way.",
    "authors": [
      "vaeng"
    ],
    "contributors": []
  },
  "links": [
    {
      "url": "https://en.cppreference.com/w/cpp/language/classes",
      "description": "C++ reference on for classes"
    }
  ]
}