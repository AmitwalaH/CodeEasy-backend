{
  "language": "cpp",
  "slug": "pointers",
  "title": "Pointers",
  "docs": {
    "about": "# Introduction\r\n\r\nLike many other languages, C++ has _pointers_.\r\nYou already know _references_ and _pointers_ are similar, but think of them as a level closer to the inner workings of your computer.\r\n_Pointers_ are variables that hold object addresses.\r\nThey are used to directly interact with objects, enabling dynamic memory allocation and efficient data manipulation in C++.\r\n\r\nIf you're new to _pointers_, they can feel a little mysterious but once you get used to them, they're quite straight-forward.\r\n\r\nThey're a crucial part of C++, so take some time to really understand them.\r\nThe bare-bone version in this concept is also called _dumb pointer_ or _raw pointer_.\r\nWith modern C++ there are also _smart pointers_, the basic type is not smart at all and you have to handle all the work manually.\r\n\r\nBefore digging into the details, it's worth understanding the use of _pointers_.\r\n_Pointers_ are a way to share an object's address with other parts of our program, which is useful for two major reasons:\r\n\r\n1. Like _references_, pointers avoid copies and help to reduce the resource-footprint of your program.\r\n1. Unlike _references_, pointers can be reassigned to different objects.\r\n1. Pointers can also point to a null value, to indicate, that they currently do not point to any object.\r\n\r\n## General Syntax\r\n\r\nA pointer declaration in C++ involves specifying the data type to which the the pointer is pointing, followed by an asterisk (`*`) and the pointer's name.\r\nWhen pointers are declared, they are not automatically initialized.\r\nWithout explicit assignment, a pointer typically holds an indeterminate value, often referred to as a \"garbage address.\"\r\nWhile certain compilers might initialize pointers to `nullptr`, this behavior is not guaranteed across all compilers, so it's essential not to rely on it.\r\nIt's best practice to explicitly initialize raw pointers and verify their non-null status before utilization to avoid potential issues.\r\n\r\n```cpp\r\nint* ptr{nullptr}; // Declares a pointer and makes sure it is not invalid\r\n```\r\n\r\nTo assign the address of a variable to a pointer, you use the address-of operator (`&`).\r\nDereferencing a pointer is done using the _indirection operator_ (`*`) operator.\r\n\r\n```cpp\r\nstd::string opponent{\"Solomon Lane\"};\r\n// 'ethan' points to the address of the string opponent\r\nstd::string* ethan{&opponent};\r\n// Instead of ethan's, the opponent's name address is given to the passPort\r\nstd::string passportName{*ethan};\r\n```\r\n\r\nAttention: dereferencing has to be done explicitly, while _references_ just worked like an alias.\r\n\r\n## Pointer Arithmetic\r\n\r\n_Pointer arithmetic_ allows you to perform arithmetic operations on pointers, which is particularly useful when working with arrays.\r\nAdding an integer to a pointer makes it point to a different element.\r\n\r\n```cpp\r\n// Stargate Coordinate Code\r\nint gateCode[] = {462, 753, 218, 611, 977};\r\n// 'ptr' points to the first element of 'gateCode'\r\nint* ptr{&gateCode[0]};\r\n// Accesses the third Stargate address through pointer arithmetic\r\nint dialedAddress{*(ptr + 2)};\r\n// Chevron encoded! Dialing Stargate address:\r\nopenStarGate(dialedAddress);\r\n```\r\n\r\n~~~~exercism/caution\r\nPointer arithmetic in C++ can easily lead to __undefined behavior__ if not handled carefully.\r\nUndefined behavior can manifest in unexpected program outcomes, crashes, or even security vulnerabilities.\r\nOne infamous example of the consequences of undefined behavior occurred in the [explosion of the Ariane 5 rocket][ariane-flight-v88] in 1996, where a software exception caused by the conversion of a 64-bit floating-point number to a 16-bit signed integer led to a catastrophic failure.\r\n\r\n[ariane-flight-v88]: https://en.wikipedia.org/wiki/Ariane_flight_V88\r\n~~~~\r\n\r\n## Accessing member variables\r\n\r\nIn C++, the `->` operator is used to access members of an object through a pointer to that object.\r\nIt is a shorthand which simplifies accessing members of objects pointed to by pointers.\r\nFor instance, if `ptr` is a pointer to an object with a member variable `x`, instead of using `(*ptr).x`, you can directly use `ptr->x`.\r\nThis operator enhances code readability and reduces verbosity when working with pointers to objects.\r\n\r\nHere's a brief example, with a _struct_ `Superhero` that has a member variable `superpower`.\r\nThe main function creates a pointer `dianaPrince` to a `Superhero` object (representing Wonder Woman).\r\nThe `->` operator is used to access the member variable `superpower`, showcasing Wonder Woman's iconic \"Lasso of Truth.\"\r\n\r\n```cpp\r\nstruct Superhero {\r\n    std::string superpower;\r\n};\r\n\r\nSuperhero wonder_woman{};\r\nSuperhero* dianaPrince = &wonder_woman;\r\ndianaPrince->superpower = \"Lasso of Truth\";\r\n\r\n// Using the -> operator to access member variable superpower:\r\nstd::cout << \"Wonder Woman, possesses the mighty \" << dianaPrince->superpower;\r\n\r\n// Memory cleanup:\r\ndelete dianaPrince;\r\n```\r\n\r\n## Pointers vs. references\r\n\r\nPointers and references both enable indirect access to objects, but they differ in their capabilities and safety considerations.\r\nPointers offer the flexibility of changing their target object and can be assigned null.\r\nHowever, this flexibility introduces risks, such as dereferencing null pointers or creating dangling pointers.\r\nReferences, on the other hand, cannot be null and are bound to valid objects upon creation, avoiding these risks.\r\nGiven their safer nature, references should be preferred over pointers unless the additional functionalities provided by pointers are necessary.\r\n\r\n~~~~exercism/advanced\r\n## Dynamic Memory Allocation and Null Pointers\r\n\r\nIn C++, `new` is used to dynamically allocate memory for objects on the heap during runtime.\r\nIt returns a pointer to the allocated memory address, allowing objects to have lifetimes not tied to a specific scope.\r\nHowever, it's important to always pair `new` with `delete` to properly deallocate memory.\r\nDynamic memory allocation should be used cautiously to prevent common issues like memory leaks and accessing deallocated memory.\r\n\r\nPointers can also be set to a special value called a _null pointer_, which indicates that they do not point to a valid address.\r\nNull pointers are commonly used to initialize pointers before assigning them to valid values.\r\n\r\n```cpp\r\n// There is a dark mark bearer, but who is it?\r\nstd::string* darkMarkBearer{nullptr};\r\n// It is Bellatrix!\r\ndarkMarkBearer = new std::string{\"Bellatrix Lestrange\"};\r\n// She has been defeated\r\ndelete darkMarkBearer;\r\n// Reset pointer to null, symbolizing there is no more darkMarkBearer at the moment\r\ndarkMarkBearer = nullptr;\r\n```\r\n\r\nA pointer should either hold the address of a valid object, or be set to `nullptr`.\r\nThat way you only need to test pointers for null, and can assume any non-null pointer is valid.\r\nWhen an object is destroyed, any pointers to the destroyed object will be left _dangling_ (they will not be automatically set to `nullptr`).\r\nIt is your responsibility to detect these cases and ensure those pointers are subsequently set to `nullptr`.\r\n\r\n\r\nIn older code, you might encounter two alternatives to `nullptr`.\r\nFirstly, the literal `0` is specifically interpreted as a null value for pointers, though it's the only scenario where an integral literal can be assigned to a pointer.\r\nSecondly, the `preprocessor macro` `NULL`, inherited from C and defined in the `<cstddef>` header, is another representation of a null pointer, though its usage is less common in modern C++ code.\r\n~~~~\r\n",
    "introduction": "# Introduction\r\n\r\nLike many other languages, C++ has _pointers_.\r\nYou already know _references_ and _pointers_ are similar, but think of them as a level closer to the inner workings of your computer.\r\n_Pointers_ are variables that hold object addresses.\r\nThey are used to directly interact with objects, enabling dynamic memory allocation and efficient data manipulation in C++.\r\n\r\nIf you're new to _pointers_, they can feel a little mysterious but once you get used to them, they're quite straight-forward.\r\n\r\nThey're a crucial part of C++, so take some time to really understand them.\r\nThe bare-bone version in this concept is also called _dumb pointer_ or _raw pointer_.\r\nWith modern C++ there are also _smart pointers_, the basic type is not smart at all and you have to handle all the work manually.\r\n\r\nBefore digging into the details, it's worth understanding the use of _pointers_.\r\n_Pointers_ are a way to share an object's address with other parts of our program, which is useful for two major reasons:\r\n\r\n1. Like _references_, pointers avoid copies and help to reduce the resource-footprint of your program.\r\n1. Unlike _references_, pointers can be reassigned to different objects.\r\n1. Pointers can also point to a null value, to indicate, that they currently do not point to any object.\r\n\r\n## General Syntax\r\n\r\nA pointer declaration in C++ involves specifying the data type to which the the pointer is pointing, followed by an asterisk (`*`) and the pointer's name.\r\nWhen pointers are declared, they are not automatically initialized.\r\nWithout explicit assignment, a pointer typically holds an indeterminate value, often referred to as a \"garbage address.\"\r\nWhile certain compilers might initialize pointers to `nullptr`, this behavior is not guaranteed across all compilers, so it's essential not to rely on it.\r\nIt's best practice to explicitly initialize raw pointers and verify their non-null status before utilization to avoid potential issues.\r\n\r\n```cpp\r\nint* ptr{nullptr}; // Declares a pointer and makes sure it is not invalid\r\n```\r\n\r\nTo assign the address of a variable to a pointer, you use the address-of operator (`&`).\r\nDereferencing a pointer is done using the _indirection operator_ (`*`) operator.\r\n\r\n```cpp\r\nstd::string opponent{\"Solomon Lane\"};\r\n// 'ethan' points to the address of the string opponent\r\nstd::string* ethan{&opponent};\r\n// Instead of ethan's, the opponent's name address is given to the passPort\r\nstd::string passportName{*ethan};\r\n```\r\n\r\nAttention: dereferencing has to be done explicitly, while _references_ just worked like an alias.\r\n\r\n## Pointer Arithmetic\r\n\r\n_Pointer arithmetic_ allows you to perform arithmetic operations on pointers, which is particularly useful when working with arrays.\r\nAdding an integer to a pointer makes it point to a different element.\r\n\r\n```cpp\r\n// Stargate Coordinate Code\r\nint gateCode[] = {462, 753, 218, 611, 977};\r\n// 'ptr' points to the first element of 'gateCode'\r\nint* ptr{&gateCode[0]};\r\n// Accesses the third Stargate address through pointer arithmetic\r\nint dialedAddress{*(ptr + 2)};\r\n// Chevron encoded! Dialing Stargate address:\r\nopenStarGate(dialedAddress);\r\n```\r\n\r\n~~~~exercism/caution\r\nPointer arithmetic in C++ can easily lead to __undefined behavior__ if not handled carefully.\r\nUndefined behavior can manifest in unexpected program outcomes, crashes, or even security vulnerabilities.\r\nOne infamous example of the consequences of undefined behavior occurred in the [explosion of the Ariane 5 rocket][ariane-flight-v88] in 1996, where a software exception caused by the conversion of a 64-bit floating-point number to a 16-bit signed integer led to a catastrophic failure.\r\n\r\n[ariane-flight-v88]: https://en.wikipedia.org/wiki/Ariane_flight_V88\r\n~~~~\r\n\r\n## Accessing member variables\r\n\r\nIn C++, the `->` operator is used to access members of an object through a pointer to that object.\r\nIt is a shorthand which simplifies accessing members of objects pointed to by pointers.\r\nFor instance, if `ptr` is a pointer to an object with a member variable `x`, instead of using `(*ptr).x`, you can directly use `ptr->x`.\r\nThis operator enhances code readability and reduces verbosity when working with pointers to objects.\r\n\r\nHere's a brief example, with a _struct_ `Superhero` that has a member variable `superpower`.\r\nThe main function creates a pointer `dianaPrince` to a `Superhero` object (representing Wonder Woman).\r\nThe `->` operator is used to access the member variable `superpower`, showcasing Wonder Woman's iconic \"Lasso of Truth.\"\r\n\r\n```cpp\r\nstruct Superhero {\r\n    std::string superpower;\r\n};\r\nSuperhero wonder_woman{};\r\nSuperhero* dianaPrince = &wonder_woman;\r\ndianaPrince->superpower = \"Lasso of Truth\";\r\n// Using the -> operator to access member variable superpower:\r\nstd::cout << \"Wonder Woman, possesses the mighty \" << dianaPrince->superpower;\r\n// Memory cleanup:\r\ndelete dianaPrince;\r\n```\r\n\r\n## Pointers vs. references\r\n\r\nPointers and references both enable indirect access to objects, but they differ in their capabilities and safety considerations.\r\nPointers offer the flexibility of changing their target object and can be assigned null.\r\nHowever, this flexibility introduces risks, such as dereferencing null pointers or creating dangling pointers.\r\nReferences, on the other hand, cannot be null and are bound to valid objects upon creation, avoiding these risks.\r\nGiven their safer nature, references should be preferred over pointers unless the additional functionalities provided by pointers are necessary.\r\n"
  },
  "meta": {
    "blurb": "In C++, pointers are variables that store object addresses. They allow you to directly manipulate memory and access to data structures like arrays and objects.",
    "authors": [
      "vaeng"
    ]
  },
  "links": [
    {
      "url": "https://en.cppreference.com/w/c/language/pointer",
      "description": "C++ reference on pointers"
    },
    {
      "url": "https://en.cppreference.com/w/cpp/memory/new",
      "description": "C++ reference on dynamic memory allocation with new"
    },
    {
      "url": "https://en.cppreference.com/w/cpp/language/delete",
      "description": "C++ reference on dynamic memory deallocation with delete"
    }
  ]
}