{
  "language": "cpp",
  "slug": "functions",
  "title": "Functions",
  "docs": {
    "about": "# About\r\n\r\n## Terminology\r\n\r\nYou have already used and written C++ functions in a couple of concepts.\r\nIt is time to get technical.\r\nThe code snippet below shows the most common terms for easy reference.\r\nAs C++ ignores whitespace, the formatting has been changed to put each element on a single line.\r\n\r\n```cpp\r\n// Function declaration:\r\nbool                                              // Return type\r\nadmin_detected(string user, string password)      // Type signature\r\n;                                                 // Don't forget the ';' for the declaration\r\n\r\n// Function definition:\r\nbool                                              // Return type\r\nadmin_detected                                    // Function name\r\n(string user, string password)                    // Parameter list\r\n{ return user == \"admin\" && password == \"1234\"; } // Function body\r\n```\r\n~~~~exercism/advanced\r\nThe declaration works like a note to the compiler, that there is a function of that name, return type and parameter list.\r\nThe code will not work, if the definition is missing.\r\nDeclarations are optional, they are needed if you use the function before its definiton.\r\nDeclarations can solve problems like cyclic references and they can be used to separate the interface from the implementation.\r\n~~~~\r\n\r\n## The const qualifier\r\n\r\nSometimes you want to make sure that values cannot be changed after they have been initialized.\r\nC++ uses the `const` keyword as a qualifier for constants.\r\n\r\n```cpp\r\nconst int number_of_dragon_balls{7};\r\nnumber_of_dragon_balls--; // compilation error\r\n```\r\n\r\n~~~~exercism/note\r\nYou will often see constants written in _UPPER_SNAKE_CASE_.\r\nIt is recommened to reserve this casing for macros, if there is no other convention.\r\n~~~~\r\n\r\nIf you try to change a constant variable after it has been set, your code will not compile.\r\nThis helps to avoid unintended changes but also opens up optimization possibilities for the compiler.\r\nAs a human, it is also easier to reason about the code, if you know that certain parts will not be affected.\r\n\r\nYou can also have `const` as a qualifier for function parameters.\r\n\r\n```cpp\r\nstring guess_number(const int& secret, const int& guess) {\r\n    if (secret < guess) return \"lower.\";\r\n    if (secret > guess) return \"higher.\";\r\n    return \"exact!\";\r\n}\r\n```\r\n\r\nWhen you pass a `const` reference to the function, you can be sure that it will be left unchanged.\r\nYou will often see `const` references for objects that might be costly to copy, like longer strings.\r\nA third use-case for the `const` qualifier are member functions that do not change the instance of a class.\r\n\r\n```cpp\r\nclass Stubborn {\r\n    public:\r\n    Stubborn(string reply) {\r\n        response = reply;\r\n    }\r\n    string answer(const string& question) const {\r\n        if (question.length() == 0) { return \"\";}\r\n        return response;\r\n    }\r\n    private:\r\n    string response{};\r\n};\r\n```\r\n\r\nThe `Stubborn` member function `answer` uses a `const string&` reference as a parameter.\r\nThis avoids a copy operation from the original object that was passed to the function.\r\n\r\n## Function overloading\r\n\r\nMultiple functions can have the same name if the parameter list is different.\r\nThat is called function overloading and it is usually done if these functions perform very similar tasks.\r\n\r\nThe function header without the return type is the function's __type signature__.\r\nA change in the type signature results in a new function.\r\n\r\nThe `play_sound` example has six different overloads to accommodate different scenarios:\r\n\r\n```cpp\r\n// different argument types:\r\nvoid play_sound(char note);         // C, D, E, ..., B\r\nvoid play_sound(string solfege);    // do, re, mi, ..., ti\r\nvoid play_sound(int jianpu);        // 1, 2, 3, ..., 7\r\n\r\n// different number of arguments:\r\nvoid play_sound(string solfege, double duration);\r\n\r\n// different qualifiers:\r\nvoid play_sound(vector<string>& solfege);\r\nvoid play_sound(const vector<string>& solfege);\r\n```\r\n\r\n~~~~exercism/advanced\r\nThe type signature is defined by the function's name, the number of parameters, their types, and their qualifiers (but not their names).\r\nThe return type is explicitly not part of the type signature and you will get compilation errors if you have two functions that only differ in their return type.\r\nThe compiler will complain because it is not clear which of the two should be used.\r\n~~~~\r\n\r\n## Default arguments\r\n\r\nSome functions can get very lengthy and many of its calls might use the same values for most of the parameters.\r\nThe repetition in those calls can be avoided with default arguments.\r\n\r\n```cpp\r\nvoid record_new_horse_birth(string name, int weight, string color=\"brown-ish\", string dam=\"Alruccaba\", string sire=\"Poseidon\");\r\n\r\nrecord_new_horse_birth(\"Urban Sea\", 130); // color will be brown, dam \"Alruccabam\", sire \"Poseidon\"\r\nrecord_new_horse_birth(\"Highclere\", 175, \"off-white\", \"Fall Aspen\");   // sire will be \"Poseidon\"\r\n```\r\n\r\nAs the function declaration is often read before the definition, it is the better place to set the default arguments.\r\nIf one parameter has a default declaration, all the parameters to its right need a default declaration as well.\r\nSometimes complicated function overloads can be refactored to fewer functions with default arguments to improve maintainability.\r\n",
    "introduction": "# Introduction\r\n\r\n## Terminology\r\n\r\nYou have already used and written C++ functions in a couple of concepts.\r\nIt is time to get technical.\r\nThe code snippet below shows the most common terms for easy reference.\r\nAs C++ ignores whitespace, the formatting has been changed to put each element on a single line.\r\n\r\n```cpp\r\n// Function declaration:\r\nbool                                              // Return type\r\nadmin_detected(string user, string password)      // Type signature\r\n;                                                 // Don't forget the ';' for the declaration\r\n\r\n// Function definition:\r\nbool                                              // Return type\r\nadmin_detected                                    // Function name\r\n(string user, string password)                    // Parameter list\r\n{ return user == \"admin\" && password == \"1234\"; } // Function body\r\n```\r\n~~~~exercism/advanced\r\nThe declaration works like a note to the compiler, that there is a function of that name, return type and parameter list.\r\nThe code will not work, if the definition is missing.\r\nDeclarations are optional, they are needed if you use the function before its definiton.\r\nDeclarations can solve problems like cyclic references and they can be used to separate the interface from the implementation.\r\n~~~~\r\n\r\n## The const qualifier\r\n\r\nSometimes you want to make sure that values cannot be changed after they have been initialized.\r\nC++ uses the `const` keyword as a qualifier for constants.\r\n\r\n```cpp\r\nconst int number_of_dragon_balls{7};\r\nnumber_of_dragon_balls--; // compilation error\r\n```\r\n\r\n~~~~exercism/note\r\nYou will often see constants written in _UPPER_SNAKE_CASE_.\r\nIt is recommened to reserve this casing for macros, if there is no other convention.\r\n~~~~\r\n\r\nIf you try to change a constant variable after it has been set, your code will not compile.\r\nThis helps to avoid unintended changes but also opens up optimization possibilities for the compiler.\r\nAs a human, it is also easier to reason about the code, if you know that certain parts will not be affected.\r\n\r\nYou can also have `const` as a qualifier for function parameters.\r\n\r\n```cpp\r\nstring guess_number(const int& secret, const int& guess) {\r\n    if (secret < guess) return \"lower.\";\r\n    if (secret > guess) return \"higher.\";\r\n    return \"exact!\";\r\n}\r\n```\r\n\r\nWhen you pass a `const` reference to the function, you can be sure that it will be left unchanged.\r\nYou will often see `const` references for objects that might be costly to copy, like longer strings.\r\nA third use-case for the `const` qualifier are member functions that do not change the instance of a class.\r\n\r\n```cpp\r\nclass Stubborn {\r\n    public:\r\n    Stubborn(string reply) {\r\n        response = reply;\r\n    }\r\n    string answer(const string& question) const {\r\n        if (question.length() == 0) { return \"\"; }\r\n        return response;\r\n    }\r\n    private:\r\n    string response{};\r\n};\r\n```\r\n\r\nThe `Stubborn` member function `answer` uses a `const string&` reference as a parameter.\r\nThis avoids a copy operation from the original object that was passed to the function.\r\n\r\n## Function overloading\r\n\r\nMultiple functions can have the same name if the parameter list is different.\r\nThat is called function overloading and it is usually done if these functions perform very similar tasks.\r\n\r\nThe function header without the return type is the function's __type signature__.\r\nA change in the type signature results in a new function.\r\n\r\nThe `play_sound` example has six different overloads to accommodate different scenarios:\r\n\r\n```cpp\r\n// different argument types:\r\nvoid play_sound(char note);         // C, D, E, ..., B\r\nvoid play_sound(string solfege);    // do, re, mi, ..., ti\r\nvoid play_sound(int jianpu);        // 1, 2, 3, ..., 7\r\n\r\n// different number of arguments:\r\nvoid play_sound(string solfege, double duration);\r\n\r\n// different qualifiers:\r\nvoid play_sound(vector<string>& solfege);\r\nvoid play_sound(const vector<string>& solfege);\r\n```\r\n\r\n~~~~exercism/advanced\r\nThe type signature is defined by the function's name, the number of parameters, their types, and their qualifiers (but not their names).\r\nThe return type is explicitly not part of the type signature and you will get compilation errors if you have two functions that only differ in their return type.\r\nThe compiler will complain because it is not clear which of the two should be used.\r\n~~~~\r\n\r\n## Default arguments\r\n\r\nSome functions can get very lengthy and many of its calls might use the same values for most of the parameters.\r\nThe repetition in those calls can be avoided with default arguments.\r\n\r\n```cpp\r\nvoid record_new_horse_birth(string name, int weight, string color=\"brown-ish\", string dam=\"Alruccaba\", string sire=\"Poseidon\");\r\n\r\nrecord_new_horse_birth(\"Urban Sea\", 130); // color will be brown, dam \"Alruccabam\", sire \"Poseidon\"\r\nrecord_new_horse_birth(\"Highclere\", 175, \"off-white\", \"Fall Aspen\");   // sire will be \"Poseidon\"\r\n```\r\n\r\nAs the function declaration is often read before the definition, it is the better place to set the default arguments.\r\nIf one parameter has a default declaration, all the parameters to its right need a default declaration as well.\r\nSometimes complicated function overloads can be refactored to fewer functions with default arguments to improve maintainability.\r\n"
  },
  "meta": {
    "blurb": "In C++, functions support overloading, constant arguments, and default values.",
    "authors": [
      "vaeng"
    ],
    "contributors": []
  },
  "links": [
    {
      "url": "https://en.cppreference.com/w/cpp/language/cv",
      "description": "C++ reference on const qualifiers"
    },
    {
      "url": "https://en.cppreference.com/book/intro/function_overloading",
      "description": "C++ reference on function overloading"
    },
    {
      "url": "https://en.cppreference.com/w/cpp/language/overload_resolution",
      "description": "C++ reference on overload resolution"
    },
    {
      "url": "https://en.cppreference.com/w/cpp/language/default_arguments",
      "description": "C++ reference on default arguments"
    }
  ]
}