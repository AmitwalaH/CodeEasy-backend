{
  "language": "cpp",
  "slug": "lasagna",
  "docs": {
    "introduction": "# Introduction\r\n\r\n## Basics\r\n\r\nTo set off the C++ journey we are starting with variables, function calls, and comments.\r\n\r\n### Comments\r\n\r\nComments come in two flavors: single- and multi-line.\r\nEverything that comes after `//` on the same line is ignored by the compiler.\r\nMulti-line comments are also known as C-style comments.\r\nThey are surrounded by `/*` and `*/`.\r\nAnything that comes between these will be ignored as well.\r\n\r\n### Variables\r\n\r\nC++ is a typed language.\r\nAll types need to be known at compile time, and you generally need to state them explicitly.\r\nA variable's type cannot change.\r\nAn integer variable with the name `years` can be declared like this:\r\n\r\n```cpp\r\nint years;\r\n```\r\n\r\nIt is good practice to initialize variables upon declaration.\r\nC++ offers different mechanisms to do so.\r\nThe version with the curly braces is more in line with modern C++, but the equal-sign version is also very common.\r\n\r\n```cpp\r\nint tomatoes{80};\r\nint potatoes = 40;\r\n```\r\n\r\n~~~~exercism/caution\r\nC++ does allow using uninitialized variables.\r\nUntil the variable is deliberately set, it is undefined and might contain anything.\r\nTo avoid used-before-set errors and undefined behavior it is advisable to **always initialize**.\r\nUndefined behavior can crash your program at the worst possible moment, while it was running fine previously.\r\nIt cannot be stressed enough: avoid undefined behavior at all cost.\r\n~~~~\r\n\r\n### Arithmetic Operations\r\n\r\nArithmetic operators like `*`, `+`, or `-` can be part of an expression like `3 * 2` or `tomatoes + potatoes`.\r\n\r\n### Updating Variables\r\n\r\nYou can reassign variables, as long as they keep their type:\r\n\r\n```cpp\r\ntomatoes = tomatoes - 5; // tomatoes is now 75\r\npotatoes = (32 * 2) + 11; // potatoes is now 75 as well\r\n```\r\n\r\n### Functions\r\n\r\nFunctions have a name, a return type and a (possibly empty) parameter list.\r\nAn example of a function named `always_fortyseven` that would always return 47 would look like this:\r\n\r\n```cpp\r\nint always_fortyseven() {\r\n    return 47;\r\n}\r\n```\r\n\r\nHere is `vip_fee`, which has one parameter:\r\n\r\n```cpp\r\nint vip_fee(int standard_fee) {\r\n    /*\r\n    vip_fee calculates the vip fee based on the standard_fee.\r\n    */\r\n    int vip_multi{3};\r\n    return standard_fee * vip_multi;\r\n}\r\n```\r\n\r\nOr `total_fee`, a function with three parameters and a call to another function.\r\n\r\n```cpp\r\nint total_fee(int vips, int adults, int kids) {\r\n    /*\r\n    total_fee calculates the total price for a group of VIP and adult guests with kids.\r\n    Kids get a flat discount on the standard fee.\r\n    VIP guest fees are calculated by calling vip_fee.\r\n    */\r\n    int standard_fee{30};\r\n    int kids_discount{15};\r\n\r\n    int kids_total_fee = kids * (standard_fee - kids_discount);\r\n    int vips_total_fee = vips * vip_fee(standard_fee);\r\n    int adult_total_fee = adults * standard_fee;\r\n\r\n    return vips_total_fee + adult_total_fee + kids_total_fee;\r\n}\r\n```\r\n\r\nFunctions in C++ do not return the value of the last statement like in some other languages.\r\nThe `return` keyword is required for the code to compile.\r\n\r\n### Whitespace\r\n\r\nWhitespace is used for formatting source code and includes spaces, tabs, or newlines.\r\nAs the compiler ignores unnecessary whitespace, you can use it to structure your code.\r\nSmart use of whitespace can improve the readability of your code.\r\nThere are different formatting standards, but these are all conventional and not enforced by the compiler.\r\n\r\n```cpp\r\n// Formatting makes it easier to find bugs\r\n\r\nint eggs_yolks =  3;\r\nint      yeast = 15;\r\n\r\nint flour=500;int sugar=200;// compact, but difficult to read\r\n```\r\n",
    "instructions": "# Instructions\r\n\r\nLucian's girlfriend is on her way home and he hasn't cooked their anniversary dinner!\r\n\r\nIn this exercise, you're going to write some code to help Lucian cook an exquisite lasagna from his favorite cookbook.\r\n\r\nYou have four tasks, all related to the time spent cooking the lasagna.\r\n\r\n## 1. Define the expected oven time in minutes\r\n\r\nDefine the `ovenTime()` function that does not take any arguments and returns how many minutes the lasagna should be in the oven.\r\nAccording to the cookbook, the expected oven time is 40 minutes:\r\n\r\n```cpp\r\novenTime();\r\n// => 40\r\n```\r\n\r\n## 2. Calculate the remaining oven time in minutes\r\n\r\nDefine the `remainingOvenTime(int actualMinutesInOven)` function that takes the actual minutes the lasagna has been in the oven as an argument and returns how many minutes the lasagna still has to remain in the oven, based on the expected oven time in minutes from the previous task.\r\n\r\n```cpp\r\nremainingOvenTime(30);\r\n// => 10\r\n```\r\n\r\n## 3. Calculate the preparation time in minutes\r\n\r\nDefine the `preparationTime(int numberOfLayers)` function that takes the number of layers you added to the lasagna as an argument and returns how many minutes you spent preparing the lasagna, assuming each layer takes you 2 minutes to prepare.\r\n\r\n```cpp\r\npreparationTime(2);\r\n// => 4\r\n```\r\n\r\n## 4. Calculate the elapsed time in minutes\r\n\r\nDefine the `elapsedTime(int numberOfLayers, int actualMinutesInOven)` function that takes two arguments: the first argument is the number of layers you added to the lasagna, and the second argument is the number of minutes the lasagna has been in the oven. The function should return how many minutes you've worked on cooking the lasagna, which is the sum of the preparation time in minutes, and the time in minutes the lasagna has spent in the oven at the moment.\r\n\r\n```cpp\r\nelapsedTime(3, 20);\r\n// => 26\r\n```\r\n",
    "hints": "# Hints\r\n\r\n## General\r\n\r\n- Don't forget the `;` after each statement.\r\n- You can define an integer with `int myInteger = 44;`.\r\n\r\n## 1. Get the baking time.\r\n\r\n- The instructions have information on the time for the recipe.\r\n- A function can return a value in the form of `return 2;`\r\n\r\n## 2. Get the preparation time.\r\n\r\n- You can access the number of layers by using the respective parameter.\r\n- You can do calculations when you define an integer: `int myInteger = 3 + myOtherInteger;`\r\n\r\n## 3. Calculate the time left in the oven\r\n\r\n- You can call other functions and use the returned value like variables: `return 22 * myOtherCalculation();`\r\n\r\n## 4. Calculate the total time spent on the lasagna\r\n\r\n- The output should combine the time for the preparation and the time the lasagna has already been in the oven.\r\n"
  },
  "starter_code": {
    "lasagna.cpp": "// ovenTime returns the amount in minutes that the lasagna should stay in the\r\n// oven.\r\nint ovenTime() {\r\n    // TODO: Return the correct time.\r\n    return 0;\r\n}\r\n\r\n/* remainingOvenTime returns the remaining\r\n   minutes based on the actual minutes already in the oven.\r\n*/\r\nint remainingOvenTime(int actualMinutesInOven) {\r\n    // TODO: Calculate and return the remaining in the oven based on the time\r\n    // the lasagna has already been there.\r\n    return 0;\r\n}\r\n\r\n/* preparationTime returns an estimate of the preparation time based on the\r\n   number of layers and the necessary time per layer.\r\n*/\r\nint preparationTime(int numberOfLayers) {\r\n    // TODO: Calculate and return the preparation time with the\r\n    // `numberOfLayers`.\r\n    return 0;\r\n}\r\n\r\n// elapsedTime calculates the total time spent to create and bake the lasagna so\r\n// far.\r\nint elapsedTime(int numberOfLayers, int actualMinutesInOven) {\r\n    // TODO: Calculate and return the total time so far.\r\n    return 0;\r\n}\r\n"
  },
  "tests": {
    "lasagna_test.cpp": "#include \"lasagna.cpp\"\r\n#ifdef EXERCISM_TEST_SUITE\r\n#include <catch2/catch.hpp>\r\n#else\r\n#include \"test/catch.hpp\"\r\n#endif\r\n\r\nusing namespace std;\r\n\r\nTEST_CASE(\"Preparation time correct\", \"[task_1]\") {\r\n    int actual = 40;\r\n    int expected = ovenTime();\r\n\r\n    REQUIRE(expected == actual);\r\n}\r\n\r\n#if defined(EXERCISM_RUN_ALL_TESTS)\r\n\r\nTEST_CASE(\"Fresh in the oven\", \"[task_2]\") {\r\n    int timeSpendInOven = 0;\r\n    int neededBakeTime = 40;\r\n    int actual = remainingOvenTime(timeSpendInOven);\r\n    int expected{neededBakeTime - timeSpendInOven};\r\n\r\n    REQUIRE(expected == actual);\r\n}\r\n\r\nTEST_CASE(\"Halfway done\", \"[task_2]\") {\r\n    int timeSpendInOven = 20;\r\n    int neededBakeTime = 40;\r\n    int actual = remainingOvenTime(timeSpendInOven);\r\n    int expected{neededBakeTime - timeSpendInOven};\r\n\r\n    REQUIRE(expected == actual);\r\n}\r\n\r\nTEST_CASE(\"Correct for six layers\", \"[task_3]\") {\r\n    int timePerLayer = 2;\r\n    int layers = 6;\r\n    int actual = preparationTime(layers);\r\n    int expected{timePerLayer * layers};\r\n\r\n    REQUIRE(expected == actual);\r\n}\r\n\r\nTEST_CASE(\"Correct for 11 layers\", \"[task_3]\") {\r\n    int timePerLayer = 2;\r\n    int layers = 11;\r\n    int actual = preparationTime(layers);\r\n    int expected{timePerLayer * layers};\r\n\r\n    REQUIRE(expected == actual);\r\n}\r\n\r\nTEST_CASE(\"Fresh in the oven, 12 layers!\", \"[task_4]\") {\r\n    int timeSpendInOven = 0;\r\n    int timePerLayer = 2;\r\n    int layers = 12;\r\n    int actual = elapsedTime(layers, timeSpendInOven);\r\n    int expected{timePerLayer * layers + timeSpendInOven};\r\n\r\n    REQUIRE(expected == actual);\r\n}\r\n\r\nTEST_CASE(\"One minute left, 5 layers!\", \"[task_4]\") {\r\n    int timeSpendInOven = 39;\r\n    int timePerLayer = 2;\r\n    int layers = 5;\r\n    int actual = elapsedTime(layers, timeSpendInOven);\r\n    int expected{timePerLayer * layers + timeSpendInOven};\r\n\r\n    REQUIRE(expected == actual);\r\n}\r\n\r\n#endif\r\n"
  }
}