{
  "language": "cpp",
  "slug": "power-of-troy",
  "docs": {
    "introduction": "# Introduction\r\n\r\n## The `auto` Keyword in C++\r\n\r\nIn C++, the `auto` keyword is a powerful feature introduced in C++11, used to declare variables with an inferred data type.\r\nThe compiler deduces the type of the variable based on its initializer, which can make code more readable and easier to maintain.\r\n\r\n## Example Usage\r\n\r\nConsider the following example where `auto` is used to declare variables:\r\n\r\n```cpp\r\nauto dragon_population{3};          // dragon_population is deduced as an integer\r\nauto westeros{7.7777};              // westeros is deduced as a double\r\nauto wedding_location{\"The Twins\"}; // wedding_location is deduced as a const char*, not std::string\r\n```\r\n\r\nIn each case, the type of the variable is inferred from the value it is initialized with.\r\n\r\n## Type Inference\r\n\r\nThe `auto` keyword helps by writing more concise and readable code by reducing the verbosity of explicit types.\r\n\r\n```cpp\r\nconst std::vector<std::string> pigeon_pie{\"flour\", \"butter\", \"pigeon\", \"salt\"};\r\nauto purple_wedding_pie{pigeon_pie};\r\npurple_wedding_pie.emplace_back(\"the strangler\");\r\n```\r\n\r\nIn this loop, `auto` deduces the type of `purple_wedding_pie` as `std::vector<std::string>`, avoiding the need to explicitly specify the type again.\r\n\r\n## Compatibility\r\n\r\nThe `auto` keyword is compatible with various C++ constructs making it a versatile tool in modern C++ programming.\r\n\r\n```cpp\r\nauto& element{array[0]};           // reference to an element\r\nconst auto object{otherObject};    // const type version of otherObject's type\r\nauto* ptr{&x};                     // pointer to x with the same type as x, but as a pointer.\r\n```\r\n\r\nIn later concept we will often see the `auto` keyword with lambda expressions, range-based for-loops, and iterators.\r\n\r\n## Smart Pointers\r\n\r\nSmart pointers are a modern C++ feature designed to provide automatic memory management, helping to prevent memory leaks and dangling pointers commonly associated with raw pointers.\r\nThey act as wrappers around raw pointers, adding additional functionality such as automatic memory deallocation when the pointer is no longer needed.\r\n\r\n## General Syntax\r\n\r\nSmart pointers are typically implemented as class templates in the C++ standard library.\r\nThe two most commonly used smart pointers are `std::unique_ptr` and `std::shared_ptr`.\r\n\r\n## Unique Pointers\r\n\r\n`std::unique_ptr` is a smart pointer that owns the object exclusively.\r\nIt ensures that at any given time, only one `std::unique_ptr` object owns the resource.\r\nWhen the owning `std::unique_ptr` is destroyed or reset, it automatically destructs the objects and releases its memory.\r\n\r\n```cpp\r\n#include <memory>\r\n// Declaring and defining a unique pointer\r\nauto rightful_king_of_england = std::make_unique<std::string>(\"Excalibur\");\r\n\r\n// Unique pointers cannot be copied or assigned\r\nauto mordred = rightful_king_of_england; // Error: Cannot copy a unique_ptr\r\n```\r\n\r\n## Advantages of `std::make_unique()`\r\n\r\nWhen creating a `std::unique_ptr`, it's preferable to use `std::make_unique()` instead of directly using `new` to allocate memory.\r\n`std::make_unique()` provides several advantages:\r\n1. **Exception Safety**: `std::make_unique()` guarantees exception safety.\r\n  If an exception is thrown during the construction of the object, memory will be automatically deallocated, preventing memory leaks.\r\n2. **Clarity**: Using `std::make_unique()` makes code clearer and more concise.\r\n  It eliminates the need to explicitly specify the type being allocated, as the template arguments are deduced automatically.\r\n3. **Optimization Opportunities**: Compilers have the opportunity to optimize `std::make_unique()` more effectively than manually allocating memory with `new`, potentially resulting in improved performance.\r\n4. **Avoiding Misuse**: Deleting the underlying resource is possible, when the `std::unique_ptr` is constructed manually.\r\n  That would lead to undefined behavior, when the `std::unique_ptr` tries to delete it at its end of scope.\r\n\r\n## Shared Pointers\r\n\r\n`std::shared_ptr` is a smart pointer that allows multiple `std::shared_ptr` objects to share ownership of the same resource.\r\nIt keeps track of how many shared pointers are referencing the resource, and deallocates the memory only when the last shared pointer owning the resource goes out of scope or is reset.\r\n\r\n```cpp\r\n// Declaring and defining a shared pointer to a dynamically allocated string\r\nauto martian_congressional_republic = std::make_shared<std::string>(\"protomolecule\");\r\n\r\n// Creating more shared pointer that shares ownership\r\nauto outer_planets_alliance = martian_congressional_republic;\r\nauto united_nations = martian_congressional_republic;\r\n```\r\n\r\n~~~~exercism/caution\r\nIn C++17 and below, using `std::shared_ptr` with arrays via `std::make_shared<T[]>` is not directly supported.\r\nWhile it's possible to allocate arrays with `std::make_shared<T[]>`, creating shared pointers directly from them may lead to undefined behavior due to differences in memory management between single objects and arrays.\r\nInstead, consider using `std::vector` or custom deletion functions to manage arrays with shared pointers effectively.\r\nAlways ensure compatibility with your compiler and standard library implementation when dealing with array allocations and shared pointers in C++17.\r\n~~~~\r\n\r\n## Advantages of `std::make_shared()`\r\n\r\nSimilar to `std::make_unique()`, `std::make_shared()` offers benefits such as improved memory efficiency, exception safety, and readability.\r\nIt combines memory allocation for the control block and the managed object into a single operation, enhancing efficiency and reducing the risk of memory leaks.\r\nAdditionally, automatic deduction of template arguments simplifies code and enhances readability.\r\nUsing `std::make_shared()` promotes cleaner, safer, and more efficient code when working with `std::shared_ptr` objects in C++.\r\n\r\n## Usage advice\r\n\r\nUse smart pointers by default: `std::unique_ptr` for exclusive ownership and `std::shared_ptr` for shared ownership.\r\nReserve raw pointers for non-owning references or when interfacing with legacy code.\r\nIn most cases, `std::unique_ptr` is sufficient for exclusive ownership, as it offers lightweight memory management without the overhead of reference counting.\r\n`std::shared_ptr` should be used sparingly, as it introduces overhead and complexity unless true shared ownership is needed.\r\n",
    "instructions": "# Instructions\r\n\r\nThis exercise takes you to the world of Troy.\r\nThe lives of its people are full of wonder and magic.\r\nMany humans in Troy possess _powers_, that are used frequently in their daily lives.\r\nPowers are used to re-shape the world or influence Troy's fauna and other people.\r\nMagic also manifests in _unique artifacts_, that are highly sought after by adventurers, artisans and sages.\r\n\r\nIn this exercise you are going to write code to model the humans of Troy, their possessed artifacts and power interactions.\r\n\r\nYou have six tasks.\r\nThe first one is related to creating a human, the other five are about handling powers and artifacts.\r\n\r\n## 1. Bring humans to the world of Troy\r\n\r\nFor your model of Troy, humans are the most important feature.\r\nYour model human should be able to possess a _unique artifact_.\r\nThey should also have the ability to manifest a _power_.\r\nThese powers might affect other humans, so you also want to model if a human is influenced by some other power.\r\n\r\nYou are provided with basic implementations of `artifact` and `power` structs.\r\nImplement a `human` struct (or class) that has a _smart-pointer_ to an `artifact` member variable named `possession`.\r\nEach artifact can only be possessed by a single human at any given time.\r\n\r\nA `human` must have two additional member variables.\r\nOne holds their `own_power` and the other is a power they are `influenced_by`.\r\nBoth `own_power` and `influenced_by` are _smart-pointers_ to `powers`.\r\nEach `power` might be owned by a single human, but also influence other humans at the same time.\r\n\r\nBy default, humans are born without any artifact and neither own any powers nor are they influenced by them.\r\n\r\n```cpp\r\nhuman mindy_mccready{};\r\nmindy_mccready.possession;\r\n// => nullptr\r\nmindy_mccready.own_power;\r\n// => nullptr\r\nmindy_mccready.influenced_by;\r\n// => nullptr\r\n```\r\n\r\n## 2. Bring Artifacts into Troy\r\n\r\nYour model is boring without the interaction of its parts.\r\nYou want to create unique artifacts and give them to certain humans.\r\n\r\nDefine the function `give_new_artifact` which returns nothing but takes a reference to a `human` and a `string`.\r\nWith the `string` it should define a new `artifact` object and set the `possession` pointer of the `human` accordingly.\r\nThe function should not return anything.\r\n\r\n```cpp\r\nhuman erik_magnus_lehnsherr{};\r\ngive_new_artifact(erik_magnus_lehnsherr, \"Mind shielding helmet\");\r\n\r\nerik_magnus_lehnsherr.possession->name;\r\n// \"Mind shielding helmet\"\r\n```\r\n\r\n## 3. Make items tradeable\r\n\r\nThe world of Troy is all about interaction.\r\nYou want people to make trades by exchanging their possessions.\r\n\r\nWrite a function `exchange_artifacts` that returns nothing but takes two artifact smart-pointers to exchange the items.\r\nRemember, that you cannot copy a `unique_ptr`.\r\nThis includes the usage in function parameters.\r\nUse a reference to the `unique_ptr` instead.\r\n\r\n```cpp\r\nhuman uchiha{};\r\ngive_new_artifact(uchiha, \"konoha headband\");\r\nhuman uzumaki{};\r\ngive_new_artifact(uzumaki, \"forehead protector\");\r\n\r\nexchange_artifacts(uchiha.possession, uzumaki.possession);\r\n\r\nuchiha.possession->name;\r\n// \"forehead protector\"\r\nuzumaki.possession->name;\r\n// \"konoha headband\"\r\n```\r\n\r\n## 4. Give Power to the People\r\n\r\nThe most exciting feature of Troy are the special powers that people might wield.\r\nSome can smelt iron with their thoughts, while others can heal every wound instantly at nighttime.\r\n\r\nDefine the function `manifest_power` which returns nothing but takes a reference to a `human` and a `string`.\r\nWith the `string` it should define a new `power` object and set the `own_power` pointer of the `human` accordingly.\r\nThe function should not return anything.\r\n\r\n```cpp\r\nhuman eleven {};\r\nmanifest_power(eleven, \"psychokinesis\");\r\n\r\neleven.own_power->effect;\r\n// \"psychokinesis\"\r\n```\r\n\r\n## 5. Use the Power\r\n\r\nWhat use are the greatest powers, if you cannot use them.\r\nYour model concentrates on humans, so you want to track the influence of powers.\r\n\r\nWrite a _void_ function `use_power` that takes two references to humans.\r\nThe first human is the caster and the second represents the target.\r\nThe target's `influenced_by` pointer should be pointed to the power of the caster.\r\n\r\nFor simplicity, humans can only be influenced by a single power.\r\nThis power stays in place even if the caster does not exist any longer.\r\n\r\n```cpp\r\nhuman pamela_isley{};\r\nmanifest_power(pamela_isley, \"control pheromones\");\r\n\r\nhuman count_vertigo{};\r\nuse_power(pamela_isley, count_vertigo);\r\ncount_vertigo.influenced_by->effect;\r\n// \"control pheromones\"\r\n```\r\n\r\n## 6. Keep watch on the power's intensity\r\n\r\nCertain powers lose their potency or trigger certain effects in your simulation when they are applied to several humans.\r\nYou want to track the number of people who are connected to each power.\r\n\r\nDefine the function `power_intensity`, that takes a human and returns the intensity of their power as an _int_.\r\nIf the person has no power, the return value should be `0`.\r\nOtherwise the intensity should reflect the caster and all currently influenced people.\r\n\r\n```cpp\r\nhuman jean_grey{};\r\nmanifest_power(jean_grey, \"uplifting personality\");\r\n\r\nhuman scott{};\r\nhuman logan{};\r\nhuman ororo{};\r\n\r\nuse_power(jean_grey, ororo);\r\nuse_power(jean_grey, logan);\r\nuse_power(jean_grey, scott);\r\n\r\npower_intensity(jean_grey);\r\n// 4\r\n```\r\n",
    "hints": "# Hints\r\n\r\n## 1. Bring humans to the world of Troy\r\n\r\n- The core of this exercise is the usage of `unique_ptr` and `shared_ptr`.\r\n  Which kind of smart pointer should be used for each of the `human` variables?\r\n- `artifacts` are not shared, but `powers` are needed to track influenced people.\r\n- the `possession` pointer should be unique, the power pointers should be shared.\r\n\r\n## 2. Bring Artifacts into Troy\r\n\r\n- You need to create a smart pointer and assign it to the `possession` variable\r\n- Use _references_ to change the object outside of the function.\r\n- Look up [`std::make_unique`][make_unique] for some hints.\r\n- The type of the pointer's target object has to be put in the angled brackets and again inside the parens to define the object.\r\n- Here is a full example: `variable = std::make_unique<int>(int{23});`\r\n\r\n## 3. Make items tradeable\r\n\r\n- You can look through the [unique_ptr reference][unique_ptr] to find a fitting function.\r\n- Do you think `std::swap` can help you?\r\n\r\n## 4. Give Power to the People\r\n\r\n- You need to create a smart pointer and assign it to the `own_power` variable\r\n- Use _references_ to change the object outside of the function.\r\n- Look up [`std::make_shared`][make_shared] for some hints.\r\n- The type of the pointer's target object has to be put in the angled brackets and again inside the parens to define the object.\r\n- Here is a full example: `variable = std::make_shared<int>(int{23});`\r\n\r\n## 5. Use the Power\r\n\r\n- Use _references_ to change the object outside of the function.\r\n\r\n## 6. Keep watch on the power's intensity\r\n\r\n- You can look through the [shared_ptr reference][shared_ptr] to find a fitting function.\r\n- Do you think `use_count` can help you?\r\n\r\n[unique_ptr]: https://en.cppreference.com/w/cpp/memory/unique_ptr\r\n[make_unique]: https://en.cppreference.com/w/cpp/memory/unique_ptr/make_unique\r\n[shared_ptr]: https://en.cppreference.com/w/cpp/memory/shared_ptr\r\n[make_shared]: https://en.cppreference.com/w/cpp/memory/shared_ptr/make_shared\r\n"
  },
  "starter_code": {
    "power_of_troy.cpp": "#include \"power_of_troy.h\"\r\n\r\nnamespace troy {}  // namespace troy\r\n",
    "power_of_troy.h": "#pragma once\r\n\r\n#include <string>\r\n\r\nnamespace troy {\r\n\r\nstruct artifact {\r\n    // constructors needed (until C++20)\r\n    artifact(std::string name) : name(name) {}\r\n    std::string name;\r\n};\r\n\r\nstruct power {\r\n    // constructors needed (until C++20)\r\n    power(std::string effect) : effect(effect) {}\r\n    std::string effect;\r\n};\r\n\r\n}  // namespace troy\r\n"
  },
  "tests": {
    "power_of_troy_test.cpp": "#include \"power_of_troy.h\"\r\n#ifdef EXERCISM_TEST_SUITE\r\n#include <catch2/catch.hpp>\r\n#else\r\n#include \"test/catch.hpp\"\r\n#endif\r\n\r\nusing namespace troy;\r\n\r\nTEST_CASE(\"Create a human\", \"[task_1]\") {\r\n    human lanfeust{};\r\n\r\n    REQUIRE(lanfeust.possession == nullptr);\r\n    REQUIRE(lanfeust.own_power == nullptr);\r\n    REQUIRE(lanfeust.influenced_by == nullptr);\r\n}\r\n\r\n#if defined(EXERCISM_RUN_ALL_TESTS)\r\n\r\nTEST_CASE(\"Give a new artifact to a human\", \"[task_2]\") {\r\n    human lanfeust{};\r\n    std::string pommel{\"Magohamoth Ivory Sword Pommel\"};\r\n\r\n    give_new_artifact(lanfeust, pommel);\r\n\r\n    REQUIRE(lanfeust.possession != nullptr);\r\n    REQUIRE(lanfeust.possession->name == pommel);\r\n}\r\n\r\nTEST_CASE(\"Exchange artifact with another human\", \"[task_3]\") {\r\n    human zoltan{};\r\n    std::string worldstone_shard{\"Soulstone\"};\r\n    give_new_artifact(zoltan, worldstone_shard);\r\n    human tal_rasha{};\r\n\r\n    exchange_artifacts(zoltan.possession, tal_rasha.possession);\r\n\r\n    REQUIRE(zoltan.possession == nullptr);\r\n    REQUIRE(tal_rasha.possession->name == worldstone_shard);\r\n}\r\n\r\nTEST_CASE(\"Manifest power in a human\", \"[task_4]\") {\r\n    human cian{};\r\n    std::string gift_of_night{\"heal\"};\r\n\r\n    manifest_power(cian, gift_of_night);\r\n\r\n    REQUIRE(cian.own_power != nullptr);\r\n    REQUIRE(cian.own_power->effect == gift_of_night);\r\n}\r\n\r\nTEST_CASE(\"Use power on another human\", \"[task_5]\") {\r\n    human cian{};\r\n    manifest_power(cian, \"heal\");\r\n    human lanfeust{};\r\n\r\n    use_power(cian, lanfeust);\r\n\r\n    REQUIRE(cian.influenced_by == nullptr);\r\n    REQUIRE(lanfeust.influenced_by == cian.own_power);\r\n}\r\n\r\nTEST_CASE(\"Check power intensity of person without power\", \"[task_6]\") {\r\n    human cixi{};\r\n\r\n    REQUIRE(power_intensity(cixi) == 0);\r\n}\r\n\r\nTEST_CASE(\"Check power intensity when not in use\", \"[task_6]\") {\r\n    human nicolede{};\r\n    manifest_power(nicolede, \"enchantment\");\r\n\r\n    REQUIRE(power_intensity(nicolede) == 1);\r\n}\r\n\r\nTEST_CASE(\"Check power intensity when used on just one person\", \"[task_6]\") {\r\n    human nicolede{};\r\n    manifest_power(nicolede, \"enchantment\");\r\n    human hebus{};\r\n\r\n    use_power(nicolede, hebus);\r\n\r\n    REQUIRE(power_intensity(nicolede) == 2);\r\n}\r\n\r\nTEST_CASE(\"Check power intensity when used on group of four\", \"[task_6]\") {\r\n    human sue{};\r\n    human reed{};\r\n    human johnny{};\r\n    human ben{};\r\n\r\n    human victor{};\r\n    manifest_power(victor, \"technopathic super-genius\");\r\n\r\n    use_power(victor, reed);\r\n    use_power(victor, johnny);\r\n    use_power(victor, ben);\r\n    use_power(victor, sue);\r\n\r\n    REQUIRE(power_intensity(victor) == 5);\r\n}\r\n\r\nTEST_CASE(\"Check power intensity drop after usage\", \"[task_6]\") {\r\n    human palpatine{};\r\n    manifest_power(palpatine, \"force torrent\");\r\n\r\n    // let's start a non-canon duel:\r\n    // (Everything in the scope of the brackets is deleted after the brackets\r\n    // close)\r\n    {\r\n        human grievous{};\r\n        use_power(palpatine, grievous);\r\n        REQUIRE(power_intensity(palpatine) == 2);\r\n    }\r\n    REQUIRE(power_intensity(palpatine) == 1);\r\n}\r\n\r\n#endif\r\n"
  }
}