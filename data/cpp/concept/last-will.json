{
  "language": "cpp",
  "slug": "last-will",
  "docs": {
    "introduction": "# Introduction\r\n\r\n## Namespaces\r\n\r\nAn important method for code organization is the use of namespaces.\r\nTwo functions might have a naming collision, which can be resolved by putting them in different namespaces.\r\nNamespaces can be nested, which might help to structure big code bases.\r\nAccess to the namespaces is done via the scope-resolution operator `::`.\r\n\r\nThe example below shows the use of two different `foo` functions.\r\nThey are used together by prefixing their respective namespaces.\r\n\r\n```cpp\r\nnamespace my_ns {\r\n    int foo() {\r\n        return 44;\r\n    }\r\n    namespace my_inner_ns {\r\n        int baz() {\r\n            return 90;\r\n        }\r\n    }\r\n}\r\nnamespace my_other_ns {\r\n    int foo() {\r\n        return -2;\r\n    }\r\n}\r\n\r\nint myresult{my_ns::foo() + my_other_ns::foo() * my_ns::my_inner_ns::baz()};\r\n```\r\n",
    "instructions": "# Instructions\r\n\r\nYou work for a prestigious law firm that is specialized in handling unique testament requests.\r\n\r\nIn this exercise, you are going to open a mysterious vault.\r\nYou are the executor of the estate and will assemble the long-kept secret codes of three families to get an account number and the matching code.\r\n\r\nTo prevent any family from opening the vault alone, it can only be opened by combining their knowledge with a secret modifier that you know from the last will.\r\n\r\nYou have three tasks, all related to helping the families to open the vault.\r\n\r\n## 1. Take your seat in front of the families and lay out your papers\r\n\r\nDefine a namespace called `estate_executor`.\r\nThe code from the next tasks should be defined in the body of the `estate_executor` namespace.\r\n\r\n```cpp\r\nnamespace some_name {\r\n    // The space between the curly brackets\r\n    // is called body of the  namespace.\r\n}\r\n```\r\n\r\n## 2. Find the secret account number\r\n\r\nThis is your big moment.\r\nOnly you have the secret modifier key to reveal the secret account number.\r\n\r\nDefine the `assemble_account_number(int secret_modifier)` function that takes the secret modifier as an argument and returns the assembled account number as an `int`.\r\n\r\nTo get the correct number, you have to sum up the `bank_number_part` from each of the three families.\r\n\r\n## 3. Last step: Enter the secret code\r\n\r\nThe instructions in the testament ask you to add all the blue and then all the red fragments.\r\nThe resulting code is obtained by multiplying both sums.\r\n\r\nDefine the `assemble_code()` function that returns the resulting code by combining the fragments from the three families to a single `integer`.\r\nThe function does not have any arguments and relies solely on the information in the relevant namespaces from the families.\r\n",
    "hints": "# Hints\r\n\r\n## General\r\n\r\n- Do not change the code in the families' namespaces.\r\n- Do not copy the values into your code, call the functions.\r\n\r\n## 1. Take your seat in front of the families and lay out your papers\r\n\r\n- The namespace has to be called `estate_executor` for the tests to work.\r\n\r\n## 2. Find the secret account number\r\n\r\nEach `bank_number_part` has to be called with the `secret_modifier` from the parameter list.\r\n\r\n## 3. Last step: Enter the secret code\r\n\r\n- You can call functions from nested namespaces like this `outer_namespace::inner_namespac::my_function`.\r\n\r\n- Take care to add the blue and the red fragments separately before multiplicating both parts.\r\n"
  },
  "starter_code": {
    "last_will.cpp": "// Enter your code below the lines of the families' information\r\n\r\n// Secret knowledge of the Zhang family:\r\nnamespace zhang {\r\nint bank_number_part(int secret_modifier) {\r\n    int zhang_part{8'541};\r\n    return (zhang_part * secret_modifier) % 10000;\r\n}\r\nnamespace red {\r\nint code_fragment() { return 512; }\r\n}  // namespace red\r\nnamespace blue {\r\nint code_fragment() { return 677; }\r\n}  // namespace blue\r\n}  // namespace zhang\r\n\r\n// Secret knowledge of the Khan family:\r\nnamespace khan {\r\nint bank_number_part(int secret_modifier) {\r\n    int khan_part{4'142};\r\n    return (khan_part * secret_modifier) % 10000;\r\n}\r\nnamespace red {\r\nint code_fragment() { return 148; }\r\n}  // namespace red\r\nnamespace blue {\r\nint code_fragment() { return 875; }\r\n}  // namespace blue\r\n}  // namespace khan\r\n\r\n// Secret knowledge of the Garcia family:\r\nnamespace garcia {\r\nint bank_number_part(int secret_modifier) {\r\n    int garcia_part{4'023};\r\n    return (garcia_part * secret_modifier) % 10000;\r\n}\r\nnamespace red {\r\nint code_fragment() { return 118; }\r\n}  // namespace red\r\nnamespace blue {\r\nint code_fragment() { return 923; }\r\n}  // namespace blue\r\n}  // namespace garcia\r\n\r\n// Enter your code below\r\n"
  },
  "tests": {
    "last_will_test.cpp": "#include \"last_will.cpp\"\r\n#ifdef EXERCISM_TEST_SUITE\r\n#include <catch2/catch.hpp>\r\n#else\r\n#include \"test/catch.hpp\"\r\n#endif\r\n\r\nusing namespace std;\r\n\r\nTEST_CASE(\"Family secrets have not been altered\", \"[task_1]\") {\r\n    // We cannot test the existence of a namespace in the compiled\r\n    // Code.\r\n    // This test merely checks if the numbers in the file have\r\n    // been changed. They have to be correct for the test to work.\r\n\r\n    REQUIRE(zhang::bank_number_part(1) == 8541);\r\n    REQUIRE(zhang::bank_number_part(3) == 8541 * 3 % 10'000);\r\n    REQUIRE(khan::bank_number_part(1) == 4142);\r\n    REQUIRE(khan::bank_number_part(3) == 4142 * 3 % 10'000);\r\n    REQUIRE(garcia::bank_number_part(1) == 4023);\r\n    REQUIRE(garcia::bank_number_part(3) == 4023 * 3 % 10'000);\r\n\r\n    REQUIRE(zhang::red::code_fragment() == 512);\r\n    REQUIRE(khan::red::code_fragment() == 148);\r\n    REQUIRE(garcia::red::code_fragment() == 118);\r\n\r\n    REQUIRE(zhang::blue::code_fragment() == 677);\r\n    REQUIRE(khan::blue::code_fragment() == 875);\r\n    REQUIRE(garcia::blue::code_fragment() == 923);\r\n}\r\n\r\nTEST_CASE(\"Account number assembly function exists in correct namespace\",\r\n          \"[task_2]\") {\r\n    REQUIRE_NOTHROW(estate_executor::assemble_account_number(0));\r\n}\r\n\r\n#if defined(EXERCISM_RUN_ALL_TESTS)\r\n\r\nTEST_CASE(\"Account number assembly works correctly\", \"[task_2]\") {\r\n    int account_with_secret_1{16706};\r\n    int account_with_secret_23{14238};\r\n\r\n    REQUIRE(estate_executor::assemble_account_number(1) ==\r\n            account_with_secret_1);\r\n    REQUIRE(estate_executor::assemble_account_number(23) ==\r\n            account_with_secret_23);\r\n}\r\n\r\nTEST_CASE(\"Code fragment number assembly function exists in correct namespace\",\r\n          \"[task_3]\") {\r\n    REQUIRE_NOTHROW(estate_executor::assemble_code());\r\n}\r\n\r\nTEST_CASE(\"Code fragments fit correctly\", \"[task_3]\") {\r\n    int final_code{1925550};\r\n\r\n    REQUIRE(estate_executor::assemble_code() == final_code);\r\n}\r\n\r\n#endif\r\n"
  }
}