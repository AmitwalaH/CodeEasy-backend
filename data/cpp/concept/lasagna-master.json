{
  "language": "cpp",
  "slug": "lasagna-master",
  "docs": {
    "introduction": "# Introduction\r\n\r\n## Terminology\r\n\r\nYou have already used and written C++ functions in a couple of concepts.\r\nIt is time to get technical.\r\nThe code snippet below shows the most common terms for easy reference.\r\nAs C++ ignores whitespace, the formatting has been changed to put each element on a single line.\r\n\r\n```cpp\r\n// Function declaration:\r\nbool                                              // Return type\r\nadmin_detected(string user, string password)      // Type signature\r\n;                                                 // Don't forget the ';' for the declaration\r\n\r\n// Function definition:\r\nbool                                              // Return type\r\nadmin_detected                                    // Function name\r\n(string user, string password)                    // Parameter list\r\n{ return user == \"admin\" && password == \"1234\"; } // Function body\r\n```\r\n~~~~exercism/advanced\r\nThe declaration works like a note to the compiler, that there is a function of that name, return type and parameter list.\r\nThe code will not work, if the definition is missing.\r\nDeclarations are optional, they are needed if you use the function before its definition.\r\nDeclarations can solve problems like cyclic references and they can be used to separate the interface from the implementation.\r\n~~~~\r\n\r\n## The const qualifier\r\n\r\nSometimes you want to make sure that values cannot be changed after they have been initialized.\r\nC++ uses the `const` keyword as a qualifier for constants.\r\n\r\n```cpp\r\nconst int number_of_dragon_balls{7};\r\nnumber_of_dragon_balls--; // compilation error\r\n```\r\n\r\n~~~~exercism/note\r\nYou will often see constants written in _UPPER_SNAKE_CASE_.\r\nIt is recommended to reserve this casing for macros, if there is no other convention.\r\n~~~~\r\n\r\nIf you try to change a constant variable after it has been set, your code will not compile.\r\nThis helps to avoid unintended changes but also opens up optimization possibilities for the compiler.\r\nAs a human, it is also easier to reason about the code, if you know that certain parts will not be affected.\r\n\r\nYou can also have `const` as a qualifier for function parameters.\r\n\r\n```cpp\r\nstring guess_number(const int& secret, const int& guess) {\r\n    if (secret < guess) return \"lower.\";\r\n    if (secret > guess) return \"higher.\";\r\n    return \"exact!\";\r\n}\r\n```\r\n\r\nWhen you pass a `const` reference to the function, you can be sure that it will be left unchanged.\r\nYou will often see `const` references for objects that might be costly to copy, like longer strings.\r\nA third use-case for the `const` qualifier are member functions that do not change the instance of a class.\r\n\r\n```cpp\r\nclass Stubborn {\r\n    public:\r\n    Stubborn(string reply) {\r\n        response = reply;\r\n    }\r\n    string answer(const string& question) const {\r\n        if (question.length() == 0) { return \"\"; }\r\n        return response;\r\n    }\r\n    private:\r\n    string response{};\r\n};\r\n```\r\n\r\nThe `Stubborn` member function `answer` uses a `const string&` reference as a parameter.\r\nThis avoids a copy operation from the original object that was passed to the function.\r\n\r\n## Function overloading\r\n\r\nMultiple functions can have the same name if the parameter list is different.\r\nThat is called function overloading and it is usually done if these functions perform very similar tasks.\r\n\r\nThe function header without the return type is the function's __type signature__.\r\nA change in the type signature results in a new function.\r\n\r\nThe `play_sound` example has six different overloads to accommodate different scenarios:\r\n\r\n```cpp\r\n// different argument types:\r\nvoid play_sound(char note);         // C, D, E, ..., B\r\nvoid play_sound(string solfege);    // do, re, mi, ..., ti\r\nvoid play_sound(int jianpu);        // 1, 2, 3, ..., 7\r\n\r\n// different number of arguments:\r\nvoid play_sound(string solfege, double duration);\r\n\r\n// different qualifiers:\r\nvoid play_sound(vector<string>& solfege);\r\nvoid play_sound(const vector<string>& solfege);\r\n```\r\n\r\n~~~~exercism/advanced\r\nThe type signature is defined by the function's name, the number of parameters, their types, and their qualifiers (but not their names).\r\nThe return type is explicitly not part of the type signature and you will get compilation errors if you have two functions that only differ in their return type.\r\nThe compiler will complain because it is not clear which of the two should be used.\r\n~~~~\r\n\r\n## Default arguments\r\n\r\nSome functions can get very lengthy and many of its calls might use the same values for most of the parameters.\r\nThe repetition in those calls can be avoided with default arguments.\r\n\r\n```cpp\r\nvoid record_new_horse_birth(string name, int weight, string color=\"brown-ish\", string dam=\"Alruccaba\", string sire=\"Poseidon\");\r\n\r\nrecord_new_horse_birth(\"Urban Sea\", 130); // color will be brown, dam \"Alruccabam\", sire \"Poseidon\"\r\nrecord_new_horse_birth(\"Highclere\", 175, \"off-white\", \"Fall Aspen\");   // sire will be \"Poseidon\"\r\n```\r\n\r\nAs the function declaration is often read before the definition, it is the better place to set the default arguments.\r\nIf one parameter has a default declaration, all the parameters to its right need a default declaration as well.\r\nSometimes complicated function overloads can be refactored to fewer functions with default arguments to improve maintainability.\r\n",
    "instructions": "# Instructions\r\n\r\nIn this exercise you are going to write some more code related to preparing and cooking your brilliant lasagna from your favorite cookbook.\r\n\r\nYou have five tasks.\r\nThe first one is related to the cooking itself, the other four are about the perfect preparation.\r\n\r\n## 1. Estimate the preparation time\r\n\r\nFor the next lasagna that you will prepare, you want to make sure you have enough time reserved so you can enjoy the cooking.\r\nYou already planned which layers your lasagna will have.\r\nNow you want to estimate how long the preparation will take based on that.\r\n\r\nImplement a function `preparationTime` that accepts a vector of layers as `string` and the average preparation time per layer in minutes as an `int`.\r\nThe function should return the estimate for the total preparation time based on the number of layers as an `int`.\r\nIf the average preparation time is not passed then the default value of `2` should be used.\r\n\r\n```cpp\r\nstd::vector<std::string> layers{\"sauce\", \"noodles\", \"sauce\", \"meat\", \"mozzarella\", \"noodles\"};\r\npreparationTime(layers, 3)\r\n// => 18\r\npreparationTime(layers)\r\n// => 12\r\n```\r\n\r\n## 2. Compute the amounts of noodles and sauce needed\r\n\r\nBesides reserving the time, you also want to make sure you have enough sauce and noodles to cook the lasagna of your dreams.\r\nFor each noodle layer in your lasagna, you will need 50 grams of noodles.\r\nFor each sauce layer in your lasagna, you will need 0.2 liters of sauce.\r\n\r\nDefine the function `quantities` that takes a vector of layers as parameter as `string`.\r\nThe function will then determine the quantity of noodles and sauce needed to make your meal.\r\nThe result should be returned as an `amount` _struct_, which is already  defined for you.\r\n`amount` has two member variables one for the weight of the `noodles` as an `int` and the second one as the volume of the `sauce` as a `double`.\r\n\r\n```cpp\r\nstruct amount { int noodles; double sauce; };\r\n\r\namount needed{quantities({\"sauce\", \"noodles\", \"sauce\", \"meat\", \"mozzarella\", \"noodles\"})};\r\n// needed.noodles => 100\r\n// needed.sauce => 0.4\r\n```\r\n\r\n## 3. Add the secret ingredient\r\n\r\nA while ago you visited a friend and ate lasagna there.\r\nIt was amazing and had something special to it.\r\nThe friend sent you the list of ingredients and told you the last item on the list is the \"secret ingredient\" that made the meal so special.\r\nNow you want to add that secret ingredient to your recipe as well.\r\n\r\nWrite a function `addSecretIngredient` that accepts two `vector of strings` as parameters.\r\nThe first parameter is a _reference_ to the ingredients of your own recipe, and the second _vector_ of strings has the ingredients your friend sent you.\r\nThe last element in your ingredient list is always `\"?\"`.\r\nThe function should replace it with the last item from your friends list.\r\n**Note:** `addSecretIngredient` does not return anything - you should modify the list of your ingredients directly.\r\nThe list with your friend's ingredients can also be a reference (for improving the performance), but it should **not** be modified.\r\nMake sure the list will not be modified with a `const` reference.\r\n\r\n```cpp\r\nstd::vector<std::string> friendsList{\"noodles\", \"sauce\", \"mozzarella\", \"kampot pepper\"};\r\nstd::vector<std::string> myList{\"noodles\", \"meat\", \"sauce\", \"mozzarella\", \"?\"};\r\n\r\naddSecretIngredient(myList, friendsList);\r\n// myList => {\"noodles\", \"meat\", \"sauce\", \"mozzarella\", \"kampot pepper\"}\r\n```\r\n\r\n## 4. Scale the recipe\r\n\r\nThe amounts listed in your cookbook only yield enough lasagna for two portions.\r\nSince you want to cook for more people next time, you want to calculate the amounts for different numbers of portions.\r\n\r\nImplement a function `scaleRecipe` that takes two parameters.\r\n\r\n- A vector of `double` amounts needed for 2 portions.\r\n- The number of portions you want to cook.\r\n\r\nThe function should return a new vector of the amounts needed for the desired number of portions.\r\nYou want to keep the original recipe though.\r\nThis means the `quantities` argument should not be modified in this function.\r\n\r\n```cpp\r\nstd::vector<double> quantities{1.2, 3.6, 10.5};\r\nscaleRecipe(quantities, 4);\r\n// => { 2.4, 7.2, 21 }\r\n```\r\n\r\n## 5. Unlock the Family Secret\r\n\r\nYou remember stories from your childhood, tales of your great-grand auntie, the guardian of the family's deepest culinary secrets.\r\nLegend has it that she holds the key to unlocking flavors beyond imagination, but her methods are unconventional.\r\nShe doesn't deal in lists or measurements; she speaks in whispers, revealing only one ingredient at a time.\r\n\r\nWith a mixture of excitement and trepidation, you decide to reach out to your great-grand auntie.\r\nAs expected, she responds in her cryptic manner, offering a single secret ingredient, wrapped in mystery.\r\n\r\nYour great-grand auntie's contribution adds a layer of complexity, that you want to use in your recipe.\r\nImplement another version of the `addSecretIngredient` function that accepts two arguments: a reference to a vector representing your list of ingredients and a single string representing the enigmatic offering from your great-grand auntie.\r\n\r\n```cpp\r\nstd::vector<std::string> myList{\"noodles\", \"meat\", \"sauce\", \"mozzarella\", \"?\"};\r\nstd::string secretIngredient{\"spice melange\"};\r\naddSecretIngredient(myList, secretIngredient);\r\n// myList => {\"noodles\", \"meat\", \"sauce\", \"mozzarella\", \"spice melange\"}\r\n```\r\n\r\nGood luck, brave chef!\r\n",
    "hints": "# Hints\r\n\r\n## 1. Estimate the preparation time\r\n\r\n- Use the vector's [`size()`][size-func] to determine the number of layers (length of the layers slice).\r\n\r\n## 2. Compute the amounts of noodles and sauce needed\r\n\r\n- First, set up an `amount` object to track the amount of noodles and sauce.\r\n- Use a [for-loop][for-loop] to iterate through the layers.\r\n- If you encounter a `\"noodles\"` or `\"sauce\"` layer in your loop, increase the amount stored in the `amount` object accordingly.\r\n\r\n## 3. Add the secret ingredient\r\n\r\n- Revisit [vectors][concept-vector] to find out how to retrieve an element from a a vector and how to replace an element in a vector.\r\n- The index of the last element in a vector `a` is `a.size() - 1` or you can use `a.back()` directly.\r\n\r\n## 4. Scale the recipe\r\n\r\n- First make a new slice of the same size as the input slice\r\n- Use a [for-loop][for-loop] to iterate through the input slice and generate the output slice\r\n\r\n## 5. Unlock the Family Secret\r\n\r\n- You can re-use your code from task 3.\r\n- This tasks needs [function overloading][function overloading].\r\n\r\n[size-func]: https://en.cppreference.com/w/cpp/container/vector/size\r\n[concept-vector]: https://exercism.org/tracks/cpp/concepts/vector-arrays\r\n[for-loop]: https://exercism.org/tracks/cpp/concepts/loops\r\n[function overloading]: https://www.learncpp.com/cpp-tutorial/introduction-to-function-overloading/\r\n"
  },
  "starter_code": {
    "lasagna_master.cpp": "#include \"lasagna_master.h\"\r\n\r\nnamespace lasagna_master {\r\n\r\n// TODO: add your solution here\r\n\r\n}  // namespace lasagna_master\r\n",
    "lasagna_master.h": "#pragma once\r\n\r\nnamespace lasagna_master {\r\n\r\nstruct amount {\r\n    int noodles;\r\n    double sauce;\r\n};\r\n\r\n}  // namespace lasagna_master\r\n"
  },
  "tests": {
    "lasagna_master_test.cpp": "#include \"lasagna_master.h\"\r\n#ifdef EXERCISM_TEST_SUITE\r\n#include <catch2/catch.hpp>\r\n#else\r\n#include \"test/catch.hpp\"\r\n#endif\r\n\r\n#include <cmath>\r\n\r\nusing namespace lasagna_master;\r\n\r\n// As long as we have catch2 v2 and v3 in parallel, we can't use either\r\n//  of their comparison marcors for floating point comparisons.\r\n#define REQUIRE_VECTOR_APROX_EQUAL(vec1, vec2, margin)       \\\r\n    REQUIRE(vec1.size() == vec2.size());                     \\\r\n    for (size_t i = 0; i < vec1.size(); i++) {               \\\r\n        REQUIRE(std::abs(vec1.at(i) - vec2.at(i)) < margin); \\\r\n    }\r\n\r\nTEST_CASE(\r\n    // clang-format off\r\n    \"preparationTime: Preparation time for many layers with custom average time\",\r\n    // clang-format on\r\n    \"[task_1]\") {\r\n    std::vector<std::string> layers{\r\n        \"sauce\",      \"noodles\", \"béchamel\", \"meat\",\r\n        \"mozzarella\", \"noodles\", \"ricotta\",  \"eggplant\",\r\n        \"béchamel\",   \"noodles\", \"sauce\",    \"mozzarella\",\r\n    };\r\n    int time{1};\r\n    int expected{12};\r\n    REQUIRE(preparationTime(layers, time) == expected);\r\n}\r\n\r\n#if defined(EXERCISM_RUN_ALL_TESTS)\r\n\r\nTEST_CASE(\"preparationTime: Preparation time for few layers\", \"[task_1]\") {\r\n    std::vector<std::string> layers{\r\n        \"sauce\",\r\n        \"noodles\",\r\n    };\r\n    int time{3};\r\n    int expected{6};\r\n    REQUIRE(preparationTime(layers, time) == expected);\r\n}\r\n\r\nTEST_CASE(\"preparationTime: Preparation time for default case\", \"[task_1]\") {\r\n    std::vector<std::string> layers{\r\n        \"sauce\",\r\n        \"noodles\",\r\n    };\r\n    int expected{4};\r\n    REQUIRE(preparationTime(layers) == expected);\r\n}\r\n\r\nTEST_CASE(\"quantities: few layers\", \"[task_2]\") {\r\n    std::vector<std::string> layers{\"noodles\", \"sauce\", \"noodles\"};\r\n    int expNoodles{100};\r\n    double expSauce{0.2};\r\n    amount amount = quantities(layers);\r\n    REQUIRE(amount.sauce == expSauce);\r\n    REQUIRE(amount.noodles == expNoodles);\r\n}\r\n\r\nTEST_CASE(\"quantities: many layers\", \"[task_2]\") {\r\n    std::vector<std::string> layers{\"sauce\",   \"noodles\",    \"béchamel\",\r\n                                    \"meat\",    \"mozzarella\", \"noodles\",\r\n                                    \"ricotta\", \"eggplant\",   \"béchamel\",\r\n                                    \"noodles\", \"sauce\",      \"mozzarella\"};\r\n    int expNoodles{150};\r\n    double expSauce{0.4};\r\n    amount amount = quantities(layers);\r\n    REQUIRE(amount.sauce == expSauce);\r\n    REQUIRE(amount.noodles == expNoodles);\r\n}\r\n\r\nTEST_CASE(\"quantities: no noodles\", \"[task_2]\") {\r\n    std::vector<std::string> layers{\"sauce\", \"meat\", \"mozzarella\", \"sauce\",\r\n                                    \"mozzarella\"};\r\n    int expNoodles{0};\r\n    double expSauce{0.4};\r\n    amount amount = quantities(layers);\r\n    REQUIRE(amount.sauce == expSauce);\r\n    REQUIRE(amount.noodles == expNoodles);\r\n}\r\n\r\nTEST_CASE(\"quantities: no sauce\", \"[task_2]\") {\r\n    std::vector<std::string> layers{\"noodles\", \"meat\", \"mozzarella\", \"noodles\",\r\n                                    \"mozzarella\"};\r\n    int expNoodles{100};\r\n    double expSauce{0.0};\r\n    amount amount = quantities(layers);\r\n    REQUIRE(amount.sauce == expSauce);\r\n    REQUIRE(amount.noodles == expNoodles);\r\n}\r\n\r\nTEST_CASE(\"Adds secret vector ingredient\", \"[task_3]\") {\r\n    const std::vector<std::string> friendsList{\"sauce\", \"noodles\", \"béchamel\",\r\n                                               \"marjoram\"};\r\n    std::vector<std::string> myList{\"sauce\", \"noodles\", \"meat\", \"tomatoes\",\r\n                                    \"?\"};\r\n    std::vector<std::string> expected{\"sauce\", \"noodles\", \"meat\", \"tomatoes\",\r\n                                      \"marjoram\"};\r\n    addSecretIngredient(myList, friendsList);\r\n    REQUIRE(myList == expected);\r\n}\r\n\r\nTEST_CASE(\"scaleRecipe: scales up correctly\", \"[task_4]\") {\r\n    const std::vector<double> input{0.5, 250, 150, 3, 0.5};\r\n    int portions{6};\r\n    std::vector<double> expected{1.5, 750, 450, 9, 1.5};\r\n    std::vector<double> scaled{scaleRecipe(input, portions)};\r\n    REQUIRE_VECTOR_APROX_EQUAL(expected, scaled, 0.0001)\r\n}\r\n\r\nTEST_CASE(\"scaleRecipe: scales up correctly (2)\", \"[task_4]\") {\r\n    const std::vector<double> input{0.6, 300, 1, 0.5, 50, 0.1, 100};\r\n    int portions{3};\r\n    std::vector<double> expected{0.9, 450, 1.5, 0.75, 75, 0.15, 150};\r\n    std::vector<double> scaled{scaleRecipe(input, portions)};\r\n    REQUIRE_VECTOR_APROX_EQUAL(expected, scaled, 0.0001)\r\n}\r\n\r\nTEST_CASE(\"scaleRecipe: scales down correctly\", \"[task_4]\") {\r\n    const std::vector<double> input{0.5, 250, 150, 3, 0.5};\r\n    int portions{1};\r\n    std::vector<double> expected{0.25, 125, 75, 1.5, 0.25};\r\n    std::vector<double> scaled{scaleRecipe(input, portions)};\r\n    REQUIRE_VECTOR_APROX_EQUAL(expected, scaled, 0.0001)\r\n}\r\n\r\nTEST_CASE(\"scaleRecipe: empty recipe\", \"[task_4]\") {\r\n    const std::vector<double> input{};\r\n    int portions{100};\r\n    std::vector<double> expected{};\r\n    std::vector<double> scaled{scaleRecipe(input, portions)};\r\n    REQUIRE_VECTOR_APROX_EQUAL(expected, scaled, 0.0001)\r\n}\r\n\r\nTEST_CASE(\"Adds secret string ingredient\", \"[task_5]\") {\r\n    const std::string auntiesSecret{\"mirkwood mushrooms\"};\r\n    std::vector<std::string> myList{\"sauce\", \"noodles\", \"meat\", \"tomatoes\",\r\n                                    \"?\"};\r\n    std::vector<std::string> expected{\"sauce\", \"noodles\", \"meat\", \"tomatoes\",\r\n                                      \"mirkwood mushrooms\"};\r\n    addSecretIngredient(myList, auntiesSecret);\r\n    REQUIRE(myList == expected);\r\n}\r\n\r\n#endif\r\n"
  }
}