{
  "language": "cpp",
  "slug": "ellens-alien-game",
  "docs": {
    "introduction": "# Introduction\r\n\r\n## Classes\r\n\r\nIt is time to get to one of the core paradigms of C++: object-oriented programming (OOP).\r\nOOP is centered around `classes` - user-defined types of data with their own set of related functions.\r\nWe will start with the basics and will cover more advanced topics further down the syllabus tree.\r\n\r\n### Members\r\n\r\nClasses can have **member variables** and **member functions**.\r\nThey are accessed by the **member selection** operator `.`.\r\nJust as variables outside of `classes`, it is advisable to initialize member variables with a value upon declaration.\r\nThis value will then become the default for newly created objects of this class.\r\n\r\n### Encapsulation and Information Hiding\r\n\r\nClasses offer the option to restrict access to their members.\r\nThe two basic `access specifiers` are `private` and `public`.\r\n`private` members are not accessible from outside the class.\r\n`public` members can be accessed freely.\r\nAll members of a `class` are `private` by default.\r\nOnly members explicitly marked with `public` are freely usable outside of the class.\r\n\r\n### Basic example\r\n\r\nThe definition of a `class` can be seen in the following example.\r\nNotice the `;` after the definition:\r\n\r\n```cpp\r\nclass Wizard {\r\n  public:               // from here on all members are publicly accessible\r\n    int cast_spell() {  // defines the public member function cast_spell\r\n      return damage;\r\n    }\r\n    std::string name{}; // defines the public member variable `name`\r\n  private:              // from here on all members are private\r\n    int damage{5};      // defines the private member variable `damage`\r\n};\r\n\r\n```\r\n\r\nYou can access all member variables from within the class.\r\nTake a look at `damage` inside the `cast_spell` function.\r\nYou cannot read or change `private` members outside of the class:\r\n\r\n```cpp\r\nWizard silverhand{};\r\n// calling the `cast_spell` function is okay, it is public:\r\nsilverhand.cast_spell();\r\n// => 5\r\n\r\n// name is public and can be changed:\r\nsilverhand.name = \"Laeral\";\r\n\r\n// damage is private:\r\nsilverhand.damage = 500;\r\n // => Compilation error\r\n```\r\n\r\n### Constructors\r\n\r\nConstructors offer the possibility to assign values to member variables at object creation.\r\nThey have the same name as the `class` and do not have a return type.\r\nA class can have several constructors.\r\nThis is useful if you do not always have a need to set all variables.\r\nSometimes you might want to keep everything at default but change the `name` variable.\r\nIn the case of a significant Wizard you might want to change the damage as well, so you need two `constructors`.\r\n\r\n```cpp\r\nclass Wizard {\r\n  public:\r\n    Wizard(std::string new_name) {\r\n      name = new_name;\r\n    }\r\n    Wizard(std::string new_name, int new_damage) {\r\n      name = new_name;\r\n      damage = new_damage;\r\n    }\r\n    int cast_spell() {\r\n      return damage;\r\n    }\r\n    std::string name{};\r\n  private:\r\n    int damage{5};\r\n};\r\n\r\nWizard el{\"Eleven\"};       // deals  5 damage\r\nWizard vecna{\"Vecna\", 50}; // deals 50 damage\r\n```\r\n\r\nConstructors are a big topic and have many nuances.\r\nIf you are not explicitly defining a `constructor` for your `class`, then - and only then - the compiler will do the job for you.\r\nThis has happened in the first example above.\r\nThe _silverhand_ object is created by calling the default constructor, no arguments were passed.\r\nAll variables are set to the value that was stated in the definition of the class.\r\nIf you had not given any values in that definition, the variables might be uninitialized, which might have unintended consequences.\r\n\r\n~~~~exercism/note\r\n## Structs\r\n\r\nStructs came from the language's original C roots and are as old as C++ itself.\r\nThey are effectively the same thing as `classes` with one important exception.\r\nBy default, everything in a `class` is `private`.\r\nStructs, on the other hand, are `public` until defined otherwise.\r\nConventionally, the `struct` keyword is often used for **data-only structures**.\r\nThe `class` keyword is preferred for objects that need to ensure certain properties.\r\nSuch an invariant could be that the `damage` of your `Wizard` `class` cannot turn negative.\r\nThe `damage` variable is private and any function that changes the damage would ensure the invariant is preserved.\r\n~~~~\r\n",
    "instructions": "# Instructions\r\n\r\nEllen is making a game where the player has to fight aliens.\r\nShe has just learned about Object Oriented Programming (OOP) and is eager to take advantage of what using `classes` could offer her program.\r\n\r\nTo Ellen's delight, you have offered to help and she has given you the task of programming the aliens that the player has to fight.\r\n\r\n\r\n## 1. Create the `Alien` Class\r\n\r\nDefine the `Alien` class with a constructor that accepts two `int` parameters `x` and `y`, putting them into `x_coordinate` and `y_coordinate` member variables.\r\nEvery alien will also start off with a health level of `3`, so the `health` member variable should be initialized as well.\r\n\r\n`health` should be a private member variable.\r\nTo let other parts of the program read the health information, Ellen wants to have a `public` `get_health()` method which returns an `int`.\r\n\r\n```cpp\r\nAlien alien{2, 0};\r\nalien.x_coordinate;\r\n// => 2\r\nalien.y_coordinate;\r\n// => 0\r\nalien.get_health();\r\n// => 3\r\n```\r\n\r\nNow, each alien should be able to internally track its own position and health.\r\n\r\n## 2. The `hit` Function\r\n\r\nEllen would like the Alien `class` to have a `hit` method that decrements the health of an alien object by `1` when called.\r\nThis way, she can simply call `some_alien_instance.hit()` instead of having to manually change an alien's health.\r\nMake sure that the health points do not drop below zero.\r\nThe function should return `true`.\r\nEllen wants to introduce shields at a later point, which would then report `false` if the shield is up.\r\n\r\n```cpp\r\nAlien alien {0, 0};\r\nalien.get_health();\r\n// => 3 (Initial health value)\r\n\r\nalien.hit(); // Decrements health by 1 point.\r\nalien.get_health();\r\n// => 2\r\n```\r\n\r\n## 3. The `is_alive` Function\r\n\r\nYou realize that if the health keeps decreasing, at some point it will probably hit `0`.\r\nIt would be a good idea to add an `is_alive` method that Ellen can quickly call to check if the alien is... well... alive. ðŸ˜‰\r\n`some_alien_instance.is_alive()` should return a boolean.\r\n\r\n```cpp\r\nalien.get_health();\r\n// => 1\r\nalien.is_alive();\r\n// => true\r\nalien.hit();\r\nalien.get_health();\r\n// => 0\r\nalien.is_alive();\r\n// => false\r\n```\r\n\r\n## 4. The `teleport` Function\r\n\r\nIn Ellen's game, the aliens can teleport!\r\nYou will need to write a `teleport` method that takes `x_new` and `y_new` values, and changes the alien's coordinates accordingly.\r\nFor the time being, the function should return `true`.\r\nEllen wants to add teleport-blocking bombs in later levels, which would then report `false` for failed teleporting attempts.\r\n\r\n```cpp\r\nalien.teleport(5, -4);\r\nalien.x_coordinate;\r\n// => 5\r\nalien.y_coordinate;\r\n// => -4\r\n```\r\n\r\n## 5. The `collision_detection` Function\r\n\r\nIf the aliens can be hit by something, then they need to be able to detect when such a collision might occur.\r\nEllen needs to know if two aliens occupy the same coordinates.\r\nThe `collision_detection()` function takes another alien object as an argument and returns a `bool`.\r\n\r\n```cpp\r\nAlien lrrr {3, 6};\r\nAlien ndnd {-2, 12};\r\nlrrr.collision_detection(ndnd);\r\n// => false\r\nndnd.teleport(3, 6);\r\nndnd.collision_detection(lrrr);\r\n// => true\r\n```\r\n",
    "hints": "# Hints\r\n\r\n## 1. Create the `Alien` Class\r\n\r\n- The `constructor` does not have a return type and has the same name as the `class`.\r\n- A common convention for `classes` is using names in __PascalCase__.\r\n\r\n## 2. The `hit` Function\r\n\r\n- Remember the invariant: health points can't be negative.\r\n\r\n## 3. The `is_alive` Function\r\n\r\n- life points at `0` is the only 'dead' condition.\r\n\r\n## 4. The `teleport` Function\r\n\r\n- Member variables can be updated by any function of the class.\r\n\r\n## 5. The `collision_detection` Function\r\n\r\n- All `public` member variables can be accessed from outside the class.\r\n"
  },
  "starter_code": {
    "ellens_alien_game.cpp": "namespace targets {\r\n// TODO: Insert the code for the alien class here\r\n\r\n}  // namespace targets\r\n"
  },
  "tests": {
    "ellens_alien_game_test.cpp": "#include \"ellens_alien_game.cpp\"\r\n#ifdef EXERCISM_TEST_SUITE\r\n#include <catch2/catch.hpp>\r\n#else\r\n#include \"test/catch.hpp\"\r\n#endif\r\n\r\nusing namespace targets;\r\n\r\nTEST_CASE(\"Alien has correct initial coordinates\", \"[task_1]\") {\r\n    Alien alien{2, -1};\r\n    REQUIRE(alien.x_coordinate == 2);\r\n    REQUIRE(alien.y_coordinate == -1);\r\n}\r\n\r\n#if defined(EXERCISM_RUN_ALL_TESTS)\r\n\r\nTEST_CASE(\"Alien has correct initial health\", \"[task_1]\") {\r\n    Alien alien{22, 0};\r\n    REQUIRE(alien.get_health() == 3);\r\n}\r\n\r\nTEST_CASE(\"New alien does not share old aliens position\", \"[task_1]\") {\r\n    Alien alien1{22, 0};\r\n    Alien alien2{0, 22};\r\n    REQUIRE(alien1.x_coordinate != alien2.x_coordinate);\r\n    REQUIRE(alien1.y_coordinate != alien2.y_coordinate);\r\n}\r\n\r\nTEST_CASE(\"Alien is always hit\", \"[task_2]\") {\r\n    Alien alien{6, 7};\r\n    REQUIRE(alien.hit());\r\n}\r\n\r\nTEST_CASE(\r\n    \"Alien is alive while health is greater than 0 and stays dead afterwards\",\r\n    \"[task_3]\") {\r\n    Alien alien{2, 54};\r\n    REQUIRE(alien.is_alive());\r\n    alien.hit();\r\n    REQUIRE(alien.is_alive());\r\n    alien.hit();\r\n    REQUIRE(alien.is_alive());\r\n    alien.hit();\r\n    REQUIRE(!alien.is_alive());\r\n    alien.hit();\r\n    REQUIRE(!alien.is_alive());\r\n    REQUIRE(alien.get_health() == 0);\r\n}\r\n\r\nTEST_CASE(\"Alien Teleports reports succesful\", \"[task_4]\") {\r\n    Alien alien{22, 1};\r\n    REQUIRE(alien.teleport(99, 8));\r\n}\r\n\r\nTEST_CASE(\"Alien Teleports where it should\", \"[task_4]\") {\r\n    Alien alien{2, -54};\r\n    REQUIRE(alien.x_coordinate == 2);\r\n    REQUIRE(alien.y_coordinate == -54);\r\n    alien.teleport(99, 8);\r\n    REQUIRE(alien.x_coordinate == 99);\r\n    REQUIRE(alien.y_coordinate == 8);\r\n}\r\n\r\nTEST_CASE(\"Alien collision detection with other aliens\", \"[task_5]\") {\r\n    Alien alien1{22, 0};\r\n    Alien alien2{0, 22};\r\n    Alien alien3{22, 0};\r\n    REQUIRE_FALSE(alien1.collision_detection(alien2));\r\n    REQUIRE(alien1.collision_detection(alien3));\r\n}\r\n\r\n#endif\r\n"
  }
}