{
  "language": "cpp",
  "slug": "speedywagon",
  "docs": {
    "introduction": "# Introduction\r\n\r\nLike many other languages, C++ has _pointers_.\r\nYou already know _references_ and _pointers_ are similar, but think of them as a level closer to the inner workings of your computer.\r\n_Pointers_ are variables that hold object addresses.\r\nThey are used to directly interact with objects, enabling dynamic memory allocation and efficient data manipulation in C++.\r\n\r\nIf you're new to _pointers_, they can feel a little mysterious but once you get used to them, they're quite straight-forward.\r\n\r\nThey're a crucial part of C++, so take some time to really understand them.\r\nThe bare-bone version in this concept is also called _dumb pointer_ or _raw pointer_.\r\nWith modern C++ there are also _smart pointers_, the basic type is not smart at all and you have to handle all the work manually.\r\n\r\nBefore digging into the details, it's worth understanding the use of _pointers_.\r\n_Pointers_ are a way to share an object's address with other parts of our program, which is useful for two major reasons:\r\n\r\n1. Like _references_, pointers avoid copies and help to reduce the resource-footprint of your program.\r\n1. Unlike _references_, pointers can be reassigned to different objects.\r\n1. Pointers can also point to a null value, to indicate, that they currently do not point to any object.\r\n\r\n## General Syntax\r\n\r\nA pointer declaration in C++ involves specifying the data type to which the the pointer is pointing, followed by an asterisk (`*`) and the pointer's name.\r\nWhen pointers are declared, they are not automatically initialized.\r\nWithout explicit assignment, a pointer typically holds an indeterminate value, often referred to as a \"garbage address.\"\r\nWhile certain compilers might initialize pointers to `nullptr`, this behavior is not guaranteed across all compilers, so it's essential not to rely on it.\r\nIt's best practice to explicitly initialize raw pointers and verify their non-null status before utilization to avoid potential issues.\r\n\r\n```cpp\r\nint* ptr{nullptr}; // Declares a pointer and makes sure it is not invalid\r\n```\r\n\r\nTo assign the address of a variable to a pointer, you use the address-of operator (`&`).\r\nDereferencing a pointer is done using the _indirection operator_ (`*`) operator.\r\n\r\n```cpp\r\nstd::string opponent{\"Solomon Lane\"};\r\n// 'ethan' points to the address of the string opponent\r\nstd::string* ethan{&opponent};\r\n// Instead of ethan's, the opponent's name address is given to the passPort\r\nstd::string passportName{*ethan};\r\n```\r\n\r\nAttention: dereferencing has to be done explicitly, while _references_ just worked like an alias.\r\n\r\n## Pointer Arithmetic\r\n\r\n_Pointer arithmetic_ allows you to perform arithmetic operations on pointers, which is particularly useful when working with arrays.\r\nAdding an integer to a pointer makes it point to a different element.\r\n\r\n```cpp\r\n// Stargate Coordinate Code\r\nint gateCode[] = {462, 753, 218, 611, 977};\r\n// 'ptr' points to the first element of 'gateCode'\r\nint* ptr{&gateCode[0]};\r\n// Accesses the third Stargate address through pointer arithmetic\r\nint dialedAddress{*(ptr + 2)};\r\n// Chevron encoded! Dialing Stargate address:\r\nopenStarGate(dialedAddress);\r\n```\r\n\r\n~~~~exercism/caution\r\nPointer arithmetic in C++ can easily lead to __undefined behavior__ if not handled carefully.\r\nUndefined behavior can manifest in unexpected program outcomes, crashes, or even security vulnerabilities.\r\nOne infamous example of the consequences of undefined behavior occurred in the [explosion of the Ariane 5 rocket][ariane-flight-v88] in 1996, where a software exception caused by the conversion of a 64-bit floating-point number to a 16-bit signed integer led to a catastrophic failure.\r\n\r\n[ariane-flight-v88]: https://en.wikipedia.org/wiki/Ariane_flight_V88\r\n~~~~\r\n\r\n## Accessing member variables\r\n\r\nIn C++, the `->` operator is used to access members of an object through a pointer to that object.\r\nIt is a shorthand which simplifies accessing members of objects pointed to by pointers.\r\nFor instance, if `ptr` is a pointer to an object with a member variable `x`, instead of using `(*ptr).x`, you can directly use `ptr->x`.\r\nThis operator enhances code readability and reduces verbosity when working with pointers to objects.\r\n\r\nHere's a brief example, with a _struct_ `Superhero` that has a member variable `superpower`.\r\nThe main function creates a pointer `dianaPrince` to a `Superhero` object (representing Wonder Woman).\r\nThe `->` operator is used to access the member variable `superpower`, showcasing Wonder Woman's iconic \"Lasso of Truth.\"\r\n\r\n```cpp\r\nstruct Superhero {\r\n    std::string superpower;\r\n};\r\nSuperhero wonder_woman{};\r\nSuperhero* dianaPrince = &wonder_woman;\r\ndianaPrince->superpower = \"Lasso of Truth\";\r\n// Using the -> operator to access member variable superpower:\r\nstd::cout << \"Wonder Woman, possesses the mighty \" << dianaPrince->superpower;\r\n```\r\n\r\n## Pointers vs. references\r\n\r\nPointers and references both enable indirect access to objects, but they differ in their capabilities and safety considerations.\r\nPointers offer the flexibility of changing their target object and can be assigned null.\r\nHowever, this flexibility introduces risks, such as dereferencing null pointers or creating dangling pointers.\r\nReferences, on the other hand, cannot be null and are bound to valid objects upon creation, avoiding these risks.\r\nGiven their safer nature, references should be preferred over pointers unless the additional functionalities provided by pointers are necessary.\r\n",
    "instructions": "# Instructions\r\n\r\nWelcome, Engineer!\r\nYou are one of the last veterans of the Speedywagon Foundation, a secret organization that, for decades, has been battling ancient threats like the Pillar Men.\r\nIn the course of this effort, you've spent years maintaining the Foundation's technological systems, built using a mix of cutting-edge tech and aging libraries.\r\n\r\nHowever, in recent times, the sensors that track Pillar Men activities are malfunctioning.\r\nThe Foundation's systems are old, and the code interacts with a legacy C++ library that cannot be updated.\r\nYour task is to implement four core functions that monitor Pillar Men sensor activity using an old-fashioned pointer-based library.\r\n\r\nAs a modern C++ engineer, you’d prefer using smart pointers, but alas, legacy code demands respect for the old ways.\r\nThe fate of humanity may rest on these pointers, so proceed carefully, and may the Hamon energy guide you.\r\n\r\n~~~~exercism/note\r\nAs sensor readings can be huge, we supply a mockup _struct_ that is used in the actual library.\r\nThe code has already been implemented in the header file for you.\r\n\r\n```cpp\r\nstruct pillar_men_sensor {\r\n    int activity{};\r\n    std::string location{};\r\n    std::vector<int> data{};\r\n};\r\n```\r\n~~~~\r\n\r\n## 1. Check Sensor Connection (`connection_check`)\r\n\r\nYour first task is to ensure that the Pillar Men sensor is connected properly.\r\nWe can't have false alarms triggered by disconnected sensors.\r\nYou will write a function `connection_check`, which tests if the sensor's pointer is valid by checking for `nullptr`.\r\n\r\n- Define a function that accepts a pointer to a `pillar_men_sensor` _struct_.\r\n- The function should return `true` if the sensor pointer is not null, and `false` otherwise.\r\n\r\n```cpp\r\npillar_men_sensor* sensor{nullptr};\r\nbool isConnected = connection_check(sensor);\r\n// isConnected => false\r\n```\r\n\r\n## 2. Count Activity of Sensors (`activity_counter`)\r\n\r\nPillar Men are lurking in the shadows, and we need to know if sensors have detected any activity.\r\nYou will write the `activity_counter` function, which takes in an array of sensors and a capacity indicating the number of sensors in the array.\r\n\r\n- Define a function that accepts a pointer to the first element of an array and the arrays capacity.\r\n- Use pointer arithmetic to loop through the sensor array and accumulate the activity readings.\r\n- Return the accumulated activity.\r\n\r\n```cpp\r\npillar_men_sensor sensor_array[3] = {{0}, {101}, {22}};\r\nint totalActivity = activity_counter(sensor_array, 3);\r\n// totalActivity => 123\r\n```\r\n\r\n## 3. Alarm Control (`alarm_control`)\r\n\r\nNot every sensor should trigger an alarm unless there’s real danger.\r\nThe `alarm_control` function ensures that a sensor only triggers an alarm if its activity level is greater than 0.\r\nThis function should also check for null sensors to prevent system crashes.\r\n\r\n- Define a function that accepts the pointer to a `pillar_men_sensor`.\r\n- The function should first check for a `nullptr` sensor. If the sensor is `nullptr`, return `false`.\r\n- If the sensor is valid and its activity is greater than 0, return `true`; otherwise, return `false`.\r\n\r\n```cpp\r\npillar_men_sensor db{9008, \"songokunoie\", {7, 7, 7}};\r\nbool alarm = alarm_control(&db);\r\n// alarm => true\r\n```\r\n\r\n## 4. Checking the data for anomalies with the `uv_alarm` function\r\n\r\nIn this task, you will implement the `uv_alarm` function to determine whether an alarm should be triggered based on UV light exposure levels and sensor activity.\r\nThe `uv_alarm` function should use the provided `uv_light_heuristic` function, which operates on a vector of data and returns a value based on certain thresholds.\r\nThis is a mockup version of the complex code that will run during production, please don't change the interface.\r\n\r\nDefine the `uv_alarm` function in the `speedywagon` namespace. It should:\r\n\r\n- Take a pointer to a `pillar_men_sensor` _struct_ as its parameter.\r\n- Return `false` if the sensor pointer is null.\r\n- Call the `uv_light_heuristic` function, passing the address of the sensor's `data` array.\r\n- Return `true` if the value returned by `uv_light_heuristic` is greater than the `sensor->activity` level, otherwise return `false`.\r\n",
    "hints": "# Hints\r\n\r\n## General\r\n\r\n- Pay close attention to pointer syntax.\r\n  You will be using `*` (dereference operator) and `->` (member access through pointer).\r\n- Make sure to check for null pointers (`nullptr`) where necessary to avoid accessing invalid memory.\r\n- You can run the tests even if your code isn't complete; a rough structure is enough to see test results.\r\n- All functions used by the tests must be declared in the header file.\r\n- If your program crashes or behaves unexpectedly, it's often due to null pointer dereferencing.\r\n  Double-check that you handle `nullptr` properly.\r\n- When using pointer arithmetic, ensure that you stay within the bounds of the sensor array.\r\n  Going beyond the array's capacity can lead to memory issues.\r\n\r\n## 1. Check Sensor Connection (`connection_check`)\r\n\r\n- The task is mainly about verifying whether a pointer is null or not.\r\n- Use the comparison operator `!=` to check if a pointer is valid.\r\n- If you're unsure whether you're checking the pointer correctly, think about what `nullptr` represents (the absence of a valid memory address).\r\n\r\n\r\n## 2. Count Activity of Sensors (`activity_counter`)\r\n\r\n- You need to iterate over the array of sensors.\r\n  An array in C++ can be treated as a pointer to its first element.\r\n- Use pointer arithmetic (`sensor_array + i`) to access the sensor at index `i`.\r\n- The `->` operator is used to access a member of the struct through a pointer.\r\n\r\n### Example\r\n\r\n```cpp\r\nint sum = (sensor_array + i)->activity; // Access activity using pointer arithmetic\r\n```\r\n\r\n## 3. Alarm Control (`alarm_control`)\r\n\r\n- First, check if the pointer is null before accessing the sensor.\r\n- Use the `->` operator to access the `activity` member of the `pillar_men_sensor` struct.\r\n- Think carefully about what should happen if the sensor's activity level is `0`.\r\n  Should the alarm trigger?\r\n\r\n## 4. Checking the data for anomalies with the `uv_alarm` function\r\n\r\n- Use the `&` operator to pass a pointer to the sensor's data array into the `uv_light_heuristic` function.\r\n- Ensure you correctly check for a null pointer before accessing the sensor's data.\r\n- Compare the result of `uv_light_heuristic` with the sensor's `activity` value to determine if the alarm should trigger.\r\n"
  },
  "starter_code": {
    "speedywagon.cpp": "#include \"speedywagon.h\"\r\n\r\nnamespace speedywagon {\r\n\r\n// Enter your code below:\r\n\r\n// Please don't change the interface of the uv_light_heuristic function\r\nint uv_light_heuristic(std::vector<int>* data_array) {\r\n    double avg{};\r\n    for (auto element : *data_array) {\r\n        avg += element;\r\n    }\r\n    avg /= data_array->size();\r\n    int uv_index{};\r\n    for (auto element : *data_array) {\r\n        if (element > avg) ++uv_index;\r\n    }\r\n    return uv_index;\r\n}\r\n\r\n}  // namespace speedywagon\r\n",
    "speedywagon.h": "#pragma once\r\n\r\n#include <string>\r\n#include <vector>\r\n\r\nnamespace speedywagon {\r\n\r\nstruct pillar_men_sensor {\r\n    int activity{};\r\n    std::string location{};\r\n    std::vector<int> data{};\r\n};\r\n\r\nint uv_light_heuristic(std::vector<int>* data_array);\r\n\r\n}  // namespace speedywagon\r\n"
  },
  "tests": {
    "speedywagon_test.cpp": "#include \"speedywagon.h\"\r\n#ifdef EXERCISM_TEST_SUITE\r\n#include <catch2/catch.hpp>\r\n#else\r\n#include \"test/catch.hpp\"\r\n#endif\r\n\r\nTEST_CASE(\"connection_check: test for nullptr\", \"[task_1]\") {\r\n    speedywagon::pillar_men_sensor* nothing_connected{nullptr};\r\n    REQUIRE_FALSE(speedywagon::connection_check(nothing_connected));\r\n}\r\n\r\n#if defined(EXERCISM_RUN_ALL_TESTS)\r\n\r\nTEST_CASE(\"connection_check: test for connected sensor\", \"[task_1]\") {\r\n    speedywagon::pillar_men_sensor active_sensor{42, \"colloseum\", {}};\r\n    REQUIRE(speedywagon::connection_check(&active_sensor));\r\n}\r\n\r\nTEST_CASE(\"activity_counter: sum for three nullptr\", \"[task_2]\") {\r\n    speedywagon::pillar_men_sensor rome[3]{};\r\n    REQUIRE(speedywagon::activity_counter(&rome[0], 3) == 0);\r\n}\r\n\r\nTEST_CASE(\"activity_counter: sum for two with real data\", \"[task_2]\") {\r\n    speedywagon::pillar_men_sensor rome[2]{{4900, \"kars\", {}},\r\n                                           {4102, \"wham\", {}}};\r\n    REQUIRE(speedywagon::activity_counter(&rome[0], 2) == 9002);\r\n}\r\n\r\nTEST_CASE(\"activity_counter: sum for a nullptr\", \"[task_2]\") {\r\n    speedywagon::pillar_men_sensor rome[2]{{4900, \"kars\", {}},\r\n                                           {4102, \"wham\", {}}};\r\n    REQUIRE(speedywagon::activity_counter(nullptr, 0) == 0);\r\n}\r\n\r\nTEST_CASE(\"alarm_control: works correctly for pointer\", \"[task_3]\") {\r\n    speedywagon::pillar_men_sensor* kars_in_space{nullptr};\r\n    REQUIRE_FALSE(speedywagon::alarm_control(kars_in_space));\r\n}\r\n\r\nTEST_CASE(\"alarm_control: works correctly for nullptr\", \"[task_3]\") {\r\n    speedywagon::pillar_men_sensor santana{0, \"Mexico\", {1981, 1987}};\r\n    REQUIRE_FALSE(speedywagon::alarm_control(&santana));\r\n    santana.activity = 9002;\r\n    REQUIRE(speedywagon::alarm_control(&santana));\r\n}\r\n\r\nTEST_CASE(\"uv_alarm: works correctly for nullptr\", \"[task_4]\") {\r\n    speedywagon::pillar_men_sensor* wham{nullptr};\r\n    REQUIRE_FALSE(speedywagon::uv_alarm(wham));\r\n}\r\n\r\nTEST_CASE(\"uv_alarm: works correctly with mock data\", \"[task_4]\") {\r\n    speedywagon::pillar_men_sensor wham{0, \"Rome\", {1, 605, 313, 4000}};\r\n    REQUIRE(speedywagon::uv_alarm(&wham));\r\n    wham.activity = 9001;\r\n    REQUIRE_FALSE(speedywagon::uv_alarm(&wham));\r\n}\r\n\r\n#endif\r\n"
  }
}