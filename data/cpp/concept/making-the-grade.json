{
  "language": "cpp",
  "slug": "making-the-grade",
  "docs": {
    "introduction": "# Introduction\r\n\r\n## Arrays and Vectors\r\n\r\nC++ offers different containers to store elements of the same type in an ordered way.\r\nThere is `std::array` for containers of a fixed size and `std::vector`, which comes with dynamic resizing capabilities.\r\n\r\n### Construction\r\n\r\nWhen you declare an array or a vector you need to specify the type of elements, that container will hold.\r\nArrays also need a size.\r\nLook at these examples to see the two container types' initializations:\r\n\r\n```cpp\r\n#include <array>\r\n#include <string>\r\n\r\n// std::array<element_type, size> variable_name {list of elements}\r\nstd::array<std::string, 3> indie_rock {\"yeah\", \"yeah\", \"yeah\"};\r\n// indie_rock contains the elements \"yeah\" three times\r\n```\r\n\r\nVectors usually need more space, as they allocate memory for further growth.\r\nYou do not need to specify a size:\r\n\r\n```cpp\r\n#include <vector>\r\n\r\n// std::vector<element_type> variable_name {list of elements}\r\nstd::vector<int> countdown {3, 2, 1};\r\n// countdown contains the elements 3, 2 and 1\r\n```\r\n\r\n> Note: You do not need to know the exact mechanics behind the template concept yet, it will have its own concept further down the syllabus tree.\r\n\r\n### Element access\r\n\r\nVectors and arrays share the same functions to access their elements.\r\nYou can use the member functions `front` and `back` to get the first and last elements of the container.\r\nThere is also `at` and the `[]` operator to access specific elements.\r\n\r\n```cpp\r\ncountdown[0];\r\n// => 3\r\ncountdown.at(2);\r\n// => 1\r\ncountdown[1] = 4;\r\n// countdown now contains 3, 4 and 1\r\nindie_rock.back() = \"yeahs\";\r\n// indie_rock is now \"yeah\", \"yeah\", \"yeahs\"\r\n```\r\n\r\n> Note: If you pick a position that is not in the range of your container, `[]` might lead to undefined behavior.\r\n> The `at` function would raise an exception, which might make your life easier in the long term.\r\n\r\n### Vector modifiers\r\n\r\nAs a `vector` is not fixed in size, it is possible to add or remove elements.\r\nTwo common functions for that purpose are `emplace_back` and `pop_back`.\r\n\r\n```cpp\r\nstd::vector<std::string> witches {\"Holly\", \"Alyssa\", \"Shannen\"};\r\nwitches.pop_back();\r\n// Shannen is no longer with the witches\r\nwitches.emplace_back(\"Rose\");\r\n// Rose has joined the team\r\n```\r\n\r\n### Capacity\r\n\r\nYou can check the containers for emptiness with the member function `empty`.\r\nIf you want to know the number of elements, you can use `size`.\r\n",
    "instructions": "# Instructions\r\n\r\nYou're a teaching assistant correcting student exams.\r\nKeeping track of results manually is getting both tedious and mistake-prone.\r\nYou decide to make things a little more interesting by putting together some functions to count and calculate results for the class.\r\n\r\n## 1. Rounding Scores\r\n\r\nWhile you can give \"partial credit\" on exam questions, overall exam scores have to be `int`s.\r\nSo before you can do anything else with the class scores, you need to go through the grades and turn any `double` scores into `int`s.\r\n\r\nCreate the function `round_down_scores()` that takes a `vector` of `student_scores`.\r\nThe schools' requested rounding is a truncation.\r\nLucky for you, C++ can cast one type into another with `static_cast`.\r\nThe `static_cast` conversion from `double` to `int` cuts off any digit after the decimal.\r\nThis function should take the input `vector` and `return` a new vector with all the scores converted to `int`s.\r\n\r\n```cpp\r\nstd::vector<double> student_scores {90.33, 40.5, 55.44, 70.05, 30.55, 25.45, 80.45, 95.3, 38.7, 40.3};\r\nround_down_scores(student_scores)\r\n// => {90, 40, 55, 70, 30, 25, 80, 95, 38, 40}\r\n```\r\n\r\nThere are other methods which achieve the same result, but a _cast_ is a common sight.\r\n\r\n```cpp\r\nint new_PI{static_cast<int>(3.14) + static_cast<int>(0.001592653589)};\r\n// new_PI is 3.\r\n```\r\n\r\n## 2. Non-Passing Students\r\n\r\nAs you were grading the exam, you noticed some students weren't performing as well as you'd hoped.\r\nBut you were distracted, and forgot to note exactly _how many_ students.\r\n\r\nCreate the function `count_failed_students()` that takes a `vector` of `student_scores`.\r\nThis function should count up the number of students who don't have passing scores and return that count as an integer.\r\nA student needs a score greater than **40** to achieve a passing grade on the exam.\r\n\r\n```cpp\r\ncount_failed_students({90,40,55,70,30,25,80,95,38,40});\r\n// => 5\r\n```\r\n\r\n## 3. Calculating Letter Grades\r\n\r\nThe teacher you're assisting likes to assign letter grades as well as numeric scores.\r\nSince students rarely score 100 on an exam, the \"letter grade\" lower thresholds are calculated based on the highest score achieved, and increment evenly between the high score and the failing threshold of **<= 40**.\r\n\r\nCreate the function `letter_grades()` that takes the \"highest\" score on the exam as a parameter, and returns an `array` (not a vector) of lower score thresholds for each \"American style\" grade interval: `[\"D\", \"C\", \"B\", \"A\"]`.\r\n\r\n```cpp\r\n/*Where the highest score is 100, and failing is <= 40.\r\n       \"F\" <= 40\r\n 41 <= \"D\" <= 55\r\n 56 <= \"C\" <= 70\r\n 71 <= \"B\" <= 85\r\n 86 <= \"A\" <= 100\r\n*/\r\n\r\nletter_grades(100);\r\n// => {41, 56, 71, 86}\r\n\r\n\r\n/*Where the highest score is 88, and failing is <= 40.\r\n       \"F\" <= 40\r\n 41 <= \"D\" <= 52\r\n 53 <= \"C\" <= 64\r\n 65 <= \"B\" <= 76\r\n 77 <= \"A\" <= 88\r\n*/\r\n\r\nletter_grades(88);\r\n// => {41, 53, 65, 77}\r\n```\r\n\r\n## 4. Matching Names to Scores\r\n\r\nYou have exam scores in descending order, and the respective student names (sorted in the order of their exam scores).\r\nYou would like to match each student's name with their exam score and print out an overall class ranking.\r\n\r\nCreate the function `student_ranking()` with parameters `student_scores` and `student_names`.\r\nMatch each student name on the student_names `vector` with their score from the student_scores `vector`.\r\nYou can assume each argument `vector` is sorted from highest score(er) to lowest score(er).\r\nThe function should return a `vector` of strings with the format `<rank>. <student name>: <student score>`.\r\n\r\n```cpp\r\nstd::vector<int> student_scores {100, 99, 90, 84, 66, 53, 47};\r\nstd::vector<std::string> student_names {\"Joci\", \"Sara\",\"Kora\",\"Jan\",\"Indra\",\"Bern\", \"Fred\"};\r\nstudent_ranking(student_scores, student_names)\r\n// =>\r\n//  {\"1. Joci: 100\", \"2. Sara: 99\", \"3. Kora: 90\", \"4. Jan: 84\", \"5. Indra: 66\", \"6. Bern: 53\", \"7. Fred: 47\"}\r\n```\r\n\r\n## 5. A \"Perfect\" Score\r\n\r\nAlthough a \"perfect\" score of 100 is rare on an exam, it is interesting to know if at least one student has achieved it.\r\n\r\nCreate the function `perfect_score()` with parameters `student_scores` and `student_names`.\r\nThe lists are the same as in task 5.\r\nThe function should `return` _the first_ `<name>` (as a string) of the student who scored 100 on the exam.\r\n\r\nIf no 100 scores are found, an empty string `\"\"` should be returned.\r\n\r\n```cpp\r\nperfect_score({\"Nur\", \"Tony\", \"Fatima\"}, {90, 80, 100});\r\n// => \"Fatima\"\r\n\r\nperfect_score({\"Nur\", \"Tony\"}, {90, 80});\r\n// => \"\"\r\n```\r\n",
    "hints": "# Hints\r\n\r\n## General\r\n\r\n- `while` loops are used for _indefinite_ (uncounted) iteration\r\n- `for` loops are used for _definite_, (counted) iteration.\r\n- The keywords `break` and `continue` help customize loop behavior.\r\n- `std::to_string()` from `string` library can be used to convert a integer to string\r\n\r\nAlso being familiar with the following can help with completing the tasks:\r\n\r\n- [`vectors`][vectors]: indexing, size, [`<vector>.emplace_back`][emplace], [`<vector>.pop_back()`][pop].\r\n- [`string`][string]: using the `+` to concatenate strings, integer to string conversion, [`to_string`][to\\_string].\r\n\r\n## 1. Rounding Scores\r\n\r\n- `While` loops will continue to execute until their test condition evaluates to `False`.\r\n- `<vector>.back()` will return the last item in a `vector`.\r\n- `<vector>.pop_back()` will remove the last item in a `vector`.\r\n\r\n## 2. Non-Passing Students\r\n\r\n- A results counter does need to be set up and _incremented_ -- you'll want to `return` the count of non-passing students when the loop terminates.\r\n\r\n## 3. Calculating Letter Grades\r\n\r\n- The score needed to avoid failing is always 41, since an \"F\" is **<= 40**. The remaining score range, from 41 to the highest score, should be divided into four equal intervals, one for each letter grade.\r\n- Subtract 40 from the highest score to get the total range of scores that qualify for letter grades (A to D).\r\n- Divide this total range by 4 to get the size of each grade interval.\r\n- Add this interval size to 40 repeatedly to calculate the lower bounds for each letter grade.\r\n- `static_cast<int>` without parameters should round off increments nicely.\r\n- You are expected to return an array, not a vector.\r\n\r\n## 4. Matching Names to Scores\r\n\r\n- If both containers are the same length and sorted the same way, could you use the `index` from one to retrieve a `value` from the other?\r\n- `std::to_string(int)` can be used to convert a number to string.\r\n- Don't forget the follow the format of the example's output.\r\n\r\n## 5. A \"Perfect\" Score\r\n\r\n- There may be or may not be a student with a score of 100, and you can't return an empty string without checking **all** scores.\r\n- The `control flow` statements `continue` and `break` may be useful here to move past unwanted values.\r\n\r\n[vectors]: https://en.cppreference.com/w/cpp/container/vector\r\n[string]: https://en.cppreference.com/w/cpp/string/basic_string\r\n[to\\_string]: https://en.cppreference.com/w/cpp/string/basic_string/to_string\r\n[emplace]: https://en.cppreference.com/w/cpp/container/vector/emplace_back\r\n[pop]: https://en.cppreference.com/w/cpp/container/vector/pop_back\r\n"
  },
  "starter_code": {
    "making_the_grade.cpp": "#include <array>\r\n#include <string>\r\n#include <vector>\r\n\r\n// Round down all provided student scores.\r\nstd::vector<int> round_down_scores(std::vector<double> student_scores) {\r\n    // TODO: Implement round_down_scores\r\n    return {};\r\n}\r\n\r\n// Count the number of failing students out of the group provided.\r\nint count_failed_students(std::vector<int> student_scores) {\r\n    // TODO: Implement count_failed_students\r\n    return 0;\r\n}\r\n\r\n// Create a list of grade thresholds based on the provided highest grade.\r\nstd::array<int, 4> letter_grades(int highest_score) {\r\n    // TODO: Implement letter_grades\r\n    return {};\r\n}\r\n\r\n// Organize the student's rank, name, and grade information in ascending order.\r\nstd::vector<std::string> student_ranking(\r\n    std::vector<int> student_scores, std::vector<std::string> student_names) {\r\n    // TODO: Implement student_ranking\r\n    return {};\r\n}\r\n\r\n// Create a string that contains the name of the first student to make a perfect\r\n// score on the exam.\r\nstd::string perfect_score(std::vector<int> student_scores,\r\n                          std::vector<std::string> student_names) {\r\n    // TODO: Implement perfect_score\r\n    return \"\";\r\n}\r\n"
  },
  "tests": {
    "making_the_grade_test.cpp": "#include \"making_the_grade.cpp\"\r\n#ifdef EXERCISM_TEST_SUITE\r\n#include <catch2/catch.hpp>\r\n#else\r\n#include \"test/catch.hpp\"\r\n#endif\r\n\r\nusing namespace std;\r\n\r\nTEST_CASE(\"Check correct mark conversion (empty)\", \"[task_1]\") {\r\n    vector<double> input{};\r\n    vector<int> expected{};\r\n    vector<int> actual = round_down_scores(input);\r\n\r\n    REQUIRE(expected == actual);\r\n}\r\n\r\n#if defined(EXERCISM_RUN_ALL_TESTS)\r\n\r\nTEST_CASE(\"Check correct mark conversion (all < 0.5)\", \"[task_1]\") {\r\n    vector<double> input{5.2, 77.1, 91.0};\r\n    vector<int> expected{5, 77, 91};\r\n    vector<int> actual = round_down_scores(input);\r\n\r\n    REQUIRE(expected == actual);\r\n}\r\n\r\nTEST_CASE(\"Check correct mark conversion (all mixed)\", \"[task_1]\") {\r\n    vector<double> input{5.2, 77.1, 91.0, 42.9, 11.6544};\r\n    vector<int> expected{5, 77, 91, 42, 11};\r\n    vector<int> actual = round_down_scores(input);\r\n\r\n    REQUIRE(expected == actual);\r\n}\r\n\r\nTEST_CASE(\"Count failed students (none failed)\", \"[task_2]\") {\r\n    vector<int> input{89, 85, 42, 57, 90, 100, 95, 48, 70, 96};\r\n    int expected{0};\r\n    int actual = count_failed_students(input);\r\n\r\n    REQUIRE(expected == actual);\r\n}\r\n\r\nTEST_CASE(\"Count failed students (some failed)\", \"[task_2]\") {\r\n    vector<int> input{40, 40, 35, 70, 30, 41, 90};\r\n    int expected{4};\r\n    int actual = count_failed_students(input);\r\n\r\n    REQUIRE(expected == actual);\r\n}\r\n\r\nTEST_CASE(\"Test letter grades: 100\", \"[task_3]\") {\r\n    int input{100};\r\n    array<int, 4> expected{41, 56, 71, 86};\r\n    array<int, 4> actual = letter_grades(input);\r\n\r\n    REQUIRE(expected == actual);\r\n}\r\nTEST_CASE(\"Test letter grades: 97\", \"[task_3]\") {\r\n    int input{97};\r\n    array<int, 4> expected{41, 55, 69, 83};\r\n    array<int, 4> actual = letter_grades(input);\r\n\r\n    REQUIRE(expected == actual);\r\n}\r\nTEST_CASE(\"Test letter grades: 81\", \"[task_3]\") {\r\n    int input{81};\r\n    array<int, 4> expected{41, 51, 61, 71};\r\n    array<int, 4> actual = letter_grades(input);\r\n\r\n    REQUIRE(expected == actual);\r\n}\r\n\r\nTEST_CASE(\"Rank one student\", \"[task_4]\") {\r\n    vector<int> grades{82};\r\n    vector<string> names{\"Betty\"};\r\n    vector<string> expected{\"1. Betty: 82\"};\r\n    vector<string> actual = student_ranking(grades, names);\r\n\r\n    REQUIRE(expected == actual);\r\n}\r\n\r\nTEST_CASE(\"Rank several student\", \"[task_4]\") {\r\n    vector<int> grades{100, 98, 92, 86, 70, 68, 67, 60};\r\n    vector<string> names{\"Rui\",  \"Betty\", \"Joci\", \"Yoshi\",\r\n                         \"Kora\", \"Bern\",  \"Jan\",  \"Rose\"};\r\n    vector<string> expected{\"1. Rui: 100\",  \"2. Betty: 98\", \"3. Joci: 92\",\r\n                            \"4. Yoshi: 86\", \"5. Kora: 70\",  \"6. Bern: 68\",\r\n                            \"7. Jan: 67\",   \"8. Rose: 60\"};\r\n    vector<string> actual = student_ranking(grades, names);\r\n\r\n    REQUIRE(expected == actual);\r\n}\r\n\r\nTEST_CASE(\"No perfect score\", \"[task_5]\") {\r\n    vector<int> grades{11, 34, 92, 23, 70, 76, 67, 60};\r\n    vector<string> names{\"Rui\",  \"Betty\", \"Joci\", \"Yoshi\",\r\n                         \"Kora\", \"Bern\",  \"Jan\",  \"Rose\"};\r\n    string expected{\"\"};\r\n    string actual = perfect_score(grades, names);\r\n\r\n    REQUIRE(expected == actual);\r\n}\r\n\r\nTEST_CASE(\"One perfect score\", \"[task_5]\") {\r\n    vector<int> grades{11, 34, 92, 23, 70, 76, 67, 100};\r\n    vector<string> names{\"Rui\",  \"Betty\", \"Joci\", \"Yoshi\",\r\n                         \"Kora\", \"Bern\",  \"Jan\",  \"Rose\"};\r\n    string expected{\"Rose\"};\r\n    string actual = perfect_score(grades, names);\r\n\r\n    REQUIRE(expected == actual);\r\n}\r\n\r\nTEST_CASE(\"Several perfect scores\", \"[task_5]\") {\r\n    vector<int> grades{11, 100, 92, 23, 70, 100, 67, 100};\r\n    vector<string> names{\"Rui\",  \"Betty\", \"Joci\", \"Yoshi\",\r\n                         \"Kora\", \"Bern\",  \"Jan\",  \"Rose\"};\r\n    string expected{\"Betty\"};\r\n    string actual = perfect_score(grades, names);\r\n\r\n    REQUIRE(expected == actual);\r\n}\r\n\r\n#endif\r\n"
  }
}