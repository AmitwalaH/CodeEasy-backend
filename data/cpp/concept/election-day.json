{
  "language": "cpp",
  "slug": "election-day",
  "docs": {
    "introduction": "# Introduction\r\n\r\n## References\r\n\r\n### Copies and References\r\n\r\nWith our current knowledge, it is a bit cumbersome to update a variable with the help of a function.\r\nEvery function argument is handled like a copy and does not change the original value.\r\nDepending on the size of your type, this can have serious consequences for the performance of your code.\r\n\r\n```cpp\r\nint adjust_salary(int base, int kids) {\r\n    return base + kids * 500;\r\n}\r\nint now_a_mother_of_twins{2500};\r\nadjust_salary(now_a_mother_of_twins, 2);\r\n\r\n// now_a_mother_of_twins is still 2500\r\nnow_a_mother_of_twins = adjust_salary(now_a_mother_of_twins, 2);\r\n// now_a_mother_of_twins is now 3500\r\n```\r\n\r\n`References` can be seen as aliases - changes to them have an effect on the original variable.\r\n`References` use an **ampersand** (`&`) in the type declaration.\r\n\r\n```cpp\r\nint balance{1000};\r\nint& budget{balance};\r\nint pro_computer_wheels{699};\r\nbudget -= pro_computer_wheels;\r\n// budget is now 301;\r\n// balance is also 301;\r\n```\r\nReseating (changing the binding of a `reference`) is not possible.\r\nYou cannot have an uninitialized `reference`.\r\n`References` need to be initialized with an existing variable.\r\n\r\n```cpp\r\nint main_acc{1'000'000};\r\nint side_acc{-20};\r\nint& savings{main_acc};\r\n// => main_acc and savings are 1'000'000\r\n\r\n// try to reseat savings to use main account\r\nsavings = side_acc;\r\n// savings and main_acc are now -20\r\n// as this uses the **value** of side_acc\r\nsavings += 20;\r\n// savings and main_acc are now 0, side_acc is still -20\r\n\r\nint& future_budget;\r\n// => compiler error, reference must be bound!\r\n```\r\n\r\n### `void`\r\n\r\nWith the power of `references` you might not need to return a value from a function at all.\r\n`void` is used as a return type in this scenario.\r\n\r\n```cpp\r\nvoid increase_power(int& level) {\r\n    level += 500;\r\n}\r\nint goku{8700};\r\nincrease_power(goku);\r\n// goku's power level?\r\n// It's over 9000!\r\n```\r\n",
    "instructions": "# Instructions\r\n\r\nA local school near you has a very active students' association.\r\nThe students' association is managed by a president and once every 2 years,\r\nelections are run to elect a new president.\r\n\r\nIn this year's election, it was decided that a new digital system to\r\ncount the votes was needed. The school needs your help building this new system.\r\n\r\n## 1. Get the number of votes from an `ElectionResult`\r\n\r\nThe new system will need a way to get the number of votes from a counter.\r\n\r\nThe election result struct is already created for you and it's defined as:\r\n\r\n```cpp\r\nstruct ElectionResult {\r\n    // Name of the candidate\r\n    std::string name{};\r\n    // Number of votes the candidate has\r\n    int votes{};\r\n};\r\n```\r\n\r\nAs all members in the `struct` are public, you don't need to write a `constructor` to initialize an `ElectionResult` object.\r\nYou can use an `initializer list` instead:\r\n\r\n```cpp\r\nElectionResult hamilton{\"Alex\", 1804};\r\n// => the hamilton object was initialized with the name \"Alex\" and 1804 votes.\r\n```\r\n\r\nCreate a function `vote_count` that will take a reference to an `ElectionResult` as an argument and will return the number of votes in the `ElectionResult`.\r\n\r\n```cpp\r\nvote_count(hamilton);\r\n// => 1804\r\n```\r\n\r\n## 2. Increment the votes of an `ElectionResult`\r\n\r\nIt's finally time to process the votes!\r\nNow you need a way to increment the votes in an `ElectionResult`.\r\n\r\nCreate a `void` function `increment_vote_count` that will take a reference to an `ElectionResult` as an argument and a number of votes, and will increment the `ElectionResult` by that number of votes.\r\n\r\n```cpp\r\nElectionResult burr{\"Aaron \" 1801};\r\n\r\nincrement_vote_count(burr, 3);\r\n\r\nvote_count(burr);\r\n// => 1804\r\n```\r\n\r\n## 3. Vote counting and Presidency\r\n\r\nThe school handed in their votes and it is now time to check the results for the winner.\r\n\r\nCreate a function `determine_result` that receives a reference to a final count and returns a reference to the `ElectionResult` of the new president.\r\nIt should also change the name of the winner by prefixing it with \"President\".\r\nThe final count is given in the form of a `reference` to `std::vector<ElectionResult>`, a vector with `ElectionResults` of all the participating candidates.\r\n\r\n```cpp\r\nElectionResult sanchez{\"Pedro\", 471};\r\nElectionResult wheatley{\"Summer\", 340};\r\nstd::vector<ElectionResult> final_count{sanchez, wheatley};\r\n\r\nElectionResult& winner = determine_result(final_count);\r\n\r\nwinner.name;\r\n// => \"President Pedro\"\r\n```\r\n\r\nTo keep things simple, you can assume the following:\r\n- The `vector` has at least one element.\r\n- There will be no ties for first place.\r\n",
    "hints": "# Hints\r\n\r\n## General\r\n\r\n- Although you are receiving a `reference` to an `ElectionResult`, you can access its members with the dot `.` notation, as if it wasn't a `reference`!\r\n- You can get a `reference` for a variable by using the `&` operator, e.g `int&`.\r\n- If you are unsure how `references` work, try reading [Learn C++: References][learncpp-references].\r\n\r\n## 1. Get the number of votes from an `ElectionResult`\r\n\r\n- You need to create a function with a `reference` to an `ElectionResult`, in other words, a `ElectionResult&`.\r\n- - Although you are receiving a `reference` to an `ElectionResult`, you can access its members with the dot `.` notation, as if it wasn't a `reference`!\r\n\r\n## 2. Increment the votes of an `ElectionResult`\r\n\r\n- You need to create a function with a `reference` to an `ElectionResult`, in other words, a `ElectionResult&`.\r\n- - Although you are receiving a `reference` to an `ElectionResult`, you can change its member variables with the dot `.` notation, as if it wasn't a `reference`!\r\n\r\n## 3. Vote counting and Presidency\r\n\r\n- You can iterate a reference to a `vector` like a normal vector with a loop.\r\n- You can get the size of a vector with `myvector.size()`.\r\n\r\n\r\n[learncpp-references]: https://www.learncpp.com/cpp-tutorial/lvalue-references/\r\n"
  },
  "starter_code": {
    "election_day.cpp": "#include <string>\r\n#include <vector>\r\n\r\nnamespace election {\r\n\r\n// The election result struct is already created for you:\r\n\r\nstruct ElectionResult {\r\n    // Name of the candidate\r\n    std::string name{};\r\n    // Number of votes the candidate has\r\n    int votes{};\r\n};\r\n\r\n// TODO: Task 1\r\n// vote_count takes a reference to an `ElectionResult` as an argument and will\r\n// return the number of votes in the `ElectionResult.\r\n\r\n// TODO: Task 2\r\n// increment_vote_count takes a reference to an `ElectionResult` as an argument\r\n// and a number of votes (int), and will increment the `ElectionResult` by that\r\n// number of votes.\r\n\r\n// TODO: Task 3\r\n// determine_result receives the reference to a final_count and returns a\r\n// reference to the `ElectionResult` of the new president. It also changes the\r\n// name of the winner by prefixing it with \"President\". The final count is given\r\n// in the form of a `reference` to `std::vector<ElectionResult>`, a vector with\r\n// `ElectionResults` of all the participating candidates.\r\n\r\n}  // namespace election\r\n"
  },
  "tests": {
    "election_day_test.cpp": "#include \"election_day.cpp\"\r\n#ifdef EXERCISM_TEST_SUITE\r\n#include <catch2/catch.hpp>\r\n#else\r\n#include \"test/catch.hpp\"\r\n#endif\r\n\r\nusing namespace election;\r\n\r\nTEST_CASE(\"Votes are returned correctly for 0 votes\", \"[task_1]\") {\r\n    ElectionResult result{};\r\n    int expected{0};\r\n    REQUIRE(vote_count(result) == expected);\r\n}\r\n\r\n#if defined(EXERCISM_RUN_ALL_TESTS)\r\n\r\nTEST_CASE(\"Votes are returned correctly for 211 votes\", \"[task_1]\") {\r\n    ElectionResult result{\"Nadir\", 211};\r\n    int expected{211};\r\n    REQUIRE(vote_count(result) == expected);\r\n}\r\n\r\nTEST_CASE(\"Votes are incremented correctly for new votes\", \"[task_2]\") {\r\n    ElectionResult result{};\r\n    int expected{23};\r\n    increment_vote_count(result, 23);\r\n    REQUIRE(result.votes == expected);\r\n}\r\n\r\nTEST_CASE(\"Votes are incremented correctly for existing votes\", \"[task_2]\") {\r\n    ElectionResult result{\"Saoirse\", 94};\r\n    int expected{1994};\r\n    increment_vote_count(result, 1900);\r\n    REQUIRE(result.votes == expected);\r\n}\r\n\r\nTEST_CASE(\"Votes can be decremented\", \"[task_2]\") {\r\n    ElectionResult result{\"Lance\", 7};\r\n    int expected{0};\r\n    increment_vote_count(result, -7);\r\n    REQUIRE(result.votes == expected);\r\n}\r\n\r\nTEST_CASE(\"Presidency, one candidate\", \"[task_3]\") {\r\n    ElectionResult option1{\"Coriolanus Snow\", 13};\r\n    std::vector<ElectionResult> final_count{option1};\r\n\r\n    ElectionResult& result = determine_result(final_count);\r\n    std::string expected{\"President Coriolanus Snow\"};\r\n\r\n    REQUIRE(result.name == expected);\r\n}\r\n\r\nTEST_CASE(\"Presidency, two candidates\", \"[task_3]\") {\r\n    ElectionResult option1{\"Megatron\", 4};\r\n    ElectionResult option2{\"Optimus Prime\", 76};\r\n    std::vector<ElectionResult> final_count{option1, option2};\r\n\r\n    ElectionResult& result = determine_result(final_count);\r\n    std::string expected{\"President Optimus Prime\"};\r\n\r\n    REQUIRE(result.name == expected);\r\n}\r\n\r\nTEST_CASE(\"Presidency, several candidates\", \"[task_3]\") {\r\n    ElectionResult option1{\"David\", 11};\r\n    ElectionResult option2{\"Shaw\", 12};\r\n    ElectionResult option3{\"Ripley\", 79};\r\n    ElectionResult option4{\"Call\", 8};\r\n    std::vector<ElectionResult> final_count{option1, option2, option3, option4};\r\n\r\n    ElectionResult& result = determine_result(final_count);\r\n    std::string expected{\"President Ripley\"};\r\n\r\n    REQUIRE(result.name == expected);\r\n}\r\n\r\nTEST_CASE(\"Presidency, votes and other results do not change\", \"[task_3]\") {\r\n    ElectionResult option1{\"Tammy Metzler\", 0};\r\n    ElectionResult option2{\"Tracy Flick\", 257};\r\n    ElectionResult option3{\"Paul Metzler\", 256};\r\n    std::vector<ElectionResult> final_count{option1, option2, option3};\r\n\r\n    determine_result(final_count);\r\n\r\n    REQUIRE(final_count.size() == 3);\r\n    REQUIRE(final_count[0].name == \"Tammy Metzler\");\r\n    REQUIRE(final_count[0].votes == 0);\r\n    REQUIRE(final_count[1].name == \"President Tracy Flick\");\r\n    REQUIRE(final_count[1].votes == 257);\r\n    REQUIRE(final_count[2].name == \"Paul Metzler\");\r\n    REQUIRE(final_count[2].votes == 256);\r\n}\r\n\r\n#endif\r\n"
  }
}