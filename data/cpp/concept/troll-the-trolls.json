{
  "language": "cpp",
  "slug": "troll-the-trolls",
  "docs": {
    "introduction": "# Introduction\r\n\r\n## Enumerations\r\n\r\nSo far we have mostly handled numbers and strings.\r\nTo model the real world, we might want a limited number of values that a variable can take on.\r\nYou might want a dedicated type with a few distinct values with distinct names.\r\nFor example, in a skateboard factory, having the deck material be a choice of only maple, bamboo, or plastic.\r\n\r\nYou could use integers to encode those values, but you would have to use extra code to check if there is an invalid value coming from the system for the material.\r\nThe meaning of those [_magic numbers_][magic numbers] is difficult to trace over the source code and they are prone to mix-ups.\r\n`enumerations` can be used to encourage expressive code and to restrict unintentional comparison mistakes.\r\n\r\n## Example usage\r\n\r\nThe specific term for this kind of enumeration is `scoped enumeration`.\r\nThe snippet below shows how to write a `DeckMaterial` `enumeration`.\r\nNote the `enum class` keyword and the `;` at the end of the definition:\r\n\r\n```cpp\r\nenum class DeckMaterial {\r\n    maple,\r\n    bamboo,\r\n    plastic\r\n};\r\n```\r\nNow, look at a pricing function in the skate shop and take note of the scope resolution operator (`::`) specifying an `enumerator` from the `enumeration`:\r\n\r\n```cpp\r\ndouble deck_price(double base_price, DeckMaterial material) {\r\n    if(material == DeckMaterial::plastic) {\r\n        return base_price * 0.9;\r\n    }\r\n    return base_price * 1.3;\r\n}\r\n```\r\n\r\n## Scoping\r\n\r\nImagine you have a second `enumeration` for wheel material:\r\n\r\n```cpp\r\nenum class WheelMaterial {\r\n    steel,\r\n    clay,\r\n    plastic\r\n};\r\n```\r\nAlthough the wheels and the deck can both be made of _plastic_, the two cannot be confused.\r\nThey are different _types_:  `DeckMaterial` plastic and `WheelMaterial` plastic.\r\nEach `enumeration` will have its `enumerators` in its own scope - its own `namespace`.\r\nThis is the reason they are called `scoped enumerations`.\r\n\r\n~~~~exercism/advanced\r\n## Unscoped Enumerations\r\nYou might be thinking that with a name like `scoped`, there would also be  _`unscoped`_ enumerations -- and you would be correct.\r\n`Unscoped enumerations` are becoming less popular because they all share the same global namespace.\r\nBecause of the sharing, you could not have two `unscoped enumerations` with the same `enumerators` like _plastic_ in the example above.\r\n\r\nAlso, `unscoped enumerations` implicitly convert to integers.\r\nLook at the example below for a surprising result:\r\n\r\n```cpp\r\nenum CitrusFruits {\r\n    lemons,  // 0\r\n    oranges, //1\r\n};\r\n\r\nenum IceCream {\r\n    walnut,  // 0\r\n    apples,  // 1\r\n};\r\n\r\nbool comparison{apples == oranges};\r\n// => true\r\n\r\n// Example from above:\r\nbool comparison{DeckMaterial::plastic == WheelMaterial::plastic};\r\n// => Does not compile!\r\n```\r\n\r\nIf you want to convert `scoped enumerations` to integers you can use `static_cast<int>`.\r\n~~~~\r\n\r\n\r\n## Switch Statements\r\n\r\nLike other languages, C++ also provides a `switch` statement.\r\nSwitch statements are a shorter way to write long `if ... else if` statements.\r\nTo make a switch, we start by using the keyword `switch` followed by an integer.\r\nWe then declare each one of the conditions with the `case` keyword.\r\nWe can also declare a `default` case, that will run when none of the previous `case` conditions matched.\r\nEach case should end with a `break` (or a `return`) statement.\r\n\r\n```cpp\r\nint price{0};\r\nint adults{3};\r\nint kids{2};\r\n\r\nswitch (int group_size{adults + kids}) {\r\n    case 1:\r\n        price = 50;\r\n        break;\r\n    case 2:\r\n        price = 70;\r\n        break;\r\n    default:\r\n        price = group_size * 30;\r\n}\r\n```\r\n\r\n## Fall-through\r\n\r\nOne important thing about the switch construct is that the code will continue to execute until it is stopped by a `break` (or a `return`) statement.\r\nThis can lead to unexpected behavior.\r\n\r\n```cpp\r\nint adults{1};\r\nint kids{0};\r\nswitch (int group_size{adults + kids}) {\r\n    case 1:\r\n        price = 50;\r\n    case 2:\r\n        price = 70;\r\n    default:\r\n        price = group_size * 30;\r\n}\r\n// price will be 30!\r\n```\r\n\r\nThe main use case for this continued execution feature is a statement that has several labels.\r\nMultiple switch results can map to the same piece of code to be executed.\r\nThis way - in a booking app, for example - the called function for group sizes 2 and 3 can be the same:\r\n```cpp\r\nswitch (group_size) {\r\ncase 1:\r\n    book_room();\r\n    break;\r\ncase 2:\r\ncase 3:\r\n    book_apartment(group_size);\r\n    break;\r\ndefault:\r\n    book_house(group_size);\r\n}\r\n// book_apartment happens when group_size is 2 or 3\r\n```\r\n\r\n[magic numbers]: https://en.wikipedia.org/wiki/Magic_number_(programming)\r\n",
    "instructions": "# Instructions\r\n\r\nYour friend Helma made a small online game that rapidly gained popularity.\r\nIt is called _HellMath_.\r\nThe small community attracted some trolls who make the game and the forums pretty unpleasant.\r\nHelma has asked you to work on a new permission system to separate troublemakers.\r\n\r\nThe forum supports three different actions:\r\n\r\n- Read\r\n- Write\r\n- Remove\r\n\r\nThere are four types of accounts, each with different default permissions:\r\n\r\n- Guests: can read posts.\r\n- Users and Trolls: can read and write posts.\r\n- Moderators: can read, write and remove posts, they have all the permissions.\r\n\r\nHelma has noticed that it is no use to ban troll accounts.\r\nHer strategy is to give them the illusion that their time is \"well invested\", but their posts are only shown to other trolls.\r\nFor anything that requires priority ordering, trolls are last in any sequence.\r\nWhen they enter a game, the pool of available players is also limited to other trolls.\r\n\r\nThis practice is called [shadow-banning][shadow-ban].\r\n\r\n## 1. Set up user types and permissions.\r\n\r\nFirst, define an `AccountStatus` enumeration to represent the four account types: `troll`, `guest`, `user`, and `mod`.\r\n\r\nNext, define an `Action` enumeration to represent the three permission types: `read`, `write`, and `remove`.\r\n\r\n\r\n## 2. Promote trolls only to other trolls.\r\n\r\nEvery post on the forums saves the `AccountStatus` of the poster in its metadata.\r\nMake sure that posts by trolls are only displayed to other trolls.\r\n\r\nHelma needs a `display_post` function, that gets two arguments of `AccountStatus` and returns a `bool`.\r\nThe first argument is the status of the poster, the second one is the status of the viewer.\r\n\r\n```cpp\r\nusing namespace hellmath;\r\ndisplay_post(AccountStatus::troll, AccountStatus::user);\r\n// => false\r\ndisplay_post(AccountStatus::mod, AccountStatus::guest);\r\n// => true\r\n```\r\n\r\n## 3. Check permissions for different users.\r\n\r\nHelma needs a way to check if a certain action is allowed for a user.\r\n\r\nPlease implement a `permission_check` function, that takes an `Action` as a first argument and an `AccountStatus` to check against.\r\nIt should return a `bool` according to the permissions listed in the introduction.\r\n\r\n```cpp\r\npermission_check(Action::remove, AccountStatus::guest);\r\n// => false\r\npermission_check(Action::write, AccountStatus::mod);\r\n// => true\r\n```\r\n\r\n## 4. Grant game access and pair players.\r\n\r\nTo keep the actual players in the game accountable for their actions, _Hellmath_ denies access to guest users.\r\nAs mentioned above, Helma wants trolls to troll other trolls.\r\nGame connections between other users are unrestricted.\r\n\r\nImplement the `valid_player_combination` function that checks if two players can join the same game.\r\nThe function has two parameters of type `AccountStatus` and returns a `bool`.\r\n\r\n```cpp\r\nvalid_player_combination(AccountStatus::guest, AccountStatus::mod);\r\n// => false\r\nvalid_player_combination(AccountStatus::troll, AccountStatus::troll);\r\n// => true\r\n```\r\n\r\n## 5. Build priority queuing.\r\n\r\nWith the massive growth of the game and the forums, Helma now has to distribute computing power and bandwidth among users.\r\nTo handle emergencies, moderators are given the highest priority.\r\nGuests are queued behind normal users, and trolls get sorted behind everyone else.\r\n\r\nImplement the `has_priority` function that takes two `AccountStatus` arguments and returns `true`, if and only if the first account has a strictly higher priority than the second.\r\n\r\n```cpp\r\nhas_priority(AccountStatus::guest, AccountStatus::mod);\r\n// => false\r\nhas_priority(AccountStatus::user, AccountStatus::troll);\r\n// => true\r\n```\r\n\r\n[shadow-ban]: https://en.wikipedia.org/wiki/Shadow_banning\r\n",
    "hints": "# Hints\r\n\r\n## 1. Set up user types and permissions.\r\n\r\n- To handle each `AccountStatus` enumerator, you could use an `if` statement, but a [`switch` statement][switch] is a great alternative.\r\n\r\n\r\n## 2. Promote trolls only to other trolls.\r\n\r\n- You can compare enumerations like any other type with the `!=` and `==` operators.\r\n\r\n## 3. Check permissions for different users.\r\n\r\n- If you solve the task with a switch statement, [fallthroughs][fallthrough] might be helpful.\r\n- You can use [sequential labels][fallthrough] and the [default][switch] label to group permissions.\r\n\r\n## 4. Grant game access and pair players.\r\n\r\n- Your main concern are `guest` and `troll` accounts, for other combinations you do not need to split up your logic.\r\n\r\n## 5. Build priority queuing.\r\n\r\n- If you order your `AccountStatus` enumeration correctly, you can use `static_cast<int>` to compare the enumerators in a compact manner.\r\n\r\n[switch]: https://www.learncpp.com/cpp-tutorial/switch-statement-basics/\r\n[fallthrough]: https://www.learncpp.com/cpp-tutorial/switch-fallthrough-and-scoping/\r\n"
  },
  "starter_code": {
    "troll_the_trolls.cpp": "namespace hellmath {\r\n\r\n// TODO: Task 1 - Define an `AccountStatus` enumeration to represent the four\r\n// account types: `troll`, `guest`, `user`, and `mod`.\r\n\r\n// TODO: Task 1 - Define an `Action` enumeration to represent the three\r\n// permission types: `read`, `write`, and `remove`.\r\n\r\n// TODO: Task 2 - Implement the `display_post` function, that gets two arguments\r\n// of `AccountStatus` and returns a `bool`. The first argument is the status of\r\n// the poster, the second one is the status of the viewer.\r\n\r\n// TODO: Task 3 - Implement the `permission_check` function, that takes an\r\n// `Action` as a first argument and an `AccountStatus` to check against. It\r\n// should return a `bool`.\r\n\r\n// TODO: Task 4 - Implement the `valid_player_combination` function that\r\n// checks if two players can join the same game. The function has two parameters\r\n// of type `AccountStatus` and returns a `bool`.\r\n\r\n// TODO: Task 5 - Implement the `has_priority` function that takes two\r\n// `AccountStatus` arguments and returns `true`, if and only if the first\r\n// account has a strictly higher priority than the second.\r\n\r\n}  // namespace hellmath\r\n"
  },
  "tests": {
    "troll_the_trolls_test.cpp": "#include \"troll_the_trolls.cpp\"\r\n#ifdef EXERCISM_TEST_SUITE\r\n#include <catch2/catch.hpp>\r\n#else\r\n#include \"test/catch.hpp\"\r\n#endif\r\n\r\nusing namespace std;\r\nusing namespace hellmath;\r\n\r\nTEST_CASE(\"Troll posts are visible to trolls\", \"[task_2]\") {\r\n    AccountStatus poster{AccountStatus::troll};\r\n    AccountStatus viewer{AccountStatus::troll};\r\n\r\n    REQUIRE(display_post(poster, viewer));\r\n}\r\n\r\n#if defined(EXERCISM_RUN_ALL_TESTS)\r\n\r\nTEST_CASE(\"Troll posts are not visible to non-trolls\", \"[task_2]\") {\r\n    AccountStatus poster{AccountStatus::troll};\r\n\r\n    AccountStatus viewer{AccountStatus::guest};\r\n    REQUIRE_FALSE(display_post(poster, viewer));\r\n\r\n    viewer = AccountStatus::user;\r\n    REQUIRE_FALSE(display_post(poster, viewer));\r\n\r\n    viewer = AccountStatus::mod;\r\n    REQUIRE_FALSE(display_post(poster, viewer));\r\n}\r\n\r\nTEST_CASE(\"Non-troll posts are visible to guests\", \"[task_2]\") {\r\n    AccountStatus viewer{AccountStatus::guest};\r\n\r\n    AccountStatus poster{AccountStatus::user};\r\n    REQUIRE(display_post(poster, viewer));\r\n\r\n    poster = AccountStatus::mod;\r\n    REQUIRE(display_post(poster, viewer));\r\n}\r\n\r\nTEST_CASE(\"Non-troll posts are visible to trolls\", \"[task_2]\") {\r\n    AccountStatus viewer{AccountStatus::troll};\r\n\r\n    AccountStatus poster{AccountStatus::user};\r\n    REQUIRE(display_post(poster, viewer));\r\n\r\n    poster = AccountStatus::mod;\r\n    REQUIRE(display_post(poster, viewer));\r\n}\r\n\r\nTEST_CASE(\"Non-troll posts are visible to users\", \"[task_2]\") {\r\n    AccountStatus viewer{AccountStatus::user};\r\n\r\n    AccountStatus poster{AccountStatus::user};\r\n    REQUIRE(display_post(poster, viewer));\r\n\r\n    poster = AccountStatus::mod;\r\n    REQUIRE(display_post(poster, viewer));\r\n}\r\n\r\nTEST_CASE(\"Non-troll posts are visible to mods\", \"[task_2]\") {\r\n    AccountStatus viewer{AccountStatus::mod};\r\n\r\n    AccountStatus poster{AccountStatus::user};\r\n    REQUIRE(display_post(poster, viewer));\r\n\r\n    poster = AccountStatus::mod;\r\n    REQUIRE(display_post(poster, viewer));\r\n}\r\n\r\nTEST_CASE(\"Guests have correct permissions\", \"[task_3]\") {\r\n    AccountStatus status{AccountStatus::guest};\r\n\r\n    Action action{Action::read};\r\n    REQUIRE(permission_check(action, status));\r\n\r\n    action = Action::write;\r\n    REQUIRE_FALSE(permission_check(action, status));\r\n\r\n    action = Action::remove;\r\n    REQUIRE_FALSE(permission_check(action, status));\r\n}\r\n\r\nTEST_CASE(\"Trolls have correct permissions\", \"[task_3]\") {\r\n    AccountStatus status{AccountStatus::troll};\r\n\r\n    Action action{Action::read};\r\n    REQUIRE(permission_check(action, status));\r\n\r\n    action = Action::write;\r\n    REQUIRE(permission_check(action, status));\r\n\r\n    action = Action::remove;\r\n    REQUIRE_FALSE(permission_check(action, status));\r\n}\r\n\r\nTEST_CASE(\"Users have correct permissions\", \"[task_3]\") {\r\n    AccountStatus status{AccountStatus::user};\r\n\r\n    Action action{Action::read};\r\n    REQUIRE(permission_check(action, status));\r\n\r\n    action = Action::write;\r\n    REQUIRE(permission_check(action, status));\r\n\r\n    action = Action::remove;\r\n    REQUIRE_FALSE(permission_check(action, status));\r\n}\r\n\r\nTEST_CASE(\"Moderators have correct permissions\", \"[task_3]\") {\r\n    AccountStatus status{AccountStatus::mod};\r\n\r\n    Action action{Action::read};\r\n    REQUIRE(permission_check(action, status));\r\n\r\n    action = Action::write;\r\n    REQUIRE(permission_check(action, status));\r\n\r\n    action = Action::remove;\r\n    REQUIRE(permission_check(action, status));\r\n}\r\n\r\nTEST_CASE(\"Guests cannot start games\", \"[task_4]\") {\r\n    // First player is a guest\r\n    AccountStatus player1{AccountStatus::guest};\r\n\r\n    AccountStatus player2{AccountStatus::guest};\r\n    REQUIRE_FALSE(valid_player_combination(player1, player2));\r\n\r\n    player2 = AccountStatus::troll;\r\n    REQUIRE_FALSE(valid_player_combination(player1, player2));\r\n\r\n    player2 = AccountStatus::user;\r\n    REQUIRE_FALSE(valid_player_combination(player1, player2));\r\n\r\n    player2 = AccountStatus::mod;\r\n    REQUIRE_FALSE(valid_player_combination(player1, player2));\r\n\r\n    // Second player is a guest\r\n    player2 = AccountStatus::guest;\r\n\r\n    player1 = AccountStatus::troll;\r\n    REQUIRE_FALSE(valid_player_combination(player1, player2));\r\n\r\n    player1 = AccountStatus::user;\r\n    REQUIRE_FALSE(valid_player_combination(player1, player2));\r\n\r\n    player1 = AccountStatus::mod;\r\n    REQUIRE_FALSE(valid_player_combination(player1, player2));\r\n}\r\n\r\nTEST_CASE(\"Trolls can only play with other trolls\", \"[task_4]\") {\r\n    // First player is a troll\r\n    AccountStatus player1{AccountStatus::troll};\r\n\r\n    AccountStatus player2{AccountStatus::guest};\r\n    REQUIRE_FALSE(valid_player_combination(player1, player2));\r\n\r\n    player2 = AccountStatus::troll;\r\n    REQUIRE(valid_player_combination(player1, player2));\r\n\r\n    player2 = AccountStatus::user;\r\n    REQUIRE_FALSE(valid_player_combination(player1, player2));\r\n\r\n    player2 = AccountStatus::mod;\r\n    REQUIRE_FALSE(valid_player_combination(player1, player2));\r\n\r\n    // Second player is a troll\r\n    player2 = AccountStatus::troll;\r\n\r\n    player1 = AccountStatus::guest;\r\n    REQUIRE_FALSE(valid_player_combination(player1, player2));\r\n\r\n    player1 = AccountStatus::user;\r\n    REQUIRE_FALSE(valid_player_combination(player1, player2));\r\n\r\n    player1 = AccountStatus::mod;\r\n    REQUIRE_FALSE(valid_player_combination(player1, player2));\r\n}\r\n\r\nTEST_CASE(\"Users can only play with users or mods\", \"[task_4]\") {\r\n    // First player is a user\r\n    AccountStatus player1{AccountStatus::user};\r\n\r\n    AccountStatus player2{AccountStatus::guest};\r\n    REQUIRE_FALSE(valid_player_combination(player1, player2));\r\n\r\n    player2 = AccountStatus::troll;\r\n    REQUIRE_FALSE(valid_player_combination(player1, player2));\r\n\r\n    player2 = AccountStatus::user;\r\n    REQUIRE(valid_player_combination(player1, player2));\r\n\r\n    player2 = AccountStatus::mod;\r\n    REQUIRE(valid_player_combination(player1, player2));\r\n\r\n    // Second player is a user\r\n    player2 = AccountStatus::user;\r\n\r\n    player1 = AccountStatus::guest;\r\n    REQUIRE_FALSE(valid_player_combination(player1, player2));\r\n\r\n    player1 = AccountStatus::troll;\r\n    REQUIRE_FALSE(valid_player_combination(player1, player2));\r\n\r\n    player1 = AccountStatus::mod;\r\n    REQUIRE(valid_player_combination(player1, player2));\r\n}\r\n\r\nTEST_CASE(\"Moderators can only play with users or mods\", \"[task_4]\") {\r\n    // First player is a mod\r\n    AccountStatus player1{AccountStatus::mod};\r\n\r\n    AccountStatus player2{AccountStatus::guest};\r\n    REQUIRE_FALSE(valid_player_combination(player1, player2));\r\n\r\n    player2 = AccountStatus::troll;\r\n    REQUIRE_FALSE(valid_player_combination(player1, player2));\r\n\r\n    player2 = AccountStatus::user;\r\n    REQUIRE(valid_player_combination(player1, player2));\r\n\r\n    player2 = AccountStatus::mod;\r\n    REQUIRE(valid_player_combination(player1, player2));\r\n\r\n    // Second player is a mod\r\n    player2 = AccountStatus::mod;\r\n\r\n    player1 = AccountStatus::guest;\r\n    REQUIRE_FALSE(valid_player_combination(player1, player2));\r\n\r\n    player1 = AccountStatus::troll;\r\n    REQUIRE_FALSE(valid_player_combination(player1, player2));\r\n\r\n    player1 = AccountStatus::user;\r\n    REQUIRE(valid_player_combination(player1, player2));\r\n}\r\n\r\nTEST_CASE(\"Trolls have lowest priority\", \"[task_5]\") {\r\n    // First player is a troll\r\n    AccountStatus player1{AccountStatus::troll};\r\n\r\n    AccountStatus player2{AccountStatus::guest};\r\n    REQUIRE_FALSE(has_priority(player1, player2));\r\n\r\n    player2 = AccountStatus::troll;\r\n    REQUIRE_FALSE(has_priority(player1, player2));\r\n\r\n    player2 = AccountStatus::user;\r\n    REQUIRE_FALSE(has_priority(player1, player2));\r\n\r\n    player2 = AccountStatus::mod;\r\n    REQUIRE_FALSE(has_priority(player1, player2));\r\n\r\n    // Second player is a troll\r\n    player2 = AccountStatus::troll;\r\n\r\n    player1 = AccountStatus::guest;\r\n    REQUIRE(has_priority(player1, player2));\r\n\r\n    player1 = AccountStatus::user;\r\n    REQUIRE(has_priority(player1, player2));\r\n\r\n    player1 = AccountStatus::mod;\r\n    REQUIRE(has_priority(player1, player2));\r\n}\r\n\r\nTEST_CASE(\"Guests have second lowest priority\", \"[task_5]\") {\r\n    // First player is a guest\r\n    AccountStatus player1{AccountStatus::guest};\r\n\r\n    AccountStatus player2{AccountStatus::guest};\r\n    REQUIRE_FALSE(has_priority(player1, player2));\r\n\r\n    player2 = AccountStatus::troll;\r\n    REQUIRE(has_priority(player1, player2));\r\n\r\n    player2 = AccountStatus::user;\r\n    REQUIRE_FALSE(has_priority(player1, player2));\r\n\r\n    player2 = AccountStatus::mod;\r\n    REQUIRE_FALSE(has_priority(player1, player2));\r\n\r\n    // Second player is a guest\r\n    player2 = AccountStatus::guest;\r\n\r\n    player1 = AccountStatus::troll;\r\n    REQUIRE_FALSE(has_priority(player1, player2));\r\n\r\n    player1 = AccountStatus::user;\r\n    REQUIRE(has_priority(player1, player2));\r\n\r\n    player1 = AccountStatus::mod;\r\n    REQUIRE(has_priority(player1, player2));\r\n}\r\n\r\nTEST_CASE(\"Users have second highest priority\", \"[task_5]\") {\r\n    // First player is a user\r\n    AccountStatus player1{AccountStatus::user};\r\n\r\n    AccountStatus player2{AccountStatus::guest};\r\n    REQUIRE(has_priority(player1, player2));\r\n\r\n    player2 = AccountStatus::troll;\r\n    REQUIRE(has_priority(player1, player2));\r\n\r\n    player2 = AccountStatus::user;\r\n    REQUIRE_FALSE(has_priority(player1, player2));\r\n\r\n    player2 = AccountStatus::mod;\r\n    REQUIRE_FALSE(has_priority(player1, player2));\r\n\r\n    // Second player is a user\r\n    player2 = AccountStatus::user;\r\n\r\n    player1 = AccountStatus::troll;\r\n    REQUIRE_FALSE(has_priority(player1, player2));\r\n\r\n    player1 = AccountStatus::guest;\r\n    REQUIRE_FALSE(has_priority(player1, player2));\r\n\r\n    player1 = AccountStatus::mod;\r\n    REQUIRE(has_priority(player1, player2));\r\n}\r\n\r\nTEST_CASE(\"Moderators have highest priority\", \"[task_5]\") {\r\n    // First player is a mod\r\n    AccountStatus player1{AccountStatus::mod};\r\n\r\n    AccountStatus player2{AccountStatus::guest};\r\n    REQUIRE(has_priority(player1, player2));\r\n\r\n    player2 = AccountStatus::troll;\r\n    REQUIRE(has_priority(player1, player2));\r\n\r\n    player2 = AccountStatus::user;\r\n    REQUIRE(has_priority(player1, player2));\r\n\r\n    player2 = AccountStatus::mod;\r\n    REQUIRE_FALSE(has_priority(player1, player2));\r\n\r\n    // Second player is a mod\r\n    player2 = AccountStatus::mod;\r\n\r\n    player1 = AccountStatus::troll;\r\n    REQUIRE_FALSE(has_priority(player1, player2));\r\n\r\n    player1 = AccountStatus::guest;\r\n    REQUIRE_FALSE(has_priority(player1, player2));\r\n\r\n    player1 = AccountStatus::user;\r\n    REQUIRE_FALSE(has_priority(player1, player2));\r\n}\r\n\r\n#endif\r\n"
  }
}