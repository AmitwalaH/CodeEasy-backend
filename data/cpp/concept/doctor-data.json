{
  "language": "cpp",
  "slug": "doctor-data",
  "docs": {
    "introduction": "# Introduction\r\n\r\nIn C++, declarations are often separated from definitions.\r\nDeclarations are grouped into so-called header files, with the respective implementations placed in source files.\r\nYou can think of the header files as an API.\r\nThe header file will tell you _what_ a codebase has to offer without going into the details of _how_.\r\n\r\n## Header and Source\r\n\r\nThe most common file extension for header files is `.h`.\r\nSome projects use `.hpp` or skip the extension completely.\r\n\r\nThe definitions are located in a separate `.cpp` file.\r\nTo reunite the parts, the source file starts by _including_ the respective header file.\r\n\r\nIf you want to write a library called \"quick_math\" that offers a function \"super_root\" that you want to use often, the files would look like this:\r\n\r\n```cpp\r\n// A file named quick_math.h\r\n#pragma once\r\nnamespace quick_math {\r\n    double super_root(double x, int n);\r\n}\r\n```\r\n\r\n```cpp\r\n// A file named quick_math.cpp\r\n#include \"quick_math.h\"\r\n#include <cmath>\r\ndouble quick_math::super_root(double x, int n) {\r\n    while(n) { x = std::sqrt(x), --n;}\r\n    return x;\r\n}\r\n```\r\n\r\nIf you need to include a header that is only required by the implementation, the respective `#include` line is only needed in the source file.\r\nEverything that is included in the header is also available in the `.cpp` file, like the `string` library in the example below.\r\n**Attention**: the `;` is needed after the declaration in the header file, but not after the definition in the source file.\r\n\r\n~~~~exercism/note\r\nMany C++ exercises on Exercism start with two almost empty files: header and source.\r\nYou have to check the `*_test.cpp` file to see the names and namespaces of the expected functions in order to solve the exercise.\r\n~~~~\r\n\r\n## Classes and Headers\r\n\r\nClasses can become very complex and their relation to the header / source partition might be confusing.\r\nOne possible layout is to keep all the implementation details in the source file and all the declarations and member variables in the header:\r\n\r\n```cpp\r\n// A file named robot_flower.h\r\n#if !defined(ROBOT_FLOWER_H)\r\n#define ROBOT_FLOWER_H\r\n#include <string>\r\nnamespace robots {\r\n    class Flower {\r\n        private:\r\n            bool needs_water{};\r\n            int size{};\r\n            std::string name{};\r\n        public:\r\n            Flower(std::string name, int size = 0);\r\n            void give_water();\r\n            std::string get_name();\r\n            int get_size();\r\n            void start_next_day();\r\n    };\r\n}\r\n#endif\r\n```\r\n\r\n```cpp\r\n// A file named robot_flower.cpp\r\n#include \"robot_flower.h\"\r\nrobots::Flower::Flower(std::string name, int size) {this->name = \"Robotica \" + name; this->size = size;}\r\nvoid robots::Flower::start_next_day() {if (!needs_water) ++size; needs_water = true;}\r\nstd::string robots::Flower::get_name() {return name;}\r\nint robots::Flower::get_size() {return size;}\r\n```\r\n\r\nWhen the header is used as an API overview, that is where a person would look for information like default values.\r\nThe `size` parameter's default of the constructor is therefore handled in the header and not in the implementation.\r\nThe definitions in the source file are prefixed with the namespace `robots` and the class type `Flower`.\r\n\r\nAnother layout option is a _header only_ library, that does not have a `.cpp` file at all:\r\n\r\n```cpp\r\n// A file named robot_flower.h\r\n#pragma once\r\n#include <string>\r\nnamespace robots {\r\n    class Flower {\r\n        private:\r\n            bool needs_water{};\r\n            int size{};\r\n            std::string name{};\r\n        public:\r\n            Flower(std::string name, int size = 0) {this->name = \"Robotica \" + name; this->size = size;}\r\n            void give_water() {needs_water = false;}\r\n            std::string get_name() {return name;}\r\n            int get_size() {return size;}\r\n            void start_next_day() {if (!needs_water) ++size; needs_water = true;}\r\n    };\r\n}\r\n```\r\n\r\nProjects might use combinations of these layouts and there is a lot of discussion as to what might be the best fit for each use case.\r\n\r\n## Include Guards\r\n\r\nYou may have noticed the `#pragma once` line in the example header file above.\r\nThis is called an include guard - and it ensures that the content of the file is included only once during the compilation to avoid errors.\r\nThere is another, more complex variation of an include guard that starts with `#ifndef` and ends with `#endif`.\r\nIt serves the same purpose and its usage is shown in the `Flower` class example above.\r\n",
    "instructions": "# Instructions\r\n\r\nYou start your first day at an Australian company called \"Doctor Data\", which specializes in information recovery.\r\nYou aced your job interview through your knowledge of C++ and [von Neumann probes][van-neumann-probes].\r\nAs you have seen a lot of test files, your new boss wants you to recreate the respective source and header files from some test code the company has recently recovered.\r\n\r\nIn this exercise, you are going to recreate lost files.\r\nCurrently the content of the files is unusable garbage data.\r\n\r\n~~~~exercism/note\r\nThe workflow of this concept exercise is very similar to the structure of Exercism's practice exercises.\r\nThe exercise introduction text is only one part of the specification.\r\nThe test file is your definitive guide to solving a given problem.\r\nDue to the way C++ compilation works, the test results might not show up in the web interface until you have implemented a minimal version of every class, function and enumeration that is required by the tests.\r\nIf you receive compilation errors, they might disappear once you have addressed all tasks and tests.\r\n~~~~\r\n\r\nYou have four tasks, all related to recovering the lost code in the header and source files.\r\n\r\n## 1. Try to extract some first clues\r\n\r\nYou look at two recovered lines from the test files:\r\n\r\n```cpp\r\nheaven::Vessel bob{\"Robert Johansson\", 1};\r\nheaven::Vessel will{\"Riker\", 2, star_map::System::BetaHydri};\r\n```\r\n\r\nYour sharp eye instantly recognized a namespace `heaven`.\r\nYou also see that there must be a class called `Vessel`.\r\nThe constructor can apparently be called with two or three arguments.\r\nThe first argument seems to be of type `string`, the second one is a number.\r\nIt is possible to initialize the `Vessel` class with a third argument.\r\nThe third argument comes from a `star_map` namespace.\r\nIt is an enumerator of type `System`.\r\nYou even got one of the enumerations: `BetaHydri`.\r\n\r\nPrepare the source and header files with your discovered information.\r\nYou need two namespaces: `heaven` and `star_map`.\r\nThe `heaven` namespace has a class `Vessel`, which can be called with two or three arguments.\r\nThe `System` enum is to be placed in the `star_map` namespace and has an `EpsilonEridani` enumeration.\r\nKeep an eye out for other enumerations, so that you can constantly update the `System` enum.\r\n\r\n## 2. Find more details\r\n\r\nYou uncover more lines from the test:\r\n\r\n```cpp\r\nheaven::Vessel bob{\"Robert Johansson\", 1};\r\nREQUIRE(bob.current_system == star_map::System::Sol);\r\nREQUIRE(bob.generation == 1);\r\nheaven::Vessel bob5 = bob.replicate(\"Mario\");\r\nREQUIRE(bob5.current_system == star_map::System::Sol);\r\nREQUIRE(bob5.generation == 2);\r\n```\r\n\r\nThe newly found test lines uncover another member function of the `Vessel` class: `replicate`.\r\nThis function receives a string and returns another `Vessel` instance.\r\nYou get an idea about the default value of the third argument of the constructor from the previous task.\r\nYou also see two public member variables of the `Vessel` class and the specification of the `replicate` member function.\r\n\r\nAdd the `replicate` function and the public member variables `current_system` and `generation` to the header and source files.\r\n\r\n## 3. Look into the inner workings\r\n\r\nYou find some more interesting lines in the recovered test files:\r\n\r\n```cpp\r\nheaven::Vessel bob6{\"Homer\", 3, star_map::System::EpsilonEridani};\r\nREQUIRE(bob6.busters == 0);\r\nbob6.make_buster();\r\nREQUIRE(bob6.busters == 1);\r\nbool success = bob6.shoot_buster();\r\nREQUIRE(success);\r\nREQUIRE(bob6.busters == 0);\r\nsuccess = bob6.shoot_buster();\r\nREQUIRE_FALSE(success);\r\n```\r\n\r\nApparently, the `Vessel` class has a member variable `busters`, that can be changed with the two class member functions `make_buster` and `shoot_buster`.\r\nUntil other information surfaces, you take a guess that the `make_buster` function returns `void`.\r\nAs there is a test for the return value of `shoot_buster`, you assume that the function returns a `bool`.\r\n\r\nAdd the two functions and the member variable to the `Vessel` class.\r\nKeep looking for other `System` enumerators.\r\n\r\n## 4. Complete the picture\r\n\r\nDuring your scan of the test files you find only two uncovered sections of the code:\r\n\r\n```cpp\r\nheaven::Vessel bob1{\"Bob\", 1, star_map::System::AlphaCentauri};\r\nheaven::Vessel marv{\"Marvin\", 2, star_map::System::DeltaEridani};\r\nheaven::Vessel milo{\"Milo\", 3, star_map::System::DeltaEridani};\r\nheaven::Vessel howie{\"Howard\", 4, star_map::System::Omicron2Eridani};\r\n\r\nREQUIRE(\"Bob\" == heaven::get_older_bob(bob1, marv));\r\nREQUIRE(heaven::in_the_same_system(marv, milo));\r\nREQUIRE_FALSE(heaven::in_the_same_system(marv, howie));\r\n```\r\n\r\nYou see two functions, that are not members of the `Vessel` class, as they are not called with an instance.\r\n`get_older_bob` compares two `Vessel`instances and returns a `string`.\r\n`in_the_same_system` compares two `Vessel`instances and returns a `bool`.\r\n\r\nImplement the last missing functions from the recovered lines above.\r\n\r\n[van-neumann-probes]: https://en.wikipedia.org/wiki/Self-replicating_spacecraft\r\n",
    "hints": "# Hints\r\n\r\n## General\r\n\r\n- Pay attention to any enumerators you come across.\r\n- The tests can only be run when you have implemented every task.\r\n  To see the test results you only need a rough skeleton of the functions and classes.\r\n- Every function, class, and enumeration that is used by the tests must be declared in the header file.\r\n\r\n## 1. Try to extract some first clues\r\n\r\n- The class and the enum are in different namespaces.\r\n- Use a `class enum` for `System`\r\n- You can either have two constructors, or one constructor with a default argument.\r\n\r\n## 2. Find more details\r\n\r\n- The first `REQUIRE` line checks for the default `System`.\r\n- `generation` seems to increase by one in a cloned vessel.\r\n- The `System` seems to be untouched by the cloning process.\r\n\r\n## 3. Look into the inner workings\r\n\r\n- The `shoot_buster` member function seems to be dependent on an internal counter.\r\n"
  },
  "starter_code": {
    "doctor_data.cpp": "// ERROR: FILE CORRUPTED. Please supply valid C++ Code.\r\n\r\nhp4,ölacöiömthö%Äsmaö%Äsubö(311040ö%Äspaö%Äaddö(311040ö%Ädacöiömthö%Äcountö.hpt,hp4ö%Äxctöhd2ö%Ädacöiöma1\r\nhp2,öjmpö.\r\n",
    "doctor_data.h": "// ERROR: FILE CORRUPTED. Please supply valid C++ Code.\r\n\r\nhp1, üapöhp2ö % Äcountöiöma1,\r\n    öhp2ö % Älawöhp3öö / önextöstepö % Ädacöiöml1ö % Älawö7ö % Ädacöiömb1ö %\r\n        Ärandomöö % Äscrö9sö % Äsirö9sö % Äxctöhr1ö % Äaddöiömx1ö %\r\n        Ädacöiömx1ö % Äswapö % Äaddöiömy1ö % Ädacöiömy1ö % Ärandomö % Äscrö9sö %\r\n        Äsirö9sö % Äxctöhr2ö % Ädacöiömdyö % Ädioöiömdxö % Äsetupö.hpt,\r\n    3ö % Älacöranö % Ädacöiömth\r\n"
  },
  "tests": {
    "doctor_data_test.cpp": "#include \"doctor_data.h\"\r\n#ifdef EXERCISM_TEST_SUITE\r\n#include <catch2/catch.hpp>\r\n#else\r\n#include \"test/catch.hpp\"\r\n#endif\r\n\r\nTEST_CASE(\"Create different probes\", \"[task_1]\") {\r\n    heaven::Vessel bob{\"Robert Johansson\", 1};\r\n    heaven::Vessel will{\"Riker\", 2, star_map::System::BetaHydri};\r\n}\r\n\r\n#if defined(EXERCISM_RUN_ALL_TESTS)\r\n\r\nTEST_CASE(\"Create drone from replication\", \"[task_2]\") {\r\n    heaven::Vessel bob{\"Robert Johansson\", 1};\r\n    heaven::Vessel bob5 = bob.replicate(\"Mario\");\r\n    REQUIRE(bob5.current_system == star_map::System::Sol);\r\n    REQUIRE(bob5.generation == 2);\r\n}\r\n\r\nTEST_CASE(\"Check buster mechanics\", \"[task_3]\") {\r\n    heaven::Vessel bob6{\"Homer\", 3, star_map::System::EpsilonEridani};\r\n    REQUIRE(bob6.busters == 0);\r\n    bob6.make_buster();\r\n    REQUIRE(bob6.busters == 1);\r\n    bool success = bob6.shoot_buster();\r\n    REQUIRE(success);\r\n    REQUIRE(bob6.busters == 0);\r\n    success = bob6.shoot_buster();\r\n    REQUIRE_FALSE(success);\r\n}\r\n\r\nTEST_CASE(\"Check non-class functions\", \"[task_4]\") {\r\n    heaven::Vessel bob1{\"Bob\", 1, star_map::System::AlphaCentauri};\r\n    heaven::Vessel marv{\"Marvin\", 2, star_map::System::DeltaEridani};\r\n    heaven::Vessel milo{\"Milo\", 3, star_map::System::DeltaEridani};\r\n    heaven::Vessel howie{\"Howard\", 4, star_map::System::Omicron2Eridani};\r\n\r\n    REQUIRE(\"Bob\" == heaven::get_older_bob(bob1, marv));\r\n    REQUIRE(heaven::in_the_same_system(marv, milo));\r\n    REQUIRE_FALSE(heaven::in_the_same_system(marv, howie));\r\n}\r\n\r\n#endif\r\n"
  }
}