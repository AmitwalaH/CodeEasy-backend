{
  "language": "go",
  "slug": "range-iteration",
  "title": "Range Iteration",
  "docs": {
    "about": "# About\r\n\r\nYou now have the knowledge on how to iterate a slice, or a map, in Go.\r\n\r\nAs a recap, you learnt how every iteration returns two values:\r\nthe index/key and a copy of the element at that index/key.\r\n\r\n## Iterate over a slice\r\n\r\nEasy as pie, loops over a slice, ordered as expected.\r\n\r\n```go\r\nxi := []int{10, 20, 30}\r\nfor i, x := range xi {\r\n  fmt.Println(i, x)\r\n}\r\n// outputs:\r\n// 0, 10\r\n// 1, 20\r\n// 2, 30\r\n```\r\n\r\n## Iterate over a map\r\n\r\nIterating over a map raises a new problem. The order is now random.\r\n\r\n```go\r\nhash := map[int]int{9: 10, 99: 20, 999: 30}\r\nfor k, v := range hash {\r\n  fmt.Println(k, v)\r\n}\r\n// outputs, for example:\r\n// 99 20\r\n// 999 30\r\n// 9 10\r\n```\r\n\r\n~~~~exercism/note\r\nIt may seem the above output is incorrect, as one would expect the first key/value pair on the declaration of the map `9 10` to be the first one printed and not the last.\r\nHowever, maps are unordered by nature - there isn't a first or last key/value pair.\r\nBecause of that, when iterating over the entries of a map, the order by which entries will be visited will be random and not follow any specific pattern.\r\nThis means the above output is possible but might differ from what you get if you try to run this yourself.\r\nTo learn more about this see [Go Language Spec: range clause](https://go.dev/ref/spec#RangeClause).\r\n~~~~\r\n\r\n## Iteration omitting key or value\r\n\r\nIn Go an unused variable will raise an error at build time.\r\nSometimes you only need the value, as per the first example:\r\n\r\n```go\r\nxi := []int{10, 20, 30}\r\nfor i, x := range xi {\r\n  fmt.Println(x)\r\n}\r\n// Go build failed: i declared but not used\r\n```\r\n\r\nYou can replace the `i` with `_` which tells the compiler we don't use that value:\r\n\r\n```go\r\nxi := []int{10, 20, 30}\r\nfor _, x := range xi {\r\n  fmt.Println(x)\r\n}\r\n// outputs:\r\n// 10\r\n// 20\r\n// 30\r\n```\r\n\r\nIf you want to only print the index, you can replace the `x` with `_`,\r\nor simply omit the declaration:\r\n\r\n\r\n```go\r\nxi := []int{10, 20, 30}\r\n// for i, _ := range xi {\r\nfor i := range xi {\r\n  fmt.Println(i)\r\n}\r\n// outputs:\r\n// 0\r\n// 1\r\n// 2\r\n```\r\n\r\nLast but not least, if you are required to perform some action but you are not\r\ninterested in values nor keys of the slice or map, you can omit both index and\r\nvalue:\r\n\r\n```go\r\nxi := []int{10, 20, 30}\r\ncount := 0\r\nfor range xi {\r\n  count++\r\n}\r\n// count value:\r\n// 3\r\n```\r\n",
    "introduction": "# Introduction\r\n\r\nIn Go, you can iterate over a `slice` using `for` and an index, or you can use `range`.\r\n`range` also allows you to iterate over a `map` or a `channel`.\r\nThis concept will cover iterating over a `map` but iterating over a `channel` is out of the scope for this concept.\r\n\r\nEvery iteration returns two values: the index/key and a copy of the element at that index/key.\r\n\r\n## Iterate over a slice\r\n\r\nEasy as pie, loops over a slice, ordered as expected.\r\n\r\n```go\r\nxi := []int{10, 20, 30}\r\nfor i, x := range xi {\r\n  fmt.Println(i, x)\r\n}\r\n// outputs:\r\n// 0, 10\r\n// 1, 20\r\n// 2, 30\r\n```\r\n\r\n## Iterate over a map\r\n\r\nIterating over a map raises a new problem. The order is now random.\r\n\r\n```go\r\nhash := map[int]int{9: 10, 99: 20, 999: 30}\r\nfor k, v := range hash {\r\n  fmt.Println(k, v)\r\n}\r\n// outputs, for example:\r\n// 99 20\r\n// 999 30\r\n// 9 10\r\n```\r\n\r\n~~~~exercism/note\r\nIt may seem the above output is incorrect, as one would expect the first key/value pair on the declaration of the map `9 10` to be the first one printed and not the last.\r\nHowever, maps are unordered by nature - there isn't a first or last key/value pair.\r\nBecause of that, when iterating over the entries of a map, the order by which entries will be visited will be random and not follow any specific pattern.\r\nThis means the above output is possible but might differ from what you get if you try to run this yourself.\r\nTo learn more about this see [Go Language Spec: range clause](https://go.dev/ref/spec#RangeClause).\r\n~~~~\r\n\r\n## Iteration omitting key or value\r\n\r\nIn Go an unused variable will raise an error at build time.\r\nSometimes you only need the value, as per the first example:\r\n\r\n```go\r\nxi := []int{10, 20, 30}\r\nfor i, x := range xi {\r\n  fmt.Println(x)\r\n}\r\n// Go build failed: i declared but not used\r\n```\r\n\r\nYou can replace the `i` with `_` which tells the compiler we don't use that value:\r\n\r\n```go\r\nxi := []int{10, 20, 30}\r\nfor _, x := range xi {\r\n  fmt.Println(x)\r\n}\r\n// outputs:\r\n// 10\r\n// 20\r\n// 30\r\n```\r\n\r\nIf you want to only print the index, you can replace the `x` with `_`,\r\nor simply omit the declaration:\r\n\r\n\r\n```go\r\nxi := []int{10, 20, 30}\r\n// for i, _ := range xi {\r\nfor i := range xi {\r\n  fmt.Println(i)\r\n}\r\n// outputs:\r\n// 0\r\n// 1\r\n// 2\r\n```\r\n\r\nLast but not least, if you are required to perform some action but you are not\r\ninterested in values nor keys of the slice or map, you can omit both index and\r\nvalue:\r\n\r\n```go\r\nxi := []int{10, 20, 30}\r\ncount := 0\r\nfor range xi {\r\n  count++\r\n}\r\n// count value:\r\n// 3\r\n```\r\n"
  },
  "meta": {
    "blurb": "Go has a special \"for range\" loop to easily iterate over collections of data.",
    "authors": [
      "brugnara",
      "tehsphinx"
    ],
    "contributors": []
  },
  "links": [
    {
      "url": "https://tour.golang.org/moretypes/16",
      "description": "A Tour of Go: Range"
    },
    {
      "url": "https://gobyexample.com/range",
      "description": "Go by Example: Range"
    },
    {
      "url": "https://golang.org/ref/spec#For_range",
      "description": "Go Language Spec: For statements with range clause"
    }
  ]
}