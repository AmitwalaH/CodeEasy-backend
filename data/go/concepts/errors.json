{
  "language": "go",
  "slug": "errors",
  "title": "Errors",
  "docs": {
    "about": "# About\r\n\r\n## The error interface\r\n\r\nError handling is **not** done via exceptions in Go.\r\nInstead, errors are normal _values_ of types that implement the built-in `error` interface.\r\nThe `error` interface is very minimal.\r\nIt contains only one method `Error()` that returns the error message as a string.\r\n\r\n```go\r\ntype error interface {\r\n  Error() string\r\n}\r\n```\r\n\r\nEvery time you define a function in which an error could happen during the execution that needs to reach the caller, you need to include `error` as one of the return types.\r\nIf the function has multiple return values, by convention `error` is always the last one.\r\n\r\n```go\r\nfunc DoSomething() (int, error) {\r\n  // ...\r\n}\r\n```\r\n\r\n## Creating and returning a simple error\r\n\r\nYou do not have to always implement the error interface yourself.\r\nTo create a simple error, you can use the `errors.New()` function that is part of the standard library package `errors`.\r\nThe only thing you need to pass in is the error message as a string, and `errors.New()` will take care of creating a value that contains your message and implements the `error` interface.\r\n\r\nIf the function returns an error, it is good practice to return the zero value for all other return parameters:\r\n\r\n```go\r\nfunc DoSomething() (SomeStruct, int, error) {\r\n  // ...\r\n  return SomeStruct{}, 0, errors.New(\"failed to calculate result\")\r\n}\r\n```\r\n\r\n~~~~exercism/caution\r\nYou should not assume that all functions return zero values for other return values if an error is present.\r\nIt is best practice to assume that it is not safe to use any of the other return values if an error is returned.\r\n\r\nAs an example, imagine a function was trying to read from a file and returns a half-filled byte slice and an error.\r\nIf you would re-use that returned byte slice in your code, assuming it is always empty because there was error, you can run into subtle bugs.\r\n\r\nThe only exceptions are cases where the function documentation clearly states that other returns values are meaningful in case of an error.\r\nLook at the [documentation for `Write` on a buffer][buffer-write] for an example.\r\n~~~~\r\n\r\nMake sure the error message you provide is as specific as possible as errors do not include any stack traces by default.\r\nBy convention, the error message should start with a lowercase letter and not end with a period.\r\n\r\nIf you want to use such an error in multiple places (or you want to make the error available to the consumer of your package), you should declare a variable for the error instead of using `errors.New` in-line.\r\nBy convention, the name of the variable should start with `Err` or `err` (depending on whether it is exported or not). These error variables are often called _sentinel errors_.\r\n\r\n```go\r\nimport \"errors\"\r\n\r\nvar ErrNotFound = errors.New(\"resource was not found\")\r\n\r\nfunc DoSomething() error {\r\n  // ...\r\n  return ErrNotFound\r\n}\r\n```\r\n\r\nReturn `nil` for the error to signal that there were no errors during the function execution:\r\n\r\n```go\r\nfunc Foo() (int, error) {\r\n  return 10, nil\r\n}\r\n```\r\n\r\n## Including variables in the error message\r\n\r\nIf you need to construct a more complex error message from some variables, you can make use of string formatting.\r\nGo has a special `fmt.Errorf` function for this purpose.\r\nIt constructs the error message string and returns an error.\r\n\r\n```go\r\ninput := 123\r\naction := \"UPDATE\"\r\n\r\nerr := fmt.Errorf(\"invalid input %d for action %s\", input, action)\r\nerr.Error()\r\n// => \"invalid input 123 for action UPDATE\"\r\n```\r\n\r\n## Error checking\r\n\r\nIf you call a function that returns an error, it is common to store the error value in a variable called `err`.\r\nBefore you use the actual result of the function, you need to check that there was no error.\r\nWe can use `==` and `!=` to compare the error against `nil` and we know there was an error when `err` is not `nil`.\r\n\r\nTo avoid nesting the \"happy path\" of your code, error cases should be handled first, usually via an early return.\r\nSee this famous [article by Mat Ryer][line-of-sight] for more details.\r\n\r\n```go\r\n// Do this:\r\nfunc myFunc() error {\r\n  file, err := os.Open(\"./users.csv\")\r\n  if err != nil {\r\n    return err\r\n  }\r\n  // do something with file\r\n}\r\n\r\n// Not this:\r\nfunc myFunc() error {\r\n  file, err := os.Open(\"./users.csv\")\r\n  if err != nil {\r\n    // handle err\r\n  } else {\r\n    // do something with file\r\n  }\r\n}\r\n\r\n// Also not this:\r\nfunc myFunc() error {\r\n  file, err := os.Open(\"./users.csv\")\r\n  if err == nil {\r\n    // do something with file\r\n  }\r\n  // handle err\r\n}\r\n```\r\n\r\nMost of the time, the error will be returned up the function stack as shown in first example above.\r\nAnother way of handling the error could be to log it and continue with some other operation.\r\nIt is good practice to either return or log the error, never both.\r\n\r\nSince most functions in Go include an error as one of the return values, you will see/use the `if err != nil` pattern all over the place in Go code.\r\n\r\n## Custom error types\r\n\r\nIf you want your error to include more information than just the error message string, you can create a custom error type.\r\nAs mentioned before, everything that implements the `error` interface (i.e. has an `Error() string` method) can serve as an error in Go.\r\n\r\nUsually, a struct is used to create a custom error type.\r\nBy convention, custom error type names should end with `Error`.\r\nAlso, it is best to set up the `Error() string` method with a pointer receiver, see this [Stackoverflow comment][stackoverflow-errors] to learn about the reasoning.\r\nNote that this means you need to return a pointer to your custom error otherwise it will not count as `error` because the non-pointer value does not provide the `Error() string` method.\r\n\r\n```go\r\ntype MyCustomError struct {\r\n  message string\r\n  details string\r\n}\r\n\r\nfunc (e *MyCustomError) Error() string {\r\n  return fmt.Sprintf(\"%s, details: %s\", e.message, e.details)\r\n}\r\n\r\nfunc someFunction() error {\r\n  // ...\r\n  return &MyCustomError{\r\n    message: \"...\",\r\n    details: \"...\",\r\n  }\r\n}\r\n```\r\n\r\n[stackoverflow-errors]: https://stackoverflow.com/a/50333850\r\n[line-of-sight]: https://medium.com/@matryer/line-of-sight-in-code-186dd7cdea88\r\n[buffer-write]: https://pkg.go.dev/bytes#Buffer.Write\r\n\r\n",
    "introduction": "# Introduction\r\n\r\n## The error interface\r\n\r\nError handling is **not** done via exceptions in Go.\r\nInstead, errors are normal _values_ of types that implement the built-in `error` interface.\r\nThe `error` interface is very minimal.\r\nIt contains only one method `Error()` that returns the error message as a string.\r\n\r\n```go\r\ntype error interface {\r\n  Error() string\r\n}\r\n```\r\n\r\nEvery time you define a function in which an error could happen during the execution that needs to reach the caller, you need to include `error` as one of the return types.\r\nIf the function has multiple return values, by convention `error` is always the last one.\r\n\r\n```go\r\nfunc DoSomething() (int, error) {\r\n  // ...\r\n}\r\n```\r\n\r\n## Creating and returning a simple error\r\n\r\nYou do not have to always implement the error interface yourself.\r\nTo create a simple error, you can use the `errors.New()` function that is part of the standard library package `errors`.\r\nThe only thing you need to pass in is the error message as a string, and `errors.New()` will take care of creating a value that contains your message and implements the `error` interface.\r\n\r\nIf the function returns an error, it is good practice to return the zero value for all other return parameters:\r\n\r\n```go\r\nfunc DoSomething() (SomeStruct, int, error) {\r\n  // ...\r\n  return SomeStruct{}, 0, errors.New(\"failed to calculate result\")\r\n}\r\n```\r\n\r\n~~~~exercism/caution\r\nYou should not assume that all functions return zero values for other return values if an error is present.\r\nIt is best practice to assume that it is not safe to use any of the other return values if an error occurred.\r\nThe only exceptions are cases where the documentation clearly states that other returns values are meaningful in case of an error.\r\n~~~~\r\n\r\nIf you want to use such a simple error in multiple places, you should declare a variable for the error instead of using `errors.New` in-line.\r\nBy convention, the name of the variable should start with `Err` or `err` (depending on whether it is exported or not).\r\nThese error variables are often called _sentinel errors_.\r\n\r\n```go\r\nimport \"errors\"\r\n\r\nvar ErrNotFound = errors.New(\"resource was not found\")\r\n\r\nfunc DoSomething() error {\r\n  // ...\r\n  return ErrNotFound\r\n}\r\n```\r\n\r\nReturn `nil` for the error to signal that there were no errors during the function execution:\r\n\r\n```go\r\nfunc Foo() (int, error) {\r\n  return 10, nil\r\n}\r\n```\r\n\r\n## Error checking\r\n\r\nIf you call a function that returns an error, it is common to store the error value in a variable called `err`.\r\nBefore you use the actual result of the function, you need to check that there was no error.\r\n\r\nTo avoid nesting the \"happy path\" of your code, error cases should be handled first.\r\nWe can use `==` and `!=` to compare the error against `nil` and we know there was an error when `err` is not `nil`.\r\n\r\n```go\r\nfunc processUserFile() error {\r\n\tfile, err := os.Open(\"./users.csv\")\r\n\tif err != nil {\r\n\t\treturn err\r\n\t}\r\n\r\n\t// do something with file\r\n}\r\n```\r\n\r\nMost of the time, the error will be returned up the function stack as shown in the example above.\r\nAnother way of handling the error could be to log it and continue with some other operation.\r\nIt is good practice to either return or log the error, never both.\r\n\r\nSince most functions in Go include an error as one of the return values, you will see/use the `if err != nil` pattern all over the place in Go code.\r\n\r\n## Custom error types\r\n\r\nIf you want your error to include more information than just the error message string, you can create a custom error type.\r\nAs mentioned before, everything that implements the `error` interface (i.e. has an `Error() string` method) can serve as an error in Go.\r\n\r\nUsually, a struct is used to create a custom error type.\r\nBy convention, custom error type names should end with `Error`.\r\nAlso, it is best to set up the `Error() string` method with a pointer receiver, see this [Stackoverflow comment][stackoverflow-errors] to learn about the reasoning.\r\nNote that this means you need to return a pointer to your custom error otherwise it will not count as `error` because the non-pointer value does not provide the `Error() string` method.\r\n\r\n```go\r\ntype MyCustomError struct {\r\n  message string\r\n  details string\r\n}\r\n\r\nfunc (e *MyCustomError) Error() string {\r\n  return fmt.Sprintf(\"%s, details: %s\", e.message, e.details)\r\n}\r\n\r\nfunc someFunction() error {\r\n  // ...\r\n  return &MyCustomError{\r\n    message: \"...\",\r\n    details: \"...\",\r\n  }\r\n}\r\n```\r\n\r\n[stackoverflow-errors]: https://stackoverflow.com/a/50333850\r\n"
  },
  "meta": {
    "blurb": "Error handling is NOT done via exceptions in Go. Instead, errors are normal values that are returned as the last return value of a function.",
    "authors": [
      "micuffaro",
      "brugnara",
      "junedev"
    ],
    "contributors": [
      "jmrunkle"
    ]
  },
  "links": [
    {
      "url": "https://go.dev/blog/error-handling-and-go",
      "description": "Go Blog: Error Handling and Go"
    },
    {
      "url": "https://github.com/golang/go/wiki/Errors",
      "description": "Go Wiki: Errors"
    },
    {
      "url": "https://dave.cheney.net/2016/04/27/dont-just-check-errors-handle-them-gracefully",
      "description": "Dave Cheney on error handling"
    }
  ]
}