{
  "language": "go",
  "slug": "interfaces",
  "title": "Interfaces",
  "docs": {
    "about": "# About\r\n\r\n## Interface as a set of methods\r\n\r\nIn its simplest form, an **interface type** is a set of method signatures.\r\nHere is an example of an interface definition that includes two methods `Add` and `Value`:\r\n\r\n```go\r\ntype Counter interface {\r\n    Add(increment int)\r\n    Value() int\r\n}\r\n```\r\n\r\nThe parameter names like `increment` can be omitted from the interface definition but they often increase readability.\r\n\r\nInterface names in Go do not contain the word `Interface` or `I`.\r\nInstead, they often end with `er`, e.g. `Reader`, `Stringer`.\r\n\r\n## Implementing an interface\r\n\r\nAny type that defines the methods of the interface automatically implicitly \"implements\" the interface.\r\nThere is no `implements` keyword in Go.\r\n\r\nThe following type implements the `Counter` interface we saw above.\r\n\r\n```go\r\ntype Stats struct {\r\n    value int\r\n    // ...\r\n}\r\n\r\nfunc (s Stats) Add(v int) {\r\n    s.value += v\r\n}\r\n\r\nfunc (s Stats) Value() int {\r\n    return s.value\r\n}\r\n\r\nfunc (s Stats) SomeOtherMethod() {\r\n    // The type can have additional methods not mentioned in the interface.\r\n}\r\n```\r\n\r\nFor implementing the interface, it does not matter whether the method has a value or pointer receiver.\r\n(Revisit the [methods concepts][concept-methods] if you are unsure about those.)\r\n\r\n> A value of interface type can hold any value that implements those methods. [^1]\r\n\r\nThat means `Stats` can now be used in all the places that expect the `Counter` interface.\r\n\r\n```go\r\nfunc SetUpAnalytics(counter Counter) {\r\n    // ...\r\n}\r\n\r\nstats := Stats{}\r\nSetUpAnalytics(stats)\r\n// works because Stats implements Counter\r\n```\r\n\r\nIf all function parameters and return values needed to use concrete (ie. non-interface) types, that would strongly limit their re-usability.\r\nBy using interface types for the parameters, only the behavior that is needed for the function to do its job is defined.\r\nNow the function can be used with parameters of different concrete types, as long as those concrete types implement the interface.\r\nThe same logic applies when using interface types as return values.\r\n\r\nBecause interfaces are implemented implicitly, a type can easily implement multiple interfaces.\r\nIt only needs to have all the necessary methods defined.\r\n\r\n## Combining interfaces\r\n\r\nInterface definitions can include other interfaces.\r\nHere is an example from the standard library.\r\n\r\n```go\r\ntype ReadCloser interface {\r\n\tReader\r\n\tCloser\r\n}\r\n\r\n// Based on these interfaces:\r\n\r\ntype Reader interface {\r\n\tRead(p []byte) (n int, err error)\r\n}\r\n\r\ntype Closer interface {\r\n\tClose() error\r\n}\r\n```\r\n\r\nInstead of repeating the method signatures for `Read` and `Close`, to define `ReadCloser`, the interface definition makes use of the existing definitions for `Reader` and `Closer`.\r\n\r\n## Empty interface\r\n\r\nThere is one very special interface type in Go, the **empty interface** type that contains zero methods.\r\nThe empty interface is written like this: `interface{}`.\r\nIn Go 1.18 or higher, `any` can be used as well. It was defined as an alias.\r\n\r\nSince the empty interface has no methods, every type implements it implicitly.\r\nThis is helpful for defining a function that can generically accept any value.\r\nIn that case, the function parameter uses the empty interface type.\r\n\r\nFor example:\r\n\r\n```go\r\nfunc AnythingGoes(i interface{}) string {\r\n    if i == 0 {\r\n        return \"zero\"\r\n    }\r\n    if i == \"\" {\r\n        return \"empty string\"\r\n    }\r\n    return \"something else\"\r\n}\r\n```\r\n\r\n[^1]: [Tour of Go: Interfaces][tour-of-go-interfaces]\r\n\r\n[concept-methods]: /tracks/go/concepts/methods\r\n[tour-of-go-interfaces]: https://go.dev/tour/methods/9\r\n",
    "introduction": "# Introduction\r\n\r\n## Interface as a set of methods\r\n\r\nIn its simplest form, an **interface type** is a set of method signatures.\r\nHere is an example of an interface definition that includes two methods `Add` and `Value`:\r\n\r\n```go\r\ntype Counter interface {\r\n    Add(increment int)\r\n    Value() int\r\n}\r\n```\r\n\r\nThe parameter names like `increment` can be omitted from the interface definition but they often increase readability.\r\n\r\nInterface names in Go do not contain the word `Interface` or `I`.\r\nInstead, they often end with `er`, e.g. `Reader`, `Stringer`.\r\n\r\n## Implementing an interface\r\n\r\nAny type that defines the methods of the interface automatically implicitly \"implements\" the interface.\r\nThere is no `implements` keyword in Go.\r\n\r\nThe following type implements the `Counter` interface we saw above.\r\n\r\n```go\r\ntype Stats struct {\r\n    value int\r\n    // ...\r\n}\r\n\r\nfunc (s Stats) Add(v int) {\r\n    s.value += v\r\n}\r\n\r\nfunc (s Stats) Value() int {\r\n    return s.value\r\n}\r\n\r\nfunc (s Stats) SomeOtherMethod() {\r\n    // The type can have additional methods not mentioned in the interface.\r\n}\r\n```\r\n\r\nFor implementing the interface, it does not matter whether the method has a value or pointer receiver.\r\n(Revisit the [methods concepts][concept-methods] if you are unsure about those.)\r\n\r\n> A value of interface type can hold any value that implements those methods. [^1]\r\n\r\nThat means `Stats` can now be used in all the places that expect the `Counter` interface.\r\n\r\n```go\r\nfunc SetUpAnalytics(counter Counter) {\r\n    // ...\r\n}\r\n\r\nstats := Stats{}\r\nSetUpAnalytics(stats)\r\n// works because Stats implements Counter\r\n```\r\n\r\nBecause interfaces are implemented implicitly, a type can easily implement multiple interfaces.\r\nIt only needs to have all the necessary methods defined.\r\n\r\n## Empty interface\r\n\r\nThere is one very special interface type in Go, the **empty interface** type that contains zero methods.\r\nThe empty interface is written like this: `interface{}`.\r\nIn Go 1.18 or higher, `any` can be used as well. It was defined as an alias.\r\n\r\nSince the empty interface has no methods, every type implements it implicitly.\r\nThis is helpful for defining a function that can generically accept any value.\r\nIn that case, the function parameter uses the empty interface type.\r\n\r\n[^1]: https://go.dev/tour/methods/9\r\n\r\n[concept-methods]: /tracks/go/concepts/methods\r\n"
  },
  "meta": {
    "blurb": "Interfaces define method sets and are implemented implicitily by all types that have those methods.",
    "authors": [
      "jmrunkle",
      "junedev"
    ],
    "contributors": []
  },
  "links": [
    {
      "url": "https://tour.golang.org/methods/9",
      "description": "A Tour of Go: Interfaces"
    },
    {
      "url": "https://golangbot.com/interfaces-part-1",
      "description": "Golangbot: A Practical Guide to Interfaces"
    },
    {
      "url": "https://gobyexample.com/interfaces",
      "description": "Go by Example: Interfaces"
    },
    {
      "url": "https://golang.org/doc/effective_go#interfaces",
      "description": "Effective Go: Interfaces"
    }
  ]
}