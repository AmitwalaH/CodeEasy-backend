{
  "language": "go",
  "slug": "regular-expressions",
  "title": "Regular Expressions",
  "docs": {
    "about": "# About \r\n\r\nPackage [regexp][package-regexp] offers support for regular expressions in Go.\r\n\r\n## Syntax \r\n\r\nThe [syntax][regexp-syntax] of the regular expressions accepted is the same general syntax used by Perl, Python, and other languages. \r\n\r\nBoth the search patterns and the input texts are interpreted as UTF-8.  \r\n\r\nWhen using backticks (\\`) to make strings, backslashes (`\\`)  don't have any special meaning and don't mark the beginning of special characters like tabs `\\t` or newlines `\\n`:\r\n\r\n```go\r\n\"\\t\\n\" // regular string literal with 2 characters: a tab and a newline\r\n`\\t\\n`// raw string literal with 4 characters: two backslashes, a 't', and an 'n'\r\n```\r\n\r\nBecause of this, using backticks is desirable to make regular expressions,\r\nbecause it means we don't need to escape backslashes:\r\n\r\n```go\r\n\"\\\\\" // string with a single backslash\r\n`\\\\` // string with 2 backslashes\r\n```\r\n\r\n## Compiling patterns - `RegExp` type\r\n\r\nTo use a regular expression, we first must compile the string pattern.\r\nCompilation here means taking the string pattern of the regular expression and converting it into an internal representation that is easier to work with.\r\nWe only need to compile each pattern once, after that we can use the compiled version of the regular expression many times.\r\nThe type `regexp.Regexp` represents a compiled regular expressions.\r\nWe can compile a string pattern into a `regexp.Regexp` using the function  `regexp.Compile`.\r\nThis function returns `nil` and an error if compilation failed:\r\n\r\n```go\r\nre, err := regexp.Compile(`(a|b)+`)\r\nfmt.Println(re, err) // => (a|b)+ <nil>\r\nre, err = regexp.Compile(`a|b)+`)\r\nfmt.Println(re, err) // => <nil> error parsing regexp: unexpected ): `a|b)+`\r\n```\r\n\r\nFunction `MustCompile` is a convenient alternative to `Compile`: \r\n\r\n```go \r\nre = regexp.MustCompile(`[a-z]+\\d*`)\r\n```\r\n\r\nUsing this function, there is no need to handle an error. \r\n\r\n~~~~exercism/caution\r\n `MustCompile` should only be used when we know for sure the pattern does compile, as otherwise the program will panic.\r\n ~~~~\r\n \r\n ## Regular expression methods\r\n \r\nThere are 16 methods of `Regexp` that match a regular expression and identify the matched text.\r\nTheir names are matched by this regular expression:\r\n\r\n```text\r\nFind(All)?(String)?(Submatch)?(Index)?\r\n```\r\n\r\n* If `All` is present, the routine matches successive non-overlapping matches of the entire expressions.\r\n* If `String` is present, the argument is a string; otherwise it is a slice of bytes; return values are adjusted as appropriate. \r\n* If `Submatch` is present, the return value is a slice identifying the successive submatches of the expression.\r\n* If `Index` is present, matches and submatches are identified by byte index pairs within the input string.\r\n\r\nThere are also methods for:\r\n\r\n* replacing matches of regular expressions with replacement strings and\r\n* splitting of strings separated by regular expressions.\r\n\r\nAll-in-all, the `regexp` package defines more than 40 functions and methods.\r\nWe will demonstrate the use of a few methods below.\r\nPlease see the [API documentation][package-regexp] for details of these and other functions.\r\n \r\n### `MatchString` Examples \r\n\r\nMethod `MatchString` reports whether a string contains any match of a regular expression.\r\n\r\n```go\r\nre = regexp.MustCompile(`[a-z]+\\d*`)\r\nb = re.MatchString(\"[a12]\")       // => true\r\nb = re.MatchString(\"12abc34(ef)\") // => true\r\nb = re.MatchString(\" abc!\")       // => true\r\nb = re.MatchString(\"123 456\")     // => false    \r\n```\r\n\r\n### `FindString` Examples \r\n\r\nMethod `FindString` returns a string holding the text of the leftmost match of the regular expression.\r\n\r\n```go\r\nre = regexp.MustCompile(`[a-z]+\\d*`)\r\ns = re.FindString(\"[a12]\")       // => \"a12\"\r\ns = re.FindString(\"12abc34(ef)\") // => \"abc34\"\r\ns = re.FindString(\" abc!\")       // => \"abc\"\r\ns = re.FindString(\"123 456\")     // => \"\"\r\n```\r\n\r\n### `FindStringSubmatch` Examples\r\n\r\nMethod `FindStringSubmatch` returns a slice of strings holding the text of the leftmost match of the regular expression and the matches, if any, of its subexpressions.\r\nThis can be used to identify the strings matching capturing groups.\r\nA return value of `nil` indicates no match.\r\n\r\n```go \r\nre = regexp.MustCompile(`[a-z]+(\\d*)`)\r\nsl = re.FindStringSubmatch(\"[a12]\")       // => []string{\"a12\",\"12\"}\r\nsl = re.FindStringSubmatch(\"12abc34(ef)\") // => []string{\"abc34\",\"34\"}\r\nsl = re.FindStringSubmatch(\" abc!\")       // => []string{\"abc\",\"\"}\r\nsl = re.FindStringSubmatch(\"123 456\")     // => <nil>\r\n```\r\n\r\n### `ReplaceAllString` Examples\r\n\r\nMethod `re.ReplaceAllString(src,repl)` returns a copy of `src`, replacing matches of the regular expression `re` with the replacement string `repl`.\r\n\r\n```go\r\nre = regexp.MustCompile(`[a-z]+\\d*`)\r\ns = re.ReplaceAllString(\"[a12]\", \"X\")       // => \"[X]\"\r\ns = re.ReplaceAllString(\"12abc34(ef)\", \"X\") // => \"12X(X)\"\r\ns = re.ReplaceAllString(\" abc!\", \"X\")       // => \" X!\"\r\ns = re.ReplaceAllString(\"123 456\", \"X\")     // => \"123 456\"\r\n```\r\n \r\n ### `Split` Examples\r\n \r\nMethod `re.Split(s,n)` slices a text `s` into substrings separated by the expression and returns a slice of the substrings between those expression matches.\r\nThe count `n` determines the maximal number of substrings to return.\r\nIf `n<0`, the method returns all substrings.\r\n\r\n```go\r\nre = regexp.MustCompile(`[a-z]+\\d*`)\r\nsl = re.Split(\"[a12]\", -1)      // => []string{\"[\",\"]\"}\r\nsl = re.Split(\"12abc34(ef)\", 2) // => []string{\"12\",\"(ef)\"}\r\nsl = re.Split(\" abc!\", -1)      // => []string{\" \",\"!\"}\r\nsl = re.Split(\"123 456\", -1)    // => []string{\"123 456\"}\r\n```\r\n\r\n## Performance\r\n\r\nThe regexp implementation provided by this package is guaranteed to run in \r\n[time linear in the size of the input][re2-performance].  \r\n\r\n## Caveat\r\n \r\nPackage `regexp` implements [RE2 regular expressions][re2-syntax] (except for `\\C`). \r\nThe syntax is largely compatible with PCRE (\"Perl Compatible Regular Expression\"), but there are some differences.\r\nPlease see the \"Caveat section\" in [this article][reg-exp-wild] for details.\r\n   \r\n[package-regexp]:https://pkg.go.dev/regexp\r\n[regexp-syntax]:https://pkg.go.dev/regexp/syntax\r\n[re2-syntax]: https://golang.org/s/re2syntax\r\n[reg-exp-wild]: https://swtch.com/~rsc/regexp/regexp3.html\r\n[re2-performance]: https://swtch.com/~rsc/regexp/regexp1.html\r\n",
    "introduction": "# Introduction\r\n\r\nPackage [regexp][package-regexp] offers support for regular expressions in Go.\r\n\r\n## Syntax \r\n\r\nThe [syntax][regexp-syntax] of the regular expressions accepted is the same general syntax used by Perl, Python, and other languages. \r\n\r\nBoth the search patterns and the input texts are interpreted as UTF-8.  \r\n\r\nWhen using backticks (\\`) to make strings, backslashes (`\\`)  don't have any special meaning and don't mark the beginning of special characters like tabs `\\t` or newlines `\\n`:\r\n\r\n```go\r\n\"\\t\\n\" // regular string literal with 2 characters: a tab and a newline\r\n`\\t\\n`// raw string literal with 4 characters: two backslashes, a 't', and an 'n'\r\n```\r\n\r\nBecause of this, using backticks is desirable to make regular expressions,\r\nbecause it means we don't need to escape backslashes:\r\n\r\n```go\r\n\"\\\\\" // string with a single backslash\r\n`\\\\` // string with 2 backslashes\r\n```\r\n\r\n## Compiling patterns - `RegExp` type\r\n\r\nTo use a regular expression, we first must compile the string pattern.\r\nCompilation here means taking the string pattern of the regular expression and converting it into an internal representation that is easier to work with.\r\nWe only need to compile each pattern once, after that we can use the compiled version of the regular expression many times.\r\nThe type `regexp.Regexp` represents a compiled regular expression.\r\nWe can compile a string pattern into a `regexp.Regexp` using the function  `regexp.Compile`.\r\nThis function returns `nil` and an error if compilation failed:\r\n\r\n```go\r\nre, err := regexp.Compile(`(a|b)+`)\r\nfmt.Println(re, err) // => (a|b)+ <nil>\r\nre, err = regexp.Compile(`a|b)+`)\r\nfmt.Println(re, err) // => <nil> error parsing regexp: unexpected ): `a|b)+`\r\n```\r\n\r\nFunction `MustCompile` is a convenient alternative to `Compile`: \r\n\r\n```go \r\nre = regexp.MustCompile(`[a-z]+\\d*`)\r\n```\r\n\r\nUsing this function, there is no need to handle an error. \r\n\r\n~~~~exercism/caution\r\n `MustCompile` should only be used when we know for sure the pattern does compile, as otherwise the program will panic.\r\n ~~~~\r\n \r\n ## Regular expression methods\r\n \r\nThere are 16 methods of `Regexp` that match a regular expression and identify the matched text.\r\nTheir names are matched by this regular expression:\r\n\r\n```text\r\nFind(All)?(String)?(Submatch)?(Index)?\r\n```\r\n\r\n* If `All` is present, the routine matches successive non-overlapping matches of the entire expression.\r\n* If `String` is present, the argument is a string; otherwise it is a slice of bytes; return values are adjusted as appropriate. \r\n* If `Submatch` is present, the return value is a slice identifying the successive submatches of the expression.\r\n* If `Index` is present, matches and submatches are identified by byte index pairs within the input string.\r\n\r\nThere are also methods for:\r\n\r\n* replacing matches of regular expressions with replacement strings and\r\n* splitting of strings separated by regular expressions.\r\n\r\nAll-in-all, the `regexp` package defines more than 40 functions and methods.\r\nWe will demonstrate the use of a few methods below.\r\nPlease see the [API documentation][package-regexp] for details of these and other functions.\r\n \r\n### `MatchString` Examples \r\n\r\nMethod `MatchString` reports whether a string contains any match of a regular expression.\r\n\r\n```go\r\nre = regexp.MustCompile(`[a-z]+\\d*`)\r\nb = re.MatchString(\"[a12]\")       // => true\r\nb = re.MatchString(\"12abc34(ef)\") // => true\r\nb = re.MatchString(\" abc!\")       // => true\r\nb = re.MatchString(\"123 456\")     // => false    \r\n```\r\n\r\n### `FindString` Examples \r\n\r\nMethod `FindString` returns a string holding the text of the leftmost match of the regular expression.\r\n\r\n```go\r\nre = regexp.MustCompile(`[a-z]+\\d*`)\r\ns = re.FindString(\"[a12]\")       // => \"a12\"\r\ns = re.FindString(\"12abc34(ef)\") // => \"abc34\"\r\ns = re.FindString(\" abc!\")       // => \"abc\"\r\ns = re.FindString(\"123 456\")     // => \"\"\r\n```\r\n\r\n### `FindStringSubmatch` Examples\r\n\r\nMethod `FindStringSubmatch` returns a slice of strings holding the text of the leftmost match of the regular expression and the matches, if any, of its subexpressions.\r\nThis can be used to identify the strings matching capturing groups.\r\nA return value of `nil` indicates no match.\r\n\r\n```go \r\nre = regexp.MustCompile(`[a-z]+(\\d*)`)\r\nsl = re.FindStringSubmatch(\"[a12]\")       // => []string{\"a12\",\"12\"}\r\nsl = re.FindStringSubmatch(\"12abc34(ef)\") // => []string{\"abc34\",\"34\"}\r\nsl = re.FindStringSubmatch(\" abc!\")       // => []string{\"abc\",\"\"}\r\nsl = re.FindStringSubmatch(\"123 456\")     // => <nil>\r\n```\r\n\r\n### `ReplaceAllString` Examples\r\n\r\nMethod `re.ReplaceAllString(src,repl)` returns a copy of `src`, replacing matches of the regular expression `re` with the replacement string `repl`.\r\n\r\n```go\r\nre = regexp.MustCompile(`[a-z]+\\d*`)\r\ns = re.ReplaceAllString(\"[a12]\", \"X\")       // => \"[X]\"\r\ns = re.ReplaceAllString(\"12abc34(ef)\", \"X\") // => \"12X(X)\"\r\ns = re.ReplaceAllString(\" abc!\", \"X\")       // => \" X!\"\r\ns = re.ReplaceAllString(\"123 456\", \"X\")     // => \"123 456\"\r\n```\r\n \r\n ### `Split` Examples\r\n \r\nMethod `re.Split(s,n)` slices a text `s` into substrings separated by the expression and returns a slice of the substrings between those expression matches.\r\nThe count `n` determines the maximal number of substrings to return.\r\nIf `n<0`, the method returns all substrings.\r\n\r\n```go\r\nre = regexp.MustCompile(`[a-z]+\\d*`)\r\nsl = re.Split(\"[a12]\", -1)      // => []string{\"[\",\"]\"}\r\nsl = re.Split(\"12abc34(ef)\", 2) // => []string{\"12\",\"(ef)\"}\r\nsl = re.Split(\" abc!\", -1)      // => []string{\" \",\"!\"}\r\nsl = re.Split(\"123 456\", -1)    // => []string{\"123 456\"}\r\n```\r\n  \r\n[package-regexp]: https://pkg.go.dev/regexp\r\n[regexp-syntax]: https://pkg.go.dev/regexp/syntax\r\n"
  },
  "meta": {
    "blurb": "A regular expression is a sequence of characters that specify a search pattern.",
    "authors": [
      "norbs57"
    ],
    "contributors": []
  },
  "links": [
    {
      "url": "https://pkg.go.dev/regexp",
      "description": "Go standard library: package regexp"
    },
    {
      "url": "https://pkg.go.dev/regexp/syntax",
      "description": "Go standard library: package regexp/syntax"
    },
    {
      "url": "https://regex101.com/",
      "description": "regex101.com: online regular expression tester"
    },
    {
      "url": "https://en.wikipedia.org/wiki/Regular_expression",
      "description": "Wikipedia: regular expressions"
    },
    {
      "url": "https://gobyexample.com/regular-expressions",
      "description": "Go by example: regular expressions"
    },
    {
      "url": "https://yourbasic.org/golang/regexp-cheat-sheet",
      "description": "Youbasic.org: Regexp tutorial and cheat sheet"
    }
  ]
}