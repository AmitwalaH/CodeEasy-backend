{
  "language": "go",
  "slug": "slices",
  "title": "Slices",
  "docs": {
    "about": "# About\r\n\r\nSlices in Go are similar to lists or arrays in other languages.\r\nThey hold several elements of a specific type (or interface).\r\n\r\nSlices in Go are based on arrays.\r\nArrays have a fixed size.\r\nA slice, on the other hand, is a dynamically-sized, flexible view of the elements of an array.\r\n\r\nA slice is written like `[]T` with `T` being the type of the elements in the slice:\r\n\r\n```go\r\nvar empty []int                 // an empty slice\r\nwithData := []int{0,1,2,3,4,5}  // a slice pre-filled with some data\r\n```\r\n\r\nYou can get or set an element at a given zero-based index using the square-bracket notation:\r\n\r\n```go\r\nwithData[1] = 5\r\nx := withData[1] // x is now 5\r\n```\r\n\r\nYou can create a new slice from an existing slice by getting a range of elements.\r\nOnce again using square-bracket notation, but specifying both a starting (inclusive) and ending (exclusive) index.\r\nIf you don't specify a starting index, it defaults to 0.\r\nIf you don't specify an ending index, it defaults to the length of the slice.\r\n\r\n```go\r\nnewSlice := withData[2:4]\r\n// => []int{2,3}\r\nnewSlice := withData[:2]\r\n// => []int{0,1}\r\nnewSlice := withData[2:]\r\n// => []int{2,3,4,5}\r\nnewSlice := withData[:]\r\n// => []int{0,1,2,3,4,5}\r\n```\r\n\r\nYou can add elements to a slice using the `append` function.\r\nBelow we append `4` and `2` to the `a` slice.\r\n\r\n```go\r\na := []int{1, 3}\r\na = append(a, 4, 2)\r\n// => []int{1,3,4,2}\r\n```\r\n\r\n`append` always returns a new slice, and when we just want to append elements to an existing slice, it's common to reassign it back to the slice variable we pass as the first argument as we did above.\r\n\r\n`append` can also be used to merge two slices:\r\n\r\n```go\r\nnextSlice := []int{100,101,102}\r\nnewSlice  := append(withData, nextSlice...)\r\n// => []int{0,1,2,3,4,5,100,101,102}\r\n```\r\n\r\n## Indexes in slices\r\n\r\nWorking with indexes of slices should always be protected in some way by a check that makes sure the index actually exists.\r\nFailing to do so will crash the entire application.\r\n\r\n## Empty slices\r\n\r\n`nil`-slices are the default empty slice. They have no drawbacks towards a slice with no values in them.\r\nThe `len` function works on `nil`-slices, items can be added without initializing it, and so on.\r\nIf creating a new slice prefer `var s []int` (`nil`-slice) over `s := []int{}` (empty, non-`nil` slice).\r\n\r\n## Performance\r\n\r\nWhen creating slices to be filled iteratively, there is a low-hanging fruit to improve performance, if the final size of the slice is known.\r\nThe key is to minimize the number of times memory has to be allocated, which is rather expensive and happens if the slice grows beyond its allocated memory space.\r\nThe safest way to do this is to specify a capacity `cap` for the slice with `s := make([]int, 0, cap)` and then `append` to the slice as usual.\r\nThis way the space for `cap` amount of items is allocated immediately while the slice length is zero.\r\nIn practice, `cap` is often the length of another slice: `s := make([]int, 0, len(otherSlice))`.\r\n\r\n## Append is not a pure function\r\n\r\nThe `append` function of Go is optimized for performance and therefore does not make a copy of the input slice.\r\nThis means that the original slice (1st parameter in `append`) will be changed sometimes.\r\n",
    "introduction": "# Introduction\r\n\r\nSlices in Go are similar to lists or arrays in other languages.\r\nThey hold several elements of a specific type (or interface).\r\n\r\nSlices in Go are based on arrays.\r\nArrays have a fixed size.\r\nA slice, on the other hand, is a dynamically-sized, flexible view of the elements of an array.\r\n\r\nA slice is written like `[]T` with `T` being the type of the elements in the slice:\r\n\r\n```go\r\nvar empty []int                 // an empty slice\r\nwithData := []int{0,1,2,3,4,5}  // a slice pre-filled with some data\r\n```\r\n\r\nYou can get or set an element at a given zero-based index using the square-bracket notation:\r\n\r\n```go\r\nwithData[1] = 5\r\nx := withData[1] // x is now 5\r\n```\r\n\r\nYou can create a new slice from an existing slice by getting a range of elements.\r\nOnce again using square-bracket notation, but specifying both a starting (inclusive) and ending (exclusive) index.\r\nIf you don't specify a starting index, it defaults to 0.\r\nIf you don't specify an ending index, it defaults to the length of the slice.\r\n\r\n```go\r\nnewSlice := withData[2:4]\r\n// => []int{2,3}\r\nnewSlice := withData[:2]\r\n// => []int{0,1}\r\nnewSlice := withData[2:]\r\n// => []int{2,3,4,5}\r\nnewSlice := withData[:]\r\n// => []int{0,1,2,3,4,5}\r\n```\r\n\r\nYou can add elements to a slice using the `append` function.\r\nBelow we append `4` and `2` to the `a` slice.\r\n\r\n```go\r\na := []int{1, 3}\r\na = append(a, 4, 2)\r\n// => []int{1,3,4,2}\r\n```\r\n\r\n`append` always returns a new slice, and when we just want to append elements to an existing slice, it's common to reassign it back to the slice variable we pass as the first argument as we did above.\r\n\r\n`append` can also be used to merge two slices:\r\n\r\n```go\r\nnextSlice := []int{100,101,102}\r\nnewSlice  := append(withData, nextSlice...)\r\n// => []int{0,1,2,3,4,5,100,101,102}\r\n```\r\n\r\n## Indexes in slices\r\n\r\nWorking with indexes of slices should always be protected in some way by a check that makes sure the index actually exists.\r\nFailing to do so will crash the entire application.\r\n\r\n## Empty slices\r\n\r\n`nil`-slices are the default empty slice. They have no drawbacks towards a slice with no values in them.\r\nThe `len` function works on `nil`-slices, items can be added without initializing it, and so on.\r\nIf creating a new slice prefer `var s []int` (`nil`-slice) over `s := []int{}` (empty, non-`nil` slice).\r\n\r\n## Performance\r\n\r\nWhen creating slices to be filled iteratively, there is a low-hanging fruit to improve performance, if the final size of the slice is known.\r\nThe key is to minimize the number of times memory has to be allocated, which is rather expensive and happens if the slice grows beyond its allocated memory space.\r\nThe safest way to do this is to specify a capacity `cap` for the slice with `s := make([]int, 0, cap)` and then `append` to the slice as usual.\r\nThis way the space for `cap` amount of items is allocated immediately while the slice length is zero.\r\nIn practice, `cap` is often the length of another slice: `s := make([]int, 0, len(otherSlice))`.\r\n\r\n## Append is not a pure function\r\n\r\nThe `append` function of Go is optimized for performance and therefore does not make a copy of the input slice.\r\nThis means that the original slice (1st parameter in `append`) will be changed sometimes.\r\n"
  },
  "meta": {
    "blurb": "Slices are lists of items of the same type.",
    "authors": [
      "ErikSchierboom"
    ],
    "contributors": []
  },
  "links": [
    {
      "url": "https://tour.golang.org/moretypes/7",
      "description": "A Tour of Go: Slices"
    },
    {
      "url": "https://gobyexample.com/slices",
      "description": "Go by Example: Slices"
    },
    {
      "url": "https://go.dev/blog/slices-intro",
      "description": "Go Dev Blog: Slices - Usage and internals"
    },
    {
      "url": "https://github.com/golang/go/wiki/SliceTricks",
      "description": "Slice Tricks"
    },
    {
      "url": "https://golang.org/ref/spec#Slice_types",
      "description": "Go Language Spec: Slice Types"
    }
  ]
}