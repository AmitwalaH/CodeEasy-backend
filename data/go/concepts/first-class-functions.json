{
  "language": "go",
  "slug": "first-class-functions",
  "title": "First Class Functions",
  "docs": {
    "about": "# About\r\n\r\nIn Go, functions are first-class values. This means that you can do with functions the same things you can do with all other values - assign functions to variables, pass them as arguments to other functions or even return functions from other functions. \r\n\r\nBelow we are creating two functions, `engGreeting` and `espGreeting` and we are assigning them to the variable `greeting`:\r\n\r\n```go\r\nimport \"fmt\"\r\n\r\nfunc engGreeting(name string) string {\r\n\treturn fmt.Sprintf(\"Hello %s, nice to meet you!\", name)\r\n}\r\n\r\nfunc espGreeting(name string) string {\r\n\treturn fmt.Sprintf(\"¡Hola %s, mucho gusto!\", name)\r\n}\r\n\r\ngreeting := engGreeting\t\t\t// greeting is a variable of type func(string) string\r\nfmt.Println(greeting(\"Alice\"))\t// Hello Alice, nice to meet you!\r\n\r\ngreeting = espGreeting\r\nfmt.Println(greeting(\"Alice\")) \t// ¡Hola Alice, mucho gusto!\r\n```\r\n\r\nFunction values provide an opportunity to parameterize functions not only with data but with behavior too.\r\nIn the following example, we are passing behavior to the `dialog` function via the `greetingFunc` parameter:\r\n\r\n```go\r\nfunc dialog(name string, greetingFunc func(string) string) {\r\n\tfmt.Println(greetingFunc(name))\r\n\tfmt.Println(\"I'm a dialog bot.\")\r\n}\r\n\r\nfunc espGreeting(name string) string {\r\n\treturn fmt.Sprintf(\"¡Hola %s, mucho gusto!\", name)\r\n}\r\n\r\ngreeting := espGreeting\r\ndialog(\"Alice\", greeting)\r\n// Output:\r\n// ¡Hola Alice, mucho gusto!\r\n// I'm a dialog bot.\r\n```\r\n\r\nThe value of an uninitialized variable of function type is `nil`.\r\nTherefore, calling a `nil` function value causes a panic.\r\n\r\n```go\r\nvar dutchGreeting func(string) string\r\ndutchGreeting(\"Alice\") // panic: call of nil function\r\n```\r\n\r\nFunction values can be compared with `nil`. This can be useful to avoid unnecessary program panics.\r\n\r\n```go\r\nvar dutchGreeting func(string) string\r\nif dutchGreeting != nil {\r\n\tdutchGreeting(\"Alice\") // safe to call dutchGreeting\r\n}\r\n```\r\n\r\n## Function types\r\n\r\nUsing function values is possible thanks to the function types in Go. A function type denotes the set of all functions with the same sequence of parameter types and the same sequence of result types. User-defined types can be declared on top of function types. For instance, the `dialog` function from the previous examples can be updated as following:\r\n\r\n```go\r\ntype greetingFunc func(string) string\r\n\r\nfunc dialog(name string, f greetingFunc) {\r\n\tfmt.Println(f(name))\r\n\tfmt.Println(\"I'm a dialog bot.\")\r\n}\r\n```\r\n\r\n## Anonymous functions\r\n\r\nAnother powerful tool that is available thanks to first-class functions support is anonymous functions. Anonymous functions are defined at their point of use, without a name following the `func` keyword. Such functions have access to the variables of the enclosing function.\r\n\r\nFor example:\r\n\r\n```go\r\nfunc fib() func() int {\r\n\tvar n1, n2 int\r\n\r\n\treturn func() int {\r\n\t\tif n1 == 0 && n2 == 0 {\r\n\t\t\tn1 = 1\r\n\t\t} else {\r\n\t\t\tn1, n2 = n2, n1 + n2\r\n\t\t}\r\n\t\treturn n2\r\n\t}\r\n}\r\n\r\nnext := fib()\r\nfor i := 0; i < N; i++ {\r\n  fmt.Printf(\"F%d\\t= %4d\\n\", i, next())\r\n}\r\n```\r\n\r\nA call to `fib` declares the variables `n1` and `n2` and returns an anonymous function that, in turn, changes the values of these variables each time the function is called. Nth calls of the anonymous function return the Nth number of the Fibonacci sequence starting from 0. The anonymous inner function has access to the local variables (`n1` and `n2`) of the enclosing function `fib`. This is a great way to have function values keep state between calls. We say that the anonymous function is a closure of the variables `n1` and `n2`. [Closures][closure] are widely used in programming and you might see other languages supporting them.\r\n\r\n[closure]: https://en.wikipedia.org/wiki/Closure_(computer_programming)\r\n",
    "introduction": "# Introduction\r\n\r\nIn Go, functions are first-class values. This means that you can do with functions the same things you can do with all other values - assign functions to variables, pass them as arguments to other functions or even return functions from other functions. \r\n\r\nBelow we are creating two functions, `engGreeting` and `espGreeting` and we are assigning them to the variable `greeting`:\r\n\r\n```go\r\nimport \"fmt\"\r\n\r\nfunc engGreeting(name string) string {\r\n\treturn fmt.Sprintf(\"Hello %s, nice to meet you!\", name)\r\n}\r\n\r\nfunc espGreeting(name string) string {\r\n\treturn fmt.Sprintf(\"¡Hola %s, mucho gusto!\", name)\r\n}\r\n\r\ngreeting := engGreeting\t\t\t// greeting is a variable of type func(string) string\r\nfmt.Println(greeting(\"Alice\"))\t// Hello Alice, nice to meet you!\r\n\r\ngreeting = espGreeting\r\nfmt.Println(greeting(\"Alice\")) \t// ¡Hola Alice, mucho gusto!\r\n```\r\n\r\nFunction values provide an opportunity to parameterize functions not only with data but with behavior too.\r\nIn the following example, we are passing behavior to the `dialog` function via the `greetingFunc` parameter:\r\n\r\n```go\r\nfunc dialog(name string, greetingFunc func(string) string) {\r\n\tfmt.Println(greetingFunc(name))\r\n\tfmt.Println(\"I'm a dialog bot.\")\r\n}\r\n\r\nfunc espGreeting(name string) string {\r\n\treturn fmt.Sprintf(\"¡Hola %s, mucho gusto!\", name)\r\n}\r\n\r\ngreeting := espGreeting\r\ndialog(\"Alice\", greeting)\r\n// Output:\r\n// ¡Hola Alice, mucho gusto!\r\n// I'm a dialog bot.\r\n```\r\n\r\nThe value of an uninitialized variable of function type is `nil`.\r\nTherefore, calling a `nil` function value causes a panic.\r\n\r\n```go\r\nvar dutchGreeting func(string) string\r\ndutchGreeting(\"Alice\") // panic: call of nil function\r\n```\r\n\r\nFunction values can be compared with `nil`. This can be useful to avoid unnecessary program panics.\r\n\r\n```go\r\nvar dutchGreeting func(string) string\r\nif dutchGreeting != nil {\r\n\tdutchGreeting(\"Alice\") // safe to call dutchGreeting\r\n}\r\n```\r\n\r\n## Function types\r\n\r\nUsing function values is possible thanks to the function types in Go. A function type denotes the set of all functions with the same sequence of parameter types and the same sequence of result types. User-defined types can be declared on top of function types. For instance, the `dialog` function from the previous examples can be updated as following:\r\n\r\n```go\r\ntype greetingFunc func(string) string\r\n\r\nfunc dialog(name string, f greetingFunc) {\r\n\tfmt.Println(f(name))\r\n\tfmt.Println(\"I'm a dialog bot.\")\r\n}\r\n```\r\n\r\n## Anonymous functions\r\n\r\nAnother powerful tool that is available thanks to first-class functions support is anonymous functions. Anonymous functions are defined at their point of use, without a name following the `func` keyword. Such functions have access to the variables of the enclosing function.\r\n\r\nFor example:\r\n\r\n```go\r\nfunc fib() func() int {\r\n\tvar n1, n2 int\r\n\r\n\treturn func() int {\r\n\t\tif n1 == 0 && n2 == 0 {\r\n\t\t\tn1 = 1\r\n\t\t} else {\r\n\t\t\tn1, n2 = n2, n1 + n2\r\n\t\t}\r\n\t\treturn n2\r\n\t}\r\n}\r\n\r\nnext := fib()\r\nfor i := 0; i < N; i++ {\r\n  fmt.Printf(\"F%d\\t= %4d\\n\", i, next())\r\n}\r\n```\r\n\r\nA call to `fib` declares the variables `n1` and `n2` and returns an anonymous function that, in turn, changes the values of these variables each time the function is called. Nth calls of the anonymous function return the Nth number of the Fibonacci sequence starting from 0. The anonymous inner function has access to the local variables (`n1` and `n2`) of the enclosing function `fib`. This is a great way to have function values keep state between calls. We say that the anonymous function is a closure of the variables `n1` and `n2`. [Closures][closure] are widely used in programming and you might see other languages supporting them.\r\n\r\n[closure]: https://en.wikipedia.org/wiki/Closure_(computer_programming)\r\n"
  },
  "meta": {
    "authors": [
      "antklim"
    ],
    "contributors": [
      "andrerfcsantos"
    ],
    "blurb": "Functions in Go can be used as regular values of the language."
  },
  "links": [
    {
      "url": "https://go.dev/ref/spec#Function_types",
      "description": "Go Language Spec: Function types"
    },
    {
      "url": "https://go.dev/tour/moretypes/24",
      "description": "Tour of Go: Function values"
    },
    {
      "url": "https://golangbot.com/first-class-functions/",
      "description": "Golang tutorial: First Class Functions"
    }
  ]
}