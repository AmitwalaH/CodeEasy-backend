{
  "language": "go",
  "slug": "pointers",
  "title": "Pointers",
  "docs": {
    "about": "# About\r\n\r\nLike many other languages, Go has pointers. \r\nIf you're new to pointers, they can feel a little mysterious but once you get used to them, they're quite straight-forward.\r\nThey're a crucial part of Go, so take some time to really understand them.\r\n\r\nBefore digging into the details, it's worth understanding the use of pointers. Pointers are a way to share memory with other parts of our program, which is useful for two major reasons:\r\n1. When we have large amounts of data, making copies to pass between functions is very inefficient. \r\n  By passing the memory location of where the data is stored instead, we can dramatically reduce the resource-footprint of our programs.\r\n2. By passing pointers between functions, we can access and modify the single copy of the data directly, meaning that any changes made by one function are immediately visible to other parts of the program when the function ends.\r\n\r\n## Variables and Memory\r\n\r\nLet's say we have a regular integer variable `a`:\r\n\r\n```go\r\nvar a int\r\n```\r\n\r\nWhen we declare a variable, Go has to find a place in memory to store its value. This is largely abstracted from us — when we need to fetch the value stored in that piece of memory, we can just refer to it by the variable name.\r\n\r\nFor instance, when we write `a + 2`, we are effectively fetching the value stored in the memory associated with the variable `a` and adding 2 to it.\r\n\r\nSimilarly, when we need to change the value in the piece of memory of `a`, we can use the variable name to do an assignment:\r\n\r\n```go\r\na = 3\r\n```\r\n\r\nThe piece of memory that is associated with `a` will now be storing the value `3`.\r\n\r\n## Pointers\r\n\r\nWhile variables allow us to refer to values in memory, sometimes it's useful to know the **memory address** to which the variable is pointing. **Pointers** hold the memory addresses of those values. You declare a variable with a pointer type by prefixing the underlying type with an asterisk: \r\n\r\n```go\r\nvar p *int // 'p' contains the memory address of an integer\r\n```\r\n\r\nHere we declare a variable `p` of type \"pointer to int\" (`*int`). This means that `p` will hold the memory address of an integer. The zero value of pointers is `nil` because a `nil` pointer holds no memory address.\r\n\r\n### Getting a pointer to a variable\r\n\r\nTo find the memory address of the value of a variable, we can use the `&` operator. \r\nFor example, if we want to find and store the memory address of variable `a` in the pointer `p`, we can do the following:\r\n\r\n```go\r\nvar a int\r\na = 2\r\n\r\nvar p *int\r\np = &a // the variable 'p' contains the memory address of 'a'\r\n```\r\n\r\n### Accessing the value via a pointer (dereferencing)\r\n\r\nWhen we have a pointer, we might want to know the value stored in the memory address the pointer represents. We can do this using the `*` operator:\r\n\r\n```go\r\nvar a int \r\na = 2\r\n\r\nvar p *int \r\np = &a // the variable 'p' contains the memory address of 'a'\r\n\r\nvar b int\r\nb = *p // b == 2\r\n```\r\n\r\nThe operation `*p` fetches the value stored at the memory address stored in `p`. This operation is often called \"dereferencing\".\r\n\r\nWe can also use the dereference operator to assign a new value to the memory address referenced by the pointer:\r\n\r\n```go\r\nvar a int        // declare int variable 'a'\r\na = 2            // assign 'a' the value of 2\r\n\r\nvar pa *int\r\npa = &a          // 'pa' now contains to the memory address of 'a'  \r\n*pa = *pa + 2    // increment by 2 the value at memory address 'pa'\r\n\r\nfmt.Println(a)   // Output: 4\r\n                 // 'a' will have the new value that was changed via the pointer!\r\n```\r\n\r\nAssigning to `*pa` will change the value stored at the memory address `pa` holds. Since `pa` holds the memory address of `a`, by assigning to `*pa` we are effectively changing the value of `a`! \r\n\r\nA note of caution however: always check if a pointer is not `nil` before dereferencing. Dereferencing a `nil` pointer will make the program crash at runtime!\r\n\r\n```go\r\nvar p *int // p is nil initially\r\nfmt.Println(*p)\r\n// panic: runtime error: invalid memory address or nil pointer dereference\r\n```\r\n\r\n### Pointers to structs\r\n\r\nSo far we've only seen pointers to primitive values. We can also create pointers for structs:\r\n\r\n```go\r\ntype Person struct {\r\n    Name string\r\n    Age  int\r\n}\r\n\r\nvar peter Person\r\npeter = Person{Name: \"Peter\", Age: 22}\r\n\r\nvar p *Person\r\np = &peter\r\n```\r\n\r\nWe could have also created a new `Person` and immediately stored a pointer to it:\r\n\r\n```go\r\nvar p *Person\r\np = &Person{Name: \"Peter\", Age: 22}\r\n```\r\n\r\nWhen we have a pointer to a struct, we don't need to dereference the pointer before accessing one of the fields:\r\n\r\n```go\r\nvar p *Person\r\np = &Person{Name: \"Peter\", Age: 22}\r\n\r\nfmt.Println(p.Name) // Output: \"Peter\" \r\n                    // Go automatically dereferences 'p' to allow\r\n                    // access to the 'Name' field\r\n```\r\n\r\n## Slices and maps are already pointers\r\n\r\nSlices and maps are special types because they already have pointers in their implementation. This means that more often than not, we don't need to create pointers for these types to share the memory address for their values. Imagine we have a function that increments the value of a key in a map:\r\n\r\n\r\n```go\r\nfunc incrementPeterAge(m map[string]int) {\r\n\tm[\"Peter\"] += 1\r\n}\r\n```\r\n\r\nIf we create a map and call this function, the changes the function made to the map persist after the function ended. This is a similar behavior we get if we were using a pointer, but note how on this example we are not using any referencing/dereferencing or any of the pointer syntax:\r\n\r\n```go\r\nages := map[string]int{\r\n  \"Peter\": 21\r\n}\r\nincrementPeterAge(ages)\r\nfmt.Println(ages)\r\n// Output: map[Peter:22]\r\n// The changes the function 'incrementPeterAge' made to the map are visible after the function ends!\r\n```\r\n\r\nThe same applies when changing an existing item in a slice.\r\n\r\nHowever, actions that return a new slice like `append` are a special case and **might not** modify the slice outside of the function.\r\nThis is due to the way slices work internally, but we won't cover this in detail, as this is a more advanced topic.\r\nIf you are really curious you can read more about this in [Go Blog: Mechanics of 'append'][mechanics-of-append]\r\n\r\n## Pointer arithmetic\r\n\r\nUnlike other languages, Go does not support pointer arithmetic. This means you cannot go from a memory address of one value to the address of another by incrementing the pointer value. So snippets like the following are invalid:\r\n\r\n```go\r\nvar a int\r\na = 2\r\n\r\nvar pa *int\r\npa = &a\r\npa++ // NOT ALLOWED: incrementing the pointer or any other pointer arithmetic operations are invalid\r\n```\r\n\r\n[mechanics-of-append]: https://go.dev/blog/slices\r\n",
    "introduction": "# Introduction\r\n\r\nLike many other languages, Go has pointers.\r\nIf you're new to pointers, they can feel a little mysterious but once you get used to them, they're quite straight-forward.\r\nThey're a crucial part of Go, so take some time to really understand them.\r\n\r\nBefore digging into the details, it's worth understanding the use of pointers. Pointers are a way to share memory with other parts of our program, which is useful for two major reasons:\r\n1. When we have large amounts of data, making copies to pass between functions is very inefficient.\r\n  By passing the memory location of where the data is stored instead, we can dramatically reduce the resource-footprint of our programs.\r\n2. By passing pointers between functions, we can access and modify the single copy of the data directly, meaning that any changes made by one function are immediately visible to other parts of the program when the function ends.\r\n\r\n## Variables and Memory\r\n\r\nLet's say we have a regular integer variable `a`:\r\n\r\n```go\r\nvar a int\r\n```\r\n\r\nWhen we declare a variable, Go has to find a place in memory to store its value. This is largely abstracted from us — when we need to fetch the value stored in that piece of memory, we can just refer to it by the variable name.\r\n\r\nFor instance, when we write `a + 2`, we are effectively fetching the value stored in the memory associated with the variable `a` and adding 2 to it.\r\n\r\nSimilarly, when we need to change the value in the piece of memory of `a`, we can use the variable name to do an assignment:\r\n\r\n```go\r\na = 3\r\n```\r\n\r\nThe piece of memory that is associated with `a` will now be storing the value `3`.\r\n\r\n## Pointers\r\n\r\nWhile variables allow us to refer to values in memory, sometimes it's useful to know the **memory address** to which the variable is pointing. **Pointers** hold the memory addresses of those values. You declare a variable with a pointer type by prefixing the underlying type with an asterisk:\r\n\r\n```go\r\nvar p *int // 'p' contains the memory address of an integer\r\n```\r\n\r\nHere we declare a variable `p` of type \"pointer to int\" (`*int`). This means that `p` will hold the memory address of an integer. The zero value of pointers is `nil` because a `nil` pointer holds no memory address.\r\n\r\n### Getting a pointer to a variable\r\n\r\nTo find the memory address of the value of a variable, we can use the `&` operator.\r\nFor example, if we want to find and store the memory address of variable `a` in the pointer `p`, we can do the following:\r\n\r\n```go\r\nvar a int\r\na = 2\r\n\r\nvar p *int\r\np = &a // the variable 'p' contains the memory address of 'a'\r\n```\r\n\r\n### Accessing the value via a pointer (dereferencing)\r\n\r\nWhen we have a pointer, we might want to know the value stored in the memory address the pointer represents. We can do this using the `*` operator:\r\n\r\n```go\r\nvar a int\r\na = 2\r\n\r\nvar p *int\r\np = &a // the variable 'p' contains the memory address of 'a'\r\n\r\nvar b int\r\nb = *p // b == 2\r\n```\r\n\r\nThe operation `*p` fetches the value stored at the memory address stored in `p`. This operation is often called \"dereferencing\".\r\n\r\nWe can also use the dereference operator to assign a new value to the memory address referenced by the pointer:\r\n\r\n```go\r\nvar a int        // declare int variable 'a'\r\na = 2            // assign 'a' the value of 2\r\n\r\nvar pa *int\r\npa = &a          // 'pa' now contains to the memory address of 'a'\r\n*pa = *pa + 2    // increment by 2 the value at memory address 'pa'\r\n\r\nfmt.Println(a)   // Output: 4\r\n                 // 'a' will have the new value that was changed via the pointer!\r\n```\r\n\r\nAssigning to `*pa` will change the value stored at the memory address `pa` holds. Since `pa` holds the memory address of `a`, by assigning to `*pa` we are effectively changing the value of `a`!\r\n\r\nA note of caution however: always check if a pointer is not `nil` before dereferencing. Dereferencing a `nil` pointer will make the program crash at runtime!\r\n\r\n```go\r\nvar p *int // p is nil initially\r\nfmt.Println(*p)\r\n// panic: runtime error: invalid memory address or nil pointer dereference\r\n```\r\n\r\n### Pointers to structs\r\n\r\nSo far we've only seen pointers to primitive values. We can also create pointers for structs:\r\n\r\n```go\r\ntype Person struct {\r\n    Name string\r\n    Age  int\r\n}\r\n\r\nvar peter Person\r\npeter = Person{Name: \"Peter\", Age: 22}\r\n\r\nvar p *Person\r\np = &peter\r\n```\r\n\r\nWe could have also created a new `Person` and immediately stored a pointer to it:\r\n\r\n```go\r\nvar p *Person\r\np = &Person{Name: \"Peter\", Age: 22}\r\n```\r\n\r\nWhen we have a pointer to a struct, we don't need to dereference the pointer before accessing one of the fields:\r\n\r\n```go\r\nvar p *Person\r\np = &Person{Name: \"Peter\", Age: 22}\r\n\r\nfmt.Println(p.Name) // Output: \"Peter\"\r\n                    // Go automatically dereferences 'p' to allow\r\n                    // access to the 'Name' field\r\n```\r\n\r\n## Slices and maps are already pointers\r\n\r\nSlices and maps are special types because they already have pointers in their implementation. This means that more often than not, we don't need to create pointers for these types to share the memory address for their values. Imagine we have a function that increments the value of a key in a map:\r\n\r\n\r\n```go\r\nfunc incrementPeterAge(m map[string]int) {\r\n\tm[\"Peter\"] += 1\r\n}\r\n```\r\n\r\nIf we create a map and call this function, the changes the function made to the map persist after the function ended. This is a similar behavior we get if we were using a pointer, but note how on this example we are not using any referencing/dereferencing or any of the pointer syntax:\r\n\r\n```go\r\nages := map[string]int{\r\n  \"Peter\": 21\r\n}\r\nincrementPeterAge(ages)\r\nfmt.Println(ages)\r\n// Output: map[Peter:22]\r\n// The changes the function 'incrementPeterAge' made to the map are visible after the function ends!\r\n```\r\n\r\nThe same applies when changing an existing item in a slice.\r\n\r\nHowever, actions that return a new slice like `append` are a special case and **might not** modify the slice outside of the function.\r\nThis is due to the way slices work internally, but we won't cover this in detail, as this is a more advanced topic.\r\nIf you are really curious you can read more about this in [Go Blog: Mechanics of 'append'][mechanics-of-append]\r\n\r\n[mechanics-of-append]: https://go.dev/blog/slices\r\n"
  },
  "meta": {
    "blurb": "Pointers hold the memory address of a value.",
    "authors": [
      "andrerfcsantos"
    ],
    "contributors": []
  },
  "links": [
    {
      "url": "https://tour.golang.org/moretypes/1",
      "description": "A Tour of Go: Pointers"
    },
    {
      "url": "https://gobyexample.com/pointers",
      "description": "Go by Example: Pointers"
    },
    {
      "url": "https://www.digitalocean.com/community/conceptual_articles/understanding-pointers-in-go",
      "description": "Article: Understanding Pointers in Go"
    }
  ]
}