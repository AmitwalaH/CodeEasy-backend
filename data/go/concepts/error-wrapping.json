{
  "language": "go",
  "slug": "error-wrapping",
  "title": "Error Wrapping",
  "docs": {
    "about": "# About\r\n\r\n## Adding context to errors\r\n\r\nWe explored basic error handling in Go in the [errors concept][concept-errors].\r\nAs you learned there, by default errors do not carry around stack traces.\r\nThat makes it crucial to ensure the error itself contains enough information to identify the problem.\r\n\r\nIf we wanted to add information to an existing error with the tools we already know, we could write something like this to create a new error with the combined text of the original error and the additional information:\r\n\r\n```go\r\nerr := errors.New(fmt.Sprintf(\"parsing age for user %d: %v\", userID, originalError))\r\n```\r\n\r\nLuckily, the `fmt` package from the standard library contains a short-hand version for this in form of the `Errorf` function.\r\nThat allows you, for example, to easily add information about the context in which the error occurred.\r\n\r\n```go\r\noriginalError := errors.New(\"unexpected negative number\")\r\nuserID := 123\r\nerr := fmt.Errorf(\"parsing age for user %d: %v\", userID, originalError)\r\nerr.Error()\r\n// => \"parsing age for user 123: unexpected negative number\"\r\n```\r\n\r\nUnless you are sure that the error already has enough information included, you should try to get into the habit of always adding context to an error before returning it from a function.\r\nThat means your standard error handling pattern should look like this:\r\n\r\n```go\r\nresult, err := calculateSomething()\r\nif err != nil {\r\n  return 0, fmt.Errorf(\"calculating something: %v\", err)\r\n}\r\n```\r\n\r\nAs shown in the examples, the convention is to separate the error from the added message with a colon.\r\nJust like the message of the original error, also the context message should not be capitalized and no period should be added at the end.\r\n\r\n~~~~exercism/note\r\nWhen adding context to an error, it is tempting to start the message with \"failed to ...\" or similar.\r\nHowever, as an error can accumulate a lot of additional context as it travels up the function chain, this can make the final message that will be logged or the user will see harder to read/ full of duplication.\r\n\r\nHere is an example to illustrate:\r\n\r\n```text\r\nfailed to validate request: failed to parse path parameter: failed to convert number: invalid input \"abc\"\r\nvs.\r\nvalidating request: parsing path parameter: converting to number: invalid input \"abc\"\r\n```\r\n\r\nSo keep this end result in mind when writing the context messages and refrain from adding text about the fact that something did not go as expected.\r\nThis is usually clear from the context (e.g. log level \"ERROR\") and the original error message.\r\n~~~~\r\n\r\nOften this way of adding information for an error is good enough but there are cases where you want to allow the consumer of your error to check for or retrieve the original underlying error.\r\nAdding context in way that allows this is called \"wrapping an error\" in Go.\r\n\r\n## Wrapping errors and checking for sentinel errors\r\n\r\nError wrapping can be achieved with a very minor change to the code we saw above.\r\nTo wrap an error, you need to use the formatting verb `%w` instead of `%v`.\r\nBehind the scenes, this will make sure that the resulting error implements an `Unwrap` method which returns the original error.\r\nBecause of that, then `errors.Is` can be used to check whether a specific sentinel error appears somewhere along the \"error chain\".\r\nIt does that by secretly calling `Unwrap` repeatedly until the error in question was found or the chain ended.\r\n\r\n```go\r\noriginalError := errors.New(\"unexpected negative number\")\r\nerr := fmt.Errorf(\"parsing age: %w\", originalError)\r\nerrors.Is(err, originalError)\r\n// => true\r\n```\r\n\r\nChecking for the original error with `errors.Is` would not work with the regular `%v` formatting verb.\r\n\r\n```go\r\noriginalError := errors.New(\"unexpected negative number\")\r\nerr := fmt.Errorf(\"parsing age: %v\", originalError)\r\nerrors.Is(err, originalError)\r\n// => false\r\n```\r\n\r\nAs a result, it is good practice to use `%v` by default and only use `%w` if you explicitly want to allow your consumer to access an underlying error ([Google Go Styleguide][google-go-styleguide]).\r\n\r\nIf you find ourself in a situation where you want to check for a sentinel error but explicitly don't want to unwrap, you can use `==` instead of `errors.Is`.\r\n\r\n```go\r\nvar originalError = errors.New(\"unexpected negative number\")\r\nfunc someFunc() error {\r\n  return originalError\r\n}\r\n\r\nerr := someFunc()\r\nerr == originalError \r\n// => true\r\n```\r\n\r\nIn contrast, `==` would not identify the error if it was wrapped.\r\n\r\n```go\r\nvar originalError = errors.New(\"unexpected negative number\")\r\nfunc someFunc() error {\r\n  return fmt.Errorf(\"parsing age: %v\", originalError)\r\n}\r\n\r\nerr := someFunc()\r\nerr == originalError \r\n// => false\r\n```\r\n\r\nIt is fine to work with `errors.Is` by default, but you should always be aware that this means the whole error chain will be searched.\r\n\r\n## Checking for (custom) error types\r\n\r\nThere is an equivalent to `errors.Is` that allows to check for and retrieve an error of a specific type from the error chain.\r\nThe function for that is `errors.As` and just like `errors.Is` it will search for the given error type along the whole chain.\r\n`errors.As` does only then extract the error it found that matches the type so you can further work with it, e.g. retrieve specific fields.\r\n\r\n```go\r\ntype MyCustomError struct {\r\n  Message string\r\n  Details string\r\n}\r\n\r\nfunc (e *MyCustomError) Error() string {\r\n  return fmt.Sprintf(\"%s, details: %s\", e.Message, e.Details)\r\n}\r\n\r\nfunc someFunc() error {\r\n  originalError := &MyCustomError{\r\n    Message: \"some message\",\r\n    Details: \"some details\",\r\n  }\r\n\r\n  return fmt.Errorf(\"doing something: %w\", originalError)\r\n}\r\n\r\nerr := someFunc()\r\nvar customError *MyCustomError\r\nerrors.As(err, &customError)\r\n// => true\r\n\r\n// customError now contains the error that was found in the error chain.\r\ncustomError.Details\r\n// => \"some details\"\r\n```\r\n\r\n~~~~exercism/caution\r\nBe careful with the syntax regarding the pointers above.\r\nThe code will only work and compile correctly if `customError` has the exact type that implements the error interface.\r\nIn our case, that is `*MyCustomError` (a [pointer][concept-pointers] to `MyCustomError`), not `MyCustomError` itself.\r\n\r\nOn top of that, the second argument needs to be a pointer to the error variable.\r\nSince our error is already a pointer, what we are passing to `errors.As` is a pointer to a pointer (to MyCustomError).\r\nOnly with this set up correctly, Go can then fill the variable with the error it found.\r\n~~~~\r\n\r\nAs before, `errors.As` would not have found the error type if `%v` would have been used when calling `Errorf`.\r\n\r\nIf you don't want to unwrap for some reason, type assertion can be used instead (equivalent to `==` above).\r\n\r\n```go\r\n// MyCustomError defined as above.\r\n\r\nfunc someFunc() error {\r\n  return &MyCustomError{\r\n    Message: \"some message\",\r\n    Details: \"some details\",\r\n  }\r\n}\r\n\r\nerr := someFunc()\r\ncustomError, ok := err.(*CustomError)\r\n// \"ok\" is now true\r\ncustomError.Details\r\n// => \"some details\"\r\n```\r\n\r\nType assertion will not be able to identify the error type if the error would have been wrapped.\r\n\r\n## Allowing errors of custom types to be unwrapped\r\n\r\nSometimes just wrapping an error with some additional text is not enough.\r\nYou can create a custom error type instead that holds the original error and the additional structured data that you want to add.\r\nIf you want to allow unwrapping for your error type, the only thing you have to do is to manually add an `Unwrap() error` method so the `Unwrap` interface is satisfied.\r\n\r\n```go\r\ntype SpecialError struct {\r\n  originalError error\r\n  metadata string\r\n}\r\n\r\nfunc (e *SpecialError) Error() string {\r\n  // The usual serialization code goes here.\r\n}\r\n\r\nfunc (e *SpecialError) Unwrap() error {\r\n  return e.originalError\r\n}\r\n```\r\n\r\n## Combining multiple errors\r\n\r\nIn Go 1.20, a new `Join` function was added to the built-in `errors` package.\r\n`Join` allows it to combine multiple errors together in a way that still allows unwrapping, i.e. checking for a specific error or error type along the chain.\r\nWith that, the error chain can actually be an error tree in reality.\r\nMore information can be found in the [release notes][release-notes] and the [documentation][doc-join].\r\n\r\n[concept-errors]: /tracks/go/concepts/errors\r\n[concept-pointers]: /tracks/go/concepts/pointers\r\n[google-go-styleguide]: https://google.github.io/styleguide/go/best-practices#adding-information-to-errors\r\n[release-notes]: https://tip.golang.org/doc/go1.20#errors\r\n[doc-join]: https://pkg.go.dev/errors#Join",
    "introduction": "# Introduction\r\n\r\n## Adding context to errors\r\n\r\nWe explored basic error handling in Go in the [errors concept][concept-errors].\r\nAs you learned there, by default errors do not carry around stack traces.\r\nThat makes it crucial to ensure the error itself contains enough information to identify the problem.\r\n\r\nIf we wanted to add information to an existing error with the tools we already know, we could write something like this to create a new error with the combined text of the original error and the additional information:\r\n\r\n```go\r\nerr := errors.New(fmt.Sprintf(\"parsing age for user %d: %v\", userID, originalError))\r\n```\r\n\r\nLuckily, the `fmt` package from the standard library contains a short-hand version for this in form of the `Errorf` function.\r\nThat allows you, for example, to easily add information about the context in which the error occurred.\r\n\r\n```go\r\noriginalError := errors.New(\"unexpected negative number\")\r\nuserID := 123\r\nerr := fmt.Errorf(\"parsing age for user %d: %v\", userID, originalError)\r\nerr.Error()\r\n// => \"parsing age for user 123: unexpected negative number\"\r\n```\r\n\r\nOften this way of adding information for an error is good enough but there are cases where you want to allow the consumer of your error to check for or retrieve the original underlying error.\r\nAdding context in way that allows this is called \"wrapping an error\" in Go.\r\n\r\n## Wrapping errors and checking for sentinel errors\r\n\r\nError wrapping can be achieved with a very minor change to the code we saw above.\r\nTo wrap an error, you need to use the formatting verb `%w` instead of `%v`.\r\nBehind the scenes, this will make sure that the resulting error implements an `Unwrap` method which returns the original error.\r\nBecause of that, then `errors.Is` can be used to check whether a specific sentinel error appears somewhere along the \"error chain\".\r\nIt does that by secretly calling `Unwrap` repeatedly until the error in question was found or the chain ended.\r\n\r\n```go\r\noriginalError := errors.New(\"unexpected negative number\")\r\nerr := fmt.Errorf(\"parsing age: %w\", originalError)\r\nerrors.Is(err, originalError)\r\n// => true\r\n```\r\n\r\nIt is good practice to use `%v` by default and only use `%w` if you explicitly want to allow your consumer to access an underlying error ([Google Go Styleguide][google-go-styleguide]).\r\n\r\nIf you find ourself in a situation where you want to check for a sentinel error but explicitly don't want to unwrap, you can use `==` instead of `errors.Is`.\r\n\r\n```go\r\nvar originalError = errors.New(\"unexpected negative number\")\r\nfunc someFunc() error {\r\n  return originalError\r\n}\r\n\r\nerr := someFunc()\r\nerr == originalError \r\n// => true\r\n```\r\n\r\nIt is fine to work with `errors.Is` by default, but you should always be aware that this means the whole error chain will be searched.\r\n\r\n## Checking for (custom) error types\r\n\r\nThere is an equivalent to `errors.Is` that allows to check for and retrieve an error of a specific type from the error chain.\r\nThe function for that is `errors.As` and just like `errors.Is` it will search for the given error type along the whole chain.\r\n`errors.As` does only then extract the error it found that matches the type so you can further work with it, e.g. retrieve specific fields.\r\n\r\n```go\r\ntype MyCustomError struct {\r\n  Message string\r\n  Details string\r\n}\r\n\r\nfunc (e *MyCustomError) Error() string {\r\n  return fmt.Sprintf(\"%s, details: %s\", e.Message, e.Details)\r\n}\r\n\r\nfunc someFunc() error {\r\n  originalError := &MyCustomError{\r\n    Message: \"some message\",\r\n    Details: \"some details\",\r\n  }\r\n\r\n  return fmt.Errorf(\"doing something: %w\", originalError)\r\n}\r\n\r\nerr := someFunc()\r\nvar customError *MyCustomError\r\nerrors.As(err, &customError)\r\n// => true\r\n\r\n// customError now contains the error that was found in the error chain.\r\ncustomError.Details\r\n// => \"some details\"\r\n```\r\n\r\n~~~~exercism/caution\r\nBe careful with the syntax regarding the pointers above.\r\nThe code will only work and compile correctly if `customError` has the exact type that implements the error interface.\r\nIn our case, that is `*MyCustomError` (a [pointer][concept-pointers] to `MyCustomError`), not `MyCustomError` itself.\r\n\r\nOn top of that, the second argument needs to be a pointer to the error variable.\r\nSince our error is already a pointer, what we are passing to `errors.As` is a pointer to a pointer (to MyCustomError).\r\nOnly with this set up correctly, Go can then fill the variable with the error it found.\r\n~~~~\r\n\r\nAs before, `errors.As` would not have found the error type if `%v` would have been used when calling `Errorf`.\r\n\r\nIf you don't want to unwrap for some reason, type assertion can be used instead (equivalent to `==` above).\r\n\r\n```go\r\n// MyCustomError defined as above.\r\n\r\nfunc someFunc() error {\r\n  return &MyCustomError{\r\n    Message: \"some message\",\r\n    Details: \"some details\",\r\n  }\r\n}\r\n\r\nerr := someFunc()\r\ncustomError, ok := err.(*CustomError)\r\n// \"ok\" is now true\r\ncustomError.Details\r\n// => \"some details\"\r\n```\r\n\r\nType assertion will not be able to identify the error type if the error would have been wrapped.\r\n\r\n## Allowing errors of custom types to be unwrapped\r\n\r\nSometimes just wrapping an error with some additional text is not enough.\r\nYou can create a custom error type instead that holds the original error and the additional structured data that you want to add.\r\nIf you want to allow unwrapping for your error type, the only thing you have to do is to manually add an `Unwrap() error` method so the `Unwrap` interface is satisfied.\r\n\r\n```go\r\ntype SpecialError struct {\r\n  originalError error\r\n  metadata string\r\n}\r\n\r\nfunc (e *SpecialError) Error() string {\r\n  // The usual serialization code goes here.\r\n}\r\n\r\nfunc (e *SpecialError) Unwrap() error {\r\n  return e.originalError\r\n}\r\n```\r\n\r\n[concept-errors]: /tracks/go/concepts/errors\r\n[concept-pointers]: /tracks/go/concepts/pointers\r\n[google-go-styleguide]: https://google.github.io/styleguide/go/best-practices#adding-information-to-errors\r\n[release-notes]: https://tip.golang.org/doc/go1.20#errors\r\n[doc-join]: https://pkg.go.dev/errors#Join"
  },
  "meta": {
    "blurb": "Go allows to add context to errors and provides functions to check for or retrieve the original error later on. This is called error wrapping (and unwrapping).",
    "authors": [
      "junedev"
    ],
    "contributors": []
  },
  "links": [
    {
      "url": "https://go.dev/blog/go1.13-errors",
      "description": "Go Blog: Working with Errors in Go 1.13"
    },
    {
      "url": "https://www.digitalocean.com/community/tutorials/how-to-add-extra-information-to-errors-in-go",
      "description": "Digital Ocean: How to Add Extra Information to Errors in Go"
    }
  ]
}