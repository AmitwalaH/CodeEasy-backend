{
  "language": "go",
  "slug": "type-assertion",
  "title": "Type Assertion",
  "docs": {
    "about": "# About Type Assertions\r\n\r\nInterfaces in Go can introduce ambiguity about the underlying type.\r\nIn fact, the empty interface can take any concrete value at all (including primitives).\r\nA type assertion allows us to extract the interface value's underlying concrete value using this syntax: `interfaceVariable.(concreteType)`.\r\n\r\nIf we assign the result of this statement to a single value, we assert that the interface variable holds a value of the concrete type.\r\nAs a result, it may panic at runtime if the interface value does not have the specified concrete type.\r\nFor example:\r\n\r\n```go\r\nvar input interface{} = 12\r\nstr := input.(string) // panic at runtime since input is not a string!\r\n```\r\n\r\nWe can test whether an interface value holds a specific concrete type by making use of both return values of the type assertion: the underlying value and a boolean value that reports whether the assertion succeeded.\r\nFor example:\r\n\r\n```go\r\nstr, ok := input.(string) // no panic if input is not a string\r\n```\r\n\r\nIf `input` holds a `string`, then `str` will be the underlying value and `ok` will be true.\r\nIf `input` does not hold a `string`, then `str` will be the zero value of type `string` (ie. `\"\"` - the empty string) and `ok` will be false.\r\nNo panic occurs in any case.\r\n\r\nIt is common to see this sort of idiom:\r\n\r\n```go\r\nstr, ok := input.(string)\r\nif !ok {\r\n    str = \"a default value\"\r\n}\r\n```\r\n\r\n## Type Switches\r\n\r\nA **type switch** can perform several type assertions in a row.\r\nIt has the same syntax as a type assertion (`interfaceVariable.(concreteType)`), but instead of a specific `concreteType` it uses the keyword `type`.\r\nHere is an example:\r\n\r\n```go\r\nvar i interface{} = 12 // try: 12.3, true, int64(12), []int{}, map[string]int{}\r\n\r\nswitch v := i.(type) {\r\ncase int:\r\n    fmt.Printf(\"the integer %d\\n\", v)\r\ncase string:\r\n    fmt.Printf(\"the string %s\\n\", v)\r\ndefault:\r\n    fmt.Printf(\"type, %T, not handled explicitly: %#v\\n\", v, v)\r\n}\r\n```\r\n",
    "introduction": "# Introduction to Type Assertions\r\n\r\nInterfaces in Go can introduce ambiguity about the underlying type.\r\nA type assertion allows us to extract the interface value's underlying concrete value using this syntax: `interfaceVariable.(concreteType)`.\r\n\r\nFor example:\r\n\r\n```go\r\nvar input interface{} = 12\r\nnumber := input.(int)\r\n```\r\n\r\nNOTE: this will cause a panic if the interface variable does not hold a value of the concrete type.\r\n\r\nWe can test whether an interface value holds a specific concrete type by making use of both return values of the type assertion: the underlying value and a boolean value that reports whether the assertion succeeded.\r\nFor example:\r\n\r\n```go\r\nstr, ok := input.(string) // no panic if input is not a string\r\n```\r\n\r\nIf `input` holds a `string`, then `str` will be the underlying value and `ok` will be true.\r\nIf `input` does not hold a `string`, then `str` will be the zero value of type `string` (ie. `\"\"` - the empty string) and `ok` will be false.\r\nNo panic occurs in any case.\r\n\r\n## Type Switches\r\n\r\nA **type switch** can perform several type assertions in series.\r\nIt has the same syntax as a type assertion (`interfaceVariable.(concreteType)`), but the `concreteType` is replaced with the keyword `type`.\r\nHere is an example:\r\n\r\n```go\r\nvar i interface{} = 12 // try: 12.3, true, int64(12), []int{}, map[string]int{}\r\n\r\nswitch v := i.(type) {\r\ncase int:\r\n    fmt.Printf(\"the integer %d\\n\", v)\r\ncase string:\r\n    fmt.Printf(\"the string %q\\n\", v)\r\ndefault:\r\n    fmt.Printf(\"type, %T, not handled explicitly: %#v\\n\", v, v)\r\n}\r\n```\r\n"
  },
  "meta": {
    "blurb": "Use type assertions to access an interface value's underlying concrete value.",
    "authors": [
      "jmrunkle"
    ],
    "contributors": []
  },
  "links": [
    {
      "url": "https://tour.golang.org/methods/15",
      "description": "A Tour of Go: Type Assertions"
    },
    {
      "url": "https://tour.golang.org/methods/16",
      "description": "A Tour of Go: Type Switches"
    },
    {
      "url": "https://golangdocs.com/type-assertions-in-golang",
      "description": "GoDocs: Type Assertions in GoLang"
    }
  ]
}