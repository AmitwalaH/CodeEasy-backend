{
  "language": "go",
  "slug": "chessboard",
  "docs": {
    "introduction": "# Introduction\r\n\r\nIn Go, you can iterate over a `slice` using `for` and an index, or you can use `range`.\r\n`range` also allows you to iterate over a `map`.\r\n\r\nEvery iteration returns two values: the index/key and a copy of the element at that index/key.\r\n\r\n## Iterate over a slice\r\n\r\nEasy as pie, loops over a slice, ordered as expected.\r\n\r\n```go\r\nxi := []int{10, 20, 30}\r\nfor i, x := range xi {\r\n  fmt.Println(i, x)\r\n}\r\n// outputs:\r\n// 0, 10\r\n// 1, 20\r\n// 2, 30\r\n```\r\n\r\n## Iterate over a map\r\n\r\nIterating over a map raises a new problem. The order is now random.\r\n\r\n```go\r\nhash := map[int]int{9: 10, 99: 20, 999: 30}\r\nfor k, v := range hash {\r\n  fmt.Println(k, v)\r\n}\r\n// outputs, for example:\r\n// 99 20\r\n// 999 30\r\n// 9 10\r\n```\r\n\r\n~~~~exercism/note\r\nIt may seem the above output is incorrect, as one would expect the first key/value pair on the declaration of the map `9 10` to be the first one printed and not the last.\r\nHowever, maps are unordered by nature - there isn't a first or last key/value pair.\r\nBecause of that, when iterating over the entries of a map, the order by which entries will be visited will be random and not follow any specific pattern.\r\nThis means the above output is possible but might differ from what you get if you try to run this yourself.\r\nTo learn more about this see [Go Language Spec: range clause](https://go.dev/ref/spec#RangeClause).\r\n~~~~\r\n\r\n## Iteration omitting key or value\r\n\r\nIn Go an unused variable will raise an error at build time.\r\nSometimes you only need the value, as per the first example:\r\n\r\n```go\r\nxi := []int{10, 20, 30}\r\nfor i, x := range xi {\r\n  fmt.Println(x)\r\n}\r\n// Go build failed: i declared but not used\r\n```\r\n\r\nYou can replace the `i` with `_` which tells the compiler we don't use that value:\r\n\r\n```go\r\nxi := []int{10, 20, 30}\r\nfor _, x := range xi {\r\n  fmt.Println(x)\r\n}\r\n// outputs:\r\n// 10\r\n// 20\r\n// 30\r\n```\r\n\r\nIf you want to only print the index, you can replace the `x` with `_`,\r\nor simply omit the declaration:\r\n\r\n```go\r\nxi := []int{10, 20, 30}\r\n// for i, _ := range xi {\r\nfor i := range xi {\r\n  fmt.Println(i)\r\n}\r\n// outputs:\r\n// 0\r\n// 1\r\n// 2\r\n```\r\n\r\n## Non-struct types\r\n\r\nYou've previously seen defining struct types.\r\nIt is also possible to define non-struct types which you can use as an alias for a built-in type declaration, and you can define receiver functions on them to extend them in the same way as struct types.\r\n\r\n```go\r\ntype Name string\r\nfunc SayHello(n Name) {\r\n  fmt.Printf(\"Hello %s\\n\", n)\r\n}\r\nn := Name(\"Fred\")\r\nSayHello(n)\r\n// Output: Hello Fred\r\n```\r\n\r\nYou can also define non-struct types composed of arrays and maps.\r\n\r\n```go\r\ntype Names []string\r\nfunc SayHello(n Names) {\r\n  for _, name := range n {\r\n    fmt.Printf(\"Hello %s\\n\", name)\r\n  }\r\n}\r\nn := Names([]string{\"Fred\", \"Bill\"})\r\nSayHello(n)\r\n// Output:\r\n// Hello Fred\r\n// Hello Bill\r\n```\r\n",
    "instructions": "# Instructions\r\n\r\nAs a chess enthusiast, you would like to write your own version of the game. Yes, there may be plenty of implementations of chess available online already, but yours will be unique!\r\n\r\nEach square of the chessboard is identified by a letter-number pair:\r\n - The horizontal rows of squares, called ranks, are numbered 1 through 8.\r\n - The vertical columns of squares, called files, are labeled A through H.\r\n\r\n```\r\n   A B C D E F G H\r\n 8 # _ _ _ # _ _ # 8\r\n 7 _ _ _ _ _ _ _ _ 7\r\n 6 _ _ _ _ # _ _ # 6\r\n 5 _ # _ _ _ _ _ # 5\r\n 4 _ _ _ _ _ _ # # 4\r\n 3 # _ # _ _ _ _ # 3\r\n 2 _ _ _ _ _ _ _ # 2\r\n 1 # _ _ _ _ _ _ # 1\r\n   A B C D E F G H\r\n```\r\n\r\n## 1. Given a Chessboard and a File, count how many squares are occupied\r\n\r\nImplement the `CountInFile(board Chessboard, file string) int` function.\r\nIt should count the total number of occupied squares by ranging over a map. Return an integer.\r\nReturn a count of zero (`0`) if the given file cannot be found in the map.\r\n\r\n```go\r\nCountInFile(board, \"A\")\r\n// => 3\r\n```\r\n\r\n## 2. Given a Chessboard and a Rank, count how many squares are occupied\r\n\r\nImplement the `CountInRank(board Chessboard, rank int) int` function.\r\nIt should count the total number of occupied squares by ranging over the given rank. Return an integer.\r\nReturn a count of zero (`0`) if the given rank is not a valid one (not between `1` and `8`, inclusive).\r\n\r\n```go\r\nCountInRank(board, 2)\r\n// => 1\r\n```\r\n\r\n## 3. Count how many squares are present in the given chessboard\r\n\r\nImplement the `CountAll(board Chessboard) int` function.\r\nIt should count how many squares are present in the chessboard and returns\r\nan integer. Since you don't need to check the content of the squares,\r\nconsider using range omitting both `index` and `value`.\r\n\r\n```go\r\nCountAll(board)\r\n// => 64\r\n```\r\n\r\n## 4. Count how many squares are occupied in the given chessboard\r\n\r\nImplement the `CountOccupied(board Chessboard) int` function.\r\nIt should count how many squares are occupied in the chessboard.\r\nReturn an integer.\r\n\r\n```go\r\nCountOccupied(board)\r\n// => 15\r\n```\r\n",
    "hints": "# Hints\r\n\r\n## General\r\n\r\n- An [integer value][integers] can be defined as one or more consecutive digits.\r\n- A [map value][maps] stores key-value data\r\n\r\n## 1. Given a Chessboard and a File, count how many squares are occupied\r\n\r\n- You can iterate a [map][maps]\r\n- Check if the value is true. If it is increment. This is to count pieces.\r\n- You have to [explicitly return an integer][return] from a function.\r\n\r\n## 2. Given a Chessboard and a Rank, count how many squares are occupied\r\n\r\n- You'll first need to check the rank is within range.\r\n- Loop over the chessboard.\r\n- Add one if the square is occupied.\r\n\r\n## 3. Count how many squares are present in the given chessboard\r\n\r\n- There are many ways to solve this.\r\n- This should return how many squares are configured in a chess-board.\r\n\r\n## 4. Count how many squares are occupied in the given chessboard\r\n\r\n- Get the CountInFile for all files in the chessboard.\r\n\r\n[functions]: https://golang.org/ref/spec#Function_declarations\r\n[return]: https://golang.org/ref/spec#Return_statements\r\n[operators]: https://golang.org/ref/spec#Operators\r\n[integers]: https://golang.org/ref/spec#Integer_literals\r\n[calls]: https://golang.org/ref/spec#Calls\r\n[maps]: /tracks/go/concepts/maps\r\n"
  },
  "starter_code": "package chessboard\r\n\r\n// Declare a type named File which stores if a square is occupied by a piece - this will be a slice of bools\r\n\r\n// Declare a type named Chessboard which contains a map of eight Files, accessed with keys from \"A\" to \"H\"\r\n\r\n// CountInFile returns how many squares are occupied in the chessboard,\r\n// within the given file.\r\nfunc CountInFile(cb Chessboard, file string) int {\r\n\tpanic(\"Please implement CountInFile()\")\r\n}\r\n\r\n// CountInRank returns how many squares are occupied in the chessboard,\r\n// within the given rank.\r\nfunc CountInRank(cb Chessboard, rank int) int {\r\n\tpanic(\"Please implement CountInRank()\")\r\n}\r\n\r\n// CountAll should count how many squares are present in the chessboard.\r\nfunc CountAll(cb Chessboard) int {\r\n\tpanic(\"Please implement CountAll()\")\r\n}\r\n\r\n// CountOccupied returns how many squares are occupied in the chessboard.\r\nfunc CountOccupied(cb Chessboard) int {\r\n\tpanic(\"Please implement CountOccupied()\")\r\n}\r\n",
  "tests": "package chessboard\r\n\r\nimport (\r\n\t\"fmt\"\r\n\t\"testing\"\r\n)\r\n\r\n// newChessboard return a *Chessboard for tests\r\n//\r\n//   A B C D E F G H\r\n// 8 # _ _ _ # _ _ # 8\r\n// 7 _ _ _ _ _ _ _ _ 7\r\n// 6 _ _ _ _ # _ _ # 6\r\n// 5 _ # _ _ _ _ _ # 5\r\n// 4 _ _ _ _ _ _ # # 4\r\n// 3 # _ # _ _ _ _ # 3\r\n// 2 _ _ _ _ _ _ _ # 2\r\n// 1 # _ _ _ _ _ _ # 1\r\n//   A B C D E F G H\r\n\r\nfunc newChessboard() Chessboard {\r\n\treturn Chessboard{\r\n\t\t\"A\": File{true, false, true, false, false, false, false, true},\r\n\t\t\"B\": File{false, false, false, false, true, false, false, false},\r\n\t\t\"C\": File{false, false, true, false, false, false, false, false},\r\n\t\t\"D\": File{false, false, false, false, false, false, false, false},\r\n\t\t\"E\": File{false, false, false, false, false, true, false, true},\r\n\t\t\"F\": File{false, false, false, false, false, false, false, false},\r\n\t\t\"G\": File{false, false, false, true, false, false, false, false},\r\n\t\t\"H\": File{true, true, true, true, true, true, false, true},\r\n\t}\r\n}\r\n\r\nfunc TestCountInFile(t *testing.T) {\r\n\tcb := newChessboard()\r\n\ttestCases := []struct {\r\n\t\tin       string\r\n\t\texpected int\r\n\t}{\r\n\t\t{in: \"A\", expected: 3},\r\n\t\t{in: \"B\", expected: 1},\r\n\t\t{in: \"C\", expected: 1},\r\n\t\t{in: \"D\", expected: 0},\r\n\t\t{in: \"E\", expected: 2},\r\n\t\t{in: \"F\", expected: 0},\r\n\t\t{in: \"G\", expected: 1},\r\n\t\t{in: \"H\", expected: 7},\r\n\t\t{in: \"Z\", expected: 0},\r\n\t}\r\n\tfor _, test := range testCases {\r\n\t\tt.Run(fmt.Sprintf(\"Count of occupied squares in file %s\", test.in), func(t *testing.T) {\r\n\t\t\tif got := CountInFile(cb, test.in); got != test.expected {\r\n\t\t\t\tt.Errorf(\"CountInFile(chessboard, %q) = %d, want: %d\", test.in, got, test.expected)\r\n\t\t\t}\r\n\t\t})\r\n\t}\r\n}\r\n\r\nfunc TestCountInRank(t *testing.T) {\r\n\tcb := newChessboard()\r\n\ttestCases := []struct {\r\n\t\tin       int\r\n\t\texpected int\r\n\t}{\r\n\t\t{in: 1, expected: 2},\r\n\t\t{in: 2, expected: 1},\r\n\t\t{in: 3, expected: 3},\r\n\t\t{in: 4, expected: 2},\r\n\t\t{in: 5, expected: 2},\r\n\t\t{in: 6, expected: 2},\r\n\t\t{in: 7, expected: 0},\r\n\t\t{in: 8, expected: 3},\r\n\t\t// cases not between 1 and 8, inclusive\r\n\t\t{in: 100, expected: 0},\r\n\t\t{in: 0, expected: 0},\r\n\t\t{in: -1, expected: 0},\r\n\t\t{in: -100, expected: 0},\r\n\t}\r\n\tfor _, test := range testCases {\r\n\t\tt.Run(fmt.Sprintf(\"Count of occupied squares in rank %d\", test.in), func(t *testing.T) {\r\n\t\t\tif got := CountInRank(cb, test.in); got != test.expected {\r\n\t\t\t\tt.Errorf(\"CountInRank(chessboard, %d) = %d, want: %d\", test.in, got, test.expected)\r\n\t\t\t}\r\n\t\t})\r\n\t}\r\n}\r\n\r\nfunc TestCountAll(t *testing.T) {\r\n\tcb := newChessboard()\r\n\texpected := 64\r\n\tif got := CountAll(cb); got != expected {\r\n\t\tt.Errorf(\"CountAll(chessboard) = %d, want: %d\", got, expected)\r\n\t}\r\n}\r\n\r\nfunc TestCountOccupied(t *testing.T) {\r\n\tcb := newChessboard()\r\n\texpected := 15\r\n\tif got := CountOccupied(cb); got != expected {\r\n\t\tt.Errorf(\"CountOccupied(chessboard) = %d, want: %d\", got, expected)\r\n\t}\r\n}\r\n"
}