{
  "language": "go",
  "slug": "parsing-log-files",
  "docs": {
    "introduction": "# Introduction\r\n\r\nPackage [regexp][package-regexp] offers support for regular expressions in Go.\r\n\r\n## Syntax \r\n\r\nThe [syntax][regexp-syntax] of the regular expressions accepted is the same general syntax used by Perl, Python, and other languages. \r\n\r\nBoth the search patterns and the input texts are interpreted as UTF-8.  \r\n\r\nWhen using backticks (\\`) to make strings, backslashes (`\\`)  don't have any special meaning and don't mark the beginning of special characters like tabs `\\t` or newlines `\\n`:\r\n\r\n```go\r\n\"\\t\\n\" // regular string literal with 2 characters: a tab and a newline\r\n`\\t\\n`// raw string literal with 4 characters: two backslashes, a 't', and an 'n'\r\n```\r\n\r\nBecause of this, using backticks is desirable to make regular expressions,\r\nbecause it means we don't need to escape backslashes:\r\n\r\n```go\r\n\"\\\\\" // string with a single backslash\r\n`\\\\` // string with 2 backslashes\r\n```\r\n\r\n## Compiling patterns - `RegExp` type\r\n\r\nTo use a regular expression, we first must compile the string pattern.\r\nCompilation here means taking the string pattern of the regular expression and converting it into an internal representation that is easier to work with.\r\nWe only need to compile each pattern once, after that we can use the compiled version of the regular expression many times.\r\nThe type `regexp.Regexp` represents a compiled regular expression.\r\nWe can compile a string pattern into a `regexp.Regexp` using the function  `regexp.Compile`.\r\nThis function returns `nil` and an error if compilation failed:\r\n\r\n```go\r\nre, err := regexp.Compile(`(a|b)+`)\r\nfmt.Println(re, err) // => (a|b)+ <nil>\r\nre, err = regexp.Compile(`a|b)+`)\r\nfmt.Println(re, err) // => <nil> error parsing regexp: unexpected ): `a|b)+`\r\n```\r\n\r\nFunction `MustCompile` is a convenient alternative to `Compile`: \r\n\r\n```go \r\nre = regexp.MustCompile(`[a-z]+\\d*`)\r\n```\r\n\r\nUsing this function, there is no need to handle an error. \r\n\r\n~~~~exercism/caution\r\n `MustCompile` should only be used when we know for sure the pattern does compile, as otherwise the program will panic.\r\n ~~~~\r\n \r\n ## Regular expression methods\r\n \r\nThere are 16 methods of `Regexp` that match a regular expression and identify the matched text.\r\nTheir names are matched by this regular expression:\r\n\r\n```text\r\nFind(All)?(String)?(Submatch)?(Index)?\r\n```\r\n\r\n* If `All` is present, the routine matches successive non-overlapping matches of the entire expression.\r\n* If `String` is present, the argument is a string; otherwise it is a slice of bytes; return values are adjusted as appropriate. \r\n* If `Submatch` is present, the return value is a slice identifying the successive submatches of the expression.\r\n* If `Index` is present, matches and submatches are identified by byte index pairs within the input string.\r\n\r\nThere are also methods for:\r\n\r\n* replacing matches of regular expressions with replacement strings and\r\n* splitting of strings separated by regular expressions.\r\n\r\nAll-in-all, the `regexp` package defines more than 40 functions and methods.\r\nWe will demonstrate the use of a few methods below.\r\nPlease see the [API documentation][package-regexp] for details of these and other functions.\r\n \r\n### `MatchString` Examples \r\n\r\nMethod `MatchString` reports whether a string contains any match of a regular expression.\r\n\r\n```go\r\nre = regexp.MustCompile(`[a-z]+\\d*`)\r\nb = re.MatchString(\"[a12]\")       // => true\r\nb = re.MatchString(\"12abc34(ef)\") // => true\r\nb = re.MatchString(\" abc!\")       // => true\r\nb = re.MatchString(\"123 456\")     // => false    \r\n```\r\n\r\n### `FindString` Examples \r\n\r\nMethod `FindString` returns a string holding the text of the leftmost match of the regular expression.\r\n\r\n```go\r\nre = regexp.MustCompile(`[a-z]+\\d*`)\r\ns = re.FindString(\"[a12]\")       // => \"a12\"\r\ns = re.FindString(\"12abc34(ef)\") // => \"abc34\"\r\ns = re.FindString(\" abc!\")       // => \"abc\"\r\ns = re.FindString(\"123 456\")     // => \"\"\r\n```\r\n\r\n### `FindStringSubmatch` Examples\r\n\r\nMethod `FindStringSubmatch` returns a slice of strings holding the text of the leftmost match of the regular expression and the matches, if any, of its subexpressions.\r\nThis can be used to identify the strings matching capturing groups.\r\nA return value of `nil` indicates no match.\r\n\r\n```go \r\nre = regexp.MustCompile(`[a-z]+(\\d*)`)\r\nsl = re.FindStringSubmatch(\"[a12]\")       // => []string{\"a12\",\"12\"}\r\nsl = re.FindStringSubmatch(\"12abc34(ef)\") // => []string{\"abc34\",\"34\"}\r\nsl = re.FindStringSubmatch(\" abc!\")       // => []string{\"abc\",\"\"}\r\nsl = re.FindStringSubmatch(\"123 456\")     // => <nil>\r\n```\r\n\r\n### `ReplaceAllString` Examples\r\n\r\nMethod `re.ReplaceAllString(src,repl)` returns a copy of `src`, replacing matches of the regular expression `re` with the replacement string `repl`.\r\n\r\n```go\r\nre = regexp.MustCompile(`[a-z]+\\d*`)\r\ns = re.ReplaceAllString(\"[a12]\", \"X\")       // => \"[X]\"\r\ns = re.ReplaceAllString(\"12abc34(ef)\", \"X\") // => \"12X(X)\"\r\ns = re.ReplaceAllString(\" abc!\", \"X\")       // => \" X!\"\r\ns = re.ReplaceAllString(\"123 456\", \"X\")     // => \"123 456\"\r\n```\r\n \r\n ### `Split` Examples\r\n \r\nMethod `re.Split(s,n)` slices a text `s` into substrings separated by the expression and returns a slice of the substrings between those expression matches.\r\nThe count `n` determines the maximal number of substrings to return.\r\nIf `n<0`, the method returns all substrings.\r\n\r\n```go\r\nre = regexp.MustCompile(`[a-z]+\\d*`)\r\nsl = re.Split(\"[a12]\", -1)      // => []string{\"[\",\"]\"}\r\nsl = re.Split(\"12abc34(ef)\", 2) // => []string{\"12\",\"(ef)\"}\r\nsl = re.Split(\" abc!\", -1)      // => []string{\" \",\"!\"}\r\nsl = re.Split(\"123 456\", -1)    // => []string{\"123 456\"}\r\n```\r\n  \r\n[package-regexp]: https://pkg.go.dev/regexp\r\n[regexp-syntax]: https://pkg.go.dev/regexp/syntax\r\n",
    "instructions": "# Instructions\r\n\r\nThis exercise addresses the parsing of log files.\r\n\r\nAfter a recent security review you have been asked to clean up the organization's archived log files.\r\n\r\nAll strings passed to the functions are guaranteed to be non-null and without leading and trailing spaces.\r\n\r\n## 1. Identify garbled log lines\r\n\r\nYou need some idea of how many log lines in your archive do not comply with current standards.\r\nYou believe that a simple test reveals whether a log line is valid.\r\nTo be considered valid a line should begin with one of the following strings:\r\n\r\n- [TRC]\r\n- [DBG]\r\n- [INF]\r\n- [WRN]\r\n- [ERR]\r\n- [FTL]\r\n\r\nImplement the `IsValidLine` function to return `false` if a string is not valid otherwise `true`.\r\n\r\n```go \r\nIsValidLine(\"[ERR] A good error here\")\r\n// => true\r\nIsValidLine(\"Any old [ERR] text\")\r\n// => false\r\nIsValidLine(\"[BOB] Any old text\")\r\n// => false\r\n```\r\n\r\n## 2. Split the log line\r\n\r\nA new team has joined the organization, and you find their log files are using a strange separator for \"fields\".\r\nInstead of something sensible like a colon \":\" they use a string such as \"<--->\" or \"<=>\" (because it's prettier) in fact any string that has a first character of \"<\" and a last character of \">\" and any combination of the following characters \"~\", \"\\*\", \"=\" and \"-\" in between.\r\n\r\nImplement the `SplitLogLine` function that takes a line and returns an array of strings each of which contains a field.\r\n\r\n```go\r\nSplitLogLine(\"section 1<*>section 2<~~~>section 3\")\r\n// => []string{\"section 1\", \"section 2\", \"section 3\"},\r\n```\r\n\r\n## 3. Count the number of lines containing `password` in quoted text\r\n\r\nThe team needs to know about references to passwords in quoted text so that they can be examined manually.\r\n\r\nImplement the `CountQuotedPasswords` function to provide an indication of the likely scale of the manual exercise.\r\n\r\nIdentify log lines where the string \"password\", which may be in any combination of upper or lower case, is surrounded by quotation marks.\r\nYou should account for the possibility of additional content between the quotation marks before and after \"password\".\r\nEach line will contain at most two quotation marks.\r\n\r\nLines passed to the routine may or may not be valid as defined in task 1.\r\nWe process them in the same way, whether or not they are valid.\r\n\r\n```go\r\nlines := []string{\r\n    `[INF] passWord`, // contains 'password' but not surrounded by quotation marks\r\n    `\"passWord\"`,  // count this one\r\n    `[INF] User saw error message \"Unexpected Error\" on page load.`, // does not contain 'password'\r\n    `[INF] The message \"Please reset your password\" was ignored by the user`, // count this one \r\n}\r\n// => 2\r\n```\r\n\r\n## 4. Remove artifacts from log\r\n\r\nYou have found that some upstream processing of the logs has been scattering the text \"end-of-line\" followed by a line number (without an intervening space) throughout the logs.\r\n\r\nImplement the `RemoveEndOfLineText` function to take a string and remove the end-of-line text and return a \"clean\" string.\r\n\r\nLines not containing end-of-line text should be returned unmodified.\r\n\r\nJust remove the end of line string. Do not attempt to adjust the whitespaces.\r\n\r\n```go\r\nRemoveEndOfLineText(\"[INF] end-of-line23033 Network Failure end-of-line27\")\r\n// => \"[INF]  Network Failure \"\r\n```\r\n\r\n## 5. Tag lines with user names\r\n\r\nYou have noticed that some of the log lines include sentences that refer to users.\r\nThese sentences always contain the string `\"User\"`, followed by one or more space characters, and then a user name.\r\nYou decide to tag such lines.\r\n\r\nImplement a function `TagWithUserName` that processes log lines:\r\n\r\n- Lines that do not contain the string `\"User \"` remain unchanged.\r\n- For lines that contain the string `\"User \"`, prefix the line with `[USR]` followed by the user name.\r\n \r\nFor example:\r\n\r\n```go\r\nresult := TagWithUserName([]string{\r\n    \"[WRN] User James123 has exceeded storage space.\",\r\n\t\"[WRN] Host down. User   Michelle4 lost connection.\",\r\n\t\"[INF] Users can login again after 23:00.\",\r\n\t\"[DBG] We need to check that user names are at least 6 chars long.\",\r\n     \r\n}) \r\n// => []string {\r\n//  \"[USR] James123 [WRN] User James123 has exceeded storage space.\",\r\n//  \"[USR] Michelle4 [WRN] Host down. User   Michelle4 lost connection.\",\r\n//  \"[INF] Users can login again after 23:00.\",\r\n//  \"[DBG] We need to check that user names are at least 6 chars long.\"\r\n// }\r\n```\r\n\r\nYou can assume that: \r\n\r\n- User names are followed by at least one whitespace character in the log.\r\n- There is at most one occurrence of the string `\"User \"` in each line.\r\n- User names are non-empty strings that do not contain whitespace.\r\n\r\n \r\n",
    "hints": "# General\r\n\r\n- API documentation: [package regexp][package-regexp]\r\n- Regular expression syntax: [regexp/syntax][regexp-syntax]\r\n- Website [regex101.com][regex101] has an online regular expression tester.\r\n- It is recommended to write regular expressions as [raw string literals][raw-string-literals] enclosed by backticks.\r\n\r\n## 1. Identify garbled log lines\r\n\r\n- Function [regexp.MatchString][fun-match-string] or method [MatchString][method-match-string] could be useful here.\r\n- In a regular expression, the character `^` matches the beginning of a line/string.\r\n\r\n## 2. Split the log line\r\n\r\n- Method [Split][regexp-split] could be useful here.\r\n  \r\n## 3. Count the number of lines containing `password` in quoted text\r\n \r\n- You can make expression matching case sensitive by prefixing the regular expression with `(?i)`.\r\nThis will set the `i` flag.  See [this tutorial][yourbasic-i-flag].\r\n\r\n## 4. Remove artifacts from log\r\n\r\n- Method [ReplaceAllString][replace-all-string] could be useful here.\r\n\r\n## 5. Tag lines with user names\r\n \r\n- Method [FindStringSubmatch][find-string-submatch] could be useful here.\r\n\r\n[raw-string-literals]: https://yourbasic.org/golang/regexp-cheat-sheet/#raw-strings\r\n[package-regexp]: https://pkg.go.dev/regexp\r\n[regexp-syntax]: https://pkg.go.dev/regexp/syntax\r\n[regex101]: https://regex101.com/\r\n[fun-re-match-string]: https://pkg.go.dev/regexp#MatchString\r\n[method-match-string]: https://pkg.go.dev/regexp#Regexp.MatchString\r\n[regexp-split]: https://pkg.go.dev/regexp#Regexp.Split\r\n[yourbasic-i-flag]: https://yourbasic.org/golang/regexp-cheat-sheet/#case-insensitive-and-multiline-matches\r\n[replace-all-string]: https://pkg.go.dev/regexp#Regexp.ReplaceAllString\r\n[find-string-submatch]: https://pkg.go.dev/regexp#Regexp.FindStringSubmatch"
  },
  "starter_code": "package parsinglogfiles\r\n\r\nfunc IsValidLine(text string) bool {\r\n\tpanic(\"Please implement the IsValidLine function\")\r\n}\r\n\r\nfunc SplitLogLine(text string) []string {\r\n\tpanic(\"Please implement the SplitLogLine function\")\r\n}\r\n\r\nfunc CountQuotedPasswords(lines []string) int {\r\n\tpanic(\"Please implement the CountQuotedPasswords function\")\r\n}\r\n\r\nfunc RemoveEndOfLineText(text string) string {\r\n\tpanic(\"Please implement the RemoveEndOfLineText function\")\r\n}\r\n\r\nfunc TagWithUserName(lines []string) []string {\r\n\tpanic(\"Please implement the TagWithUserName function\")\r\n}\r\n",
  "tests": "package parsinglogfiles\r\n\r\nimport \"testing\"\r\n\r\nfunc TestIsValidLine(t *testing.T) {\r\n\ttests := []struct {\r\n\t\tdescription string\r\n\t\ttext        string\r\n\t\texpected    bool\r\n\t}{\r\n\t\t{\r\n\t\t\tdescription: \"Valid ERR message\",\r\n\t\t\ttext:        \"[ERR] A good error here\",\r\n\t\t\texpected:    true,\r\n\t\t},\r\n\t\t{\r\n\t\t\tdescription: \"Valid INF message\",\r\n\t\t\ttext:        \"[INF] The latest information\",\r\n\t\t\texpected:    true,\r\n\t\t},\r\n\t\t{\r\n\t\t\tdescription: \"Invalid ERR message\",\r\n\t\t\ttext:        \"Any old [ERR] text\",\r\n\t\t\texpected:    false,\r\n\t\t},\r\n\t\t{\r\n\t\t\tdescription: \"Invalid INF message\",\r\n\t\t\ttext:        \"bad start to [INF] Message\",\r\n\t\t\texpected:    false,\r\n\t\t},\r\n\t\t{\r\n\t\t\tdescription: \"Invalid tag\",\r\n\t\t\ttext:        \"[BOB] Any old text\",\r\n\t\t\texpected:    false,\r\n\t\t},\r\n\t\t{\r\n\t\t\tdescription: \"Line with less characters than 5\",\r\n\t\t\ttext:        \"text\",\r\n\t\t\texpected:    false,\r\n\t\t},\r\n\t\t{\r\n\t\t\tdescription: \"Empty line\",\r\n\t\t\ttext:        \"\",\r\n\t\t\texpected:    false,\r\n\t\t},\r\n\t}\r\n\tfor _, tt := range tests {\r\n\t\tt.Run(tt.description, func(t *testing.T) {\r\n\t\t\tgot := IsValidLine(tt.text)\r\n\t\t\twant := tt.expected\r\n\t\t\tif want != got {\r\n\t\t\t\tt.Fatalf(\"expected: %v, got: %v\", want, got)\r\n\t\t\t}\r\n\t\t})\r\n\t}\r\n}\r\n\r\nfunc TestSplitLogLine(t *testing.T) {\r\n\ttests := []struct {\r\n\t\tdescription string\r\n\t\ttext        string\r\n\t\texpected    []string\r\n\t}{\r\n\t\t{\r\n\t\t\tdescription: \"three sections\",\r\n\t\t\ttext:        \"section 1<*>section 2<~~~>section 3\",\r\n\t\t\texpected:    []string{\"section 1\", \"section 2\", \"section 3\"},\r\n\t\t},\r\n\t\t{\r\n\t\t\tdescription: \"three sections with different symbols inside angular brackets\",\r\n\t\t\ttext:        \"section 1<=>section 2<-*~*->section 3\",\r\n\t\t\texpected:    []string{\"section 1\", \"section 2\", \"section 3\"},\r\n\t\t},\r\n\t\t{\r\n\t\t\tdescription: \"two sections with no characters between angular brackets\",\r\n\t\t\ttext:        \"section 1<>section 2\",\r\n\t\t\texpected:    []string{\"section 1\", \"section 2\"},\r\n\t\t},\r\n\t\t{\r\n\t\t\tdescription: \"single section with some angular brackets\",\r\n\t\t\ttext:        \"<start> <end>\",\r\n\t\t\texpected:    []string{\"<start> <end>\"},\r\n\t\t},\r\n\t\t{\r\n\t\t\tdescription: \"empty text\",\r\n\t\t\ttext:        \"\",\r\n\t\t\texpected:    []string{\"\"},\r\n\t\t},\r\n\t}\r\n\tfor _, tt := range tests {\r\n\t\tt.Run(tt.description, func(t *testing.T) {\r\n\t\t\tgot := SplitLogLine(tt.text)\r\n\t\t\twant := tt.expected\r\n\t\t\tif !stringSliceEqual(want, got) {\r\n\t\t\t\tt.Fatalf(\"expected: %v, got: %v\", want, got)\r\n\t\t\t}\r\n\t\t})\r\n\t}\r\n}\r\n\r\nfunc TestCountQuotedPasswords(t *testing.T) {\r\n\ttests := []struct {\r\n\t\tdescription string\r\n\t\tlines       []string\r\n\t\texpected    int\r\n\t}{\r\n\t\t{\r\n\t\t\tdescription: \"text with two matches\",\r\n\t\t\tlines: []string{\r\n\t\t\t\t``,\r\n\t\t\t\t`[INF] passWord`,\r\n\t\t\t\t`\"passWord\"`,\r\n\t\t\t\t`[INF] User saw error message \"Unexpected Error\" on page load.`,\r\n\t\t\t\t`[INF] The message \"Please reset your password\" was ignored by the user`,\r\n\t\t\t},\r\n\t\t\texpected: 2,\r\n\t\t},\r\n\t\t{\r\n\t\t\tdescription: \"text with no matches\",\r\n\t\t\tlines: []string{\r\n\t\t\t\t`passWord\"passWor\"`,\r\n\t\t\t},\r\n\t\t\texpected: 0,\r\n\t\t},\r\n\t}\r\n\tfor _, tt := range tests {\r\n\t\tt.Run(tt.description, func(t *testing.T) {\r\n\t\t\tgot := CountQuotedPasswords(tt.lines)\r\n\t\t\twant := tt.expected\r\n\t\t\tif want != got {\r\n\t\t\t\tt.Fatalf(\"expected: %v, got: %v\", want, got)\r\n\t\t\t}\r\n\t\t})\r\n\t}\r\n}\r\n\r\nfunc TestRemoveEndOfLineText(t *testing.T) {\r\n\ttests := []struct {\r\n\t\tdescription string\r\n\t\ttext        string\r\n\t\texpected    string\r\n\t}{\r\n\t\t{\r\n\t\t\tdescription: \"INF message\",\r\n\t\t\ttext:        \"[INF] end-of-line23033 Network Failure end-of-line27\",\r\n\t\t\texpected:    \"[INF]  Network Failure \",\r\n\t\t},\r\n\t}\r\n\tfor _, tt := range tests {\r\n\t\tt.Run(tt.description, func(t *testing.T) {\r\n\t\t\tgot := RemoveEndOfLineText(tt.text)\r\n\t\t\twant := tt.expected\r\n\t\t\tif want != got {\r\n\t\t\t\tt.Fatalf(\"expected: %v, got: %v\", want, got)\r\n\t\t\t}\r\n\t\t})\r\n\t}\r\n}\r\n\r\nfunc TestTagWithUserName(t *testing.T) {\r\n\ttests := []struct {\r\n\t\tdescription string\r\n\t\tlines       []string\r\n\t\texpected    []string\r\n\t}{\r\n\t\t{\r\n\t\t\tdescription: \"INF message\",\r\n\t\t\tlines: []string{\r\n\t\t\t\t\"[WRN] User James123 has exceeded storage space.\",\r\n\t\t\t\t\"[WRN] Host down. User   Michelle4 lost connection.\",\r\n\t\t\t\t\"[INF] Users can login again after 23:00.\",\r\n\t\t\t\t\"[DBG] We need to check that user names are at least 6 chars long.\",\r\n\t\t\t},\r\n\t\t\texpected: []string{\r\n\t\t\t\t\"[USR] James123 [WRN] User James123 has exceeded storage space.\",\r\n\t\t\t\t\"[USR] Michelle4 [WRN] Host down. User   Michelle4 lost connection.\",\r\n\t\t\t\t\"[INF] Users can login again after 23:00.\",\r\n\t\t\t\t\"[DBG] We need to check that user names are at least 6 chars long.\",\r\n\t\t\t},\r\n\t\t},\r\n\t}\r\n\tfor _, tt := range tests {\r\n\t\tt.Run(tt.description, func(t *testing.T) {\r\n\t\t\tgot := TagWithUserName(tt.lines)\r\n\t\t\twant := tt.expected\r\n\t\t\tif !stringSliceEqual(want, got) {\r\n\t\t\t\tfor i := range got {\r\n\t\t\t\t\tif want[i] != got[i] {\r\n\t\t\t\t\t\tt.Fatalf(\"expected: %v, got: %v\", want[i], got[i])\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\tt.Fatalf(\"expected: %v, got: %v\", want, got)\r\n\t\t\t}\r\n\t\t})\r\n\t}\r\n}\r\n\r\nfunc stringSliceEqual(a, b []string) bool {\r\n\tif len(a) != len(b) {\r\n\t\treturn false\r\n\t}\r\n\tif len(a) == 0 {\r\n\t\treturn true\r\n\t}\r\n\tfor i := range a {\r\n\t\tif a[i] != b[i] {\r\n\t\t\treturn false\r\n\t\t}\r\n\t}\r\n\treturn true\r\n}\r\n"
}