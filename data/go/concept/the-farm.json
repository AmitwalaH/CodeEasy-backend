{
  "language": "go",
  "slug": "the-farm",
  "docs": {
    "introduction": "# Introduction\r\n\r\n## The error interface\r\n\r\nError handling is **not** done via exceptions in Go.\r\nInstead, errors are normal _values_ of types that implement the built-in `error` interface.\r\nThe `error` interface is very minimal.\r\nIt contains only one method `Error()` that returns the error message as a string.\r\n\r\n```go\r\ntype error interface {\r\n  Error() string\r\n}\r\n```\r\n\r\nEvery time you define a function in which an error could happen during the execution that needs to reach the caller, you need to include `error` as one of the return types.\r\nIf the function has multiple return values, by convention `error` is always the last one.\r\n\r\n```go\r\nfunc DoSomething() (int, error) {\r\n  // ...\r\n}\r\n```\r\n\r\n## Creating and returning a simple error\r\n\r\nYou do not have to always implement the error interface yourself.\r\nTo create a simple error, you can use the `errors.New()` function that is part of the standard library package `errors`.\r\nThe only thing you need to pass in is the error message as a string, and `errors.New()` will take care of creating a value that contains your message and implements the `error` interface.\r\n\r\nIf the function returns an error, it is good practice to return the zero value for all other return parameters:\r\n\r\n```go\r\nfunc DoSomething() (SomeStruct, int, error) {\r\n  // ...\r\n  return SomeStruct{}, 0, errors.New(\"failed to calculate result\")\r\n}\r\n```\r\n\r\n~~~~exercism/caution\r\nYou should not assume that all functions return zero values for other return values if an error is present.\r\nIt is best practice to assume that it is not safe to use any of the other return values if an error occurred.\r\nThe only exceptions are cases where the documentation clearly states that other returns values are meaningful in case of an error.\r\n~~~~\r\n\r\nIf you want to use such a simple error in multiple places, you should declare a variable for the error instead of using `errors.New` in-line.\r\nBy convention, the name of the variable should start with `Err` or `err` (depending on whether it is exported or not).\r\nThese error variables are often called _sentinel errors_.\r\n\r\n```go\r\nimport \"errors\"\r\n\r\nvar ErrNotFound = errors.New(\"resource was not found\")\r\n\r\nfunc DoSomething() error {\r\n  // ...\r\n  return ErrNotFound\r\n}\r\n```\r\n\r\nReturn `nil` for the error to signal that there were no errors during the function execution:\r\n\r\n```go\r\nfunc Foo() (int, error) {\r\n  return 10, nil\r\n}\r\n```\r\n\r\n## Error checking\r\n\r\nIf you call a function that returns an error, it is common to store the error value in a variable called `err`.\r\nBefore you use the actual result of the function, you need to check that there was no error.\r\n\r\nTo avoid nesting the \"happy path\" of your code, error cases should be handled first.\r\nWe can use `==` and `!=` to compare the error against `nil` and we know there was an error when `err` is not `nil`.\r\n\r\n```go\r\nfunc processUserFile() error {\r\n\tfile, err := os.Open(\"./users.csv\")\r\n\tif err != nil {\r\n\t\treturn err\r\n\t}\r\n\r\n\t// do something with file\r\n}\r\n```\r\n\r\nMost of the time, the error will be returned up the function stack as shown in the example above.\r\nAnother way of handling the error could be to log it and continue with some other operation.\r\nIt is good practice to either return or log the error, never both.\r\n\r\nSince most functions in Go include an error as one of the return values, you will see/use the `if err != nil` pattern all over the place in Go code.\r\n\r\n## Custom error types\r\n\r\nIf you want your error to include more information than just the error message string, you can create a custom error type.\r\nAs mentioned before, everything that implements the `error` interface (i.e. has an `Error() string` method) can serve as an error in Go.\r\n\r\nUsually, a struct is used to create a custom error type.\r\nBy convention, custom error type names should end with `Error`.\r\nAlso, it is best to set up the `Error() string` method with a pointer receiver, see this [Stackoverflow comment][stackoverflow-errors] to learn about the reasoning.\r\nNote that this means you need to return a pointer to your custom error otherwise it will not count as `error` because the non-pointer value does not provide the `Error() string` method.\r\n\r\n```go\r\ntype MyCustomError struct {\r\n  message string\r\n  details string\r\n}\r\n\r\nfunc (e *MyCustomError) Error() string {\r\n  return fmt.Sprintf(\"%s, details: %s\", e.message, e.details)\r\n}\r\n\r\nfunc someFunction() error {\r\n  // ...\r\n  return &MyCustomError{\r\n    message: \"...\",\r\n    details: \"...\",\r\n  }\r\n}\r\n```\r\n\r\n[stackoverflow-errors]: https://stackoverflow.com/a/50333850\r\n",
    "instructions": "# Instructions\r\n\r\nThe day you waited so long finally came and you are now the proud owner of a beautiful farm in the Alps.\r\n\r\nYou still do not like waking up too early in the morning to feed your cows. \r\nBecause you are an excellent engineer, you build a food dispenser, the `FEED-M-ALL`.\r\n\r\nThe last thing required in order to finish your project, is a piece of code that calculates the amount of fodder that each cow should get.\r\nIt is important that each cow receives the same amount, you need to avoid conflicts.\r\nCows are very sensitive.\r\n\r\nLuckily, you don't need to work out all the formulas for calculating fodder amounts yourself.\r\nYou use some mysterious external library that you found on the internet.\r\nIt is supposed to result in the happiest cows.\r\nThe library exposes a type that fulfils the following interface.\r\nYou will rely on this in the code you write yourself.\r\n\r\n```go\r\ntype FodderCalculator interface {\r\n\tFodderAmount(int) (float64, error)\r\n\tFatteningFactor() (float64, error)\r\n}\r\n```\r\n\r\nAs you work on your code, you will improve the error handling to make it more robust and easier to debug later on when you use it in your daily farm life.\r\n\r\n## 1. Divide the food evenly\r\n\r\nFirst of all, you focus on writing the code that is needed to calculate the amount of fodder per cow.\r\n\r\nImplement a function `DivideFood` that accepts a `FodderCalculator` and a number of cows as an integer as arguments.\r\n*For this task, you assume the number of cows passed in is always greater than zero.*\r\nThe function should return the amount of food per cow as a `float64` or an error if one occurred.\r\n\r\nTo make the calculation, you first need to retrieve the total amount of fodder for all the cows.\r\nThis is done by calling the `FodderAmount` method and passing the number of cows.\r\nAdditionally, you need a factor that this amount needs to be multiplied with.\r\nYou get this factor via calling the `FatteningFactor` method.\r\nWith these two values and the number of cows, you can now calculate the amount of food per cow (as a `float64`).\r\nThat is what should be returned from the `DivideFood` function.\r\n\r\nIf one of the methods you call returns an error, the execution should stop and that error should be returned (as is) from the `DivideFood` function.\r\n\r\n```go\r\n// For this example, we assume FodderAmount returns 50\r\n// and FatteningFactor returns 1.5.\r\nDivideFood(fodderCalculator, 5)\r\n// => 15 <nil>\r\n\r\n// Now assuming FodderAmount returns an error with message \"something went wrong\".\r\nDivideFood(fodderCalculator, 5)\r\n// => 0 \"something went wrong\"\r\n```\r\n\r\n## 2. Check the number of cows\r\n\r\nWhile working on the first task above, you realized that the external library you use is not as high-quality as you thought it would be.\r\nFor example, it cannot properly handle invalid inputs.\r\nYou want to work around this limitation by adding a check for the input value in your own code.\r\n\r\nWrite a function `ValidateInputAndDivideFood` that has the same signature as `DivideFood` above.\r\n\r\n- If the number of cows passed in is greater than 0, the function should call `DivideFood` and return the results of that call.\r\n- If the number of cows is 0 or less, the function should return an error with message `\"invalid number of cows\"`.\r\n\r\n```go\r\nValidateInputAndDivideFood(fodderCalculator, 5)\r\n// => 15 <nil>\r\n\r\nValidateInputAndDivideFood(fodderCalculator, -2)\r\n// => 0 \"invalid number of cows\"\r\n```\r\n\r\n## 3. Improve the error handling\r\n\r\nChecking the number of cows before passing it along was a good move but you are not quite happy with the unspecific error message.\r\nYou decide to do better by creating a custom error type called `InvalidCowsError`.\r\n\r\nThe custom error should hold the number of cows (`int`) and a custom message (`string`) and the `Error` method should serialize the data in the following format:\r\n```txt\r\n{number of cows} cows are invalid: {custom message}\r\n```\r\n\r\nEquipped with your custom error, implement a function `ValidateNumberOfCows` that accepts the number of cows as an integer and returns an error (or nil).\r\n\r\n- If the number of cows is less than 0, the function returns an `InvalidCowsError` with the custom message set to `\"there are no negative cows\"`.\r\n- If the number of cows is 0, the function returns an `InvalidCowsError` with the custom message set to `\"no cows don't need food\"`.\r\n- Otherwise, the function returns `nil` to indicate that the validation was successful.\r\n\r\n```go\r\nerr := ValidateNumberOfCows(-5)\r\nerr.Error()\r\n// => \"-5 cows are invalid: there are no negative cows\"\r\n```\r\n\r\nAfter the hard work of setting up this validation function, you notice it is already evening and you leave your desk to enjoy the sunset over the mountains.\r\nYou leave the task of actually adding the new validation function to your code for another day.",
    "hints": "# Hints\r\n\r\n## 1. Divide the food evenly\r\n\r\n- Start by writing the function signature of `DivideFood`.\r\n  It should accept 2 parameters of type `FodderCalculator` and `int` and return two values of types `float64` and `error`.\r\n  Revisit the [functions concept][concept-functions] if you need more information on how to define functions.\r\n- In the function body, call the `FodderAmount` [method][concept-methods] on `FodderCalculator` to fetch the default total amount of fodder for the cows.\r\n  It will return the actual result and an error.\r\n  Handle the error via an if-statement as it was explained in the introduction.\r\n- After that, call the `FatteningFactor` method and handle the error return value as before.\r\n- Now that you have the fodder amount and the factor, you can calculate the final result.\r\n  You need to divide the fodder by the number of cows (revisit [numbers] for hints on type conversion) and multiply with the factor. Check the introduction for what to return as the error value in case of success.\r\n\r\n## 2. Check the number of cows\r\n\r\n- `ValidateInputAndDivideFood` has the same function signature as `DivideFood`.\r\n- Since you want to return early in case of an error in Go, you first check whether the number of cows is less or equal than 0 with an if-statement.\r\n- If it is, you return an error that you created with `errors.New`.\r\n  Make sure the message matches the instructions.\r\n- If the number of cows is valid, you can proceed to call the existing `DivideFood` function from task 1.\r\n\r\n## 3. Improve the error handling\r\n\r\n- Start by creating the `InvalidCowsError` [struct][concept-structs] with two unexported fields that hold the number of cows and the message.\r\n- Next, define the `Error` method on that struct (with a pointer receiver). Revisit the exercise introduction for help on how to do this.\r\n- Now you can work on the `ValidateNumberOfCows` function.\r\n  Depending on the number of cows ([if-statement][concept-conditionals]), it should create and return a new instance of the `InvalidCowsError` and set the correct message while doing so.\r\n  If the number of cows was valid, `nil` should be returned.\r\n\r\n[concept-methods]: /tracks/go/concepts/methods\r\n[concept-functions]: /tracks/go/concepts/functions\r\n[concept-numbers]: /tracks/go/concepts/numbers\r\n[concept-structs]: /tracks/go/concepts/structs\r\n[concept-conditionals]:  /tracks/go/concepts/conditionals-if"
  },
  "starter_code": "package thefarm\r\n\r\n// TODO: define the 'DivideFood' function\r\n\r\n// TODO: define the 'ValidateInputAndDivideFood' function\r\n\r\n// TODO: define the 'ValidateNumberOfCows' function\r\n\r\n// Your first steps could be to read through the tasks, and create\r\n// these functions with their correct parameter lists and return types.\r\n// The function body only needs to contain `panic(\"\")`.\r\n//\r\n// This will make the tests compile, but they will fail.\r\n// You can then implement the function logic one by one and see\r\n// an increasing number of tests passing as you implement more\r\n// functionality.\r\n",
  "tests": "package thefarm\r\n\r\nimport (\r\n\t\"errors\"\r\n\t\"math\"\r\n\t\"reflect\"\r\n\t\"testing\"\r\n)\r\n\r\nconst precision = 1e-5\r\n\r\nvar (\r\n\terrDeterminingAmount = errors.New(\"amount could not be determined\")\r\n\terrDeterminingFactor = errors.New(\"factor could not be determined\")\r\n)\r\n\r\ntype testFodderCalculator struct {\r\n\tamount    float64\r\n\tamountErr error\r\n\tfactor    float64\r\n\tfactorErr error\r\n}\r\n\r\nfunc (fc testFodderCalculator) FodderAmount(int) (float64, error) {\r\n\treturn fc.amount, fc.amountErr\r\n}\r\n\r\nfunc (fc testFodderCalculator) FatteningFactor() (float64, error) {\r\n\treturn fc.factor, fc.factorErr\r\n}\r\n\r\n// testRunnerTaskID=1\r\nfunc TestDivideFood(t *testing.T) {\r\n\ttests := []struct {\r\n\t\tname             string\r\n\t\tfodderCalculator FodderCalculator\r\n\t\tcows             int\r\n\t\twantAmount       float64\r\n\t\twantErr          error\r\n\t}{\r\n\t\t{\r\n\t\t\tname: \"success, simple inputs\",\r\n\t\t\tfodderCalculator: testFodderCalculator{\r\n\t\t\t\tamount: 100,\r\n\t\t\t\tfactor: 1,\r\n\t\t\t},\r\n\t\t\tcows:       10,\r\n\t\t\twantAmount: 10,\r\n\t\t\twantErr:    nil,\r\n\t\t},\r\n\t\t{\r\n\t\t\tname: \"success, decimal inputs\",\r\n\t\t\tfodderCalculator: testFodderCalculator{\r\n\t\t\t\tamount: 60.5,\r\n\t\t\t\tfactor: 1.3,\r\n\t\t\t},\r\n\t\t\tcows:       5,\r\n\t\t\twantAmount: 15.73,\r\n\t\t\twantErr:    nil,\r\n\t\t},\r\n\t\t{\r\n\t\t\tname: \"error when retrieving fodder amount\",\r\n\t\t\tfodderCalculator: testFodderCalculator{\r\n\t\t\t\tamountErr: errDeterminingAmount,\r\n\t\t\t},\r\n\t\t\tcows:       10,\r\n\t\t\twantAmount: 0,\r\n\t\t\twantErr:    errDeterminingAmount,\r\n\t\t},\r\n\t\t{\r\n\t\t\tname: \"error when retrieving fattening factor\",\r\n\t\t\tfodderCalculator: testFodderCalculator{\r\n\t\t\t\tfactorErr: errDeterminingFactor,\r\n\t\t\t},\r\n\t\t\tcows:       10,\r\n\t\t\twantAmount: 0,\r\n\t\t\twantErr:    errDeterminingFactor,\r\n\t\t},\r\n\t}\r\n\r\n\tfor _, tt := range tests {\r\n\t\tt.Run(tt.name, func(t *testing.T) {\r\n\t\t\tgotAmount, gotErr := DivideFood(tt.fodderCalculator, tt.cows)\r\n\r\n\t\t\tif gotErr != tt.wantErr {\r\n\t\t\t\tmsg := \"expected error %q but got %q\\n\" +\r\n\t\t\t\t\t\"(if expected and actual look the same that means the message matches but the errors are not identical)\"\r\n\t\t\t\tt.Fatalf(msg, tt.wantErr, gotErr)\r\n\t\t\t}\r\n\r\n\t\t\tif math.Abs(gotAmount-tt.wantAmount) > precision {\r\n\t\t\t\tt.Fatalf(\"expected amount %v but got %v\", tt.wantAmount, gotAmount)\r\n\t\t\t}\r\n\t\t})\r\n\t}\r\n}\r\n\r\n// testRunnerTaskID=2\r\nfunc TestValidateInputAndDivideFood(t *testing.T) {\r\n\ttests := []struct {\r\n\t\tname             string\r\n\t\tfodderCalculator FodderCalculator\r\n\t\tcows             int\r\n\t\twantAmount       float64\r\n\t\twantErr          error\r\n\t}{\r\n\t\t{\r\n\t\t\tname: \"negative cows are invalid\",\r\n\t\t\tfodderCalculator: testFodderCalculator{\r\n\t\t\t\tamount: 10,\r\n\t\t\t\tfactor: 1,\r\n\t\t\t},\r\n\t\t\tcows:       -10,\r\n\t\t\twantAmount: 0,\r\n\t\t\twantErr:    errors.New(\"invalid number of cows\"),\r\n\t\t},\r\n\t\t{\r\n\t\t\tname: \"zero cows are invalid\",\r\n\t\t\tfodderCalculator: testFodderCalculator{\r\n\t\t\t\tamount: 10,\r\n\t\t\t\tfactor: 1,\r\n\t\t\t},\r\n\t\t\tcows:       0,\r\n\t\t\twantAmount: 0,\r\n\t\t\twantErr:    errors.New(\"invalid number of cows\"),\r\n\t\t},\r\n\t\t{\r\n\t\t\tname: \"success, simple inputs\",\r\n\t\t\tfodderCalculator: testFodderCalculator{\r\n\t\t\t\tamount: 100,\r\n\t\t\t\tfactor: 1,\r\n\t\t\t},\r\n\t\t\tcows:       10,\r\n\t\t\twantAmount: 10,\r\n\t\t\twantErr:    nil,\r\n\t\t},\r\n\t\t{\r\n\t\t\tname: \"success, decimal inputs\",\r\n\t\t\tfodderCalculator: testFodderCalculator{\r\n\t\t\t\tamount: 60.5,\r\n\t\t\t\tfactor: 1.3,\r\n\t\t\t},\r\n\t\t\tcows:       5,\r\n\t\t\twantAmount: 15.73,\r\n\t\t\twantErr:    nil,\r\n\t\t},\r\n\t\t{\r\n\t\t\tname: \"error when retrieving fodder amount\",\r\n\t\t\tfodderCalculator: testFodderCalculator{\r\n\t\t\t\tamountErr: errDeterminingAmount,\r\n\t\t\t},\r\n\t\t\tcows:       10,\r\n\t\t\twantAmount: 0,\r\n\t\t\twantErr:    errDeterminingAmount,\r\n\t\t},\r\n\t\t{\r\n\t\t\tname: \"error when retrieving fattening factor\",\r\n\t\t\tfodderCalculator: testFodderCalculator{\r\n\t\t\t\tfactorErr: errDeterminingFactor,\r\n\t\t\t},\r\n\t\t\tcows:       10,\r\n\t\t\twantAmount: 0,\r\n\t\t\twantErr:    errDeterminingFactor,\r\n\t\t},\r\n\t}\r\n\r\n\tfor _, tt := range tests {\r\n\t\tt.Run(tt.name, func(t *testing.T) {\r\n\t\t\tgotAmount, gotErr := ValidateInputAndDivideFood(tt.fodderCalculator, tt.cows)\r\n\r\n\t\t\tif tt.wantErr != nil && gotErr != nil && tt.wantErr.Error() != gotErr.Error() {\r\n\t\t\t\tt.Fatalf(\"expected error %q but got %q\", tt.wantErr, gotErr)\r\n\t\t\t}\r\n\r\n\t\t\tif tt.wantErr == nil && gotErr != nil {\r\n\t\t\t\tt.Fatalf(\"expected nil but got error %q\", gotErr)\r\n\t\t\t}\r\n\r\n\t\t\tif tt.wantErr != nil && gotErr == nil {\r\n\t\t\t\tt.Fatalf(\"expected error %q but got nil\", tt.wantErr)\r\n\t\t\t}\r\n\r\n\t\t\tif math.Abs(gotAmount-tt.wantAmount) > precision {\r\n\t\t\t\tt.Fatalf(\"expected amount %v but got %v\", tt.wantAmount, gotAmount)\r\n\t\t\t}\r\n\t\t})\r\n\t}\r\n}\r\n\r\n// testRunnerTaskID=3\r\nfunc TestValidateNumberOfCows(t *testing.T) {\r\n\ttests := []struct {\r\n\t\tname          string\r\n\t\tcows          int\r\n\t\terrorExpected bool\r\n\t\twantErrMsg    string\r\n\t}{\r\n\t\t{\r\n\t\t\tname:          \"big positive number of cows\",\r\n\t\t\tcows:          80,\r\n\t\t\terrorExpected: false,\r\n\t\t},\r\n\t\t{\r\n\t\t\tname:          \"small positive number of cows\",\r\n\t\t\tcows:          2,\r\n\t\t\terrorExpected: false,\r\n\t\t},\r\n\t\t{\r\n\t\t\tname:          \"big negative number of cows\",\r\n\t\t\tcows:          -20,\r\n\t\t\terrorExpected: true,\r\n\t\t\twantErrMsg:    \"-20 cows are invalid: there are no negative cows\",\r\n\t\t},\r\n\t\t{\r\n\t\t\tname:          \"small negative number of cows\",\r\n\t\t\tcows:          -1,\r\n\t\t\terrorExpected: true,\r\n\t\t\twantErrMsg:    \"-1 cows are invalid: there are no negative cows\",\r\n\t\t},\r\n\t\t{\r\n\t\t\tname:          \"zero cows\",\r\n\t\t\tcows:          0,\r\n\t\t\terrorExpected: true,\r\n\t\t\twantErrMsg:    \"0 cows are invalid: no cows don't need food\",\r\n\t\t},\r\n\t}\r\n\r\n\tfor _, tt := range tests {\r\n\t\tt.Run(tt.name, func(t *testing.T) {\r\n\t\t\tgotErr := ValidateNumberOfCows(tt.cows)\r\n\r\n\t\t\tif tt.errorExpected && gotErr == nil {\r\n\t\t\t\tt.Fatalf(\"an error was expected but got nil\")\r\n\t\t\t}\r\n\r\n\t\t\tif tt.errorExpected && tt.wantErrMsg != gotErr.Error() {\r\n\t\t\t\tt.Fatalf(\"want error %q but got %q\", tt.wantErrMsg, gotErr)\r\n\t\t\t}\r\n\r\n\t\t\tif !tt.errorExpected && gotErr != nil {\r\n\t\t\t\tt.Fatalf(\"expected nil but got %q\", gotErr)\r\n\t\t\t}\r\n\t\t})\r\n\t}\r\n}\r\n\r\n// testRunnerTaskID=3\r\nfunc TestValidateNumberOfCows_PointerReturned(t *testing.T) {\r\n\tgotErr := ValidateNumberOfCows(-10)\r\n\r\n\tif reflect.ValueOf(gotErr).Kind() != reflect.Ptr {\r\n\t\tt.Fatalf(\"expected pointer but got %v\", reflect.ValueOf(gotErr).Kind())\r\n\t}\r\n}\r\n"
}