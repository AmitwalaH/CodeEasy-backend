{
  "language": "go",
  "slug": "expenses",
  "docs": {
    "introduction": "# Introduction\r\n\r\nIn Go, functions are first-class values. This means that you can do with functions the same things you can do with all other values - assign functions to variables, pass them as arguments to other functions or even return functions from other functions. \r\n\r\nBelow we are creating two functions, `engGreeting` and `espGreeting` and we are assigning them to the variable `greeting`:\r\n\r\n```go\r\nimport \"fmt\"\r\n\r\nfunc engGreeting(name string) string {\r\n\treturn fmt.Sprintf(\"Hello %s, nice to meet you!\", name)\r\n}\r\n\r\nfunc espGreeting(name string) string {\r\n\treturn fmt.Sprintf(\"¡Hola %s, mucho gusto!\", name)\r\n}\r\n\r\ngreeting := engGreeting\t\t\t// greeting is a variable of type func(string) string\r\nfmt.Println(greeting(\"Alice\"))\t// Hello Alice, nice to meet you!\r\n\r\ngreeting = espGreeting\r\nfmt.Println(greeting(\"Alice\")) \t// ¡Hola Alice, mucho gusto!\r\n```\r\n\r\nFunction values provide an opportunity to parameterize functions not only with data but with behavior too.\r\nIn the following example, we are passing behavior to the `dialog` function via the `greetingFunc` parameter:\r\n\r\n```go\r\nfunc dialog(name string, greetingFunc func(string) string) {\r\n\tfmt.Println(greetingFunc(name))\r\n\tfmt.Println(\"I'm a dialog bot.\")\r\n}\r\n\r\nfunc espGreeting(name string) string {\r\n\treturn fmt.Sprintf(\"¡Hola %s, mucho gusto!\", name)\r\n}\r\n\r\ngreeting := espGreeting\r\ndialog(\"Alice\", greeting)\r\n// =>\r\n// ¡Hola Alice, mucho gusto!\r\n// I'm a dialog bot.\r\n```\r\n\r\nThe value of an uninitialized variable of function type is `nil`.\r\nTherefore, calling a `nil` function value causes a panic.\r\n\r\n```go\r\nvar dutchGreeting func(string) string\r\ndutchGreeting(\"Alice\") // panic: call of nil function\r\n```\r\n\r\nFunction values can be compared with `nil`. This can be useful to avoid unnecessary program panics.\r\n\r\n```go\r\nvar dutchGreeting func(string) string\r\nif dutchGreeting != nil {\r\n\tdutchGreeting(\"Alice\") // safe to call dutchGreeting\r\n}\r\n```\r\n\r\n## Function types\r\n\r\nUsing function values is possible thanks to the function types in Go. A function type denotes the set of all functions with the same sequence of parameter types and the same sequence of result types. User-defined types can be declared on top of function types. For instance, the `dialog` function from the previous examples can be updated as following:\r\n\r\n```go\r\ntype greetingFunc func(string) string\r\n\r\nfunc dialog(name string, f greetingFunc) {\r\n\tfmt.Println(f(name))\r\n\tfmt.Println(\"I'm a dialog bot.\")\r\n}\r\n```\r\n\r\n## Anonymous functions\r\n\r\nAnother powerful tool that is available thanks to first-class functions support is anonymous functions. Anonymous functions are defined at their point of use, without a name following the `func` keyword. Such functions have access to the variables of the enclosing function.\r\n\r\nFor example:\r\n\r\n```go\r\nfunc fib() func() int {\r\n\tvar n1, n2 int\r\n\r\n\treturn func() int {\r\n\t\tif n1 == 0 && n2 == 0 {\r\n\t\t\tn1 = 1\r\n\t\t} else {\r\n\t\t\tn1, n2 = n2, n1 + n2\r\n\t\t}\r\n\t\treturn n2\r\n\t}\r\n}\r\n\r\nnext := fib()\r\nfor i := 0; i < N; i++ {\r\n  fmt.Printf(\"F%d\\t= %4d\\n\", i, next())\r\n}\r\n```\r\n\r\nA call to `fib` declares the variables `n1` and `n2` and returns an anonymous function that, in turn, changes the values of these variables each time the function is called. Nth calls of the anonymous function return the Nth number of the Fibonacci sequence starting from 0. The anonymous inner function has access to the local variables (`n1` and `n2`) of the enclosing function `fib`. This is a great way to have function values keep state between calls. We say that the anonymous function is a closure of the variables `n1` and `n2`. [Closures][closure] are widely used in programming and you might see other languages supporting them.\r\n\r\n[closure]: https://en.wikipedia.org/wiki/Closure_(computer_programming)\r\n",
    "instructions": "# Instructions\r\n\r\nBob is a financial adviser and helps people to manage their expenses. Bob's clients send expenses records for him to analyze. Bob has records for the previous periods so he can see changes in spending. Bob does not like calendars and uses *Bob epoch* instead of dates. Bob epoch is the number of days elapsed since Bob's client started their activity.\r\n\r\nIn this exercise, you are going to build a program to help Bob manage and analyze the expenses of his clients.\r\n\r\nBob works with `Record`s and `DaysPeriod`s.\r\n\r\nA `Record` represents an expense record that contains the day in which the expense was made, the money spent, and the category of the expense.\r\n\r\n```go\r\n// Record represents an expense record.\r\ntype Record struct {\r\n\tDay         int\r\n\tAmount      float64\r\n\tCategory    string\r\n}\r\n```\r\n\r\nA `DaysPeriod` represents a range of days and includes all days from the day `From` up to the day `To`.\r\nBoth ends are included in the range.\r\n\r\n```go\r\n// DaysPeriod represents a period of days.\r\ntype DaysPeriod struct {\r\n\tFrom int\r\n\tTo   int\r\n}\r\n\r\np := DaysPeriod{From: 1, To: 31}\r\n// p represents all days from the day 1 to the day 31:\r\n//  - days 1, 20, 16 and 31 are examples of days that are included\r\n//    in the range of time specified by p\r\n//  - days 50 and 40 are examples of days that are not included\r\n//    in the range of time specified by p  \r\n```\r\n\r\n## 1. Implement a general records filter\r\n\r\nBob deals with a lot of records every day, but not all of them are interesting depending on the analysis Bob is making.\r\nLet's help Bob perform some basic filtering of records.\r\n\r\nImplement the generic `Filter` function to filter records according to a criteria given by a function.\r\nThis filter function accepts a collection of records and a predicate function and returns only the records in the collection that satisfy the predicate.\r\n\r\n```go\r\nrecords := []Record{\r\n  {Day: 1, Amount: 15, Category: \"groceries\"},\r\n  {Day: 11, Amount: 300, Category: \"utility-bills\"},\r\n  {Day: 12, Amount: 28, Category: \"groceries\"},\r\n}\r\n\r\n// Day1Records only returns true for records that are from day 1\r\nfunc Day1Records(r Record) bool {\r\n  return r.Day == 1\r\n}\r\n\r\nFilter(records, Day1Records)\r\n// =>\r\n// [\r\n//   {Day: 1, Amount: 15, Category: \"groceries\"}\r\n// ]\r\n```\r\n\r\n## 2. Filter records within a period of time\r\n\r\nBob frequently needs to filter records that are in a given period of time.\r\n\r\nImplement the `ByDaysPeriod` function that will help Bob create such filters.\r\nThis function accepts a `DaysPeriod` and returns function that takes a record and tells whether the record is in the period of time specified by the `DaysPeriod` given as argument.\r\n\r\n```go\r\nrecords := []Record{\r\n  {Day: 1, Amount: 15, Category: \"groceries\"},\r\n  {Day: 11, Amount: 300, Category: \"utility-bills\"},\r\n  {Day: 12, Amount: 28, Category: \"groceries\"},\r\n  {Day: 26, Amount: 300, Category: \"university\"},\r\n  {Day: 28, Amount: 1300, Category: \"rent\"},\r\n}\r\n\r\nperiod := DaysPeriod{From: 1, To: 15}\r\n\r\nFilter(records, ByDaysPeriod(period))\r\n// =>\r\n// [\r\n//   {Day: 1, Amount: 15, Category: \"groceries\"},\r\n//   {Day: 11, Amount: 300, Category: \"utility-bills\"},\r\n//   {Day: 12, Amount: 28, Category: \"groceries\"},\r\n// ]\r\n```\r\n\r\n## 3. Filter records by category\r\n\r\nOther than filtering records by a period of time, Bob also needs to filter records by its category.\r\n\r\nImplement the `ByCategory` function that will help Bob create such filters.\r\nThis function accepts a category and returns a function that takes a record and tells whether the category of this record is the same as the category given as the argument.\r\n\r\n```go\r\nrecords := []Record{\r\n  {Day: 1, Amount: 15, Category: \"groceries\"},\r\n  {Day: 11, Amount: 300, Category: \"utility-bills\"},\r\n  {Day: 12, Amount: 28, Category: \"groceries\"},\r\n  {Day: 28, Amount: 1300, Category: \"rent\"},\r\n}\r\n\r\nFilter(records, ByCategory(\"groceries\"))\r\n// =>\r\n// [\r\n//   {Day: 1, Amount: 15, Category: \"groceries\"},\r\n//   {Day: 12, Amount: 28, Category: \"groceries\"},\r\n// ]\r\n```\r\n\r\n## 4. Calculate the total amount of expenses in a period\r\n\r\nBob also wants to know the total amount of the expenses in a period of time.\r\n\r\nImplement the `TotalByPeriod` function to return a sum of expenses in the days period.\r\n\r\n```go\r\nrecords := []Record{\r\n  {Day: 15, Amount: 16, Category: \"entertainment\"},\r\n  {Day: 32, Amount: 20, Category: \"groceries\"},\r\n  {Day: 40, Amount: 30, Category: \"entertainment\"}\r\n}\r\n\r\np1 := DaysPeriod{From: 1, To: 30}\r\np2 := DaysPeriod{From: 31, To: 60}\r\n\r\nTotalByPeriod(records, p1)\r\n// => 16\r\n\r\nTotalByPeriod(records, p2)\r\n// => 50\r\n```\r\n\r\n## 5. Calculate the total expenses for records of a category in a period\r\n\r\nFor the most complex reports Bob makes to his clients, Bob needs to filter records by category and period of time at the same time. \r\nThat means Bob wants to know the total expenses for records in a category in a given period of time.\r\n\r\nImplement the `CategoryExpenses` function that returns the total amount of expenses in a category in a given period of days. The function should also differentiate the case when the given category is not present in the expenses records and the case when there are no category's expenses in the provided period.\r\nWhen the category is not a category of any of the records (regardless of period of time) the function should return an error.\r\n\r\n```go\r\np1 := DaysPeriod{From: 1, To: 30}\r\np2 := DaysPeriod{From: 31, To: 60}\r\n\r\nrecords := []Record{\r\n  {Day: 1, Amount: 15, Category: \"groceries\"},\r\n  {Day: 11, Amount: 300, Category: \"utility-bills\"},\r\n  {Day: 12, Amount: 28, Category: \"groceries\"},\r\n  {Day: 26, Amount: 300, Category: \"university\"},\r\n  {Day: 28, Amount: 1300, Category: \"rent\"},\r\n}\r\n\r\nCategoryExpenses(records, p1, \"entertainment\")\r\n// => 0, error(unknown category entertainment)\r\n\r\nCategoryExpenses(records, p1, \"rent\")\r\n// => 1300, nil\r\n\r\nCategoryExpenses(records, p2, \"rent\")\r\n// => 0, nil\r\n```\r\n",
    "hints": "# Hints\r\n\r\n## 1. Implement a general records filter\r\n\r\n- Create a new `[]Record` to hold the filtered results\r\n- Iterate over the records and call the predicate function on each one\r\n- Add to the results slice only the records for which calling the predicate function on them returns `true`\r\n\r\n## 2. Filter records within a period of time\r\n\r\n- Make the function return an anonymous function that receives a `Record` and returns a `bool` indicating if the record is within the period of time that `ByDaysPeriod` receives as an argument.\r\n- Inside your anonymous function, you have access to the `DaysPeriod` argument that `ByDaysPeriod` receives. Together with the `Record` argument of the anonymous function, make a boolean expression that checks if the day in the record is inside the `DaysPeriod` that `ByDaysPeriod` receives. Return that boolean expression from the anonymous function.\r\n\r\n## 3. Filter records by category\r\n\r\n- This is very similar to the previous task, but now you are dealing with a category instead of a period of time.\r\n- Make the function return an anonymous function that receives a `Record` and returns a `bool` indicating if the record belongs to the category that `ByCategory` receives as an argument.\r\n- Inside your anonymous function, you have access to the category argument that `ByCategory` receives. Together with the `Record` argument of the anonymous function, make a boolean expression that checks if the category of the record is the same as the category that `ByCategory` receives as an argument. Return that boolean expression from the anonymous function.\r\n\r\n## 4. Calculate the total amount of expenses in a period\r\n\r\n- Use the `ByDaysPeriod` function you made in step 2 to make a period filter function.\r\n- Pass that filter function as the second argument of the `Filter` function you made in step 1. This allows you to filter the results by a period of time.\r\n- Iterate over the filtered records and sum up all their amounts.\r\n\r\n## 5. Calculate the total expenses for records of a category in a period\r\n\r\n- Use the `ByCategory` function you made in step 3 to make a category filter function.\r\n- Pass that filter function as the second argument of the `Filter` function you made in step 1. This allows you to filter the results by a particular category.\r\n- After filtering the records by category, check if you have any records for thatcategory. If you don't, you must return an error.\r\n- If you have records belonging to that category, compute the total expenses for the given period of time using the `TotalByPeriod` function you made in step 4.\r\n"
  },
  "starter_code": "package expenses\r\n\r\n// Record represents an expense record.\r\ntype Record struct {\r\n\tDay      int\r\n\tAmount   float64\r\n\tCategory string\r\n}\r\n\r\n// DaysPeriod represents a period of days for expenses.\r\ntype DaysPeriod struct {\r\n\tFrom int\r\n\tTo   int\r\n}\r\n\r\n// Filter returns the records for which the predicate function returns true.\r\nfunc Filter(in []Record, predicate func(Record) bool) []Record {\r\n\tpanic(\"Please implement the Filter function\")\r\n}\r\n\r\n// ByDaysPeriod returns predicate function that returns true when\r\n// the day of the record is inside the period of day and false otherwise.\r\nfunc ByDaysPeriod(p DaysPeriod) func(Record) bool {\r\n\tpanic(\"Please implement the ByDaysPeriod function\")\r\n}\r\n\r\n// ByCategory returns predicate function that returns true when\r\n// the category of the record is the same as the provided category\r\n// and false otherwise.\r\nfunc ByCategory(c string) func(Record) bool {\r\n\tpanic(\"Please implement the ByCategory function\")\r\n}\r\n\r\n// TotalByPeriod returns total amount of expenses for records\r\n// inside the period p.\r\nfunc TotalByPeriod(in []Record, p DaysPeriod) float64 {\r\n\tpanic(\"Please implement the TotalByPeriod function\")\r\n}\r\n\r\n// CategoryExpenses returns total amount of expenses for records\r\n// in category c that are also inside the period p.\r\n// An error must be returned only if there are no records in the list that belong\r\n// to the given category, regardless of period of time.\r\nfunc CategoryExpenses(in []Record, p DaysPeriod, c string) (float64, error) {\r\n\tpanic(\"Please implement the CategoryExpenses function\")\r\n}\r\n",
  "tests": "package expenses\r\n\r\nimport \"testing\"\r\n\r\nvar testExpensesRecords = []Record{\r\n\t{\r\n\t\tDay:      1,\r\n\t\tAmount:   5.15,\r\n\t\tCategory: \"groceries\",\r\n\t},\r\n\t{\r\n\t\tDay:      1,\r\n\t\tAmount:   3.45,\r\n\t\tCategory: \"groceries\",\r\n\t},\r\n\t{\r\n\t\tDay:      13,\r\n\t\tAmount:   55.67,\r\n\t\tCategory: \"utility-bills\",\r\n\t},\r\n\t{\r\n\t\tDay:      15,\r\n\t\tAmount:   11,\r\n\t\tCategory: \"groceries\",\r\n\t},\r\n\t{\r\n\t\tDay:      18,\r\n\t\tAmount:   244.33,\r\n\t\tCategory: \"utility-bills\",\r\n\t},\r\n\t{\r\n\t\tDay:      20,\r\n\t\tAmount:   300,\r\n\t\tCategory: \"university\",\r\n\t},\r\n\t{\r\n\t\tDay:      23,\r\n\t\tAmount:   20.0,\r\n\t\tCategory: \"groceries\",\r\n\t},\r\n\t{\r\n\t\tDay:      25,\r\n\t\tAmount:   24.65,\r\n\t\tCategory: \"groceries\",\r\n\t},\r\n\t{\r\n\t\tDay:      30,\r\n\t\tAmount:   1300,\r\n\t\tCategory: \"rent\",\r\n\t},\r\n}\r\n\r\n// testRunnerTaskID=2\r\nfunc TestFilterByDaysPeriod(t *testing.T) {\r\n\ttestCases := []struct {\r\n\t\tname     string\r\n\t\tp        DaysPeriod\r\n\t\texpected []Record\r\n\t}{\r\n\t\t{\r\n\t\t\tname: \"returns expenses records from 1st to 15th day\",\r\n\t\t\tp: DaysPeriod{\r\n\t\t\t\tFrom: 1,\r\n\t\t\t\tTo:   15,\r\n\t\t\t},\r\n\t\t\texpected: []Record{\r\n\t\t\t\t{\r\n\t\t\t\t\tDay:      1,\r\n\t\t\t\t\tAmount:   5.15,\r\n\t\t\t\t\tCategory: \"groceries\",\r\n\t\t\t\t},\r\n\t\t\t\t{\r\n\t\t\t\t\tDay:      1,\r\n\t\t\t\t\tAmount:   3.45,\r\n\t\t\t\t\tCategory: \"groceries\",\r\n\t\t\t\t},\r\n\t\t\t\t{\r\n\t\t\t\t\tDay:      13,\r\n\t\t\t\t\tAmount:   55.67,\r\n\t\t\t\t\tCategory: \"utility-bills\",\r\n\t\t\t\t},\r\n\t\t\t\t{\r\n\t\t\t\t\tDay:      15,\r\n\t\t\t\t\tAmount:   11,\r\n\t\t\t\t\tCategory: \"groceries\",\r\n\t\t\t\t},\r\n\t\t\t},\r\n\t\t},\r\n\t\t{\r\n\t\t\tname: \"returns empty list when no expenses found in the days period\",\r\n\t\t\tp: DaysPeriod{\r\n\t\t\t\tFrom: 40,\r\n\t\t\t\tTo:   50,\r\n\t\t\t},\r\n\t\t},\r\n\t}\r\n\tfor _, tC := range testCases {\r\n\t\tt.Run(tC.name, func(t *testing.T) {\r\n\t\t\tgot := Filter(testExpensesRecords, ByDaysPeriod(tC.p))\r\n\t\t\tif len(got) != len(tC.expected) {\r\n\t\t\t\tt.Fatalf(\"Filter by period got %d records, want %d\", len(got), len(tC.expected))\r\n\t\t\t}\r\n\r\n\t\t\tfor i, expected := range tC.expected {\r\n\t\t\t\tif got[i] != expected {\r\n\t\t\t\t\tt.Fatalf(\"Filter by period got %v, want %v\", got, tC.expected)\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t})\r\n\t}\r\n}\r\n\r\n// testRunnerTaskID=3\r\nfunc TestFilterByCategory(t *testing.T) {\r\n\ttestCases := []struct {\r\n\t\tname     string\r\n\t\tcategory string\r\n\t\texpected []Record\r\n\t}{\r\n\t\t{\r\n\t\t\tname:     \"returns expenses in groceries category\",\r\n\t\t\tcategory: \"groceries\",\r\n\t\t\texpected: []Record{\r\n\t\t\t\t{\r\n\t\t\t\t\tDay:      1,\r\n\t\t\t\t\tAmount:   5.15,\r\n\t\t\t\t\tCategory: \"groceries\",\r\n\t\t\t\t},\r\n\t\t\t\t{\r\n\t\t\t\t\tDay:      1,\r\n\t\t\t\t\tAmount:   3.45,\r\n\t\t\t\t\tCategory: \"groceries\",\r\n\t\t\t\t},\r\n\t\t\t\t{\r\n\t\t\t\t\tDay:      15,\r\n\t\t\t\t\tAmount:   11,\r\n\t\t\t\t\tCategory: \"groceries\",\r\n\t\t\t\t},\r\n\t\t\t\t{\r\n\t\t\t\t\tDay:      23,\r\n\t\t\t\t\tAmount:   20.0,\r\n\t\t\t\t\tCategory: \"groceries\",\r\n\t\t\t\t},\r\n\t\t\t\t{\r\n\t\t\t\t\tDay:      25,\r\n\t\t\t\t\tAmount:   24.65,\r\n\t\t\t\t\tCategory: \"groceries\",\r\n\t\t\t\t},\r\n\t\t\t},\r\n\t\t},\r\n\t\t{\r\n\t\t\tname:     \"returns empty list for unknown category\",\r\n\t\t\tcategory: \"ABC\",\r\n\t\t},\r\n\t}\r\n\tfor _, tC := range testCases {\r\n\t\tt.Run(tC.name, func(t *testing.T) {\r\n\t\t\tgot := Filter(testExpensesRecords, ByCategory(tC.category))\r\n\t\t\tif len(got) != len(tC.expected) {\r\n\t\t\t\tt.Fatalf(\"Filter by category got %d records, want %d\", len(got), len(tC.expected))\r\n\t\t\t}\r\n\r\n\t\t\tfor i, expected := range tC.expected {\r\n\t\t\t\tif got[i] != expected {\r\n\t\t\t\t\tt.Fatalf(\"Filter by category got %v, want %v\", got, tC.expected)\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t})\r\n\t}\r\n}\r\n\r\n// testRunnerTaskID=4\r\nfunc TestTotalByPeriod(t *testing.T) {\r\n\ttestCases := []struct {\r\n\t\tname  string\r\n\t\tp     DaysPeriod\r\n\t\ttotal float64\r\n\t}{\r\n\t\t{\r\n\t\t\tname: \"total expenses is 0 when no records found in the provided days period\",\r\n\t\t\tp: DaysPeriod{\r\n\t\t\t\tFrom: 40,\r\n\t\t\t\tTo:   50,\r\n\t\t\t},\r\n\t\t\ttotal: 0,\r\n\t\t},\r\n\t\t{\r\n\t\t\tname: \"total expenses for days period from 25th to 26th day\",\r\n\t\t\tp: DaysPeriod{\r\n\t\t\t\tFrom: 25,\r\n\t\t\t\tTo:   26,\r\n\t\t\t},\r\n\t\t\ttotal: 24.65,\r\n\t\t},\r\n\t\t{\r\n\t\t\tname: \"total expenses for the full days period\",\r\n\t\t\tp: DaysPeriod{\r\n\t\t\t\tFrom: 1,\r\n\t\t\t\tTo:   100,\r\n\t\t\t},\r\n\t\t\ttotal: 1964.25,\r\n\t\t},\r\n\t}\r\n\tfor _, tC := range testCases {\r\n\t\tt.Run(tC.name, func(t *testing.T) {\r\n\t\t\tgot := TotalByPeriod(testExpensesRecords, tC.p)\r\n\t\t\tif got != tC.total {\r\n\t\t\t\tt.Errorf(\"TotalByPeriod(%v, %v) = %.2f, want %.2f\", testExpensesRecords, tC.p, got, tC.total)\r\n\t\t\t}\r\n\t\t})\r\n\t}\r\n}\r\n\r\n// testRunnerTaskID=5\r\nfunc TestCategoryExpenses(t *testing.T) {\r\n\ttestCases := []struct {\r\n\t\tname     string\r\n\t\tcategory string\r\n\t\tp        DaysPeriod\r\n\t\ttotal    float64\r\n\t\twantErr  bool\r\n\t}{\r\n\t\t{\r\n\t\t\tname:     \"returns error when no records with category found in any days period\",\r\n\t\t\tcategory: \"food\",\r\n\t\t\tp: DaysPeriod{\r\n\t\t\t\tFrom: 1,\r\n\t\t\t\tTo:   30,\r\n\t\t\t},\r\n\t\t\ttotal:   0,\r\n\t\t\twantErr: true,\r\n\t\t},\r\n\t\t{\r\n\t\t\tname:     \"returns total category expenses in the provided days period\",\r\n\t\t\tcategory: \"groceries\",\r\n\t\t\tp: DaysPeriod{\r\n\t\t\t\tFrom: 1,\r\n\t\t\t\tTo:   15,\r\n\t\t\t},\r\n\t\t\ttotal:   19.6,\r\n\t\t\twantErr: false,\r\n\t\t},\r\n\t\t{\r\n\t\t\tname:     \"returns 0 when no category expenses found in the provided days period\",\r\n\t\t\tcategory: \"groceries\",\r\n\t\t\tp: DaysPeriod{\r\n\t\t\t\tFrom: 40,\r\n\t\t\t\tTo:   50,\r\n\t\t\t},\r\n\t\t\ttotal:   0,\r\n\t\t\twantErr: false,\r\n\t\t},\r\n\t}\r\n\tfor _, tC := range testCases {\r\n\t\tt.Run(tC.name, func(t *testing.T) {\r\n\t\t\tgot, err := CategoryExpenses(testExpensesRecords, tC.p, tC.category)\r\n\t\t\tif tC.wantErr && err == nil {\r\n\t\t\t\tt.Fatalf(\"CategoryExpenses(%v, %s, %v)=%.2f,%v but want a non-nil error\",\r\n\t\t\t\t\ttestExpensesRecords, tC.category, tC.p, got, err)\r\n\t\t\t}\r\n\r\n\t\t\tif !tC.wantErr && err != nil {\r\n\t\t\t\tt.Fatalf(\"CategoryExpenses(%v, %s, %v)=%.2f,%v but a non-nil error was not expected\",\r\n\t\t\t\t\ttestExpensesRecords, tC.category, tC.p, got, err)\r\n\t\t\t}\r\n\r\n\t\t\tif got != tC.total {\r\n\t\t\t\tvar errStr string\r\n\r\n\t\t\t\tif tC.wantErr {\r\n\t\t\t\t\terrStr = \"unknown category\"\r\n\t\t\t\t} else {\r\n\t\t\t\t\terrStr = \"nil\"\r\n\t\t\t\t}\r\n\t\t\t\tt.Fatalf(\"CategoryExpenses(%v, %s, %v) = %.2f,%v but want %.2f,%s\",\r\n\t\t\t\t\ttestExpensesRecords, tC.category, tC.p, got, err, tC.total, errStr)\r\n\t\t\t}\r\n\t\t})\r\n\t}\r\n}\r\n"
}