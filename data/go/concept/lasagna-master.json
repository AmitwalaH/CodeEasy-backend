{
  "language": "go",
  "slug": "lasagna-master",
  "docs": {
    "introduction": "# Introduction\r\n\r\nA function allows you to group code into a reusable unit.\r\nIt consists of the `func` keyword, the name of the function, and a comma-separated list of zero or more parameters and types in round brackets.\r\n\r\n## Function Parameters\r\n\r\nAll parameters must be explicitly typed; there is no type inference for parameters.\r\nThere are no default values for parameters so all function parameters are required.\r\n\r\n```go\r\nimport \"fmt\"\r\n\r\n// No parameters\r\nfunc PrintHello() {\r\n    fmt.Println(\"Hello\")\r\n}\r\n\r\n// Two parameters\r\nfunc PrintGreetingName(greeting string, name string) {\r\n  fmt.Println(greeting + \" \" + name)\r\n}\r\n```\r\n\r\nParameters of the same type can be declared together, followed by a single type declaration.\r\n\r\n```go\r\nimport \"fmt\"\r\n\r\nfunc PrintGreetingName(greeting, name string) {\r\n  fmt.Println(greeting + \" \" + name)\r\n}\r\n```\r\n\r\n## Parameters vs. Arguments\r\n\r\nLet's quickly cover two terms that are often confused together: `parameters` and `arguments`. \r\nFunction parameters are the names defined in the function's signature, such as `greeting` and `name` in the function `PrintGreetingName` above.\r\nFunction arguments are the concrete values passed to the function parameters when we invoke the function.\r\nFor instance, in the example below, `\"Hello\"` and `\"Katrina\"` are the arguments passed to the `greeting` and `name` parameters:\r\n\r\n```go\r\nPrintGreetingName(\"Hello\", \"Katrina\")\r\n```\r\n\r\n## Return Values\r\n\r\nThe function parameters are followed by zero or more return values which must also be explicitly typed.\r\nSingle return values are left bare, multiple return values are wrapped in parenthesis.\r\nValues are returned to the calling code from functions using the `return` keyword.\r\nThere can be multiple `return` statements in a function.\r\nThe execution of the function ends as soon as it hits one of those `return` statements.\r\nIf multiple values are to be returned from a function, they are comma separated.\r\n\r\n```go\r\nfunc Hello(name string) string {\r\n  return \"Hello \" + name\r\n}\r\n\r\nfunc HelloAndGoodbye(name string) (string, string) {\r\n  return \"Hello \" + name, \"Goodbye \" + name\r\n}\r\n```\r\n\r\n## Invoking Functions\r\n\r\nInvoking a function is done by specifying the function name and passing arguments for each of the function's parameters in parenthesis.\r\n\r\n```go\r\nimport \"fmt\"\r\n\r\n// No parameters, no return value\r\nfunc PrintHello() {\r\n    fmt.Println(\"Hello\")\r\n}\r\n// Called like this:\r\nPrintHello()\r\n\r\n// One parameter, one return value\r\nfunc Hello(name string) string {\r\n  return \"Hello \" + name\r\n}\r\n// Called like this:\r\ngreeting := Hello(\"Dave\")\r\n\r\n// Multiple parameters, multiple return values\r\nfunc SumAndMultiply(a, b int) (int, int) {\r\n    return a+b, a*b\r\n}\r\n// Called like this:\r\naplusb, atimesb := SumAndMultiply(a, b)\r\n```\r\n\r\n## Named Return Values and Naked Return\r\n\r\nAs well as parameters, return values can optionally be named.\r\nIf named return values are used, a `return` statement without arguments will return those values.\r\nThis is known as a 'naked' return.\r\n\r\n```go\r\nfunc SumAndMultiplyThenMinus(a, b, c int) (sum, mult int) {\r\n    sum, mult = a+b, a*b\r\n    sum -= c\r\n    mult -= c\r\n    return\r\n}\r\n```\r\n\r\n## Pass by Value vs. Pass by Reference\r\n\r\nIt is also important to clarify the concept of passing by value and passing by reference.\r\n\r\nFirst, let's clarify passing by value.\r\nIn the example below, when we pass the variable `val` to the function `MultiplyByTwo`, we passed a copy of `val`.\r\nBecause of this, `newVal` has the updated value `4` but the original variable `val` is still `2`.\r\nBehind the scene, Go essentially makes a copy of the original value so that only this copy, a.k.a. `v`, is modified by the function.\r\n\r\n```go\r\nval := 2\r\nfunc MultiplyByTwo(v int) int {\r\n    v = v * 2\r\n    return v\r\n}\r\nnewVal := MultiplyByTwo(val)\r\n// newval is 4, val is still 2 because only a copy of its value was passed into the function\r\n```\r\n\r\nStrictly speaking, all arguments are passed by value in Go, i.e. a copy is made of the value or data provided to the function.\r\nBut if you don't want to make a copy of the data that is passed to a function and want to change the data in the function,\r\nthen you should use `pointers` as arguments, a.k.a. pass by reference.\r\n\r\n## Pointers\r\n\r\nWe use a `pointer` to achieve passing by reference.\r\nBy passing `pointer` arguments into a function,\r\nwe could modify the underlying data passed into the function instead of only operating on a copy of the data.\r\n\r\nFor now, it is sufficient to know that pointer types can be recognized by the `*` in front of the type in the function signature.\r\n\r\n```go\r\nfunc HandlePointers(x, y *int) {\r\n    // Some logic to handle integer values referenced by pointers x and y\r\n}\r\n```\r\n\r\nIf the concept of `pointer` is confusing, no worries.\r\nWe have a dedicated section later in the syllabus to help you master pointers.\r\n\r\n## Exceptions\r\n\r\nNote that `slices` and `maps` are exceptions to the above-mentioned rule. \r\nWhen we pass a `slice` or a `map` as arguments into a function, they are treated as pointer types even though there is no explicit `*` in the type.\r\nThis means that if we pass a slice or map into a function and modify its underlying data,\r\nthe changes will be reflected on the original slice or map.\r\n",
    "instructions": "# Instructions\r\n\r\nIn this exercise you are going to write some more code related to preparing and cooking your brilliant lasagna from your favorite cookbook.\r\n\r\nYou have four tasks.\r\nThe first one is related to the cooking itself, the other three are about the perfect preparation.\r\n\r\n## 1. Estimate the preparation time\r\n\r\nFor the next lasagna that you will prepare, you want to make sure you have enough time reserved so you can enjoy the cooking.\r\nYou already planned which layers your lasagna will have.\r\nNow you want to estimate how long the preparation will take based on that.\r\n\r\nImplement a function `PreparationTime` that accepts a slice of layers as a `[]string` and the average preparation time per layer in minutes as an `int`.\r\nThe function should return the estimate for the total preparation time based on the number of layers as an `int`.\r\nGo has no default values for functions.\r\nIf the average preparation time is passed as `0` (the default initial value for an `int`), then the default value of `2` should be used.\r\n\r\n```go\r\nlayers := []string{\"sauce\", \"noodles\", \"sauce\", \"meat\", \"mozzarella\", \"noodles\"}\r\nPreparationTime(layers, 3)\r\n// => 18\r\nPreparationTime(layers, 0)\r\n// => 12\r\n```\r\n\r\n## 2. Compute the amounts of noodles and sauce needed\r\n\r\nBesides reserving the time, you also want to make sure you have enough sauce and noodles to cook the lasagna of your dreams.\r\nFor each noodle layer in your lasagna, you will need 50 grams of noodles.\r\nFor each sauce layer in your lasagna, you will need 0.2 liters of sauce.\r\n\r\nDefine the function `Quantities` that takes a slice of layers as parameter as a `[]string`.\r\nThe function will then determine the quantity of noodles and sauce needed to make your meal.\r\nThe result should be returned as two values of `noodles` as an `int` and `sauce` as a `float64`.\r\n\r\n```go\r\nQuantities([]string{\"sauce\", \"noodles\", \"sauce\", \"meat\", \"mozzarella\", \"noodles\"})\r\n// => 100, 0.4\r\n```\r\n\r\n## 3. Add the secret ingredient\r\n\r\nA while ago you visited a friend and ate lasagna there.\r\nIt was amazing and had something special to it.\r\nThe friend sent you the list of ingredients and told you the last item on the list is the \"secret ingredient\" that made the meal so special.\r\nNow you want to add that secret ingredient to your recipe as well.\r\n\r\nWrite a function `AddSecretIngredient` that accepts two slices of ingredients of type `[]string` as parameters.\r\nThe first parameter is the list your friend sent you, the second is the ingredient list of your own recipe.\r\nThe last element in your ingredient list is always `\"?\"`. The function should replace it with the last item from your friends list.\r\n**Note:** `AddSecretIngredient` does not return anything - you should modify the list of your ingredients directly. The list with your friend's ingredients should **not** be modified. Also, since `slice` is passed into a function as pointers, changes to the two `[]string` arguments passed into `AddSecretIngredient` will be modified directly.\r\n\r\n```go\r\nfriendsList := []string{\"noodles\", \"sauce\", \"mozzarella\", \"kampot pepper\"}\r\nmyList := []string{\"noodles\", \"meat\", \"sauce\", \"mozzarella\",\"?\"}\r\n\r\nAddSecretIngredient(friendsList, myList)\r\n// myList => []string{\"noodles\", \"meat\", \"sauce\", \"mozzarella\", \"kampot pepper\"}\r\n```\r\n\r\n## 4. Scale the recipe\r\n\r\nThe amounts listed in your cookbook only yield enough lasagna for two portions.\r\nSince you want to cook for more people next time, you want to calculate the amounts for different numbers of portions.\r\n\r\nImplement a function `ScaleRecipe` that takes two parameters.\r\n\r\n- A slice of `float64` amounts needed for 2 portions.\r\n- The number of portions you want to cook.\r\n\r\nThe function should return a slice of `float64` of the amounts needed for the desired number of portions.\r\nYou want to keep the original recipe though.\r\nThis means the `quantities` argument should not be modified in this function.\r\n\r\n```go\r\nquantities := []float64{ 1.2, 3.6, 10.5 }\r\nscaledQuantities := ScaleRecipe(quantities, 4)\r\n// => []float64{ 2.4, 7.2, 21 }\r\n```\r\n",
    "hints": "# Hints\r\n\r\n## 1. Estimate the preparation time\r\n\r\n- Use the [`len()` built-in function][len-builtin] to determine the number of layers (length of the layers slice).\r\n\r\n## 2. Compute the amounts of noodles and sauce needed\r\n\r\n- First, set up two variables to track the amount of noodles and sauce.\r\n- Use a for loop to iterate through the layers.\r\n- If you encounter a `'noodles'` or `'sauce'` layer in your loop, increase the amount stored in the respective variable accordingly.\r\n\r\n## 3. Add the secret ingredient\r\n\r\n- Revisit [slices][concept-slices] to find out how to retrieve an element from an slice and how to replace an element in a slice.\r\n- The index of the last element in a slice `a` is `len(a) - 1`.\r\n\r\n## 4. Scale the recipe\r\n\r\n- First make a new slice of the same size as the input slice\r\n- Use a [for loop][for-loop] to iterate through the input slice and generate the output slice\r\n\r\n[len-builtin]: https://pkg.go.dev/builtin#len\r\n[concept-conditonals-if]: /tracks/go/concepts/conditionals-if\r\n[concept-slices]: /tracks/go/concepts/slices\r\n[for-loop]: https://tour.golang.org/flowcontrol/1\r\n"
  },
  "starter_code": "package lasagna\r\n\r\n// TODO: define the 'PreparationTime()' function\r\n\r\n// TODO: define the 'Quantities()' function\r\n\r\n// TODO: define the 'AddSecretIngredient()' function\r\n\r\n// TODO: define the 'ScaleRecipe()' function\r\n\r\n// Your first steps could be to read through the tasks, and create\r\n// these functions with their correct parameter lists and return types.\r\n// The function body only needs to contain `panic(\"\")`.\r\n//\r\n// This will make the tests compile, but they will fail.\r\n// You can then implement the function logic one by one and see\r\n// an increasing number of tests passing as you implement more\r\n// functionality.\r\n",
  "tests": "package lasagna\r\n\r\nimport (\r\n\t\"math\"\r\n\t\"reflect\"\r\n\t\"testing\"\r\n)\r\n\r\ntype preparationTimeTests struct {\r\n\tname           string\r\n\tlayers         []string\r\n\ttime, expected int\r\n}\r\n\r\nfunc TestPreparationTime(t *testing.T) {\r\n\ttests := []preparationTimeTests{\r\n\t\t{\r\n\t\t\tname: \"Preparation time for many layers with custom average time\",\r\n\t\t\tlayers: []string{\r\n\t\t\t\t\"sauce\",\r\n\t\t\t\t\"noodles\",\r\n\t\t\t\t\"béchamel\",\r\n\t\t\t\t\"meat\",\r\n\t\t\t\t\"mozzarella\",\r\n\t\t\t\t\"noodles\",\r\n\t\t\t\t\"ricotta\",\r\n\t\t\t\t\"eggplant\",\r\n\t\t\t\t\"béchamel\",\r\n\t\t\t\t\"noodles\",\r\n\t\t\t\t\"sauce\",\r\n\t\t\t\t\"mozzarella\",\r\n\t\t\t},\r\n\t\t\ttime:     1,\r\n\t\t\texpected: 12,\r\n\t\t},\r\n\t\t{\r\n\t\t\tname: \"Preparation time for few layers\",\r\n\t\t\tlayers: []string{\r\n\t\t\t\t\"sauce\",\r\n\t\t\t\t\"noodles\",\r\n\t\t\t},\r\n\t\t\ttime:     3,\r\n\t\t\texpected: 6,\r\n\t\t},\r\n\t\t{\r\n\t\t\tname: \"Preparation time for default case\",\r\n\t\t\tlayers: []string{\r\n\t\t\t\t\"sauce\",\r\n\t\t\t\t\"noodles\",\r\n\t\t\t},\r\n\t\t\ttime:     0,\r\n\t\t\texpected: 4,\r\n\t\t},\r\n\t}\r\n\tfor _, tt := range tests {\r\n\t\tt.Run(tt.name, func(t *testing.T) {\r\n\t\t\tif got := PreparationTime(tt.layers, tt.time); got != tt.expected {\r\n\t\t\t\tt.Errorf(\"PreparationTime(%v, %d) = %d; want %d\", tt.layers, tt.time, got, tt.expected)\r\n\t\t\t}\r\n\t\t})\r\n\t}\r\n}\r\n\r\ntype quantitiesTest struct {\r\n\tname       string\r\n\tlayers     []string\r\n\texpNoodles int\r\n\texpSauce   float64\r\n}\r\n\r\nfunc TestQuantities(t *testing.T) {\r\n\ttests := []quantitiesTest{\r\n\t\t{\r\n\t\t\tname:       \"few layers\",\r\n\t\t\tlayers:     []string{\"noodles\", \"sauce\", \"noodles\"},\r\n\t\t\texpNoodles: 100,\r\n\t\t\texpSauce:   0.2,\r\n\t\t},\r\n\t\t{\r\n\t\t\tname: \"many layers\",\r\n\t\t\tlayers: []string{\r\n\t\t\t\t\"sauce\",\r\n\t\t\t\t\"noodles\",\r\n\t\t\t\t\"béchamel\",\r\n\t\t\t\t\"meat\",\r\n\t\t\t\t\"mozzarella\",\r\n\t\t\t\t\"noodles\",\r\n\t\t\t\t\"ricotta\",\r\n\t\t\t\t\"eggplant\",\r\n\t\t\t\t\"béchamel\",\r\n\t\t\t\t\"noodles\",\r\n\t\t\t\t\"sauce\",\r\n\t\t\t\t\"mozzarella\",\r\n\t\t\t},\r\n\t\t\texpNoodles: 150,\r\n\t\t\texpSauce:   0.4,\r\n\t\t},\r\n\t\t{\r\n\t\t\tname: \"no noodles\",\r\n\t\t\tlayers: []string{\r\n\t\t\t\t\"sauce\",\r\n\t\t\t\t\"meat\",\r\n\t\t\t\t\"mozzarella\",\r\n\t\t\t\t\"sauce\",\r\n\t\t\t\t\"mozzarella\",\r\n\t\t\t},\r\n\t\t\texpNoodles: 0,\r\n\t\t\texpSauce:   0.4,\r\n\t\t},\r\n\t\t{\r\n\t\t\tname: \"no sauce\",\r\n\t\t\tlayers: []string{\r\n\t\t\t\t\"noodles\",\r\n\t\t\t\t\"meat\",\r\n\t\t\t\t\"mozzarella\",\r\n\t\t\t\t\"noodles\",\r\n\t\t\t\t\"mozzarella\",\r\n\t\t\t},\r\n\t\t\texpNoodles: 100,\r\n\t\t\texpSauce:   0.0,\r\n\t\t},\r\n\t}\r\n\tfor _, tt := range tests {\r\n\t\tt.Run(tt.name, func(t *testing.T) {\r\n\t\t\tgotNoodles, gotSauce := Quantities(tt.layers)\r\n\t\t\tif gotNoodles != tt.expNoodles {\r\n\t\t\t\tt.Errorf(\"quantities(%v) = %d noodles; want %d\", tt.layers, gotNoodles, tt.expNoodles)\r\n\t\t\t}\r\n\t\t\tif gotSauce != tt.expSauce {\r\n\t\t\t\tt.Errorf(\"quantities(%v) = %f sauce; want %f\", tt.layers, gotSauce, tt.expSauce)\r\n\t\t\t}\r\n\t\t})\r\n\t}\r\n}\r\n\r\ntype secretTest struct {\r\n\tname        string\r\n\tfriendsList []string\r\n\tmyList      []string\r\n\texpected    []string\r\n}\r\n\r\nfunc TestAddSecretIngredient(t *testing.T) {\r\n\ttests := []secretTest{\r\n\t\t{\r\n\t\t\tname:        \"Adds secret ingredient\",\r\n\t\t\tfriendsList: []string{\"sauce\", \"noodles\", \"béchamel\", \"marjoram\"},\r\n\t\t\tmyList:      []string{\"sauce\", \"noodles\", \"meat\", \"tomatoes\", \"?\"},\r\n\t\t\texpected:    []string{\"sauce\", \"noodles\", \"meat\", \"tomatoes\", \"marjoram\"},\r\n\t\t},\r\n\t}\r\n\tfor _, tt := range tests {\r\n\t\tt.Run(tt.name, func(t *testing.T) {\r\n\t\t\tfriendsList := make([]string, len(tt.friendsList))\r\n\t\t\tcopy(friendsList, tt.friendsList)\r\n\t\t\tmyList := make([]string, len(tt.myList))\r\n\t\t\tcopy(myList, tt.myList)\r\n\t\t\tAddSecretIngredient(tt.friendsList, tt.myList)\r\n\t\t\tif !reflect.DeepEqual(tt.myList, tt.expected) {\r\n\t\t\t\tt.Errorf(\"addSecretIngredient(%v, %v) = %v want %v\", tt.friendsList, myList, tt.myList, tt.expected)\r\n\t\t\t}\r\n\t\t\tif !reflect.DeepEqual(friendsList, tt.friendsList) {\r\n\t\t\t\tt.Errorf(\"addSecretIngredient permuted friendsList (was %v, now %v), should not alter inputs\", tt.friendsList, friendsList)\r\n\t\t\t}\r\n\t\t})\r\n\t}\r\n}\r\n\r\ntype scaleRecipeTest struct {\r\n\tname     string\r\n\tinput    []float64\r\n\tportions int\r\n\texpected []float64\r\n}\r\n\r\nfunc TestScaleRecipe(t *testing.T) {\r\n\ttests := []scaleRecipeTest{\r\n\t\t{\r\n\t\t\tname:     \"scales up correctly\",\r\n\t\t\tinput:    []float64{0.5, 250, 150, 3, 0.5},\r\n\t\t\tportions: 6,\r\n\t\t\texpected: []float64{1.5, 750, 450, 9, 1.5},\r\n\t\t},\r\n\t\t{\r\n\t\t\tname:     \"scales up correctly (2)\",\r\n\t\t\tinput:    []float64{0.6, 300, 1, 0.5, 50, 0.1, 100},\r\n\t\t\tportions: 3,\r\n\t\t\texpected: []float64{0.9, 450, 1.5, 0.75, 75, 0.15, 150},\r\n\t\t},\r\n\t\t{\r\n\t\t\tname:     \"scales down correctly\",\r\n\t\t\tinput:    []float64{0.5, 250, 150, 3, 0.5},\r\n\t\t\tportions: 1,\r\n\t\t\texpected: []float64{0.25, 125, 75, 1.5, 0.25},\r\n\t\t},\r\n\t\t{\r\n\t\t\tname:     \"empty recipe\",\r\n\t\t\tinput:    []float64{},\r\n\t\t\tportions: 100,\r\n\t\t\texpected: []float64{},\r\n\t\t},\r\n\t}\r\n\tfor _, tt := range tests {\r\n\t\tt.Run(tt.name, func(t *testing.T) {\r\n\t\t\tinputList := make([]float64, len(tt.input))\r\n\t\t\tcopy(inputList, tt.input)\r\n\t\t\tgot := ScaleRecipe(inputList, tt.portions)\r\n\t\t\tif len(got) != len(tt.expected) {\r\n\t\t\t\tt.Errorf(\"ScaleRecipe(%v, %d) produced slice of length %d, expected %d\", inputList, tt.portions, len(got), len(tt.expected))\r\n\t\t\t}\r\n\t\t\tfor i := range tt.expected {\r\n\t\t\t\tif math.Abs(got[i]-tt.expected[i]) > 0.000001 {\r\n\t\t\t\t\tt.Errorf(\"Got %f Expected %f for index %d\", got[i], tt.expected[i], i)\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tif !reflect.DeepEqual(inputList, tt.input) {\r\n\t\t\t\tt.Errorf(\"ScaleRecipe permuted list (was %v, now %v), should not alter inputs\", tt.input, inputList)\r\n\t\t\t}\r\n\t\t})\r\n\t}\r\n}\r\n"
}