{
  "language": "go",
  "slug": "gross-store",
  "docs": {
    "introduction": "# Introduction\r\n\r\nIn Go, `map` is a built-in data type that maps keys to values. In other programming languages, you might be familiar with the concept of `map` as a dictionary, hash table, key/value store or an associative array.\r\n\r\nSyntactically, `map` looks like this:\r\n\r\n```go\r\nmap[KeyType]ElementType\r\n```\r\n\r\nIt is also important to know that each key is unique, meaning that assigning the same key twice will overwrite the value of the corresponding key.\r\n\r\nTo create a map, you can do:\r\n\r\n```go\r\n  // With map literal\r\n  foo := map[string]int{}\r\n```\r\n\r\nor\r\n\r\n```go\r\n  // or with make function\r\n  foo := make(map[string]int)\r\n```\r\n\r\nHere are some operations that you can do with a map\r\n\r\n```go\r\n  // Add a value in a map with the `=` operator:\r\n  foo[\"bar\"] = 42\r\n  // Here we update the element of `bar`\r\n  foo[\"bar\"] = 73\r\n  // To retrieve a map value, you can use\r\n  baz := foo[\"bar\"]\r\n  // To delete an item from a map, you can use\r\n  delete(foo, \"bar\")\r\n```\r\n\r\nIf you try to retrieve the value for a key which does not exist in the map, it will return the zero value of the value type.\r\nThis can confuse you, especially if the default value of your `ElementType` (for example, 0 for an int), is a valid value.\r\nTo check whether a key exists in your map, you can use\r\n\r\n```go\r\n  value, exists := foo[\"baz\"]\r\n  // If the key \"baz\" does not exist,\r\n  // value: 0; exists: false\r\n```\r\n",
    "instructions": "# Instructions\r\n\r\nA friend of yours has an old wholesale store called **Gross Store**.\r\nThe name comes from the quantity of the item that the store sell: it's all in [gross unit][gross-unit].\r\nYour friend asked you to implement a point of sale (POS) system for his store.\r\n**First, you want to build a prototype for it.**\r\n**In your prototype, your system will only record the quantity.**\r\nYour friend gave you a list of measurements to help you:\r\n\r\n| Unit               | Score |\r\n| ------------------ | ----- |\r\n| quarter_of_a_dozen | 3     |\r\n| half_of_a_dozen    | 6     |\r\n| dozen              | 12    |\r\n| small_gross        | 120   |\r\n| gross              | 144   |\r\n| great_gross        | 1728  |\r\n\r\n## 1. Store the unit of measurement in your program\r\n\r\nIn order to use the measurement, you need to store the measurement in your program.\r\n\r\n```go\r\nunits := Units()\r\nfmt.Println(units)\r\n// Output: map[...] with entries like (\"dozen\": 12)\r\n```\r\n\r\n## 2. Create a new customer bill\r\n\r\nYou need to implement a function that create a new (empty) bill for the customer.\r\n\r\n```go\r\nbill := NewBill()\r\nfmt.Println(bill)\r\n// Output: map[]\r\n```\r\n\r\n## 3. Add an item to the customer bill\r\n\r\nTo implement this, you'll need to:\r\n\r\n- Return `false` if the given `unit` is not in the `units` map.\r\n- Otherwise add the item to the customer `bill`, indexed by the item name, then return `true`.\r\n- If the item is already present in the bill, increase its quantity by the amount that belongs to the provided `unit`.\r\n\r\n```go\r\nbill := NewBill()\r\nunits := Units()\r\nok := AddItem(bill, units, \"carrot\", \"dozen\")\r\nfmt.Println(ok)\r\n// Output: true (since dozen is a valid unit)\r\n```\r\n\r\n> Note that the returned value is type `bool`.\r\n\r\n## 4. Remove an item from the customer bill\r\n\r\nTo implement this, you'll need to:\r\n\r\n- Return `false` if the given item is **not** in the bill\r\n- Return `false` if the given `unit` is not in the `units` map.\r\n- Return `false` if the new quantity would be less than 0.\r\n- If the new quantity is 0, completely remove the item from the `bill` then return `true`.\r\n- Otherwise, reduce the quantity of the item and return `true`.\r\n\r\n```go\r\nbill := NewBill()\r\nunits := Units()\r\nok := RemoveItem(bill, units, \"carrot\", \"dozen\")\r\nfmt.Println(ok)\r\n// Output: false (because there are no carrots in the bill)\r\n```\r\n\r\n> Note that the returned value is type `bool`.\r\n\r\n## 5. Return the quantity of a specific item that is in the customer bill\r\n\r\nTo implement this, you'll need to:\r\n\r\n- Return `0` and `false` if the `item` is not in the bill.\r\n- Otherwise, return the quantity of the item in the `bill` and `true`.\r\n\r\n```go\r\nbill := map[string]int{\"carrot\": 12, \"grapes\": 3}\r\nqty, ok := GetItem(bill, \"carrot\")\r\nfmt.Println(qty)\r\n// Output: 12\r\nfmt.Println(ok)\r\n// Output: true\r\n```\r\n\r\n> Note that the returned value are types `int` and `bool`.\r\n\r\n[gross-unit]: https://en.wikipedia.org/wiki/Gross_(unit)\r\n",
    "hints": "# Hints\r\n\r\n## General\r\n\r\n- [Go by example map][gobyexample-map]\r\n- [Go maps in action][goblog-map]\r\n\r\n## 1. Store the unit of measurement in your program\r\n\r\n- To store the measurement in your program, you can use map literal, see [go blog about map][goblog-map]\r\n\r\n## 2. Create a new bill\r\n\r\n- To create a new bill, all you need to do is reinitialize the customer, see [go blog about map][goblog-map]\r\n\r\n## 3. Add item to the customer bill\r\n\r\n- To check whether the given unit of measurement is correct, you can test your measurement map for a key without retrieving a value, see [go blog about map][goblog-map]\r\n\r\n## 4. Remove item from the customer bill\r\n\r\n- To check whether the given item is in customer bill, you can test your measurement map for a key without retrieving a value, see [go blog about map][goblog-map]\r\n\r\n- To check whether the given unit of measurement is correct, you can test your measurement map for a key without retrieving a value, see [go blog about map][goblog-map]\r\n\r\n## 5. Return the number of specific item that is in the customer bill\r\n\r\n- To check whether the given item is in customer bill, you can test your measurement map for a key without retrieving a value, see [go blog about map][goblog-map]\r\n\r\n[gobyexample-map]: https://gobyexample.com/maps\r\n[goblog-map]: https://blog.golang.org/maps\r\n"
  },
  "starter_code": "package gross\r\n\r\n// Units stores the Gross Store unit measurements.\r\nfunc Units() map[string]int {\r\n\tpanic(\"Please implement the Units() function\")\r\n}\r\n\r\n// NewBill creates a new bill.\r\nfunc NewBill() map[string]int {\r\n\tpanic(\"Please implement the NewBill() function\")\r\n}\r\n\r\n// AddItem adds an item to customer bill.\r\nfunc AddItem(bill, units map[string]int, item, unit string) bool {\r\n\tpanic(\"Please implement the AddItem() function\")\r\n}\r\n\r\n// RemoveItem removes an item from customer bill.\r\nfunc RemoveItem(bill, units map[string]int, item, unit string) bool {\r\n\tpanic(\"Please implement the RemoveItem() function\")\r\n}\r\n\r\n// GetItem returns the quantity of an item that the customer has in his/her bill.\r\nfunc GetItem(bill map[string]int, item string) (int, bool) {\r\n\tpanic(\"Please implement the GetItem() function\")\r\n}\r\n",
  "tests": "package gross\r\n\r\nimport (\r\n\t\"testing\"\r\n)\r\n\r\ntype entry struct {\r\n\tname string\r\n\tunit string\r\n\tqty  int\r\n}\r\n\r\nfunc TestUnits(t *testing.T) {\r\n\ttests := []struct {\r\n\t\tname string\r\n\t\tqty  int\r\n\t}{\r\n\t\t{\"quarter_of_a_dozen\", 3},\r\n\t\t{\"half_of_a_dozen\", 6},\r\n\t\t{\"dozen\", 12},\r\n\t\t{\"small_gross\", 120},\r\n\t\t{\"gross\", 144},\r\n\t\t{\"great_gross\", 1728},\r\n\t}\r\n\r\n\tunits := Units()\r\n\tfor _, tt := range tests {\r\n\t\tqty, ok := units[tt.name]\r\n\r\n\t\tif !ok {\r\n\t\t\tt.Errorf(`Unit \"%s\" not found!`, tt.name)\r\n\t\t\tcontinue\r\n\t\t}\r\n\r\n\t\tif qty != tt.qty {\r\n\t\t\tt.Errorf(`Unit \"%s\" should have quantity %d, found %d`, tt.name, tt.qty, qty)\r\n\t\t}\r\n\t}\r\n}\r\n\r\nfunc TestNewBill(t *testing.T) {\r\n\t// Success, zero out the  bill\r\n\tt.Run(\"Should reset customerbill\", func(t *testing.T) {\r\n\t\tbill := NewBill()\r\n\r\n\t\tif len(bill) != 0 {\r\n\t\t\tt.Error(\"Customer bill must be empty\")\r\n\t\t}\r\n\t})\r\n}\r\n\r\nfunc TestAddItem(t *testing.T) {\r\n\ttests := []struct {\r\n\t\tname     string\r\n\t\tentry    []entry\r\n\t\texpected bool\r\n\t}{\r\n\t\t{\r\n\t\t\t\"Invalid measurement unit\",\r\n\t\t\t[]entry{\r\n\t\t\t\t{\"pasta\", \"\", 0},\r\n\t\t\t\t{\"onion\", \"quarter\", 0},\r\n\t\t\t\t{\"pasta\", \"pound\", 0},\r\n\t\t\t},\r\n\t\t\tfalse,\r\n\t\t},\r\n\t\t{\r\n\t\t\t\"Valid measurement unit\",\r\n\t\t\t[]entry{\r\n\t\t\t\t{\"peas\", \"quarter_of_a_dozen\", 3},\r\n\t\t\t\t{\"tomato\", \"half_of_a_dozen\", 6},\r\n\t\t\t\t{\"chili\", \"dozen\", 12},\r\n\t\t\t\t{\"cucumber\", \"small_gross\", 120},\r\n\t\t\t\t{\"potato\", \"gross\", 144},\r\n\t\t\t\t{\"zucchini\", \"great_gross\", 1728},\r\n\t\t\t},\r\n\t\t\ttrue,\r\n\t\t},\r\n\t\t{\r\n\t\t\t\"check quantity of item added twice\",\r\n\t\t\t[]entry{\r\n\t\t\t\t{\"peas\", \"quarter_of_a_dozen\", 3},\r\n\t\t\t\t{\"peas\", \"quarter_of_a_dozen\", 6},\r\n\t\t\t\t{\"tomato\", \"half_of_a_dozen\", 6},\r\n\t\t\t\t{\"tomato\", \"quarter_of_a_dozen\", 9},\r\n\t\t\t},\r\n\t\t\ttrue,\r\n\t\t},\r\n\t}\r\n\tunits := Units()\r\n\tfor _, tt := range tests {\r\n\t\tt.Run(tt.name, func(t *testing.T) {\r\n\t\t\tbill := NewBill()\r\n\t\t\tfor _, item := range tt.entry {\r\n\t\t\t\tok := AddItem(bill, units, item.name, item.unit)\r\n\t\t\t\tif ok != tt.expected {\r\n\t\t\t\t\tt.Errorf(\"Expected %t from AddItem, found %t at %v\", tt.expected, ok, item.name)\r\n\t\t\t\t}\r\n\r\n\t\t\t\titemQty, ok := bill[item.name]\r\n\t\t\t\tif ok != tt.expected {\r\n\t\t\t\t\tt.Errorf(\"Unexpected item on bill: found %s with quantity %d\", item.name, itemQty)\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif itemQty != item.qty {\r\n\t\t\t\t\tt.Errorf(\"Expected %s to have quantity %d in customer bill, found %d\", item.name, item.qty, itemQty)\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t})\r\n\t}\r\n}\r\n\r\nfunc TestRemoveItem(t *testing.T) {\r\n\ttype expectedItem struct {\r\n\t\tname   string\r\n\t\tunit   string\r\n\t\tqty    int\r\n\t\texists bool\r\n\t}\r\n\r\n\ttests := []struct {\r\n\t\tname     string\r\n\t\tremove   []expectedItem\r\n\t\texpected bool\r\n\t}{\r\n\t\t{\r\n\t\t\t\"Item Not found in bill\",\r\n\t\t\t[]expectedItem{\r\n\t\t\t\t{\"papaya\", \"gross\", 0, false},\r\n\t\t\t},\r\n\t\t\tfalse,\r\n\t\t},\r\n\t\t{\r\n\t\t\t\"Invalid measurement unit\",\r\n\t\t\t[]expectedItem{\r\n\t\t\t\t{\"peas\", \"pound\", 3, true},\r\n\t\t\t\t{\"tomato\", \"kilogram\", 6, true},\r\n\t\t\t\t{\"cucumber\", \"stone\", 120, true},\r\n\t\t\t},\r\n\t\t\tfalse,\r\n\t\t},\r\n\t\t{\r\n\t\t\t\"Resulted qty less than 0\",\r\n\t\t\t[]expectedItem{\r\n\t\t\t\t{\"peas\", \"half_of_a_dozen\", 3, true},\r\n\t\t\t\t{\"tomato\", \"dozen\", 6, true},\r\n\t\t\t\t{\"chili\", \"small_gross\", 12, true},\r\n\t\t\t\t{\"cucumber\", \"gross\", 120, true},\r\n\t\t\t\t{\"potato\", \"great_gross\", 144, true},\r\n\t\t\t},\r\n\t\t\tfalse,\r\n\t\t},\r\n\t\t{\r\n\t\t\t\"Should delete the item if 0\",\r\n\t\t\t[]expectedItem{\r\n\t\t\t\t{\"peas\", \"quarter_of_a_dozen\", 0, false},\r\n\t\t\t\t{\"tomato\", \"half_of_a_dozen\", 0, false},\r\n\t\t\t\t{\"chili\", \"dozen\", 0, false},\r\n\t\t\t\t{\"cucumber\", \"small_gross\", 0, false},\r\n\t\t\t\t{\"potato\", \"gross\", 0, false},\r\n\t\t\t\t{\"zucchini\", \"great_gross\", 0, false},\r\n\t\t\t},\r\n\t\t\ttrue,\r\n\t\t},\r\n\t\t{\r\n\t\t\t\"Should reduce the qty\",\r\n\t\t\t[]expectedItem{\r\n\t\t\t\t{\"chili\", \"half_of_a_dozen\", 6, true},\r\n\t\t\t\t{\"cucumber\", \"dozen\", 108, true},\r\n\t\t\t\t{\"zucchini\", \"gross\", 1584, true},\r\n\t\t\t},\r\n\t\t\ttrue,\r\n\t\t},\r\n\t}\r\n\r\n\tunits := Units()\r\n\tfor _, tt := range tests {\r\n\t\tt.Run(tt.name, func(t *testing.T) {\r\n\t\t\tbill := setupInitialBillData()\r\n\t\t\tfor _, item := range tt.remove {\r\n\t\t\t\tok := RemoveItem(bill, units, item.name, item.unit)\r\n\t\t\t\tif ok != tt.expected {\r\n\t\t\t\t\tt.Errorf(\"Expected %t from RemoveItem, found %t at %v\", tt.expected, ok, item.name)\r\n\t\t\t\t}\r\n\r\n\t\t\t\titemQty, ok := bill[item.name]\r\n\t\t\t\tif ok != item.exists {\r\n\t\t\t\t\tt.Errorf(\"Could not find item %s in customer bill\", item.name)\r\n\t\t\t\t}\r\n\t\t\t\tif itemQty != item.qty {\r\n\t\t\t\t\tt.Errorf(\"Expected %s to have quantity %d in customer bill, found %d\", item.name, item.qty, itemQty)\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t})\r\n\t}\r\n}\r\n\r\nfunc TestGetItem(t *testing.T) {\r\n\ttype expectedItem struct {\r\n\t\tname     string\r\n\t\texpected bool\r\n\t\tqty      int\r\n\t}\r\n\r\n\ttest := []struct {\r\n\t\tname    string\r\n\t\tgetItem []expectedItem\r\n\t}{\r\n\t\t{\r\n\t\t\t\"Item Not found in bill\",\r\n\t\t\t[]expectedItem{\r\n\t\t\t\t{\"grape\", false, 0},\r\n\t\t\t},\r\n\t\t},\r\n\t\t{\r\n\t\t\t\"Success\",\r\n\t\t\t[]expectedItem{\r\n\t\t\t\t{\"peas\", true, 3},\r\n\t\t\t\t{\"tomato\", true, 6},\r\n\t\t\t\t{\"chili\", true, 12},\r\n\t\t\t\t{\"cucumber\", true, 120},\r\n\t\t\t\t{\"potato\", true, 144},\r\n\t\t\t\t{\"zucchini\", true, 1728},\r\n\t\t\t},\r\n\t\t},\r\n\t}\r\n\r\n\tfor _, tt := range test {\r\n\t\tt.Run(tt.name, func(t *testing.T) {\r\n\t\t\tbill := setupInitialBillData()\r\n\t\t\tfor _, item := range tt.getItem {\r\n\t\t\t\titemQty, ok := GetItem(bill, item.name)\r\n\r\n\t\t\t\tif ok != item.expected {\r\n\t\t\t\t\tmsg := \"Could not find item %s in customer bill, expected %t\"\r\n\t\t\t\t\tif item.expected == false {\r\n\t\t\t\t\t\tmsg = \"Found item %s in customer bill, expected %t\"\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tt.Errorf(msg, item.name, item.expected)\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif itemQty != item.qty {\r\n\t\t\t\t\tt.Errorf(\"Expected %s to have quantity %d in customer bill, found %d\", item.name, item.qty, itemQty)\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t})\r\n\t}\r\n}\r\n\r\nfunc setupInitialBillData() map[string]int {\r\n\tbill := NewBill()\r\n\tbill[\"peas\"] = 3\r\n\tbill[\"tomato\"] = 6\r\n\tbill[\"chili\"] = 12\r\n\tbill[\"cucumber\"] = 120\r\n\tbill[\"potato\"] = 144\r\n\tbill[\"zucchini\"] = 1728\r\n\treturn bill\r\n}\r\n"
}