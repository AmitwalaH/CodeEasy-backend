{
  "language": "go",
  "slug": "jedliks-toys",
  "docs": {
    "introduction": "# Introduction\r\n\r\nA method is a function with a special _receiver_ argument. The receiver appears in its own argument list between `func` keyword and the name of the method.\r\n\r\n```go\r\nfunc (receiver type) MethodName(parameters) (returnTypes) {\r\n}\r\n```\r\n\r\nYou can only define a method with a receiver whose type is defined in the same package as the method.\r\n\r\n```go\r\npackage person \r\n\r\ntype Person struct {\r\n\tName string\r\n}\r\n\r\nfunc (p Person) Greetings() string {\r\n\treturn fmt.Sprintf(\"Welcome %s!\", p.Name)\r\n}\r\n```\r\n\r\nThe method on the struct can be called via dot notation.\r\n\r\n```go\r\np := Person{Name: \"Bronson\"}\r\nfmt.Println(p.Greetings())\r\n// Output: Welcome Bronson!\r\n```\r\n\r\nNotice the way we called the method `Greetings()` on the `Person` instance `p`.\r\nItâ€™s exactly like the way you call methods in an object-oriented programming language.\r\n\r\nRemember: a method is just a function with a receiver argument.\r\nMethods help to avoid naming conflicts - since a method is tied to a particular receiver type, you can have the same method name on different types.\r\n\r\n```go\r\nimport \"math\"\r\n\r\ntype rect struct {\r\n\twidth, height int\r\n}\r\nfunc (r rect) area() int {\r\n\treturn r.width * r.height\r\n}\r\n\r\ntype circle struct {\r\n\tradius int\r\n}\r\nfunc (c circle) area() float64 {\r\n\treturn math.Pow(float64(c.radius), 2) * math.Pi\r\n}\r\n```\r\n\r\nThere are two types of receivers, value receivers, and pointer receivers.\r\n\r\nAll the methods we have seen so far have a value receiver which means they will receive a copy of the value passed to the method, meaning that any modification done to the receiver inside the method is not visible to the caller.\r\n\r\nYou can declare methods with pointer receivers in order to modify the value to which the receiver points.\r\nThis is done by prefixing the type name with a `*`.\r\nFor example with the `rect` type, a pointer receiver would be declared as `*rect`.\r\nSuch modifications are visible to the caller of the method as well.\r\n\r\n```go\r\ntype rect struct {\r\n\twidth, height int\r\n}\r\nfunc (r *rect) squareIt() {\r\n\tr.height = r.width\r\n}\r\n\r\nr := rect{width: 10, height: 20}\r\nfmt.Printf(\"Width: %d, Height: %d\\n\", r.width, r.height)\r\n// Output: Width: 10, Height: 20\r\n\r\nr.squareIt()\r\nfmt.Printf(\"Width: %d, Height: %d\\n\", r.width, r.height)\r\n// Output: Width: 10, Height: 10\r\n```\r\n",
    "instructions": "# Instructions\r\n\r\nNote: This exercise is a continuation of the `need-for-speed` exercise.\r\n\r\nIn this exercise you'll be organizing races between various types of remote controlled cars. Each car has its own speed and battery drain characteristics.\r\n\r\nCars start with full (100%) batteries. Each time you drive the car using the remote control, it covers the car's speed in meters and decreases the remaining battery percentage by its battery drain.\r\n\r\nIf a car's battery is below its battery drain percentage, you can't drive the car anymore.\r\n\r\nThe remote controlled car has a fancy LED display that shows two bits of information:\r\n\r\n- The total distance it has driven, displayed as: `\"Driven <METERS> meters\"`.\r\n- The remaining battery charge, displayed as: `\"Battery at <PERCENTAGE>%\"`.\r\n\r\nEach race track has its own distance. Cars are tested by checking if they can finish the track without running out of battery.\r\n\r\n## 1. Drive the car\r\n\r\nImplement the `Drive` method on the `Car` that updates the number of meters driven based on the car's speed, and reduces the battery according to the battery drainage:\r\n\r\n```go\r\nspeed := 5\r\nbatteryDrain := 2\r\ncar := NewCar(speed, batteryDrain)\r\ncar.Drive()\r\n// car is now Car{speed: 5, batteryDrain: 2, battery: 98, distance: 5}\r\n```\r\n\r\nNote: You should not try to drive the car if doing so will cause the car's battery to be below 0.\r\n\r\n## 2. Display the distance driven\r\n\r\nImplement a `DisplayDistance` method on `Car` to return the distance as displayed on the LED display as a `string`:\r\n\r\n```go\r\nspeed := 5\r\nbatteryDrain := 2\r\ncar := NewCar(speed, batteryDrain)\r\n\r\nfmt.Println(car.DisplayDistance())\r\n// Output: \"Driven 0 meters\"\r\n```\r\n\r\n## 3. Display the battery percentage\r\n\r\nImplement the `DisplayBattery` method on `Car` to return the battery percentage as displayed on the LED display as a `string`:\r\n\r\n```go\r\nspeed := 5\r\nbatteryDrain := 2\r\ncar := NewCar(speed, batteryDrain)\r\n\r\nfmt.Println(car.DisplayBattery())\r\n// Output: \"Battery at 100%\"\r\n```\r\n\r\n## 4. Check if a remote control car can finish a race\r\n\r\nTo finish a race, a car has to be able to drive the race's distance. This means not draining its battery before having crossed the finish line. Implement the `CanFinish` method that takes a `trackDistance int` as its parameter and returns `true` if the car can finish the race; otherwise, return `false`:\r\n\r\n```go\r\nspeed := 5\r\nbatteryDrain := 2\r\ncar := NewCar(speed, batteryDrain)\r\n\r\ntrackDistance := 100\r\n\r\ncar.CanFinish(trackDistance)\r\n// => true\r\n```\r\n",
    "hints": "# Hints\r\n\r\n## 1. Drive a car\r\n\r\n- Add a field to the `Car` struct that keeps track of the driven distance\r\n- Create a [method][method] that has a receiver of type `Car` and updates the driven distance\r\n\r\n## 2. Display the distance driven\r\n\r\n- Create a [method][method] that has a receiver of type `Car`\r\n- Show the value of the _distance_ field\r\n\r\n## 3. Display the battery percentage\r\n\r\n- Create a [method][method] that has a receiver of type `Car`\r\n- Show the value of the _battery_ field\r\n\r\n## 4. Check if a remote car can finish a race\r\n\r\n- Remember the car has a [method][method] to retrieve the distance it has driven\r\n- Consider what to do when the battery has been drained before reaching the finish line\r\n\r\n[method]: https://tour.golang.org/methods/1\r\n"
  },
  "starter_code": "package jedlik\r\n\r\n// TODO: define the 'Drive()' method\r\n\r\n// TODO: define the 'DisplayDistance() string' method\r\n\r\n// TODO: define the 'DisplayBattery() string' method\r\n\r\n// TODO: define the 'CanFinish(trackDistance int) bool' method\r\n\r\n// Your first steps could be to read through the tasks, and create\r\n// these functions with their correct parameter lists and return types.\r\n// The function body only needs to contain `panic(\"\")`.\r\n//\r\n// This will make the tests compile, but they will fail.\r\n// You can then implement the function logic one by one and see\r\n// an increasing number of tests passing as you implement more\r\n// functionality.\r\n",
  "tests": "package jedlik\r\n\r\nimport (\r\n\t\"testing\"\r\n)\r\n\r\nfunc TestDrive(t *testing.T) {\r\n\ttests := []struct {\r\n\t\tname     string\r\n\t\tcar      Car\r\n\t\texpected Car\r\n\t}{\r\n\t\t{\r\n\t\t\tname: \"Drive the car once.\",\r\n\t\t\tcar: Car{\r\n\t\t\t\tspeed:        5,\r\n\t\t\t\tbatteryDrain: 2,\r\n\t\t\t\tbattery:      100,\r\n\t\t\t\tdistance:     0,\r\n\t\t\t},\r\n\t\t\texpected: Car{\r\n\t\t\t\tspeed:        5,\r\n\t\t\t\tbatteryDrain: 2,\r\n\t\t\t\tbattery:      98,\r\n\t\t\t\tdistance:     5,\r\n\t\t\t},\r\n\t\t},\r\n\t\t{\r\n\t\t\tname: \"Drive when battery percentage is below battery drain\",\r\n\t\t\tcar: Car{\r\n\t\t\t\tspeed:        5,\r\n\t\t\t\tbatteryDrain: 7,\r\n\t\t\t\tbattery:      3,\r\n\t\t\t\tdistance:     0,\r\n\t\t\t},\r\n\t\t\texpected: Car{\r\n\t\t\t\tspeed:        5,\r\n\t\t\t\tbatteryDrain: 7,\r\n\t\t\t\tbattery:      3,\r\n\t\t\t\tdistance:     0,\r\n\t\t\t},\r\n\t\t},\r\n\t}\r\n\r\n\tfor _, tt := range tests {\r\n\t\tt.Run(tt.name, func(t *testing.T) {\r\n\t\t\tcar := tt.car\r\n\t\t\tcar.Drive()\r\n\r\n\t\t\tif car != tt.expected {\r\n\t\t\t\tt.Errorf(\"method Drive() = %v; expected %v\", car, tt.expected)\r\n\t\t\t}\r\n\t\t})\r\n\t}\r\n}\r\n\r\nfunc TestDisplayDistance(t *testing.T) {\r\n\ttests := []struct {\r\n\t\tname     string\r\n\t\tcar      Car\r\n\t\texpected string\r\n\t}{\r\n\t\t{\r\n\t\t\tname: \"Car displays driven distance\",\r\n\t\t\tcar: Car{\r\n\t\t\t\tspeed:        5,\r\n\t\t\t\tbatteryDrain: 2,\r\n\t\t\t\tbattery:      100,\r\n\t\t\t\tdistance:     0,\r\n\t\t\t},\r\n\t\t\texpected: \"Driven 0 meters\",\r\n\t\t},\r\n\t}\r\n\r\n\tfor _, tt := range tests {\r\n\t\tt.Run(tt.name, func(t *testing.T) {\r\n\t\t\tgot := tt.car.DisplayDistance()\r\n\r\n\t\t\tif got != tt.expected {\r\n\t\t\t\tt.Errorf(\"method DisplayDistance() = %v; Expected value %v\", got, tt.expected)\r\n\t\t\t}\r\n\t\t})\r\n\t}\r\n}\r\n\r\nfunc TestDisplayBattery(t *testing.T) {\r\n\ttests := []struct {\r\n\t\tname     string\r\n\t\tcar      Car\r\n\t\texpected string\r\n\t}{\r\n\t\t{\r\n\t\t\tname: \"Display battery percentage\",\r\n\t\t\tcar: Car{\r\n\t\t\t\tspeed:        5,\r\n\t\t\t\tbatteryDrain: 2,\r\n\t\t\t\tbattery:      100,\r\n\t\t\t\tdistance:     0,\r\n\t\t\t},\r\n\t\t\texpected: \"Battery at 100%\",\r\n\t\t},\r\n\t}\r\n\r\n\tfor _, tt := range tests {\r\n\t\tt.Run(tt.name, func(t *testing.T) {\r\n\t\t\tgot := tt.car.DisplayBattery()\r\n\r\n\t\t\tif got != tt.expected {\r\n\t\t\t\tt.Errorf(\"method DisplayBattery() = %v; Expected value %v\", got, tt.expected)\r\n\t\t\t}\r\n\t\t})\r\n\t}\r\n}\r\n\r\nfunc TestCanFinish(t *testing.T) {\r\n\ttests := []struct {\r\n\t\tname          string\r\n\t\tcar           Car\r\n\t\ttrackDistance int\r\n\t\texpected      bool\r\n\t}{\r\n\t\t{\r\n\t\t\tname: \"Car has 100% battery. Car can finish the race\",\r\n\t\t\tcar: Car{\r\n\t\t\t\tspeed:        5,\r\n\t\t\t\tbatteryDrain: 2,\r\n\t\t\t\tbattery:      100,\r\n\t\t\t},\r\n\t\t\ttrackDistance: 100,\r\n\t\t\texpected:      true,\r\n\t\t},\r\n\t\t{\r\n\t\t\tname: \"Car has 40% battery. Car can finish the race\",\r\n\t\t\tcar: Car{\r\n\t\t\t\tspeed:        5,\r\n\t\t\t\tbatteryDrain: 2,\r\n\t\t\t\tbattery:      40,\r\n\t\t\t},\r\n\t\t\ttrackDistance: 100,\r\n\t\t\texpected:      true,\r\n\t\t},\r\n\t\t{\r\n\t\t\tname: \"Car has 60% battery. Car cannot finish the race\",\r\n\t\t\tcar: Car{\r\n\t\t\t\tspeed:        3,\r\n\t\t\t\tbatteryDrain: 3,\r\n\t\t\t\tbattery:      60,\r\n\t\t\t},\r\n\t\t\ttrackDistance: 61,\r\n\t\t\texpected:      false,\r\n\t\t},\r\n\t\t{\r\n\t\t\tname: \"Car has 30% battery. Car cannot finish the race\",\r\n\t\t\tcar: Car{\r\n\t\t\t\tspeed:        5,\r\n\t\t\t\tbatteryDrain: 2,\r\n\t\t\t\tbattery:      30,\r\n\t\t\t},\r\n\t\t\ttrackDistance: 100,\r\n\t\t\texpected:      false,\r\n\t\t},\r\n\t}\r\n\r\n\tfor _, tt := range tests {\r\n\t\tt.Run(tt.name, func(t *testing.T) {\r\n\t\t\tgot := tt.car.CanFinish(tt.trackDistance)\r\n\r\n\t\t\tif got != tt.expected {\r\n\t\t\t\tt.Errorf(\"method CanFinish(%v) = %v. Expected value %v\", tt.trackDistance, got, tt.expected)\r\n\t\t\t}\r\n\t\t})\r\n\t}\r\n}\r\n"
}