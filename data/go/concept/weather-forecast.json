{
  "language": "go",
  "slug": "weather-forecast",
  "docs": {
    "introduction": "# Introduction\r\n\r\nIn the previous exercise, we saw that there are two ways to write comments in Go: single-line comments that are preceded by `//`, and multiline comment blocks that are wrapped with `/*` and `*/`.\r\n\r\n## Documentation comments\r\n\r\nIn Go, comments play an important role in documenting code. They are used by the `godoc` command, which extracts these comments to create documentation about Go packages. A documentation comment should be a complete sentence that starts with the name of the thing being described and ends with a period.\r\n\r\nComments should precede packages as well as exported identifiers, for example exported functions, methods, package variables, constants, and structs, which you will learn more about in the next exercises.\r\n\r\nA package-level variable can look like this:\r\n\r\n```go\r\n// TemperatureCelsius represents a certain temperature in degrees Celsius.\r\nvar TemperatureCelsius float64\r\n```\r\n\r\n## Package comments\r\n\r\nPackage comments should be written directly before a package clause (`package x`) and begin with `Package x ...` like this:\r\n\r\n```go\r\n// Package kelvin provides tools to convert\r\n// temperatures to and from Kelvin.\r\npackage kelvin\r\n```\r\n\r\n## Function comments\r\n\r\nA function comment should be written directly before the function declaration. It should be a full sentence that starts with the function name. For example, an exported comment for the function `Calculate` should take the form `Calculate  ...`. It should also explain what arguments the function takes, what it does with them, and what its return values mean, ending in a period):\r\n\r\n```go\r\n// CelsiusFreezingTemp returns an integer value equal to the temperature at which water freezes in degrees Celsius.\r\nfunc CelsiusFreezingTemp() int {\r\n\treturn 0\r\n}\r\n```\r\n",
    "instructions": "# Instructions\r\n\r\nGoblinocus is a country that takes its weather forecast very seriously. Since you are a renowned, responsible and proficient developer, they asked you to write a program that can forecast the current weather condition of various cities in Goblinocus. You were busy at the time and asked one of your friends to do the job instead. After a while, the president of Goblinocus contacted you and said they do not understand your friend's code. When you check the code, you discover that your friend did not act as a responsible programmer and there are no comments in the code. You feel obligated to clarify the program so goblins can understand them as well.\r\n\r\n## 1. Document package weather\r\n\r\nSince goblins are not as smart as you are, they forgot what the package should do for them. Please write a comment for `package weather` that describes its contents. The package comment should introduce the package and provide information relevant to the package as a whole.\r\n\r\n## 2. Document the CurrentCondition and CurrentLocation variables\r\n\r\nThe president of Goblinocus is a bit paranoid and fears uncommented variables are used to destroy their country. Please clarify the usage of the package variables `CurrentCondition` and `CurrentLocation` and put the president's mind at ease. This should tell any user of the package what information the variables store, and what they can do with it.\r\n\r\n## 3. Document the Forecast() function\r\n\r\nGoblinocus forecast operators want to know what the `Forecast()` function does (but do not tell them how it works, since unfortunately, they will get more confused). Please write a comment for this function that describes what the function does, but not how it does it.\r\n",
    "hints": "# Hints\r\n\r\n## General\r\n\r\n- A [documentation comment][comment] should be written directly before the entity that it is describing, start with the name of what it is describing, take the form of a sentence, and end with a period.\r\n\r\n## 1. Document package weather\r\n\r\n- The [package comment][comment] should be written directly before the package, start with `Package x`, and end with a period.\r\n\r\n## 2. Document the CurrentCondition and CurrentLocation variables\r\n\r\n- The [variable comment][variable comment] should be written right before the variable that it is describing, start with its name, and end with a period.\r\n\r\n## 3. Document the Forecast() function\r\n\r\n- The [function comment][comment] should come directly before the function, start with the name of the function and end with a period.\r\n\r\n[comment]: https://golang.org/doc/effective_go.html#commentary\r\n[variable comment]: https://dave.cheney.net/practical-go/presentations/qcon-china.html#_comments\r\n"
  },
  "starter_code": "package weather\r\n\r\nvar (\r\n\tCurrentCondition string\r\n\tCurrentLocation  string\r\n)\r\n\r\nfunc Forecast(city, condition string) string {\r\n\tCurrentLocation, CurrentCondition = city, condition\r\n\treturn CurrentLocation + \" - current weather condition: \" + CurrentCondition\r\n}\r\n",
  "tests": "package weather\r\n\r\nimport (\r\n\t\"fmt\"\r\n\t\"go/ast\"\r\n\t\"go/parser\"\r\n\t\"go/token\"\r\n\t\"strings\"\r\n\t\"testing\"\r\n)\r\n\r\nfunc TestComments(t *testing.T) {\r\n\tfilename := \"weather_forecast.go\"\r\n\r\n\tfs := token.NewFileSet()\r\n\tf, err := parser.ParseFile(fs, filename, nil, parser.ParseComments)\r\n\tif err != nil {\r\n\t\tt.Fatal(err)\r\n\t}\r\n\r\n\twantedComments := 4\r\n\tgot := len(f.Comments)\r\n\tif got != wantedComments {\r\n\t\tt.Errorf(\"Incorrect number of comments: got %d, want %d\", got, wantedComments)\r\n\t}\r\n\r\n\ttestPackageComment(t, f)\r\n\r\n\tast.Inspect(f, func(node ast.Node) bool {\r\n\t\tswitch n := node.(type) {\r\n\t\tcase *ast.GenDecl:\r\n\t\t\tif n.Lparen.IsValid() {\r\n\t\t\t\tfor _, v := range n.Specs {\r\n\t\t\t\t\ttestBlockIdentifierComment(t, v.(*ast.ValueSpec))\r\n\t\t\t\t}\r\n\t\t\t} else {\r\n\t\t\t\ttestIdentifierComment(t, n)\r\n\t\t\t}\r\n\t\tcase *ast.FuncDecl:\r\n\t\t\ttestFunctionComment(t, n)\r\n\t\t}\r\n\t\treturn true\r\n\t})\r\n}\r\n\r\nfunc testPackageComment(t *testing.T, node *ast.File) {\r\n\tt.Helper()\r\n\tif node.Doc == nil {\r\n\t\tt.Errorf(\"Package weather should have a comment\")\r\n\t}\r\n\r\n\tpackageName := node.Name.Name\r\n\twant := \"Package \" + packageName\r\n\tpackageComment := node.Doc.Text()\r\n\r\n\tif ok, errStr := testComment(\"Package\", packageName, packageComment, want); !ok {\r\n\t\tt.Error(errStr)\r\n\t}\r\n}\r\n\r\nfunc testIdentifierComment(t *testing.T, node *ast.GenDecl) {\r\n\tt.Helper()\r\n\r\n\tidentifierName := node.Specs[0].(*ast.ValueSpec).Names[0].Name\r\n\tif node.Doc == nil {\r\n\t\tt.Errorf(\"Exported identifier %s should have a comment\", identifierName)\r\n\t}\r\n\r\n\tidentifierComment := node.Doc.Text()\r\n\twant := identifierName\r\n\r\n\tif ok, errStr := testComment(\"Variable\", identifierName, identifierComment, want); !ok {\r\n\t\tt.Error(errStr)\r\n\t}\r\n}\r\n\r\nfunc testBlockIdentifierComment(t *testing.T, node *ast.ValueSpec) {\r\n\tt.Helper()\r\n\r\n\tidentifierName := node.Names[0].Name\r\n\tif node.Doc == nil {\r\n\t\tt.Errorf(\"Exported identifier %s should have a comment\", identifierName)\r\n\t}\r\n\r\n\tidentifierComment := node.Doc.Text()\r\n\twant := identifierName\r\n\r\n\tif ok, errStr := testComment(\"Variable\", identifierName, identifierComment, want); !ok {\r\n\t\tt.Error(errStr)\r\n\t}\r\n}\r\n\r\nfunc testFunctionComment(t *testing.T, node *ast.FuncDecl) {\r\n\tt.Helper()\r\n\tfuncName := node.Name.Name\r\n\tif node.Doc == nil {\r\n\t\tt.Errorf(\"Exported function %s() should have a comment\", funcName)\r\n\t}\r\n\r\n\tfuncComment := node.Doc.Text()\r\n\twant := funcName\r\n\r\n\tif ok, errStr := testComment(\"Function\", funcName, funcComment, want); !ok {\r\n\t\tt.Error(errStr)\r\n\t}\r\n}\r\n\r\nfunc testComment(entityKind, entityName, comment, wantedPrefix string) (ok bool, errString string) {\r\n\ttrimmedComment := strings.TrimSpace(comment)\r\n\tlowerEntity := strings.ToLower(entityKind)\r\n\r\n\t// Check if comment has wanted prefix\r\n\tif !strings.HasPrefix(trimmedComment, wantedPrefix) {\r\n\t\terrorString := fmt.Sprintf(\"%s comment for %s '%s' should start with '// %s ...': got '// %s'\",\r\n\t\t\tentityKind, lowerEntity, entityName, wantedPrefix, trimmedComment)\r\n\t\treturn false, errorString\r\n\t}\r\n\r\n\t// Check if comment content is empty\r\n\tcommentContent := strings.TrimPrefix(trimmedComment, wantedPrefix)\r\n\tcommentContent = strings.TrimSpace(commentContent)\r\n\tcommentContent = strings.TrimSuffix(commentContent, \".\")\r\n\r\n\tif commentContent == \"\" {\r\n\t\tlowerEntity := strings.ToLower(entityKind)\r\n\t\terrorString := fmt.Sprintf(\"%s comment of '%s' should provide a description of the %s, e.g '// %s <%s_description>'\",\r\n\t\t\tentityKind, entityName, lowerEntity, wantedPrefix, lowerEntity)\r\n\t\treturn false, errorString\r\n\t}\r\n\r\n\t// Check if comment ends in a period\r\n\tif !strings.HasSuffix(trimmedComment, \".\") {\r\n\t\treturn false, fmt.Sprintf(\"%s comment for %s '%s' should end with a period (.)\",\r\n\t\t\tentityKind, lowerEntity, entityName)\r\n\t}\r\n\r\n\treturn true, \"\"\r\n}\r\n"
}