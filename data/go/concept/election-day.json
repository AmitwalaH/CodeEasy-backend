{
  "language": "go",
  "slug": "election-day",
  "docs": {
    "introduction": "# Introduction\r\n\r\nLike many other languages, Go has pointers.\r\nIf you're new to pointers, they can feel a little mysterious but once you get used to them, they're quite straight-forward.\r\nThey're a crucial part of Go, so take some time to really understand them.\r\n\r\nBefore digging into the details, it's worth understanding the use of pointers. Pointers are a way to share memory with other parts of our program, which is useful for two major reasons:\r\n1. When we have large amounts of data, making copies to pass between functions is very inefficient.\r\n  By passing the memory location of where the data is stored instead, we can dramatically reduce the resource-footprint of our programs.\r\n2. By passing pointers between functions, we can access and modify the single copy of the data directly, meaning that any changes made by one function are immediately visible to other parts of the program when the function ends.\r\n\r\n## Variables and Memory\r\n\r\nLet's say we have a regular integer variable `a`:\r\n\r\n```go\r\nvar a int\r\n```\r\n\r\nWhen we declare a variable, Go has to find a place in memory to store its value. This is largely abstracted from us â€” when we need to fetch the value stored in that piece of memory, we can just refer to it by the variable name.\r\n\r\nFor instance, when we write `a + 2`, we are effectively fetching the value stored in the memory associated with the variable `a` and adding 2 to it.\r\n\r\nSimilarly, when we need to change the value in the piece of memory of `a`, we can use the variable name to do an assignment:\r\n\r\n```go\r\na = 3\r\n```\r\n\r\nThe piece of memory that is associated with `a` will now be storing the value `3`.\r\n\r\n## Pointers\r\n\r\nWhile variables allow us to refer to values in memory, sometimes it's useful to know the **memory address** to which the variable is pointing. **Pointers** hold the memory addresses of those values. You declare a variable with a pointer type by prefixing the underlying type with an asterisk:\r\n\r\n```go\r\nvar p *int // 'p' contains the memory address of an integer\r\n```\r\n\r\nHere we declare a variable `p` of type \"pointer to int\" (`*int`). This means that `p` will hold the memory address of an integer. The zero value of pointers is `nil` because a `nil` pointer holds no memory address.\r\n\r\n### Getting a pointer to a variable\r\n\r\nTo find the memory address of the value of a variable, we can use the `&` operator.\r\nFor example, if we want to find and store the memory address of variable `a` in the pointer `p`, we can do the following:\r\n\r\n```go\r\nvar a int\r\na = 2\r\n\r\nvar p *int\r\np = &a // the variable 'p' contains the memory address of 'a'\r\n```\r\n\r\n### Accessing the value via a pointer (dereferencing)\r\n\r\nWhen we have a pointer, we might want to know the value stored in the memory address the pointer represents. We can do this using the `*` operator:\r\n\r\n```go\r\nvar a int\r\na = 2\r\n\r\nvar p *int\r\np = &a // the variable 'p' contains the memory address of 'a'\r\n\r\nvar b int\r\nb = *p // b == 2\r\n```\r\n\r\nThe operation `*p` fetches the value stored at the memory address stored in `p`. This operation is often called \"dereferencing\".\r\n\r\nWe can also use the dereference operator to assign a new value to the memory address referenced by the pointer:\r\n\r\n```go\r\nvar a int        // declare int variable 'a'\r\na = 2            // assign 'a' the value of 2\r\n\r\nvar pa *int\r\npa = &a          // 'pa' now contains to the memory address of 'a'\r\n*pa = *pa + 2    // increment by 2 the value at memory address 'pa'\r\n\r\nfmt.Println(a)   // Output: 4\r\n                 // 'a' will have the new value that was changed via the pointer!\r\n```\r\n\r\nAssigning to `*pa` will change the value stored at the memory address `pa` holds. Since `pa` holds the memory address of `a`, by assigning to `*pa` we are effectively changing the value of `a`!\r\n\r\nA note of caution however: always check if a pointer is not `nil` before dereferencing. Dereferencing a `nil` pointer will make the program crash at runtime!\r\n\r\n```go\r\nvar p *int // p is nil initially\r\nfmt.Println(*p)\r\n// panic: runtime error: invalid memory address or nil pointer dereference\r\n```\r\n\r\n### Pointers to structs\r\n\r\nSo far we've only seen pointers to primitive values. We can also create pointers for structs:\r\n\r\n```go\r\ntype Person struct {\r\n    Name string\r\n    Age  int\r\n}\r\n\r\nvar peter Person\r\npeter = Person{Name: \"Peter\", Age: 22}\r\n\r\nvar p *Person\r\np = &peter\r\n```\r\n\r\nWe could have also created a new `Person` and immediately stored a pointer to it:\r\n\r\n```go\r\nvar p *Person\r\np = &Person{Name: \"Peter\", Age: 22}\r\n```\r\n\r\nWhen we have a pointer to a struct, we don't need to dereference the pointer before accessing one of the fields:\r\n\r\n```go\r\nvar p *Person\r\np = &Person{Name: \"Peter\", Age: 22}\r\n\r\nfmt.Println(p.Name) // Output: \"Peter\"\r\n                    // Go automatically dereferences 'p' to allow\r\n                    // access to the 'Name' field\r\n```\r\n\r\n## Slices and maps are already pointers\r\n\r\nSlices and maps are special types because they already have pointers in their implementation. This means that more often than not, we don't need to create pointers for these types to share the memory address for their values. Imagine we have a function that increments the value of a key in a map:\r\n\r\n\r\n```go\r\nfunc incrementPeterAge(m map[string]int) {\r\n\tm[\"Peter\"] += 1\r\n}\r\n```\r\n\r\nIf we create a map and call this function, the changes the function made to the map persist after the function ended. This is a similar behavior we get if we were using a pointer, but note how on this example we are not using any referencing/dereferencing or any of the pointer syntax:\r\n\r\n```go\r\nages := map[string]int{\r\n  \"Peter\": 21\r\n}\r\nincrementPeterAge(ages)\r\nfmt.Println(ages)\r\n// Output: map[Peter:22]\r\n// The changes the function 'incrementPeterAge' made to the map are visible after the function ends!\r\n```\r\n\r\nThe same applies when changing an existing item in a slice.\r\n\r\nHowever, actions that return a new slice like `append` are a special case and **might not** modify the slice outside of the function. This is due to the way slices work internally, but we won't cover this in detail in this exercise, as this is a more advanced topic. If you are really curious you can read more about this in [Go Blog: Mechanics of 'append'][mechanics-of-append]\r\n\r\n[mechanics-of-append]: https://go.dev/blog/slices\r\n",
    "instructions": "# Instructions\r\n\r\nA local school near you has a very active students' association.\r\nThe students' association is managed by a president and once every 2 years,\r\nelections are run to elect a new president.\r\n\r\nIn this year's election, it was decided that a new digital system to\r\ncount the votes was needed. The school needs your help building this new system.\r\n\r\n## 1. Create a vote counter\r\n\r\nOne of the first things that the new voting system needs is a vote counter.\r\nThis counter is a way to keep track of the votes a particular candidate has.\r\n\r\nCreate a function `NewVoteCounter` that accepts the number of initial votes for a candidate and returns a pointer referring to an `int`, initialized with the given number of initial votes.\r\n\r\n```go\r\nvar initialVotes int\r\ninitialVotes = 2\r\n\r\nvar counter *int\r\ncounter = NewVoteCounter(initialVotes)\r\n*counter == initialVotes // true\r\n```\r\n\r\n## 2. Get number of votes from a counter\r\n\r\nYou now have a way to create new counters! But now you realize the new system will also need a way to get the number of votes from a counter.\r\n\r\nCreate a function `VoteCount` that will take a counter (`*int`) as an argument and will return the number of votes in the counter. If the counter is `nil` you should assume the counter has no votes:\r\n\r\n```go\r\nvar votes int\r\nvotes = 3\r\n\r\nvar voteCounter *int\r\nvoteCounter = &votes\r\n\r\nVoteCount(voteCounter)\r\n// => 3\r\n\r\nvar nilVoteCounter *int\r\nVoteCount(nilVoteCounter)\r\n// => 0\r\n```\r\n\r\n## 3. Increment the votes of a counter\r\n\r\nIt's finally the time to count the votes! Now you need a way to increment the votes in a counter.\r\n\r\nCreate a function `IncrementVoteCount` that will take a counter (`*int`) as an argument and a number of votes, and will increment the counter by that number of votes. You can assume the pointer passed will never be `nil`.\r\n\r\n```go\r\nvar votes int\r\nvotes = 3\r\n\r\nvar voteCounter *int\r\nvoteCounter = &votes\r\n\r\nIncrementVoteCount(voteCounter, 2)\r\n\r\nvotes == 5          // true\r\n*voteCounter == 5   // true\r\n```\r\n\r\n## 4. Create the election results\r\n\r\nWith all the votes now counted, it's time to prepare the result announcement to the whole school.\r\nFor this, you notice that having only counters for the votes is insufficient.\r\nThere needs to be a way to associate the number of votes with a particular candidate.\r\n\r\nCreate a function `NewElectionResult` that receives the name of a candidate and their number of votes and\r\nreturns a new election result.\r\n\r\n```go\r\nvar result *ElectionResult\r\nresult = NewElectionResult(\"Peter\", 3)\r\n\r\nresult.Name == \"Peter\"  // true\r\nresult.Votes == 3       // true\r\n```\r\n\r\nThe election result struct is already created for you and it's defined as:\r\n\r\n```go\r\ntype ElectionResult struct {\r\n    // Name of the candidate\r\n    Name    string\r\n    // Votes of votes the candidate had\r\n    Votes   int\r\n}\r\n```\r\n\r\n## 5. Announce the results\r\n\r\nIt's time to announce the new president to the school!\r\nThe president will be announced in the little digital message boards that the school has.\r\nThe message should show the name of the new president and the votes they had, in the following format: `<candidate_name> (<votes>)`. This is an example of such message: `\"Peter (51)\"`.\r\n\r\nCreate a function `DisplayResult` that will receive an `*ElectionResult` as an argument and will return a string with the message to display.\r\n\r\n\r\n```go\r\nvar result *ElectionResult\r\nresult = &ElectionResult{\r\n    Name: \"John\",\r\n    Votes: 32,\r\n}\r\n\r\nDisplayResult(result)\r\n// => John (32)\r\n```\r\n\r\n## 6. Vote recounting\r\n\r\nTo make sure the final results were accurate, the votes were recounted. In the recount, it was found that the number votes for some of the candidates was off by one.\r\n\r\nCreate a function `DecrementVotesOfCandidate` that receives the final results and the name of a candidate for which you should decrement its vote count. The final results are given in the form of a `map[string]int`, where the keys are the names of the candidates and the values are its total votes.\r\n\r\n```go\r\nvar finalResults = map[string]int{\r\n    \"Mary\":  10,\r\n    \"John\":  51,\r\n}\r\n\r\nDecrementVotesOfCandidate(finalResults, \"Mary\")\r\n\r\nfinalResults[\"Mary\"]\r\n// => 9\r\n```\r\n",
    "hints": "# Hints\r\n\r\n## General\r\n\r\n- `*T` can be used to declared variables that are pointers to some type `T`, e.g `var i *int` declares a variable `i` that is a pointer to an `int`\r\n- You can get a pointer for a variable (its memory address) by using the `&` operator, e.g `mypointer := &anIntVariable`.\r\n- You can get the value stored in a pointer by using the `*` operator on a pointer, e.g. `var i int = *aPointerToInt`. This is called dereferencing the pointer.\r\n- You check if a pointer is not `nil` before dereferencing it. Attempting to dereference a `nil` pointer will give you a runtime error.\r\n- If you are unsure how pointers work, try reading [Tour of Go: Pointers][go-tour-pointers] or [Go by Example: Pointers][go-by-example-pointers]\r\n\r\n## 1. Create a vote counter\r\n\r\n- You need to create a pointer to an `int`, in other words, a `*int`.\r\n- You can use the `&` operator on a variable to create a pointer to it, e.g `&myInt`\r\n- You can create a pointer to a new variable defined by you or you can use the variable of the function argument\r\n\r\n## 2. Get number of votes from a counter\r\n\r\n- You can use the `*` operator on a pointer to dereference it and get its value, e.g `*myPointer`\r\n- Dereferencing `nil` pointers will give you a runtime error. Always make sure a pointer is not `nil` before dereferencing it.\r\n\r\n## 3. Increment the votes of a counter\r\n\r\n- If you have a pointer `var myPointer *int`, you can assign to `*myPointer` to change the value pointed by `myPointer`\r\n- To get the current value of the pointer, you need to dereference it using the `*` operator, or call the function you made in the previous task.\r\n\r\n## 4. Create the election results\r\n\r\n- Create a new `ElectionResult` literal or variable with the fields `Name` and `Votes` filled with the values in the arguments of the function.\r\n- You can create a pointer from a variable or literal by using the `&` operator before the variable name/literal declaration, e.g `&myVariable` or `&ElectionResult{Name: \"John\", Votes: 1}`\r\n\r\n## 5. Announce the results\r\n\r\n- Although you are receiving a pointer to an `ElectionResult`, you can access its fields with the dot `.` notation, like if it wasn't a pointer!\r\n- Build the message by accessing the `Name` and `Value` fields on the struct.\r\n- Even though you are accessing fields from a pointer to a struct, you don't need to do any dereferencing. Go will automatically dereference the pointer for you, like in this example:\r\n\r\n```go\r\nresult := &ElectionResult{\r\n    Name: \"John\",\r\n    Votes: 32\r\n}\r\n\r\nresult.Name // \"John\" - Go will automatically dereference the pointer\r\n            //          and access the 'Name' field of the dereferenced struct \r\n```\r\n\r\n## 6. Vote recounting\r\n\r\n- You can think of maps as being pointers already. This means that changes you make to the map inside the function will be visible outside the function.\r\n- To increment the value of a key in a `var m map[string]int`, you have several options: `m[\"mykey\"] = m[\"mykey\"] + 1 `, `m[\"mykey\"] += 1 ` or `m[\"mykey\"]++ `\r\n\r\n[go-tour-pointers]: https://tour.golang.org/moretypes/1\r\n[go-by-example-pointers]: https://gobyexample.com/pointers\r\n\r\n"
  },
  "starter_code": "package electionday\r\n\r\n// NewVoteCounter returns a new vote counter with\r\n// a given number of initial votes.\r\nfunc NewVoteCounter(initialVotes int) *int {\r\n\tpanic(\"Please implement the NewVoteCounter() function\")\r\n}\r\n\r\n// VoteCount extracts the number of votes from a counter.\r\nfunc VoteCount(counter *int) int {\r\n\tpanic(\"Please implement the VoteCount() function\")\r\n}\r\n\r\n// IncrementVoteCount increments the value in a vote counter.\r\nfunc IncrementVoteCount(counter *int, increment int) {\r\n\tpanic(\"Please implement the IncrementVoteCount() function\")\r\n}\r\n\r\n// NewElectionResult creates a new election result.\r\nfunc NewElectionResult(candidateName string, votes int) *ElectionResult {\r\n\tpanic(\"Please implement the NewElectionResult() function\")\r\n}\r\n\r\n// DisplayResult creates a message with the result to be displayed.\r\nfunc DisplayResult(result *ElectionResult) string {\r\n\tpanic(\"Please implement the DisplayResult() function\")\r\n}\r\n\r\n// DecrementVotesOfCandidate decrements by one the vote count of a candidate in a map.\r\nfunc DecrementVotesOfCandidate(results map[string]int, candidate string) {\r\n\tpanic(\"Please implement the DecrementVotesOfCandidate() function\")\r\n}\r\n",
  "tests": "package electionday\r\n\r\nimport (\r\n\t\"strconv\"\r\n\t\"testing\"\r\n)\r\n\r\nfunc TestNewVoteCounter(t *testing.T) {\r\n\ttests := []struct {\r\n\t\tname  string\r\n\t\tvotes int\r\n\t}{\r\n\t\t{\r\n\t\t\tname:  \"Simple vote counter with 2 votes\",\r\n\t\t\tvotes: 2,\r\n\t\t},\r\n\t}\r\n\r\n\tfor _, tt := range tests {\r\n\t\tt.Run(tt.name, func(t *testing.T) {\r\n\t\t\tgot := NewVoteCounter(tt.votes)\r\n\t\t\tif got == nil {\r\n\t\t\t\tt.Errorf(\"NewVoteCounter(%d) = %s, &%d\", tt.votes, intPtrRepresentation(got), tt.votes)\r\n\t\t\t}\r\n\t\t\tif got != nil && *got != tt.votes {\r\n\t\t\t\tt.Errorf(\"NewVoteCounter(%d) = %s, &%d\", tt.votes, intPtrRepresentation(got), tt.votes)\r\n\t\t\t}\r\n\t\t})\r\n\t}\r\n}\r\n\r\nfunc TestVoteCount(t *testing.T) {\r\n\ttwoVotes := 2\r\n\r\n\ttests := []struct {\r\n\t\tname     string\r\n\t\tcounter  *int\r\n\t\texpected int\r\n\t}{\r\n\t\t{\r\n\t\t\tname:     \"Call to VoteCount with a nil argument\",\r\n\t\t\tcounter:  nil,\r\n\t\t\texpected: 0,\r\n\t\t},\r\n\t\t{\r\n\t\t\tname:     \"Call to VoteCount with a pointer to an int with a value of 2\",\r\n\t\t\tcounter:  &twoVotes,\r\n\t\t\texpected: 2,\r\n\t\t},\r\n\t}\r\n\r\n\tfor _, tt := range tests {\r\n\t\tt.Run(tt.name, func(t *testing.T) {\r\n\t\t\tif got := VoteCount(tt.counter); got != tt.expected {\r\n\t\t\t\tt.Fatalf(\"VoteCount(%v) = %d, want %d\", intPtrRepresentation(tt.counter), got, tt.expected)\r\n\t\t\t}\r\n\t\t})\r\n\t}\r\n}\r\n\r\nfunc TestIncrementVoteCount(t *testing.T) {\r\n\ttwoVotes := 2\r\n\tfiveVotes := 5\r\n\tnoVotes := 0\r\n\r\n\ttests := []struct {\r\n\t\tname      string\r\n\t\tcounter   *int\r\n\t\tincrement int\r\n\t\texpected  int\r\n\t}{\r\n\t\t{\r\n\t\t\tname:      \"Call to IncrementVoteCount with a pointer to an int with a value of 0 and increment of 1\",\r\n\t\t\tcounter:   &noVotes,\r\n\t\t\tincrement: 1,\r\n\t\t\texpected:  1,\r\n\t\t},\r\n\t\t{\r\n\t\t\tname:      \"Call to IncrementVoteCount with a pointer to an int with a value of 2 and increment of 2\",\r\n\t\t\tcounter:   &twoVotes,\r\n\t\t\tincrement: 2,\r\n\t\t\texpected:  4,\r\n\t\t},\r\n\t\t{\r\n\t\t\tname:      \"Call to IncrementVoteCount with a pointer to an int with a value of 5 and increment of 7\",\r\n\t\t\tcounter:   &fiveVotes,\r\n\t\t\tincrement: 7,\r\n\t\t\texpected:  12,\r\n\t\t},\r\n\t}\r\n\r\n\tfor _, tt := range tests {\r\n\t\tt.Run(tt.name, func(t *testing.T) {\r\n\t\t\tbefore := intPtrRepresentation(tt.counter)\r\n\t\t\tIncrementVoteCount(tt.counter, tt.increment)\r\n\t\t\tafter := intPtrRepresentation(tt.counter)\r\n\r\n\t\t\tif tt.counter == nil {\r\n\t\t\t\tt.Errorf(\"counter before: %s | counter after: %v | wanted: &%d\", before, after, tt.expected)\r\n\t\t\t}\r\n\r\n\t\t\tif tt.counter != nil && *tt.counter != tt.expected {\r\n\t\t\t\tt.Errorf(\"counter before: %s | counter after: %v | wanted: &%d\", before, after, tt.expected)\r\n\t\t\t}\r\n\t\t})\r\n\t}\r\n}\r\n\r\nfunc TestNewElectionResult(t *testing.T) {\r\n\ttests := []struct {\r\n\t\tname          string\r\n\t\tcandidateName string\r\n\t\tvotes         int\r\n\t\twanted        ElectionResult\r\n\t}{\r\n\t\t{\r\n\t\t\tname:          \"Call to NewElectionResult for Peter with 2 votes\",\r\n\t\t\tcandidateName: \"Peter\",\r\n\t\t\tvotes:         2,\r\n\t\t\twanted: ElectionResult{\r\n\t\t\t\tName:  \"Peter\",\r\n\t\t\t\tVotes: 2,\r\n\t\t\t},\r\n\t\t},\r\n\t}\r\n\r\n\tfor _, tt := range tests {\r\n\t\tt.Run(tt.name, func(t *testing.T) {\r\n\t\t\tresult := NewElectionResult(tt.candidateName, tt.votes)\r\n\r\n\t\t\tif result == nil || result.Name != tt.wanted.Name || result.Votes != tt.wanted.Votes {\r\n\t\t\t\tt.Errorf(\"NewElectionResult(\\\"%s\\\", %d) = %#v, wanted %#v\",\r\n\t\t\t\t\ttt.candidateName, tt.votes, result, tt.wanted)\r\n\t\t\t}\r\n\t\t})\r\n\t}\r\n}\r\n\r\nfunc TestDisplayResult(t *testing.T) {\r\n\ttests := []struct {\r\n\t\tname   string\r\n\t\tresult *ElectionResult\r\n\t\twanted string\r\n\t}{\r\n\t\t{\r\n\t\t\tname: \"Call to DisplayResult for John with 5 votes\",\r\n\t\t\tresult: &ElectionResult{\r\n\t\t\t\tName:  \"John\",\r\n\t\t\t\tVotes: 5,\r\n\t\t\t},\r\n\t\t\twanted: \"John (5)\",\r\n\t\t},\r\n\t}\r\n\r\n\tfor _, tt := range tests {\r\n\t\tt.Run(tt.name, func(t *testing.T) {\r\n\t\t\tif result := DisplayResult(tt.result); result != tt.wanted {\r\n\t\t\t\tt.Errorf(\"DisplayResult(%#v) = %s, wanted %s\", *tt.result, result, tt.wanted)\r\n\t\t\t}\r\n\t\t})\r\n\t}\r\n}\r\n\r\nfunc TestDecrementVotesOfCandidate(t *testing.T) {\r\n\ttests := []struct {\r\n\t\tname      string\r\n\t\tcandidate string\r\n\t\tresults   map[string]int\r\n\t\twanted    int\r\n\t}{\r\n\t\t{\r\n\t\t\tname:      \"Call to DecrementVotesOfCandidate for John with 3 votes\",\r\n\t\t\tcandidate: \"John\",\r\n\t\t\tresults: map[string]int{\r\n\t\t\t\t\"John\": 3,\r\n\t\t\t},\r\n\t\t\twanted: 2,\r\n\t\t},\r\n\t}\r\n\r\n\tfor _, tt := range tests {\r\n\t\tt.Run(tt.name, func(t *testing.T) {\r\n\t\t\tDecrementVotesOfCandidate(tt.results, tt.candidate)\r\n\t\t\tif votes, ok := tt.results[tt.candidate]; !ok || votes != tt.wanted {\r\n\t\t\t\tt.Errorf(\"DecrementVotesOfCandidate(%v) | wanted %d, got %d\",\r\n\t\t\t\t\ttt.results, tt.wanted, votes)\r\n\t\t\t}\r\n\t\t})\r\n\t}\r\n}\r\n\r\nfunc intPtrRepresentation(p *int) string {\r\n\tif p == nil {\r\n\t\treturn \"nil\"\r\n\t}\r\n\treturn \"&\" + strconv.Itoa(*p)\r\n}\r\n"
}