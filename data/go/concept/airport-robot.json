{
  "language": "go",
  "slug": "airport-robot",
  "docs": {
    "introduction": "# Introduction\r\n\r\n## Interface as a set of methods\r\n\r\nIn its simplest form, an **interface type** is a set of method signatures.\r\nHere is an example of an interface definition that includes two methods `Add` and `Value`:\r\n\r\n```go\r\ntype Counter interface {\r\n    Add(increment int)\r\n    Value() int\r\n}\r\n```\r\n\r\nThe parameter names like `increment` can be omitted from the interface definition but they often increase readability.\r\n\r\nInterface names in Go do not contain the word `Interface` or `I`.\r\nInstead, they often end with `er`, e.g. `Reader`, `Stringer`.\r\n\r\n## Implementing an interface\r\n\r\nAny type that defines the methods of the interface automatically implicitly \"implements\" the interface.\r\nThere is no `implements` keyword in Go.\r\n\r\nThe following type implements the `Counter` interface we saw above.\r\n\r\n```go\r\ntype Stats struct {\r\n    value int\r\n    // ...\r\n}\r\n\r\nfunc (s Stats) Add(v int) {\r\n    s.value += v\r\n}\r\n\r\nfunc (s Stats) Value() int {\r\n    return s.value\r\n}\r\n\r\nfunc (s Stats) SomeOtherMethod() {\r\n    // The type can have additional methods not mentioned in the interface.\r\n}\r\n```\r\n\r\nFor implementing the interface, it does not matter whether the method has a value or pointer receiver.\r\n(Revisit the [methods concepts][concept-methods] if you are unsure about those.)\r\n\r\n> A value of interface type can hold any value that implements those methods. [^1]\r\n\r\nThat means `Stats` can now be used in all the places that expect the `Counter` interface.\r\n\r\n```go\r\nfunc SetUpAnalytics(counter Counter) {\r\n    // ...\r\n}\r\n\r\nstats := Stats{}\r\nSetUpAnalytics(stats)\r\n// works because Stats implements Counter\r\n```\r\n\r\nBecause interfaces are implemented implicitly, a type can easily implement multiple interfaces.\r\nIt only needs to have all the necessary methods defined.\r\n\r\n## Empty interface\r\n\r\nThere is one very special interface type in Go, the **empty interface** type that contains zero methods.\r\nThe empty interface is written like this: `interface{}`.\r\nIn Go 1.18 or higher, `any` can be used as well. It was defined as an alias.\r\n\r\nSince the empty interface has no methods, every type implements it implicitly.\r\nThis is helpful for defining a function that can generically accept any value.\r\nIn that case, the function parameter uses the empty interface type.\r\n\r\n[concept-methods]: /tracks/go/concepts/methods\r\n",
    "instructions": "# Instructions\r\n\r\nThe new airport in Berlin hired developers for their robots lab and you are starting your job there.\r\nThey have clunky, somewhat humanoid-looking robots that they are trying to use to improve customer service.\r\n\r\nYour first task on the job is to write a program so that the robot can greet people in their native language after they scanned their passports at the self-check-in counter.\r\n\r\nThe robot is proud of its abilities so it will always say which language it can speak first and then greet the person.\r\nFor example, if someone scans a German passport the robot would say:\r\n\r\n```txt\r\nI can speak German: Hallo Dietrich!\r\n```\r\n\r\n## 1. Create the abstract greeting functionality\r\n\r\nYou will not write the code for the different languages yourself so you need to structure your code for the robot so that other developers can easily add more languages later.\r\n\r\nAs a first step, define an interface `Greeter` with two methods.\r\n\r\n- `LanguageName` which returns the name of the language (a `string`) that the robot is supposed to greet the visitor in.\r\n- `Greet` which accepts a visitor's name (a `string`) and returns a `string` with the greeting message in a specific language.\r\n\r\nNext, implement a function `SayHello` that accepts the name of the visitor and anything that implements the `Greeter` interface as arguments and returns the desired greeting string.\r\nFor example, imagine a German `Greeter` implementation for which `LanguageName` returns `\"German\"` and `Greet` returns `\"Hallo {name}!\"`:\r\n\r\n```go\r\nSayHello(\"Dietrich\", germanGreeter)\r\n// => \"I can speak German: Hallo Dietrich!\"\r\n```\r\n\r\n## 2. Implement Italian\r\n\r\nNow your job is to make the robot work for people that scan Italian passports.\r\n\r\nFor that, create a struct `Italian` and implement the two methods that are needed for the struct to fulfill the `Greeter` interface you set up in task 1.\r\nYou can greet someone in Italian with `\"Ciao {name}!\"`.\r\n\r\n## 3. Implement Portuguese\r\n\r\nBefore you call it a day, you are also supposed to finish the functionality to greet people in Portuguese.\r\n\r\nFor that, create a struct `Portuguese` and implement the two methods that are needed for the struct to fulfill the `Greeter` interface here as well.\r\nYou can greet someone in Portuguese with `\"Olá {name}!\"`.\r\n",
    "hints": "# Hints\r\n\r\n## General\r\n\r\n- Maybe have a look at [Interfaces in the Tour of Go][interfaces-tour-of-go] to see more examples if you struggle with the exercise.\r\n\r\n## 1. Create the abstract greeting functionality\r\n\r\n- Look back at `Counter` example the introduction to find out how to define an interface.\r\n- Revisit the [functions concepts][concept-functions] to recap how to write function signatures in Go.\r\n- The abstract `Greeter` type can be used in a function signature the same way as a normal concrete type like `string`.\r\n- To implement `SayHello`, call the methods on the argument of type `Greeter`.\r\n  Then use string formatting or string concatenation to construct the final result.\r\n\r\n## 2. Implement Italian\r\n\r\n- Revisit the [structs concept][concept-structs] to see how to define a struct type.\r\n- To solve the task, the struct does not need any fields at all.\r\n- Once you defined the struct, you want to add the methods `LanguageName` and `Greet` to it.\r\n  Revisit the [methods concept][concept-methods] to find out how to add a method for a type.\r\n\r\n## 3. Implement Portuguese\r\n\r\n- See hints for task 2.\r\n\r\n[interfaces-tour-of-go]: https://go.dev/tour/methods/9\r\n[concept-functions]: /tracks/go/concepts/functions\r\n[concept-structs]: /tracks/go/concepts/structs\r\n[concept-methods]: /tracks/go/concepts/methods\r\n"
  },
  "starter_code": "package airportrobot\r\n\r\n// Write your code here.\r\n// This exercise does not have tests for each individual task.\r\n// Try to solve all the tasks first before running the tests.\r\n",
  "tests": "package airportrobot\r\n\r\nimport \"testing\"\r\n\r\n// testRunnerTaskID=2\r\nfunc TestSayHello_Italian(t *testing.T) {\r\n\ttests := []struct {\r\n\t\ttestName string\r\n\t\tname     string\r\n\t\twant     string\r\n\t}{\r\n\t\t{\r\n\t\t\ttestName: \"name without spaces\",\r\n\t\t\tname:     \"Flora\",\r\n\t\t\twant:     \"I can speak Italian: Ciao Flora!\",\r\n\t\t},\r\n\t\t{\r\n\t\t\ttestName: \"full name\",\r\n\t\t\tname:     \"Tomaso Giulio Micheli\",\r\n\t\t\twant:     \"I can speak Italian: Ciao Tomaso Giulio Micheli!\",\r\n\t\t},\r\n\t}\r\n\r\n\tfor _, tt := range tests {\r\n\t\tt.Run(tt.testName, func(t *testing.T) {\r\n\t\t\tif got := SayHello(tt.name, Italian{}); got != tt.want {\r\n\t\t\t\tt.Errorf(\"SayHello(%q, \\\"Italian{}\\\") = %q, want %q\", tt.name, got, tt.want)\r\n\t\t\t}\r\n\t\t})\r\n\t}\r\n}\r\n\r\n// testRunnerTaskID=3\r\nfunc TestSayHello_Portuguese(t *testing.T) {\r\n\ttests := []struct {\r\n\t\ttestName string\r\n\t\tname     string\r\n\t\twant     string\r\n\t}{\r\n\t\t{\r\n\t\t\ttestName: \"name without spaces\",\r\n\t\t\tname:     \"Fabrício\",\r\n\t\t\twant:     \"I can speak Portuguese: Olá Fabrício!\",\r\n\t\t},\r\n\t\t{\r\n\t\t\ttestName: \"full name\",\r\n\t\t\tname:     \"Manuela Alberto\",\r\n\t\t\twant:     \"I can speak Portuguese: Olá Manuela Alberto!\",\r\n\t\t},\r\n\t}\r\n\r\n\tfor _, tt := range tests {\r\n\t\tt.Run(tt.testName, func(t *testing.T) {\r\n\t\t\tif got := SayHello(tt.name, Portuguese{}); got != tt.want {\r\n\t\t\t\tt.Errorf(\"SayHello(%q, \\\"Portuguese{}\\\") = %q, want %q\", tt.name, got, tt.want)\r\n\t\t\t}\r\n\t\t})\r\n\t}\r\n}\r\n"
}