{
  "language": "go",
  "slug": "logs-logs-logs",
  "docs": {
    "introduction": "# Introduction\r\n\r\nThe `rune` type in Go is an alias for `int32`.\r\nGiven this underlying `int32` type, the `rune` type holds a signed 32-bit integer value.\r\nHowever, unlike an `int32` type, the integer value stored in a `rune` type represents a single Unicode character.\r\n\r\n## Unicode and Unicode Code Points\r\n\r\nUnicode is a superset of ASCII that represents characters by assigning a unique number to every character.\r\nThis unique number is called a Unicode code point.\r\nUnicode aims to represent all the world's characters including various alphabets, numbers, symbols, and even emoji as Unicode code points.\r\n\r\nIn Go, the `rune` type represents a single Unicode code point.\r\n\r\nThe following table contains example Unicode characters along with their Unicode code point and decimal values:\r\n\r\n| Unicode Character | Unicode Code Point | Decimal Value |\r\n|-------------------|--------------------|---------------|\r\n| 0                 | `U+0030`           | `48`          |\r\n| A                 | `U+0041`           | `65`          |\r\n| a                 | `U+0061`           | `97`          |\r\n| ¬ø                 | `U+00BF`           | `191`         |\r\n| œÄ                 | `U+03C0`           | `960`         |\r\n| üß†                | `U+1F9E0`          | `129504`      |\r\n\r\n## UTF-8\r\n\r\nUTF-8 is a variable-width character encoding that is used to encode every Unicode code point as 1, 2, 3, or 4 bytes.\r\nSince a Unicode code point can be encoded as a maximum of 4 bytes, the `rune` type needs to be able to hold up to 4 bytes of data.\r\nThat is why the `rune` type is an alias for `int32` as an `int32` type is capable of holding up to 4 bytes of data.\r\n\r\nGo source code files are encoded using UTF-8.\r\n\r\n## Using Runes\r\n\r\nVariables of type `rune` are declared by placing a character inside single quotes:\r\n\r\n```go\r\nmyRune := '¬ø'\r\n```\r\n\r\nSince `rune` is just an alias for `int32`, printing a rune's type will yield `int32`:\r\n\r\n```go\r\nmyRune := '¬ø'\r\nfmt.Printf(\"myRune type: %T\\n\", myRune)\r\n// Output: myRune type: int32\r\n```\r\n\r\nSimilarly, printing a rune's value will yield its integer (decimal) value:\r\n\r\n```go\r\nmyRune := '¬ø'\r\nfmt.Printf(\"myRune value: %v\\n\", myRune)\r\n// Output: myRune value: 191\r\n```\r\n\r\nTo print the Unicode character represented by the rune, use the `%c` formatting verb:\r\n\r\n```go\r\nmyRune := '¬ø'\r\nfmt.Printf(\"myRune Unicode character: %c\\n\", myRune)\r\n// Output: myRune Unicode character: ¬ø\r\n```\r\n\r\nTo print the Unicode code point represented by the rune, use the `%U` formatting verb:\r\n\r\n```go\r\nmyRune := '¬ø'\r\nfmt.Printf(\"myRune Unicode code point: %U\\n\", myRune)\r\n// Output: myRune Unicode code point: U+00BF\r\n```\r\n\r\n## Runes and Strings\r\n\r\nStrings in Go are encoded using UTF-8 which means they contain Unicode characters.\r\nCharacters in strings are stored and encoded as 1, 2, 3, or 4 bytes depending on the Unicode character they represent.\r\n\r\nIn Go, slices are used to represent sequences and these slices can be iterated over using range.\r\nWhen we iterate over a string, Go converts the string into a series of Runes, each of which is 4 bytes (remember, the rune type is an alias for an `int32`!)\r\n\r\nEven though a string is just a slice of bytes, the `range` keyword iterates over a string's runes, not its bytes.\r\n\r\nIn this example, the `index` variable represents the starting index of the current rune's byte sequence and the `char` variable represents the current rune:\r\n\r\n```go\r\nmyString := \"‚ùóhello\"\r\nfor index, char := range myString {\r\n  fmt.Printf(\"Index: %d\\tCharacter: %c\\t\\tCode Point: %U\\n\", index, char, char)\r\n}\r\n// Output:\r\n// Index: 0\tCharacter: ‚ùó\t\tCode Point: U+2757\r\n// Index: 3\tCharacter: h\t\tCode Point: U+0068\r\n// Index: 4\tCharacter: e\t\tCode Point: U+0065\r\n// Index: 5\tCharacter: l\t\tCode Point: U+006C\r\n// Index: 6\tCharacter: l\t\tCode Point: U+006C\r\n// Index: 7\tCharacter: o\t\tCode Point: U+006F\r\n```\r\n\r\nSince runes can be stored as 1, 2, 3, or 4 bytes, the length of a string may not always equal the number of characters in the string.\r\nUse the builtin `len` function to get the length of a string in bytes and the `utf8.RuneCountInString` function to get the number of runes in a string:\r\n\r\n```go\r\nimport \"unicode/utf8\"\r\n\r\nmyString := \"‚ùóhello\"\r\nstringLength := len(myString)\r\nnumberOfRunes := utf8.RuneCountInString(myString)\r\n\r\nfmt.Printf(\"myString - Length: %d - Runes: %d\\n\", stringLength, numberOfRunes)\r\n// Output: myString - Length: 8 - Runes: 6\r\n```\r\n",
    "instructions": "# Instructions\r\n\r\nYou have been tasked with creating a log library to assist with managing your organization's logs. This library will allow users to identify which application emitted a given log, to fix corrupted logs, and to determine if a given log line is within a certain character limit.\r\n\r\n## 1. Identify which application emitted a log\r\n\r\nLogs come from multiple applications that each use their own proprietary log format. The application emitting a log must be identified before it can be stored in a log aggregation system.\r\n\r\nImplement the `Application` function that takes a log line and returns the application that emitted the log line.\r\n\r\nTo identify which application emitted a given log line, search the log line for a specific character as specified by the following table:\r\n\r\n| Application      | Character | Unicode Code Point |\r\n|------------------|-----------|--------------------|\r\n| `recommendation` | ‚ùó        | `U+2757`           |\r\n| `search`         | üîç        | `U+1F50D`          |\r\n| `weather`        | ‚òÄ         | `U+2600`           |\r\n\r\nIf a log line does not contain one of the characters from the above table, return `default` to the caller. If a log line contains more than one character in the above table, return the application corresponding to the first character found in the log line starting from left to right.\r\n\r\n```go\r\nApplication(\"‚ùó recommended search product üîç\")\r\n// => recommendation\r\n```\r\n\r\n## 2. Fix corrupted logs\r\n\r\nDue to a rare but persistent bug in the logging infrastructure, certain characters in logs can become corrupted. After spending time identifying the corrupted characters and their original value, you decide to update the log library to assist in fixing corrupted logs.\r\n\r\nImplement the `Replace` function that takes a log line, a corrupted character, and the original value and returns a modified log line that has all occurrences of the corrupted character replaced with the original value.\r\n\r\n```go\r\nlog := \"please replace 'üëé' with 'üëç'\"\r\n\r\nReplace(log, 'üëé', 'üëç')\r\n// => please replace 'üëç' with 'üëç'\"\r\n```\r\n\r\n## 3. Determine if a log can be displayed\r\n\r\nSystems responsible for displaying logs have a limit on the number of characters that can be displayed per log line. As such, users are asking for this library to include a helper function to determine whether or not a log line is within a specific character limit.\r\n\r\nImplement the `WithinLimit` function that takes a log line and character limit and returns whether or not the log line is within the character limit.\r\n\r\n```go\r\nWithinLimit(\"hello‚ùó\", 6)\r\n// => true\r\n```\r\n",
    "hints": "# Hints\r\n\r\n## 1. Identify which application emitted a log\r\n\r\n- The `range` keyword can be used to iterate over a given string's runes.\r\n- Runes can be compared to other runes using an `if` conditional.\r\n- A character within single quotes is a `rune` in Go.\r\n\r\n## 2. Fix corrupted logs\r\n\r\n- String concatenation can be used to build the modified log line rune by rune.\r\n- For that concatenation to work, each `rune` may have to be converted to string first.\r\n- You can convert a rune `r` to `string` with `string(r)`.\r\n\r\n## 3. Determine if a log can be displayed\r\n\r\n- Runes can be 1, 2, 3, or 4 bytes so the builtin `len` function may not accurately reflect the number of characters in a string.\r\n"
  },
  "starter_code": "package logs\r\n\r\n// Application identifies the application emitting the given log.\r\nfunc Application(log string) string {\r\n\tpanic(\"Please implement the Application() function\")\r\n}\r\n\r\n// Replace replaces all occurrences of old with new, returning the modified log\r\n// to the caller.\r\nfunc Replace(log string, oldRune, newRune rune) string {\r\n\tpanic(\"Please implement the Replace() function\")\r\n}\r\n\r\n// WithinLimit determines whether or not the number of characters in log is\r\n// within the limit.\r\nfunc WithinLimit(log string, limit int) bool {\r\n\tpanic(\"Please implement the WithinLimit() function\")\r\n}\r\n",
  "tests": "package logs\r\n\r\nimport (\r\n\t\"testing\"\r\n)\r\n\r\nfunc TestApplication(t *testing.T) {\r\n\ttests := []struct {\r\n\t\tname string\r\n\t\tlog  string\r\n\t\twant string\r\n\t}{\r\n\t\t{\r\n\t\t\tname: \"single character recommendation\",\r\n\t\t\tlog:  \"‚ùó recommended product\",\r\n\t\t\twant: \"recommendation\",\r\n\t\t},\r\n\t\t{\r\n\t\t\tname: \"single character search\",\r\n\t\t\tlog:  \"executed search üîç\",\r\n\t\t\twant: \"search\",\r\n\t\t},\r\n\t\t{\r\n\t\t\tname: \"single character weather\",\r\n\t\t\tlog:  \"forecast: ‚òÄ sunny\",\r\n\t\t\twant: \"weather\",\r\n\t\t},\r\n\t\t{\r\n\t\t\tname: \"no characters default\",\r\n\t\t\tlog:  \"error: could not proceed\",\r\n\t\t\twant: \"default\",\r\n\t\t},\r\n\t\t{\r\n\t\t\tname: \"multiple characters recommendation(1/3)\",\r\n\t\t\tlog:  \"‚ùó recommended search product üîç\",\r\n\t\t\twant: \"recommendation\",\r\n\t\t},\r\n\t\t{\r\n\t\t\tname: \"multiple characters recommendation(2/3)\",\r\n\t\t\tlog:  \"üîç search recommended product ‚ùó\",\r\n\t\t\twant: \"search\",\r\n\t\t},\r\n\t\t{\r\n\t\t\tname: \"multiple characters recommendation(3/3)\",\r\n\t\t\tlog:  \"‚òÄ weather is sunny ‚ùó\",\r\n\t\t\twant: \"weather\",\r\n\t\t},\r\n\t}\r\n\r\n\tfor _, tt := range tests {\r\n\t\tt.Run(tt.name, func(t *testing.T) {\r\n\t\t\tif got := Application(tt.log); got != tt.want {\r\n\t\t\t\tt.Errorf(\"Application(\\\"%s\\\") = \\\"%s\\\", want \\\"%s\\\"\", tt.log, got, tt.want)\r\n\t\t\t}\r\n\t\t})\r\n\t}\r\n}\r\n\r\nfunc TestReplace(t *testing.T) {\r\n\ttests := []struct {\r\n\t\tname    string\r\n\t\tlog     string\r\n\t\toldChar rune\r\n\t\tnewChar rune\r\n\t\twant    string\r\n\t}{\r\n\t\t{\r\n\t\t\tname:    \"single occurrence of replacement\",\r\n\t\t\tlog:     \"‚ùó recommended product\",\r\n\t\t\toldChar: '‚ùó',\r\n\t\t\tnewChar: '?',\r\n\t\t\twant:    \"? recommended product\",\r\n\t\t},\r\n\t\t{\r\n\t\t\tname:    \"multiple occurrences of replacement\",\r\n\t\t\tlog:     \"‚ùó recommended product ‚ùó\",\r\n\t\t\toldChar: '‚ùó',\r\n\t\t\tnewChar: '?',\r\n\t\t\twant:    \"? recommended product ?\",\r\n\t\t},\r\n\t\t{\r\n\t\t\tname:    \"no occurrences of replacement\",\r\n\t\t\tlog:     \"‚ùó recommended product ‚ùó\",\r\n\t\t\toldChar: '?',\r\n\t\t\tnewChar: '?',\r\n\t\t\twant:    \"‚ùó recommended product ‚ùó\",\r\n\t\t},\r\n\t}\r\n\r\n\tfor _, tt := range tests {\r\n\t\tt.Run(tt.name, func(t *testing.T) {\r\n\t\t\tif got := Replace(tt.log, tt.oldChar, tt.newChar); got != tt.want {\r\n\t\t\t\tt.Errorf(\"Replace(\\\"%s\\\", '%c', '%c') = \\\"%s\\\", want \\\"%s\\\"\", tt.log, tt.oldChar, tt.newChar, got, tt.want)\r\n\t\t\t}\r\n\t\t})\r\n\t}\r\n}\r\n\r\nfunc TestWithinLimit(t *testing.T) {\r\n\ttests := []struct {\r\n\t\tname  string\r\n\t\tlog   string\r\n\t\tlimit int\r\n\t\twant  bool\r\n\t}{\r\n\t\t{\r\n\t\t\tname:  \"exact limit\",\r\n\t\t\tlog:   \"exercism‚ùó\",\r\n\t\t\tlimit: 9,\r\n\t\t\twant:  true,\r\n\t\t},\r\n\t\t{\r\n\t\t\tname:  \"under limit\",\r\n\t\t\tlog:   \"exercism‚ùó\",\r\n\t\t\tlimit: 10,\r\n\t\t\twant:  true,\r\n\t\t},\r\n\t\t{\r\n\t\t\tname:  \"over limit\",\r\n\t\t\tlog:   \"exercism‚ùó\",\r\n\t\t\tlimit: 8,\r\n\t\t\twant:  false,\r\n\t\t},\r\n\t\t{\r\n\t\t\tname:  \"exact limit\",\r\n\t\t\tlog:   \"exercismüîç\",\r\n\t\t\tlimit: 9,\r\n\t\t\twant:  true,\r\n\t\t},\r\n\t\t{\r\n\t\t\tname:  \"under limit\",\r\n\t\t\tlog:   \"exercismüîç\",\r\n\t\t\tlimit: 10,\r\n\t\t\twant:  true,\r\n\t\t},\r\n\t\t{\r\n\t\t\tname:  \"over limit\",\r\n\t\t\tlog:   \"exercismüîç\",\r\n\t\t\tlimit: 8,\r\n\t\t\twant:  false,\r\n\t\t},\r\n\t}\r\n\r\n\tfor _, tt := range tests {\r\n\t\tt.Run(tt.name, func(t *testing.T) {\r\n\t\t\tif got := WithinLimit(tt.log, tt.limit); got != tt.want {\r\n\t\t\t\tt.Errorf(\"WithinLimit(\\\"%s\\\", %d) = %t, want %t\", tt.log, tt.limit, got, tt.want)\r\n\t\t\t}\r\n\t\t})\r\n\t}\r\n}\r\n"
}