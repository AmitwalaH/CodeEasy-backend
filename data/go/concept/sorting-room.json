{
  "language": "go",
  "slug": "sorting-room",
  "docs": {
    "introduction": "# Introduction\r\n\r\n## Type Conversion\r\n\r\nGo requires explicit conversion between different types.\r\nConverting between types (also known as **type casting**) is done via a function with the name of the type to convert to.\r\nFor example, to convert an `int` to a `float64` you would need to do the following:\r\n\r\n```go\r\nvar x int = 42 // x has type int\r\nf := float64(x) // f has type float64 (ie. 42.0)\r\n```\r\n\r\n## Converting between primitive types and strings\r\n\r\nThere is a `strconv` package for converting between primitive types (like `int`) and `string`.\r\n\r\n```go\r\nimport \"strconv\"\r\n\r\nvar intString string = \"42\"\r\nvar i, err = strconv.Atoi(intString)\r\n\r\nvar number int = 12\r\nvar s string = strconv.Itoa(number)\r\n```\r\n\r\n## Type Assertions\r\n\r\nInterfaces in Go can introduce ambiguity about the underlying type.\r\nA type assertion allows us to extract the interface value's underlying concrete value using this syntax: `interfaceVariable.(concreteType)`.\r\n\r\nFor example:\r\n\r\n```go\r\nvar input interface{} = 12\r\nnumber := input.(int)\r\n```\r\n\r\nNOTE: this will cause a panic if the interface variable does not hold a value of the concrete type.\r\n\r\nWe can test whether an interface value holds a specific concrete type by making use of both return values of the type assertion: the underlying value and a boolean value that reports whether the assertion succeeded.\r\nFor example:\r\n\r\n```go\r\nstr, ok := input.(string) // no panic if input is not a string\r\n```\r\n\r\nIf `input` holds a `string`, then `str` will be the underlying value and `ok` will be true.\r\nIf `input` does not hold a `string`, then `str` will be the zero value of type `string` (ie. `\"\"` - the empty string) and `ok` will be false.\r\nNo panic occurs in any case.\r\n\r\n## Type Switches\r\n\r\nA **type switch** can perform several type assertions in series.\r\nIt has the same syntax as a type assertion (`interfaceVariable.(concreteType)`), but the `concreteType` is replaced with the keyword `type`.\r\nHere is an example:\r\n\r\n```go\r\nvar i interface{} = 12 // try: 12.3, true, int64(12), []int{}, map[string]int{}\r\n\r\nswitch v := i.(type) {\r\ncase int:\r\n    fmt.Printf(\"the integer %d\\n\", v)\r\ncase string:\r\n    fmt.Printf(\"the string %s\\n\", v)\r\ndefault:\r\n    fmt.Printf(\"type, %T, not handled explicitly: %#v\\n\", v, v)\r\n}\r\n```\r\n",
    "instructions": "# Instructions\r\n\r\nJen is working in the sorting room in a large factory.\r\nThe sorting room needs to process anything that comes into it by categorizing it with a label.\r\nJen is responsible for things that were pre-categorized as numbers and needs a program to help her with the sorting.\r\n\r\nMost primitive values should get straight-forward labels.\r\nFor numbers, she wants strings saying `\"This is the number 2.0\"` (if the number was 2).\r\nJen wants the same output for integers and floats.\r\n\r\nThere are a few `Box` interfaces that need to be unwrapped to get their contents.\r\nFor a `NumberBox`, she wants strings saying `\"This is a box containing the number 3.0\"` (if the `Number()` method returns 3).\r\nFor a `FancyNumberBox`, she wants strings saying `\"This is a fancy box containing the number 4.0\"`, but only if the type is a `FancyNumber`.\r\n\r\nAnything unexpected should say `\"Return to sender\"` so Jen can send them back where they came from.\r\n\r\n## 1. Describe simple numbers\r\n\r\nJen wants numbers to return strings like `\"This is the number 2.0\"` (including one digit after the decimal):\r\n\r\n```go\r\nfmt.Println(DescribeNumber(-12.345))\r\n// Output: This is the number -12.3\r\n```\r\n\r\n## 2. Describe a number box\r\n\r\nJen wants number boxes to return strings like `\"This is a box containing the number 2.0\"` (again, including one digit after the decimal):\r\n\r\n```go\r\nfmt.Println(DescribeNumberBox(numberBoxContaining{12}))\r\n// Output: This is a box containing the number 12.0\r\n```\r\n\r\n## 3. Implement a method extracting the number from a fancy number box\r\n\r\nJen needs a helper function to extract the number from a `FancyNumberBox`.\r\nIf the `FancyNumberBox` is a `FancyNumber`, extract its value and convert it from a `string` to an `int`.\r\nAny other type of `FancyNumberBox` should return 0.\r\n\r\n```go\r\nfmt.Println(ExtractFancyNumber(FancyNumber{\"10\"}))\r\n// Output: 10\r\nfmt.Println(ExtractFancyNumber(AnotherFancyNumber{\"4\"}))\r\n// Output: 0\r\n```\r\n\r\n## 4. Describe a fancy number box\r\n\r\nIf the `FancyNumberBox` is a `FancyNumber`, Jen wants strings saying `\"This is a fancy box containing the number 4.0\"`.\r\nAny other type of `FancyNumberBox` should say `\"This is a fancy box containing the number 0.0\"`.\r\n\r\n```go\r\nfmt.Println(DescribeFancyNumberBox(FancyNumber{\"10\"}))\r\n// Output: This is a fancy box containing the number 10.0\r\nfmt.Println(DescribeFancyNumberBox(AnotherFancyNumber{\"4\"}))\r\n// Output: This is a fancy box containing the number 0.0\r\n```\r\n\r\nNOTE: we should use the `ExtractFancyNumber` function!\r\n\r\n## 5. Implement `DescribeAnything` which uses them all\r\n\r\nThis is the main function Jen needs which takes any input (the empty interface means any value at all: `interface{}`).\r\n`DescribeAnything` should delegate to the other functions based on the type of the value passed in.\r\nMore specifically:\r\n\r\n- `int` and `float64` should both delegate to `DescribeNumber`\r\n- `NumberBox` should delegate to `DescribeNumberBox`\r\n- `FancyNumberBox` should delegate to `DescribeFancyNumberBox`\r\n- anything else should result in `\"Return to sender\"`\r\n\r\n```go\r\nfmt.Println(DescribeAnything(numberBoxContaining{12.345}))\r\n// Output: This is a box containing the number 12.3\r\nfmt.Println(DescribeAnything(\"some string\"))\r\n// Output: Return to sender\r\n```\r\n",
    "hints": "# Hints\r\n\r\n## 1. Describe simple numbers\r\n\r\n- use `fmt.Sprintf` to format\r\n\r\n## 2. Describe a number box\r\n\r\n- get the result from the `Number()` method\r\n- use `fmt.Sprintf` to format\r\n\r\n## 3. Implement a method extracting the number from a fancy number box\r\n\r\n- use a type assertion to check if this is a `FancyNumber`\r\n- get the `string` from the `Value()` method\r\n- use `strconv.Atoi` to convert the `string` to an `int` (we can throw away the error since we want 0 if it cannot be converted to an `int`)\r\n\r\n## 4. Describe a fancy number box\r\n\r\n- use `ExtractFancyNumber` to get the `int` value\r\n- convert the `int` to a `float64`\r\n- use `fmt.Sprintf` to format\r\n\r\n## 5. Implement `DescribeAnything` which uses them all\r\n\r\n- either use type assertions (e.g. `i.(someType)`) or a type switch (`switch v := i.(type)`)\r\n- remember to convert `int` to a `float64`\r\n"
  },
  "starter_code": "package sorting\r\n\r\n// DescribeNumber should return a string describing the number.\r\nfunc DescribeNumber(f float64) string {\r\n\tpanic(\"Please implement DescribeNumber\")\r\n}\r\n\r\ntype NumberBox interface {\r\n\tNumber() int\r\n}\r\n\r\n// DescribeNumberBox should return a string describing the NumberBox.\r\nfunc DescribeNumberBox(nb NumberBox) string {\r\n\tpanic(\"Please implement DescribeNumberBox\")\r\n}\r\n\r\ntype FancyNumber struct {\r\n\tn string\r\n}\r\n\r\nfunc (i FancyNumber) Value() string {\r\n\treturn i.n\r\n}\r\n\r\ntype FancyNumberBox interface {\r\n\tValue() string\r\n}\r\n\r\n// ExtractFancyNumber should return the integer value for a FancyNumber\r\n// and 0 if any other FancyNumberBox is supplied.\r\nfunc ExtractFancyNumber(fnb FancyNumberBox) int {\r\n\tpanic(\"Please implement ExtractFancyNumber\")\r\n}\r\n\r\n// DescribeFancyNumberBox should return a string describing the FancyNumberBox.\r\nfunc DescribeFancyNumberBox(fnb FancyNumberBox) string {\r\n\tpanic(\"Please implement DescribeFancyNumberBox\")\r\n}\r\n\r\n// DescribeAnything should return a string describing whatever it contains.\r\nfunc DescribeAnything(i interface{}) string {\r\n\tpanic(\"Please implement DescribeAnything\")\r\n}\r\n",
  "tests": "package sorting\r\n\r\nimport \"testing\"\r\n\r\nfunc TestDescribeNumber(t *testing.T) {\r\n\ttests := []struct {\r\n\t\tdescription string\r\n\t\tinput       float64\r\n\t\twant        string\r\n\t}{\r\n\t\t{\r\n\t\t\tdescription: \"Describe 4.1\",\r\n\t\t\tinput:       4.1,\r\n\t\t\twant:        \"This is the number 4.1\",\r\n\t\t},\r\n\t\t{\r\n\t\t\tdescription: \"Describe -3.2\",\r\n\t\t\tinput:       -3.2,\r\n\t\t\twant:        \"This is the number -3.2\",\r\n\t\t},\r\n\t\t{\r\n\t\t\tdescription: \"Pads to single decimal place\",\r\n\t\t\tinput:       4.0,\r\n\t\t\twant:        \"This is the number 4.0\",\r\n\t\t},\r\n\t\t{\r\n\t\t\tdescription: \"Truncates to single decimal place\",\r\n\t\t\tinput:       7.11,\r\n\t\t\twant:        \"This is the number 7.1\",\r\n\t\t},\r\n\t}\r\n\tfor _, test := range tests {\r\n\t\tt.Run(test.description, func(t *testing.T) {\r\n\t\t\tif got := DescribeNumber(test.input); got != test.want {\r\n\t\t\t\tt.Errorf(\"DescribeNumber(%v) = %v; want %v\", test.input, got, test.want)\r\n\t\t\t}\r\n\t\t})\r\n\t}\r\n}\r\n\r\ntype testNumberBox struct {\r\n\tn int\r\n}\r\n\r\nfunc (nb testNumberBox) Number() int {\r\n\treturn nb.n\r\n}\r\n\r\nfunc TestDescribeNumberBox(t *testing.T) {\r\n\ttests := []struct {\r\n\t\tdescription string\r\n\t\tinput       NumberBox\r\n\t\twant        string\r\n\t}{\r\n\t\t{\r\n\t\t\tdescription: \"Describe NumberBox with 4\",\r\n\t\t\tinput:       testNumberBox{4},\r\n\t\t\twant:        \"This is a box containing the number 4.0\",\r\n\t\t},\r\n\t\t{\r\n\t\t\tdescription: \"Describe NumberBox with -3\",\r\n\t\t\tinput:       testNumberBox{-3},\r\n\t\t\twant:        \"This is a box containing the number -3.0\",\r\n\t\t},\r\n\t}\r\n\tfor _, test := range tests {\r\n\t\tt.Run(test.description, func(t *testing.T) {\r\n\t\t\tif got := DescribeNumberBox(test.input); got != test.want {\r\n\t\t\t\tt.Errorf(\"DescribeNumberBox(%v) = %v; want %v\", test.input, got, test.want)\r\n\t\t\t}\r\n\t\t})\r\n\t}\r\n}\r\n\r\ntype differentFancyNumber struct {\r\n\tnum string\r\n}\r\n\r\nfunc (i differentFancyNumber) Value() string {\r\n\treturn i.num\r\n}\r\n\r\nfunc TestExtractFancyNumber(t *testing.T) {\r\n\ttests := []struct {\r\n\t\tdescription string\r\n\t\tinput       FancyNumberBox\r\n\t\twant        int\r\n\t}{\r\n\t\t{\r\n\t\t\tdescription: \"Extract fancy number 11\",\r\n\t\t\tinput:       FancyNumber{\"11\"},\r\n\t\t\twant:        11,\r\n\t\t},\r\n\t\t{\r\n\t\t\tdescription: \"Extract fancy number 0\",\r\n\t\t\tinput:       FancyNumber{\"0\"},\r\n\t\t\twant:        0,\r\n\t\t},\r\n\t\t{\r\n\t\t\tdescription: \"Extract a differentFancyNumber returns 0\",\r\n\t\t\tinput:       differentFancyNumber{\"4\"},\r\n\t\t\twant:        0,\r\n\t\t},\r\n\t\t{\r\n\t\t\tdescription: \"Extract an invalid fancy number returns 0\",\r\n\t\t\tinput:       FancyNumber{\"two\"},\r\n\t\t\twant:        0,\r\n\t\t},\r\n\t}\r\n\tfor _, test := range tests {\r\n\t\tt.Run(test.description, func(t *testing.T) {\r\n\t\t\tif got := ExtractFancyNumber(test.input); got != test.want {\r\n\t\t\t\tt.Errorf(\"ExtractFancyNumber(%v) = %v; want %v\", test.input, got, test.want)\r\n\t\t\t}\r\n\t\t})\r\n\t}\r\n}\r\n\r\nfunc TestDescribeFancyNumberBox(t *testing.T) {\r\n\ttests := []struct {\r\n\t\tdescription string\r\n\t\tinput       FancyNumberBox\r\n\t\twant        string\r\n\t}{\r\n\t\t{\r\n\t\t\tdescription: \"Describe fancy number 12\",\r\n\t\t\tinput:       FancyNumber{\"12\"},\r\n\t\t\twant:        \"This is a fancy box containing the number 12.0\",\r\n\t\t},\r\n\t\t{\r\n\t\t\tdescription: \"Describe fancy number 0\",\r\n\t\t\tinput:       FancyNumber{\"0\"},\r\n\t\t\twant:        \"This is a fancy box containing the number 0.0\",\r\n\t\t},\r\n\t\t{\r\n\t\t\tdescription: \"Describe a different fancy number\",\r\n\t\t\tinput:       differentFancyNumber{\"three\"},\r\n\t\t\twant:        \"This is a fancy box containing the number 0.0\",\r\n\t\t},\r\n\t\t{\r\n\t\t\tdescription: \"Describe a valid different fancy number\",\r\n\t\t\tinput:       differentFancyNumber{\"4\"},\r\n\t\t\twant:        \"This is a fancy box containing the number 0.0\",\r\n\t\t},\r\n\t}\r\n\tfor _, test := range tests {\r\n\t\tt.Run(test.description, func(t *testing.T) {\r\n\t\t\tif got := DescribeFancyNumberBox(test.input); got != test.want {\r\n\t\t\t\tt.Errorf(\"DescribeFancyNumberBox(%v) = %v; want %v\", test.input, got, test.want)\r\n\t\t\t}\r\n\t\t})\r\n\t}\r\n}\r\n\r\nfunc TestDescribeAnything(t *testing.T) {\r\n\ttests := []struct {\r\n\t\tdescription string\r\n\t\tinput       interface{}\r\n\t\twant        string\r\n\t}{\r\n\t\t{\r\n\t\t\tdescription: \"Describe 7.2\",\r\n\t\t\tinput:       7.2,\r\n\t\t\twant:        \"This is the number 7.2\",\r\n\t\t},\r\n\t\t{\r\n\t\t\tdescription: \"Describe 42\",\r\n\t\t\tinput:       42,\r\n\t\t\twant:        \"This is the number 42.0\",\r\n\t\t},\r\n\t\t{\r\n\t\t\tdescription: \"Describe NumberBox with 16\",\r\n\t\t\tinput:       testNumberBox{16},\r\n\t\t\twant:        \"This is a box containing the number 16.0\",\r\n\t\t},\r\n\t\t{\r\n\t\t\tdescription: \"Describe FancyNumber with 16\",\r\n\t\t\tinput:       FancyNumber{\"16\"},\r\n\t\t\twant:        \"This is a fancy box containing the number 16.0\",\r\n\t\t},\r\n\t\t{\r\n\t\t\tdescription: \"Describe a different FancyNumberBox\",\r\n\t\t\tinput:       differentFancyNumber{\"ten\"},\r\n\t\t\twant:        \"This is a fancy box containing the number 0.0\",\r\n\t\t},\r\n\t\t{\r\n\t\t\tdescription: \"Something unknown is labelled return to sender\",\r\n\t\t\tinput:       \"something we did not anticipate\",\r\n\t\t\twant:        \"Return to sender\",\r\n\t\t},\r\n\t}\r\n\tfor _, test := range tests {\r\n\t\tt.Run(test.description, func(t *testing.T) {\r\n\t\t\tif got := DescribeAnything(test.input); got != test.want {\r\n\t\t\t\tt.Errorf(\"DescribeAnything(%v) = %v; want %v\", test.input, got, test.want)\r\n\t\t\t}\r\n\t\t})\r\n\t}\r\n}\r\n"
}