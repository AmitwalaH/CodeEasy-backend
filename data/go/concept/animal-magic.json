{
  "language": "go",
  "slug": "animal-magic",
  "docs": {
    "introduction": "# Introduction\r\n\r\nPackage [math/rand][mathrand] provides support for generating pseudo-random numbers.\r\n\r\nHere is how to generate a random integer between `0` and `99`:\r\n\r\n```go\r\nn := rand.Intn(100) // n is a random int, 0 <= n < 100\r\n```\r\n\r\nFunction `rand.Float64` returns a random floating point number between `0.0` and `1.0`:\r\n\r\n```go\r\nf := rand.Float64() // f is a random float64, 0.0 <= f < 1.0\r\n```\r\n\r\nThere is also support for shuffling a slice (or other data structures):\r\n\r\n```go\r\nx := []string{\"a\", \"b\", \"c\", \"d\", \"e\"}\r\n// shuffling the slice put its elements into a random order\r\nrand.Shuffle(len(x), func(i, j int) {\r\n\tx[i], x[j] = x[j], x[i]\r\n})\r\n```\r\n\r\n## Seeds\r\n\r\nThe number sequences generated by package `math/rand` are not truly random.\r\nGiven a specific \"seed\" value, the results are entirely deterministic.\r\n\r\nIn Go 1.20+ the seed is automatically picked at random so you will see a different sequence of random numbers each time you run your program. \r\n\r\nIn prior versions of Go, the seed was `1` by default.\r\nSo to get different sequences for various runs of the program, you had to manually seed the random number generator, e.g. with the current time, before retrieving any random numbers.\r\n\r\n```go\r\nrand.Seed(time.Now().UnixNano())\r\n```\r\n\r\n[mathrand]: https://pkg.go.dev/math/rand\r\n",
    "instructions": "# Instructions\r\n\r\nElaine is working on a new children's game that features animals and magic wands.\r\nIt is time to code functions for rolling a die, generating random wand energy and shuffling a slice.\r\n\r\n## 1. Roll a die.\r\n\r\nImplement a `RollADie` function.\r\n\r\nThis will be the traditional twenty-sided die with numbers 1 to 20.\r\n\r\n```go\r\nd := RollADie() // d will be assigned a random int, 1 <= d <= 20\r\n```\r\n\r\n## 2. Generate wand energy.\r\n\r\nImplement a `GenerateWandEnergy` function.\r\nThe wand energy should be a random floating point number equal or greater than 0.0 and less than 12.0.\r\n\r\n```go\r\nf := GenerateWandEnergy()  // f will be assigned a random float64, 0.0 <= f < 12.0\r\n```\r\n\r\n## 3. Shuffle a slice.\r\n\r\nThe game features eight different animals:\r\n\r\n- ant\r\n- beaver\r\n- cat\r\n- dog\r\n- elephant\r\n- fox\r\n- giraffe\r\n- hedgehog\r\n\r\nWrite a function `ShuffleAnimals` that returns a slice with the eight animals in random order.\r\n",
    "hints": "# Hints\r\n\r\n## General\r\n\r\nThis [article][gobyexample] gives a nice introduction to package `math/rand`.\r\n\r\nIf you are working locally and use Go 1.19 or lower, make sure to seed your random number generator with the current time.\r\n\r\n## 1. Roll a die.\r\n\r\nThis [article][yourbasic] shows how to generate integers in a certain range.\r\n\r\n## 2. Generate wand energy.\r\n\r\nFunction [rand.Float64][float64] returns a random `float64` number between 0.0 and 1.0.\r\n\r\n## 3. Shuffle a slice.\r\n\r\nCreate a slice with the eight animal strings, then call [rand.Shuffle][shuffle] to put it into a random order.\r\n\r\n[gobyexample]: https://gobyexample.com/random-numbers\r\n[yourbasic]: https://yourbasic.org/golang/generate-number-random-range\r\n[shuffle]: https://pkg.go.dev/math/rand#Rand.Shuffle\r\n[float64]: https://pkg.go.dev/math/rand#Float64\r\n"
  },
  "starter_code": "package chance\r\n\r\n// RollADie returns a random int d with 1 <= d <= 20.\r\nfunc RollADie() int {\r\n\tpanic(\"Please implement the RollADie function\")\r\n}\r\n\r\n// GenerateWandEnergy returns a random float64 f with 0.0 <= f < 12.0.\r\nfunc GenerateWandEnergy() float64 {\r\n\tpanic(\"Please implement the GenerateWandEnergy function\")\r\n}\r\n\r\n// ShuffleAnimals returns a slice with all eight animal strings in random order.\r\nfunc ShuffleAnimals() []string {\r\n\tpanic(\"Please implement the ShuffleAnimals function\")\r\n}\r\n",
  "tests": "//nolint:gosec // In the context of this exercise, it is fine to use math.Rand instead of crypto.Rand.\r\npackage chance\r\n\r\nimport (\r\n\t\"sort\"\r\n\t\"testing\"\r\n)\r\n\r\nfunc TestRollADie(t *testing.T) {\r\n\tconst tests = 100\r\n\tvar got int\r\n\tfoundDifferent := false\r\n\tvar last int\r\n\tfor i := 0; i < tests; i++ {\r\n\t\tgot = RollADie()\r\n\t\tif got < 1 || got > 20 {\r\n\t\t\tt.Fatalf(\"RollADie() out of range: %d\", got)\r\n\t\t}\r\n\t\tif i > 0 && got != last {\r\n\t\t\tfoundDifferent = true\r\n\t\t}\r\n\t\tlast = got\r\n\t}\r\n\tif !foundDifferent {\r\n\t\tt.Errorf(\"RollADie() always generates the same number: %d\", got)\r\n\t}\r\n}\r\n\r\nfunc TestWandEnergy(t *testing.T) {\r\n\tconst tests = 200\r\n\tconst bucketSize float64 = 0.6\r\n\tvar got float64\r\n\tfoundDifferent := false\r\n\tvar last float64\r\n\tnumBuckets := int(12.0 / bucketSize)\r\n\tbuckets := make([]int, numBuckets)\r\n\tfor i := 0; i < tests; i++ {\r\n\t\tgot = GenerateWandEnergy()\r\n\t\tif got < 0.0 || got >= 12.0 {\r\n\t\t\tt.Fatalf(\"GenerateWandEnergy() out of range: %f\", got)\r\n\t\t}\r\n\t\tif i > 0 && got != last {\r\n\t\t\tfoundDifferent = true\r\n\t\t}\r\n\t\tbuckets[int(got/bucketSize)]++\r\n\t\tlast = got\r\n\t}\r\n\tif !foundDifferent {\r\n\t\tt.Fatalf(\"GenerateWandEnergy() always generates the same number: %f\", got)\r\n\t}\r\n\r\n\tvar low, high float64\r\n\tfor i, v := range buckets {\r\n\t\tif v == 0 {\r\n\t\t\tlow = float64(i) * bucketSize\r\n\t\t\thigh = float64(i+1) * bucketSize\r\n\t\t\tbreak\r\n\t\t}\r\n\t}\r\n\tif high != 0.0 {\r\n\t\tt.Errorf(\"GenerateWandEnergy() results are not uniformly distributed. %.2f to %.2f should contain values.\", low, high)\r\n\t}\r\n}\r\n\r\nfunc TestShuffleAnimals(t *testing.T) {\r\n\tconst tests = 100\r\n\tanimals := []string{\"ant\", \"beaver\", \"cat\", \"dog\", \"elephant\", \"fox\", \"giraffe\", \"hedgehog\"}\r\n\tfoundDifferent := false\r\n\tvar last []string\r\n\tvar got []string\r\n\tfor i := 0; i < tests; i++ {\r\n\t\tgot = ShuffleAnimals()\r\n\t\tgotSorted := make([]string, len(got))\r\n\t\tcopy(gotSorted, got)\r\n\t\tsort.Strings(gotSorted)\r\n\t\tif !slicesEqual(gotSorted, animals) {\r\n\t\t\tt.Fatalf(\"ShuffleAnimals() returns incorrect slice: %v\", got)\r\n\t\t}\r\n\t\tif i > 0 && !foundDifferent && !slicesEqual(last, got) {\r\n\t\t\tfoundDifferent = true\r\n\t\t}\r\n\t\tlast = got\r\n\t}\r\n\tif !foundDifferent {\r\n\t\tt.Errorf(\"ShuffleAnimals() always generates the same slice: %v\", got)\r\n\t}\r\n}\r\n\r\nfunc slicesEqual(a, b []string) bool {\r\n\tif len(a) != len(b) {\r\n\t\treturn false\r\n\t}\r\n\tif len(a) == 0 {\r\n\t\treturn true\r\n\t}\r\n\tsize := len(a)\r\n\tfor i := 0; i < size; i++ {\r\n\t\tif a[i] != b[i] {\r\n\t\t\treturn false\r\n\t\t}\r\n\t}\r\n\treturn true\r\n}\r\n"
}