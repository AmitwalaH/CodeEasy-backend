{
  "language": "go",
  "slug": "need-for-speed",
  "docs": {
    "introduction": "# Introduction\r\n\r\nIn Go, a `struct` is a sequence of named elements called _fields_, each field has a name and type.\r\nThe name of a field must be unique within the struct.\r\nStructs can be compared with _classes_ in the Object-Oriented Programming paradigm.\r\n\r\n## Defining a struct\r\n\r\nYou create a new struct by using the `type` and `struct` keywords, and explicitly define the name and type of the fields.\r\nFor example, here we define `Shape` struct, that holds the name of a shape and its size:\r\n\r\n```go\r\ntype Shape struct {\r\n    name string\r\n    size int\r\n}\r\n```\r\n\r\nField names in structs follow the Go convention - fields whose name starts with a lower case letter are only visible to code in the same package, whereas those whose name starts with an upper case letter are visible in other packages.\r\n\r\n## Creating instances of a struct\r\n\r\nOnce you have defined the `struct`, you need to create a new instance defining the fields using their field name\r\nin any order:\r\n\r\n```go\r\ns := Shape {\r\n    name: \"Square\",\r\n    size: 25,\r\n}\r\n```\r\n\r\nTo read or modify instance fields, use the `.` notation:\r\n\r\n```go\r\n// Update the name and the size\r\ns.name = \"Circle\"\r\ns.size = 35\r\nfmt.Printf(\"name: %s size: %d\\n\", s.name, s.size)\r\n// Output: name: Circle size: 35\r\n```\r\n\r\nFields that don't have an initial value assigned, will have their zero value. For example:\r\n\r\n```go\r\ns := Shape{name: \"Circle\"}\r\nfmt.Printf(\"name: %s size: %d\\n\", s.name, s.size)\r\n// Output: name: Circle size: 0\r\n```\r\n\r\nYou can create an instance of a `struct` without using the field names, as long as you define the fields _in order_:\r\n\r\n```go\r\ns := Shape {\r\n\t\"Oval\",\r\n\t20,\r\n}\r\n```\r\n\r\nHowever, this syntax is considered _brittle code_ since it can break when a field is added, especially when the new field is of a different type.\r\nIn the following example we add an extra field to `Shape`:\r\n\r\n```go\r\ntype Shape struct {\r\n\tname        string\r\n\tdescription string // new field 'description' added\r\n\tsize        int\r\n}\r\n\r\ns := Shape{\r\n    \"Circle\",\r\n    20,\r\n}\r\n// Since the second field of the struct is now a string and not an int,\r\n// the compiler will throw an error when compiling the program:\r\n// Output: cannot use 20 (type untyped int) as type string in field value\r\n// Output: too few values in Shape{...}\r\n```\r\n\r\n## \"New\" functions\r\n\r\nSometimes it can be nice to have functions that help us create struct instances.\r\nBy convention, these functions are usually called `New` or have their names starting with `New`, but since they are just regular functions, you can give them any name you want.\r\nThey might remind you of constructors in other languages, but in Go they are just regular functions.\r\n\r\nIn the following example, one of these `New` functions is used to create a new instance of `Shape` and automatically set a default value for the `size` of the shape:\r\n\r\n```go\r\nfunc NewShape(name string) Shape {\r\n\treturn Shape{\r\n\t\tname: name,\r\n\t\tsize: 100, //default-value for size is 100\r\n\t}\r\n}\r\n\r\nNewShape(\"Triangle\")\r\n// => Shape { name: \"Triangle\", size: 100 }\r\n\r\n```\r\n\r\nUsing `New` functions can have the following advantages:\r\n* validation of the given values\r\n* handling of default-values\r\n* since `New` functions are often declared in the same package of the structs they initialize, they can initialize even private fields of the struct\r\n",
    "instructions": "# Instructions\r\n\r\nIn this exercise you'll be organizing races between various types of remote controlled cars.\r\nEach car has its own speed and battery drain characteristics.\r\n\r\nCars start with full (100%) batteries. Each time you drive the car using the remote control,\r\nit covers the car's speed in meters and decreases the remaining battery percentage by its battery drain.\r\n\r\nIf a car's battery is below its battery drain percentage, you can't drive the car anymore.\r\n\r\nEach race track has its own distance. Cars are tested by checking if they can finish the track without running out of battery.\r\n\r\n## 1. Create a remote controlled car\r\n\r\nDefine a `Car` struct with the following `int` type fields:\r\n\r\n- battery\r\n- batteryDrain\r\n- speed\r\n- distance\r\n\r\nAllow creating a remote controlled car by defining a function `NewCar` that takes the speed of the car in meters,\r\nand the battery drain percentage as its two parameters (both of type `int`) and returns a `Car` instance:\r\n\r\n```go\r\nspeed := 5\r\nbatteryDrain := 2\r\ncar := NewCar(speed, batteryDrain)\r\n// => Car{speed: 5, batteryDrain: 2, battery:100, distance: 0}\r\n```\r\n\r\n## 2. Create a race track\r\n\r\nDefine another struct type called `Track` with the field `distance` of type integer.\r\nAllow creating a race track by defining a function `NewTrack` that takes the track's distance in meters as its sole parameter (which is of type `int`):\r\n\r\n```go\r\ndistance := 800\r\ntrack := NewTrack(distance)\r\n// => Track{distance: 800}\r\n```\r\n\r\n## 3. Drive the car\r\n\r\nImplement the `Drive` function that updates the number of meters driven based on the car's speed, and reduces the battery according to the battery drainage.\r\nIf there is not enough battery to drive one more time the car will not move:\r\n\r\n```go\r\nspeed := 5\r\nbatteryDrain := 2\r\ncar := NewCar(speed, batteryDrain)\r\ncar = Drive(car)\r\n// => Car{speed: 5, batteryDrain: 2, battery: 98, distance: 5}\r\n```\r\n\r\n## 4. Check if a remote controlled car can finish a race\r\n\r\nTo finish a race, a car has to be able to drive the race's distance. This means not draining its battery before having crossed the finish line. Implement the `CanFinish` function that takes a `Car` and a `Track` instance as its parameter and returns `true` if the car can finish the race; otherwise, return `false`.\r\n\r\nAssume that you are currently at the starting line of the race and start the engine of the car for the race. Take into account that the car's battery might not necessarily be fully charged when starting the race:\r\n```go\r\nspeed := 5\r\nbatteryDrain := 2\r\ncar := NewCar(speed, batteryDrain)\r\n\r\ndistance := 100\r\ntrack := NewTrack(distance)\r\n\r\nCanFinish(car, track)\r\n// => true\r\n```\r\n",
    "hints": "# Hints\r\n\r\n## General\r\n\r\n- A `struct` is a sequence of named elements, called fields, each one having a name and a type.\r\n\r\n## 1. Create a remote controlled car\r\n\r\n- Instantiate a new [struct][struct] and fill the fields except `distance`.\r\n- Create a function that returns the type of the newly created struct and update the fields accordingly\r\n\r\n## 2. Create a race track\r\n\r\n- Define a new [struct][struct] with 1 field\r\n- Create a function that returns the type of the new created struct and updates the fields accordingly\r\n\r\n## 3. Drive the car\r\n\r\n- Add a new field to keep track of the distance driven\r\n- You need to check if there is enough battery to drive the car\r\n\r\n## 4. Check if a remote controlled car can finish a race\r\n\r\n- Assume the car is just starting the race\r\n- You need to calculate the maximum distance a car can drive with the current level of battery\r\n- The number of times a car can be driven can be calculated by `battery / batteryDrain`.\r\n- The maximum distance the car can cover is the product of the car's speed and the number of times it can be driven.\r\n- Knowing the maximum distance the car can drive, compare it with the distance of the race track\r\n\r\n[struct]: https://tour.golang.org/moretypes/2\r\n"
  },
  "starter_code": "package speed\r\n\r\n// TODO: define the 'Car' type struct\r\n\r\n// NewCar creates a new remote controlled car with full battery and given specifications.\r\nfunc NewCar(speed, batteryDrain int) Car {\r\n\tpanic(\"Please implement the NewCar function\")\r\n}\r\n\r\n// TODO: define the 'Track' type struct\r\n\r\n// NewTrack creates a new track\r\nfunc NewTrack(distance int) Track {\r\n\tpanic(\"Please implement the NewTrack function\")\r\n}\r\n\r\n// Drive drives the car one time. If there is not enough battery to drive one more time,\r\n// the car will not move.\r\nfunc Drive(car Car) Car {\r\n\tpanic(\"Please implement the Drive function\")\r\n}\r\n\r\n// CanFinish checks if a car is able to finish a certain track.\r\nfunc CanFinish(car Car, track Track) bool {\r\n\tpanic(\"Please implement the CanFinish function\")\r\n}\r\n",
  "tests": "package speed\r\n\r\nimport \"testing\"\r\n\r\nfunc TestNewCar(t *testing.T) {\r\n\ttests := []struct {\r\n\t\tname     string\r\n\t\tcar      Car\r\n\t\texpected Car\r\n\t}{\r\n\t\t{\r\n\t\t\tname: \"Create a new car.\",\r\n\t\t\tcar: Car{\r\n\t\t\t\tspeed:        5,\r\n\t\t\t\tbatteryDrain: 2,\r\n\t\t\t\tbattery:      100,\r\n\t\t\t},\r\n\t\t\texpected: Car{\r\n\t\t\t\tspeed:        5,\r\n\t\t\t\tbatteryDrain: 2,\r\n\t\t\t\tbattery:      100,\r\n\t\t\t},\r\n\t\t},\r\n\t}\r\n\r\n\tfor _, tt := range tests {\r\n\t\tt.Run(tt.name, func(t *testing.T) {\r\n\t\t\tgot := NewCar(tt.car.speed, tt.car.batteryDrain)\r\n\r\n\t\t\tif got != tt.expected {\r\n\t\t\t\tt.Errorf(\"NewCar(%+v,%+v) = %+v; expected %+v\", tt.car.speed, tt.car.batteryDrain, got, tt.expected)\r\n\t\t\t}\r\n\t\t})\r\n\t}\r\n}\r\n\r\nfunc TestNewTrack(t *testing.T) {\r\n\ttests := []struct {\r\n\t\tname     string\r\n\t\ttrack    Track\r\n\t\texpected Track\r\n\t}{\r\n\t\t{\r\n\t\t\tname: \"Create a new track.\",\r\n\t\t\ttrack: Track{\r\n\t\t\t\tdistance: 800,\r\n\t\t\t},\r\n\t\t\texpected: Track{\r\n\t\t\t\tdistance: 800,\r\n\t\t\t},\r\n\t\t},\r\n\t\t{\r\n\t\t\tname: \"Create a new track.\",\r\n\t\t\ttrack: Track{\r\n\t\t\t\tdistance: 360,\r\n\t\t\t},\r\n\t\t\texpected: Track{\r\n\t\t\t\tdistance: 360,\r\n\t\t\t},\r\n\t\t},\r\n\t}\r\n\r\n\tfor _, tt := range tests {\r\n\t\tt.Run(tt.name, func(t *testing.T) {\r\n\t\t\tgot := NewTrack(tt.track.distance)\r\n\r\n\t\t\tif got != tt.expected {\r\n\t\t\t\tt.Errorf(\"NewTrack(%+v) = %+v; expected %+v\", tt.track.distance, tt.track, tt.expected)\r\n\t\t\t}\r\n\t\t})\r\n\t}\r\n}\r\n\r\nfunc TestDrive(t *testing.T) {\r\n\ttests := []struct {\r\n\t\tname     string\r\n\t\tcar      Car\r\n\t\texpected Car\r\n\t}{\r\n\t\t{\r\n\t\t\tname: \"Drive the car with full battery.\",\r\n\t\t\tcar: Car{\r\n\t\t\t\tspeed:        5,\r\n\t\t\t\tbatteryDrain: 2,\r\n\t\t\t\tbattery:      100,\r\n\t\t\t\tdistance:     0,\r\n\t\t\t},\r\n\t\t\texpected: Car{\r\n\t\t\t\tspeed:        5,\r\n\t\t\t\tbatteryDrain: 2,\r\n\t\t\t\tbattery:      98,\r\n\t\t\t\tdistance:     5,\r\n\t\t\t},\r\n\t\t},\r\n\t\t{\r\n\t\t\tname: \"Drive the car with exactly enough battery.\",\r\n\t\t\tcar: Car{\r\n\t\t\t\tspeed:        18,\r\n\t\t\t\tbatteryDrain: 10,\r\n\t\t\t\tbattery:      10,\r\n\t\t\t\tdistance:     0,\r\n\t\t\t},\r\n\t\t\texpected: Car{\r\n\t\t\t\tspeed:        18,\r\n\t\t\t\tbatteryDrain: 10,\r\n\t\t\t\tbattery:      0,\r\n\t\t\t\tdistance:     18,\r\n\t\t\t},\r\n\t\t},\r\n\t\t{\r\n\t\t\tname: \"Drive when battery percentage is below battery drain\",\r\n\t\t\tcar: Car{\r\n\t\t\t\tspeed:        5,\r\n\t\t\t\tbatteryDrain: 7,\r\n\t\t\t\tbattery:      3,\r\n\t\t\t\tdistance:     0,\r\n\t\t\t},\r\n\t\t\texpected: Car{\r\n\t\t\t\tspeed:        5,\r\n\t\t\t\tbatteryDrain: 7,\r\n\t\t\t\tbattery:      3,\r\n\t\t\t\tdistance:     0,\r\n\t\t\t},\r\n\t\t},\r\n\t\t{\r\n\t\t\tname: \"Drive the car with battery drained.\",\r\n\t\t\tcar: Car{\r\n\t\t\t\tspeed:        5,\r\n\t\t\t\tbatteryDrain: 5,\r\n\t\t\t\tbattery:      4,\r\n\t\t\t\tdistance:     0,\r\n\t\t\t},\r\n\t\t\texpected: Car{\r\n\t\t\t\tspeed:        5,\r\n\t\t\t\tbatteryDrain: 5,\r\n\t\t\t\tbattery:      4,\r\n\t\t\t\tdistance:     0,\r\n\t\t\t},\r\n\t\t},\r\n\t\t{\r\n\t\t\tname: \"Drive the car with positive initial distance and battery drained\",\r\n\t\t\tcar: Car{\r\n\t\t\t\tspeed:        5,\r\n\t\t\t\tbatteryDrain: 3,\r\n\t\t\t\tbattery:      2,\r\n\t\t\t\tdistance:     1,\r\n\t\t\t},\r\n\t\t\texpected: Car{\r\n\t\t\t\tspeed:        5,\r\n\t\t\t\tbatteryDrain: 3,\r\n\t\t\t\tbattery:      2,\r\n\t\t\t\tdistance:     1,\r\n\t\t\t},\r\n\t\t},\r\n\t\t{\r\n\t\t\tname: \"Drive the car with positive initial distance and full battery\",\r\n\t\t\tcar: Car{\r\n\t\t\t\tspeed:        5,\r\n\t\t\t\tbatteryDrain: 3,\r\n\t\t\t\tbattery:      100,\r\n\t\t\t\tdistance:     1,\r\n\t\t\t},\r\n\t\t\texpected: Car{\r\n\t\t\t\tspeed:        5,\r\n\t\t\t\tbatteryDrain: 3,\r\n\t\t\t\tbattery:      97,\r\n\t\t\t\tdistance:     6,\r\n\t\t\t},\r\n\t\t},\r\n\t}\r\n\r\n\tfor _, tt := range tests {\r\n\t\tt.Run(tt.name, func(t *testing.T) {\r\n\t\t\tgot := Drive(tt.car)\r\n\r\n\t\t\tif got != tt.expected {\r\n\t\t\t\tt.Errorf(\"Drive(%+v) = %+v; expected %+v\", tt.car, got, tt.expected)\r\n\t\t\t}\r\n\t\t})\r\n\t}\r\n}\r\n\r\nfunc TestCanFinish(t *testing.T) {\r\n\ttests := []struct {\r\n\t\tname     string\r\n\t\tcar      Car\r\n\t\ttrack    Track\r\n\t\texpected bool\r\n\t}{\r\n\t\t{\r\n\t\t\tname: \"Car can easily finish the track distance.\",\r\n\t\t\tcar: Car{\r\n\t\t\t\tspeed:        5,\r\n\t\t\t\tbatteryDrain: 2,\r\n\t\t\t\tbattery:      100,\r\n\t\t\t\tdistance:     20,\r\n\t\t\t},\r\n\t\t\ttrack: Track{\r\n\t\t\t\tdistance: 30,\r\n\t\t\t},\r\n\t\t\texpected: true,\r\n\t\t},\r\n\t\t{\r\n\t\t\tname: \"Car can finish the track distance just as the battery is drained.\",\r\n\t\t\tcar: Car{\r\n\t\t\t\tspeed:        5,\r\n\t\t\t\tbatteryDrain: 5,\r\n\t\t\t\tbattery:      100,\r\n\t\t\t\tdistance:     20,\r\n\t\t\t},\r\n\t\t\ttrack: Track{\r\n\t\t\t\tdistance: 100,\r\n\t\t\t},\r\n\t\t\texpected: true,\r\n\t\t},\r\n\t\t{\r\n\t\t\tname: \"Car cannot finish the track distance.\",\r\n\t\t\tcar: Car{\r\n\t\t\t\tspeed:        2,\r\n\t\t\t\tbatteryDrain: 6,\r\n\t\t\t\tbattery:      100,\r\n\t\t\t\tdistance:     5,\r\n\t\t\t},\r\n\t\t\ttrack: Track{\r\n\t\t\t\tdistance: 80,\r\n\t\t\t},\r\n\t\t\texpected: false,\r\n\t\t},\r\n\t\t{\r\n\t\t\tname: \"Car can finish the track distance with initial battery less than 100%\",\r\n\t\t\tcar: Car{\r\n\t\t\t\tspeed:        2,\r\n\t\t\t\tbatteryDrain: 3,\r\n\t\t\t\tbattery:      25,\r\n\t\t\t\tdistance:     0,\r\n\t\t\t},\r\n\t\t\ttrack: Track{\r\n\t\t\t\tdistance: 16,\r\n\t\t\t},\r\n\t\t\texpected: true,\r\n\t\t},\r\n\t\t{\r\n\t\t\tname: \"Car cannot finish the track distance with initial battery less than 100%\",\r\n\t\t\tcar: Car{\r\n\t\t\t\tspeed:        2,\r\n\t\t\t\tbatteryDrain: 3,\r\n\t\t\t\tbattery:      25,\r\n\t\t\t\tdistance:     0,\r\n\t\t\t},\r\n\t\t\ttrack: Track{\r\n\t\t\t\tdistance: 24,\r\n\t\t\t},\r\n\t\t\texpected: false,\r\n\t\t},\r\n\t}\r\n\r\n\tfor _, tt := range tests {\r\n\t\tt.Run(tt.name, func(t *testing.T) {\r\n\t\t\tgot := CanFinish(tt.car, tt.track)\r\n\r\n\t\t\tif got != tt.expected {\r\n\t\t\t\tt.Errorf(\"CanFinish(%#v, %#v) = %+v; expected %+v\", tt.car, tt.track, got, tt.expected)\r\n\t\t\t}\r\n\t\t})\r\n\t}\r\n}\r\n"
}