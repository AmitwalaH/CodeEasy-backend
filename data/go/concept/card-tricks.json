{
  "language": "go",
  "slug": "card-tricks",
  "docs": {
    "introduction": "# Introduction\r\n\r\n## Slices\r\n\r\nSlices in Go are similar to lists or arrays in other languages.\r\nThey hold several elements of a specific type (or interface).\r\n\r\nSlices in Go are based on arrays.\r\nArrays have a fixed size.\r\nA slice, on the other hand, is a dynamically-sized, flexible view of the elements of an array.\r\n\r\nA slice is written like `[]T` with `T` being the type of the elements in the slice:\r\n\r\n```go\r\nvar empty []int                 // an empty slice\r\nwithData := []int{0,1,2,3,4,5}  // a slice pre-filled with some data\r\n```\r\n\r\nYou can get or set an element at a given zero-based index using the square-bracket notation:\r\n\r\n```go\r\nwithData[1] = 5\r\nx := withData[1] // x is now 5\r\n```\r\n\r\nYou can create a new slice from an existing slice by getting a range of elements.\r\nOnce again using square-bracket notation, but specifying both a starting (inclusive) and ending (exclusive) index.\r\nIf you don't specify a starting index, it defaults to 0.\r\nIf you don't specify an ending index, it defaults to the length of the slice.\r\n\r\n```go\r\nnewSlice := withData[2:4]\r\n// => []int{2,3}\r\nnewSlice := withData[:2]\r\n// => []int{0,1}\r\nnewSlice := withData[2:]\r\n// => []int{2,3,4,5}\r\nnewSlice := withData[:]\r\n// => []int{0,1,2,3,4,5}\r\n```\r\n\r\nYou can add elements to a slice using the `append` function.\r\nBelow we append `4` and `2` to the `a` slice.\r\n\r\n```go\r\na := []int{1, 3}\r\na = append(a, 4, 2)\r\n// => []int{1,3,4,2}\r\n```\r\n\r\n`append` always returns a new slice, and when we just want to append elements to an existing slice, it's common to reassign it back to the slice variable we pass as the first argument as we did above.\r\n\r\n`append` can also be used to merge two slices:\r\n\r\n```go\r\nnextSlice := []int{100,101,102}\r\nnewSlice  := append(withData, nextSlice...)\r\n// => []int{0,1,2,3,4,5,100,101,102}\r\n```\r\n\r\n## Variadic Functions\r\n\r\nUsually, functions in Go accept only a fixed number of arguments.\r\nHowever, it is also possible to write variadic functions in Go.\r\n\r\nA variadic function is a function that accepts a variable number of arguments.\r\n\r\nIf the type of the last parameter in a function definition is prefixed by ellipsis `...`, then the function can accept any number of arguments for that parameter.\r\n\r\n```go\r\nfunc find(a int, b ...int) {\r\n    // ...\r\n}\r\n```\r\n\r\nIn the above function, parameter `b` is variadic and we can pass 0 or more arguments to `b`.\r\n\r\n```go\r\nfind(5, 6)\r\nfind(5, 6, 7)\r\nfind(5)\r\n```\r\n\r\n~~~~exercism/caution\r\nThe variadic parameter must be the last parameter of the function.\r\n~~~~\r\n\r\nThe way variadic functions work is by converting the variable number of arguments to a slice of the type of the variadic parameter.\r\n\r\nHere is an example of an implementation of a variadic function.\r\n\r\n```go\r\nfunc find(num int, nums ...int) {\r\n    fmt.Printf(\"type of nums is %T\\n\", nums)\r\n\r\n    for i, v := range nums {\r\n        if v == num {\r\n            fmt.Println(num, \"found at index\", i, \"in\", nums)\r\n            return\r\n        }\r\n    }\r\n\r\n    fmt.Println(num, \"not found in \", nums)\r\n}\r\n\r\nfunc main() {\r\n    find(89, 90, 91, 95)\r\n    // =>\r\n    // type of nums is []int\r\n    // 89 not found in  [90 91 95]\r\n\r\n    find(45, 56, 67, 45, 90, 109)\r\n    // =>\r\n    // type of nums is []int\r\n    // 45 found at index 2 in [56 67 45 90 109]\r\n\r\n    find(87)\r\n    // =>\r\n    // type of nums is []int\r\n    // 87 not found in  []\r\n}\r\n```\r\n\r\nIn line `find(89, 90, 91, 95)` of the program above, the variable number of arguments to the find function are `90`, `91` and `95`.\r\nThe `find` function expects a variadic int parameter after `num`.\r\nHence these three arguments will be converted by the compiler to a slice of type `int` `[]int{90, 91, 95}` and then it will be passed to the find function as `nums`.\r\n\r\nSometimes you already have a slice and want to pass that to a variadic function.\r\nThis can be achieved by passing the slice followed by `...`.\r\nThat will tell the compiler to use the slice as is inside the variadic function.\r\nThe step described above where a slice is created will simply be omitted in this case.\r\n\r\n```go\r\nlist := []int{1, 2, 3}\r\nfind(1, list...) // \"find\" defined as shown above\r\n```\r\n\r\n[append-yourbasic]: https://yourbasic.org/golang/append-explained/\r\n",
    "instructions": "# Instructions\r\n\r\nAs a magician-to-be, Elyse needs to practice some basics. She has a stack of cards that she wants to manipulate.\r\n\r\nTo make things a bit easier she only uses the cards 1 to 10.\r\n\r\n## 1. Create a slice with certain cards\r\n\r\nWhen practicing with her cards, Elyse likes to start with her favorite three cards of the deck: 2, 6 and 9.\r\nWrite a function `FavoriteCards` that returns a slice with those cards in that order.\r\n\r\n```go\r\ncards := FavoriteCards()\r\nfmt.Println(cards)\r\n// Output: [2 6 9]\r\n```\r\n\r\n## 2. Retrieve a card from a stack\r\n\r\nReturn the card at position `index` from the given stack.\r\n\r\n```go\r\ncard := GetItem([]int{1, 2, 4, 1}, 2) // card == 4\r\n```\r\n\r\nIf the index is out of bounds (ie. if it is negative or after the end of the stack), we want to return `-1`:\r\n\r\n```go\r\ncard := GetItem([]int{1, 2, 4, 1}, 10) // card == -1\r\n```\r\n~~~~exercism/note\r\nBy convention in Go, an error is returned instead of returning an \"out-of-band\" value.\r\nHere the \"out-of-band\" value is `-1` when a positive integer is expected.\r\nWhen returning an error, it's considered idiomatic to return the [`zero value`](https://www.geeksforgeeks.org/zero-value-in-golang/) with the error.\r\nReturning an error with the proper return value will be covered in a future exercise.\r\n~~~~\r\n\r\n## 3. Exchange a card in the stack\r\n\r\nExchange the card at position `index` with the new card provided and return the adjusted stack.\r\nNote that this will modify the input slice which is the expected behavior.\r\n\r\n```go\r\nindex := 2\r\nnewCard := 6\r\ncards := SetItem([]int{1, 2, 4, 1}, index, newCard)\r\nfmt.Println(cards)\r\n// Output: [1 2 6 1]\r\n```\r\n\r\nIf the index is out of bounds (ie. if it is negative or after the end of the stack), we want to append the new card to the end of the stack:\r\n\r\n```go\r\nindex := -1\r\nnewCard := 6\r\ncards := SetItem([]int{1, 2, 4, 1}, index, newCard)\r\nfmt.Println(cards)\r\n// Output: [1 2 4 1 6]\r\n```\r\n\r\n## 4. Add cards to the top of the stack\r\n\r\nAdd the card(s) specified in the `value` parameter at the top of the stack.\r\n\r\n```go\r\nslice := []int{3, 2, 6, 4, 8}\r\ncards := PrependItems(slice, 5, 1)\r\nfmt.Println(cards)\r\n// Output: [5 1 3 2 6 4 8]\r\n```\r\n\r\nIf no argument is given for the `value` parameter, then the result equals the original slice.\r\n\r\n```go\r\nslice := []int{3, 2, 6, 4, 8}\r\ncards := PrependItems(slice)\r\nfmt.Println(cards)\r\n// Output: [3 2 6 4 8]\r\n```\r\n\r\n## 5. Remove a card from the stack\r\n\r\nRemove the card at position `index` from the stack and return the stack.\r\nNote that this may modify the input slice which is ok.\r\n\r\n```go\r\ncards := RemoveItem([]int{3, 2, 6, 4, 8}, 2)\r\nfmt.Println(cards)\r\n// Output: [3 2 4 8]\r\n```\r\n\r\nIf the index is out of bounds (ie. if it is negative or after the end of the stack), we want to leave the stack unchanged:\r\n\r\n```go\r\ncards := RemoveItem([]int{3, 2, 6, 4, 8}, 11)\r\nfmt.Println(cards)\r\n// Output: [3 2 6 4 8]\r\n```\r\n",
    "hints": "# Hints\r\n\r\n## General\r\n\r\n- Slices in Go are zero-based. The first index in a slice is `0`.\r\n- The builtin [`append`][append-builtin] function is [`variadic`][variadic-gobyexample]\r\n- You can append the elements of one slice to another slice by using the three dots notation:\r\n\r\n```go\r\na := []int{1, 3}\r\nb := []int{4, 2, 6}\r\nc := append(a, b...)\r\nfmt.Println(c)\r\n// Output: [1 3 4 2 6]\r\n```\r\n\r\n## 1. Create a slice with certain cards\r\n\r\n- To create a slice pre-filled with some data, use the slice literal notation:\r\n  `s := []T{x1, x2, ..., xn}`\r\n\r\n## 2. Retrieve a card from a stack\r\n\r\n- To get the `n`th item of a slice [use an index][go-slices].\r\n- To check if an item exists in a slice use a conditional and compare the index with the [length of the slice][len-builtin].\r\n\r\n## 3. Exchange a card in the stack\r\n\r\n- To set the `n`th item in a slice [use an index][go-slices] and assign a new value to it.\r\n- To add a new item to then end of a slice use the `append` function.\r\n\r\n## 4. Add cards to the top of the stack\r\n\r\n- Adding items to the front of a slice can be done by appending the elements of the original slice to the `value` argument slice.\r\n\r\n## 5. Remove a card from the stack\r\n\r\n- Removing an item from a slice can be done by appending the part after `index` to the part before index.\r\n\r\n[go-slices]: https://blog.golang.org/go-slices-usage-and-internals\r\n[make-builtin]: https://golang.org/pkg/builtin/#make\r\n[len-builtin]: https://golang.org/pkg/builtin/#len\r\n[append-builtin]: https://golang.org/pkg/builtin/#append\r\n[variadic-gobyexample]: https://gobyexample.com/variadic-functions\r\n"
  },
  "starter_code": "package cards\r\n\r\n// FavoriteCards returns a slice with the cards 2, 6 and 9 in that order.\r\nfunc FavoriteCards() []int {\r\n\tpanic(\"Please implement the FavoriteCards function\")\r\n}\r\n\r\n// GetItem retrieves an item from a slice at given position.\r\n// If the index is out of range, we want it to return -1.\r\nfunc GetItem(slice []int, index int) int {\r\n\tpanic(\"Please implement the GetItem function\")\r\n}\r\n\r\n// SetItem writes an item to a slice at given position overwriting an existing value.\r\n// If the index is out of range the value needs to be appended.\r\nfunc SetItem(slice []int, index, value int) []int {\r\n\tpanic(\"Please implement the SetItem function\")\r\n}\r\n\r\n// PrependItems adds an arbitrary number of values at the front of a slice.\r\nfunc PrependItems(slice []int, values ...int) []int {\r\n\tpanic(\"Please implement the PrependItems function\")\r\n}\r\n\r\n// RemoveItem removes an item from a slice by modifying the existing slice.\r\nfunc RemoveItem(slice []int, index int) []int {\r\n\tpanic(\"Please implement the RemoveItem function\")\r\n}\r\n",
  "tests": "package cards\r\n\r\nimport (\r\n\t\"reflect\"\r\n\t\"testing\"\r\n)\r\n\r\nfunc TestFavoriteCards(t *testing.T) {\r\n\tgot := FavoriteCards()\r\n\twant := []int{2, 6, 9}\r\n\tif !slicesEqual(got, want) {\r\n\t\tt.Errorf(\"NewCards() got = %v, want %v\", got, want)\r\n\t}\r\n}\r\n\r\nfunc TestGetItem(t *testing.T) {\r\n\ttype args struct {\r\n\t\tslice []int\r\n\t\tindex int\r\n\t}\r\n\ttests := []struct {\r\n\t\tname string\r\n\t\targs args\r\n\t\twant int\r\n\t}{\r\n\t\t{\r\n\t\t\tname: \"Retrieve item from slice by index\",\r\n\t\t\targs: args{\r\n\t\t\t\tslice: []int{5, 2, 10, 6, 8, 7, 0, 9},\r\n\t\t\t\tindex: 4,\r\n\t\t\t},\r\n\t\t\twant: 8,\r\n\t\t},\r\n\t\t{\r\n\t\t\tname: \"Get first item from slice\",\r\n\t\t\targs: args{\r\n\t\t\t\tslice: []int{5, 2, 10, 6, 8, 7, 0, 9},\r\n\t\t\t\tindex: 0,\r\n\t\t\t},\r\n\t\t\twant: 5,\r\n\t\t},\r\n\t\t{\r\n\t\t\tname: \"Get last item from slice\",\r\n\t\t\targs: args{\r\n\t\t\t\tslice: []int{5, 2, 10, 6, 8, 7, 0, 9},\r\n\t\t\t\tindex: 7,\r\n\t\t\t},\r\n\t\t\twant: 9,\r\n\t\t},\r\n\t\t{\r\n\t\t\tname: \"Index out of bounds\",\r\n\t\t\targs: args{\r\n\t\t\t\tslice: []int{5, 2, 10, 6, 8, 7, 0, 9},\r\n\t\t\t\tindex: 9,\r\n\t\t\t},\r\n\t\t\twant: -1,\r\n\t\t},\r\n\t\t{\r\n\t\t\tname: \"Negative index\",\r\n\t\t\targs: args{\r\n\t\t\t\tslice: []int{5, 2, 10, 6, 8, 7, 0, 9},\r\n\t\t\t\tindex: -1,\r\n\t\t\t},\r\n\t\t\twant: -1,\r\n\t\t},\r\n\t}\r\n\tfor _, tt := range tests {\r\n\t\tt.Run(tt.name, func(t *testing.T) {\r\n\t\t\tgot := GetItem(tt.args.slice, tt.args.index)\r\n\t\t\tif got != tt.want {\r\n\t\t\t\tt.Errorf(\"GetItem(slice:%v, index:%v) got = %v, want %v\", tt.args.slice, tt.args.index, got, tt.want)\r\n\t\t\t}\r\n\t\t})\r\n\t}\r\n}\r\n\r\nfunc TestSetItem(t *testing.T) {\r\n\ttype args struct {\r\n\t\tslice []int\r\n\t\tindex int\r\n\t\tvalue int\r\n\t}\r\n\ttests := []struct {\r\n\t\tname string\r\n\t\targs args\r\n\t\twant []int\r\n\t}{\r\n\t\t{\r\n\t\t\tname: \"Overwrite an existing item\",\r\n\t\t\targs: args{\r\n\t\t\t\tslice: []int{5, 2, 10, 6, 8, 7, 0, 9},\r\n\t\t\t\tindex: 4,\r\n\t\t\t\tvalue: 1,\r\n\t\t\t},\r\n\t\t\twant: []int{5, 2, 10, 6, 1, 7, 0, 9},\r\n\t\t},\r\n\t\t{\r\n\t\t\tname: \"Overwrite first item\",\r\n\t\t\targs: args{\r\n\t\t\t\tslice: []int{5, 2, 10, 6, 8, 7, 0, 9},\r\n\t\t\t\tindex: 0,\r\n\t\t\t\tvalue: 8,\r\n\t\t\t},\r\n\t\t\twant: []int{8, 2, 10, 6, 8, 7, 0, 9},\r\n\t\t},\r\n\t\t{\r\n\t\t\tname: \"Overwrite last item\",\r\n\t\t\targs: args{\r\n\t\t\t\tslice: []int{5, 2, 10, 6, 8, 7, 0, 9},\r\n\t\t\t\tindex: 7,\r\n\t\t\t\tvalue: 8,\r\n\t\t\t},\r\n\t\t\twant: []int{5, 2, 10, 6, 8, 7, 0, 8},\r\n\t\t},\r\n\t\t{\r\n\t\t\tname: \"Index out of bounds\",\r\n\t\t\targs: args{\r\n\t\t\t\tslice: []int{5, 2, 10, 6, 8, 7, 0, 9},\r\n\t\t\t\tindex: 8,\r\n\t\t\t\tvalue: 8,\r\n\t\t\t},\r\n\t\t\twant: []int{5, 2, 10, 6, 8, 7, 0, 9, 8},\r\n\t\t},\r\n\t\t{\r\n\t\t\tname: \"Negative index\",\r\n\t\t\targs: args{\r\n\t\t\t\tslice: []int{5, 2, 10, 6, 8, 7, 0, 9},\r\n\t\t\t\tindex: -1,\r\n\t\t\t\tvalue: 8,\r\n\t\t\t},\r\n\t\t\twant: []int{5, 2, 10, 6, 8, 7, 0, 9, 8},\r\n\t\t},\r\n\t}\r\n\tfor _, tt := range tests {\r\n\t\tt.Run(tt.name, func(t *testing.T) {\r\n\t\t\tgot := SetItem(tt.args.slice, tt.args.index, tt.args.value)\r\n\t\t\tif !slicesEqual(got, tt.want) {\r\n\t\t\t\tt.Errorf(\"SetItem(slice:%v, index:%v, value:%v) = %v, want %v\",\r\n\t\t\t\t\ttt.args.slice, tt.args.index, tt.args.value, got, tt.want)\r\n\t\t\t}\r\n\t\t\tif len(tt.args.slice) == len(got) {\r\n\t\t\t\tfor i := range got {\r\n\t\t\t\t\tgot[i] = -1\r\n\t\t\t\t}\r\n\t\t\t\tif reflect.ValueOf(got).Pointer() != reflect.ValueOf(tt.args.slice).Pointer() {\r\n\t\t\t\t\tt.Errorf(\"SetItem(slice:%v, index:%v) does not return the modified input slice)\", tt.args.slice,\r\n\t\t\t\t\t\ttt.args.value)\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t})\r\n\t}\r\n}\r\n\r\nfunc TestPrependItems(t *testing.T) {\r\n\ttype args struct {\r\n\t\tslice []int\r\n\t\tvalue []int\r\n\t}\r\n\ttests := []struct {\r\n\t\tname string\r\n\t\targs args\r\n\t\twant []int\r\n\t}{\r\n\t\t{\r\n\t\t\tname: \"Prepend one item\",\r\n\t\t\targs: args{\r\n\t\t\t\tslice: []int{5, 2, 10, 6, 8, 7, 0, 9},\r\n\t\t\t\tvalue: []int{1},\r\n\t\t\t},\r\n\t\t\twant: []int{1, 5, 2, 10, 6, 8, 7, 0, 9},\r\n\t\t},\r\n\t\t{\r\n\t\t\tname: \"Prepend two items\",\r\n\t\t\targs: args{\r\n\t\t\t\tslice: []int{5, 2, 10, 6, 8, 7, 0, 9},\r\n\t\t\t\tvalue: []int{0, 6},\r\n\t\t\t},\r\n\t\t\twant: []int{0, 6, 5, 2, 10, 6, 8, 7, 0, 9},\r\n\t\t},\r\n\t\t{\r\n\t\t\tname: \"prepend nil\",\r\n\t\t\targs: args{\r\n\t\t\t\tslice: []int{5, 2, 10, 6, 8, 7, 0, 9},\r\n\t\t\t\tvalue: nil,\r\n\t\t\t},\r\n\t\t\twant: []int{5, 2, 10, 6, 8, 7, 0, 9},\r\n\t\t},\r\n\t\t{\r\n\t\t\tname: \"prepend zero items\",\r\n\t\t\targs: args{\r\n\t\t\t\tslice: []int{5, 2, 10, 6, 8, 7, 0, 9},\r\n\t\t\t\tvalue: []int{},\r\n\t\t\t},\r\n\t\t\twant: []int{5, 2, 10, 6, 8, 7, 0, 9},\r\n\t\t},\r\n\t\t{\r\n\t\t\tname: \"Prepend slice to itself\",\r\n\t\t\targs: args{\r\n\t\t\t\tslice: []int{5, 2, 10, 6},\r\n\t\t\t\tvalue: []int{5, 2, 10, 6},\r\n\t\t\t},\r\n\t\t\twant: []int{5, 2, 10, 6, 5, 2, 10, 6},\r\n\t\t},\r\n\t}\r\n\tfor _, tt := range tests {\r\n\t\tt.Run(tt.name, func(t *testing.T) {\r\n\t\t\tgot := PrependItems(tt.args.slice, tt.args.value...)\r\n\t\t\tif !slicesEqual(got, tt.want) {\r\n\t\t\t\tt.Errorf(\"PrependItems(slice:%v, value:%v) = %v, want %v\",\r\n\t\t\t\t\ttt.args.slice, tt.args.value, got, tt.want)\r\n\t\t\t}\r\n\t\t})\r\n\t}\r\n}\r\n\r\nfunc TestRemoveItem(t *testing.T) {\r\n\ttype args struct {\r\n\t\tslice []int\r\n\t\tindex int\r\n\t}\r\n\ttests := []struct {\r\n\t\tname string\r\n\t\targs args\r\n\t\twant []int\r\n\t}{\r\n\t\t{\r\n\t\t\tname: \"Remove an item\",\r\n\t\t\targs: args{\r\n\t\t\t\tslice: []int{3, 4, 5, 6},\r\n\t\t\t\tindex: 1,\r\n\t\t\t},\r\n\t\t\twant: []int{3, 5, 6},\r\n\t\t},\r\n\t\t{\r\n\t\t\tname: \"Remove the first item\",\r\n\t\t\targs: args{\r\n\t\t\t\tslice: []int{3, 4, 5, 6},\r\n\t\t\t\tindex: 0,\r\n\t\t\t},\r\n\t\t\twant: []int{4, 5, 6},\r\n\t\t},\r\n\t\t{\r\n\t\t\tname: \"Remove the last item\",\r\n\t\t\targs: args{\r\n\t\t\t\tslice: []int{3, 4, 5, 6},\r\n\t\t\t\tindex: 3,\r\n\t\t\t},\r\n\t\t\twant: []int{3, 4, 5},\r\n\t\t},\r\n\t\t{\r\n\t\t\tname: \"Remove out of bounds index\",\r\n\t\t\targs: args{\r\n\t\t\t\tslice: []int{3, 4, 5, 6},\r\n\t\t\t\tindex: 7,\r\n\t\t\t},\r\n\t\t\twant: []int{3, 4, 5, 6},\r\n\t\t},\r\n\t\t{\r\n\t\t\tname: \"Remove negative index\",\r\n\t\t\targs: args{\r\n\t\t\t\tslice: []int{3, 4, 5, 6},\r\n\t\t\t\tindex: -7,\r\n\t\t\t},\r\n\t\t\twant: []int{3, 4, 5, 6},\r\n\t\t},\r\n\t}\r\n\tfor _, tt := range tests {\r\n\t\tt.Run(tt.name, func(t *testing.T) {\r\n\t\t\tif got := RemoveItem(copySlice(tt.args.slice), tt.args.index); !slicesEqual(got, tt.want) {\r\n\t\t\t\tt.Errorf(\"RemoveItem(slice:%v, index:%v) = %v, want %v\", tt.args.slice, tt.args.index, got, tt.want)\r\n\t\t\t}\r\n\t\t})\r\n\t}\r\n}\r\n\r\nfunc slicesEqual(a, b []int) bool {\r\n\tif len(a) != len(b) {\r\n\t\treturn false\r\n\t}\r\n\r\n\tif len(a) == 0 {\r\n\t\treturn true\r\n\t}\r\n\r\n\tsize := len(a)\r\n\tfor i := 0; i < size; i++ {\r\n\t\tif a[i] != b[i] {\r\n\t\t\treturn false\r\n\t\t}\r\n\t}\r\n\r\n\treturn true\r\n}\r\n\r\nfunc copySlice(s []int) []int {\r\n\tslice := make([]int, len(s))\r\n\tcopy(slice, s)\r\n\treturn slice\r\n}\r\n"
}