{
  "language": "go",
  "slug": "booking-up-for-beauty",
  "docs": {
    "introduction": "# Introduction\r\n\r\nA [`Time`][time] in Go is a type describing a moment in time. The date and time information can be accessed, compared, and manipulated through its methods, but there are also some functions called on the `time` package itself. The current date and time can be retrieved through the [`time.Now`][now] function.\r\n\r\nThe [`time.Parse`][parse] function parses strings into values of type `Time`. Go has a special way of how you define the layout you expect for the parsing. You need to write an example of the layout using the values from this special timestamp:\r\n`Mon Jan 2 15:04:05 -0700 MST 2006`.\r\n\r\nFor example:\r\n\r\n```go\r\nimport \"time\"\r\n\r\nfunc parseTime() time.Time {\r\n    date := \"Tue, 09/22/1995, 13:00\"\r\n    layout := \"Mon, 01/02/2006, 15:04\"\r\n\r\n    t, err := time.Parse(layout,date) // time.Time, error\r\n}\r\n\r\n// => 1995-09-22 13:00:00 +0000 UTC\r\n```\r\n\r\nThe [`Time.Format()`][format] method returns a string representation of time. Just as with the `Parse` function, the target layout is again defined via an example that uses the values from the special timestamp.\r\n\r\nFor Example:\r\n\r\n```go\r\nimport (\r\n    \"fmt\"\r\n    \"time\"\r\n)\r\n\r\nfunc main() {\r\n    t := time.Date(1995,time.September,22,13,0,0,0,time.UTC)\r\n    formattedTime := t.Format(\"Mon, 01/02/2006, 15:04\") // string\r\n    fmt.Println(formattedTime)\r\n}\r\n\r\n// => Fri, 09/22/1995, 13:00\r\n```\r\n\r\n## Layout Options\r\n\r\nFor a custom layout use combination of these options. In Go predefined date and timestamp [format constants][const] are also available.\r\n\r\n| Time        | Options                                        |\r\n| ----------- | ---------------------------------------------- |\r\n| Year        | 2006 ; 06                                      |\r\n| Month       | Jan ; January ; 01 ; 1                         |\r\n| Day         | 02 ; 2 ; \\_2 (For preceding 0)                 |\r\n| Weekday     | Mon ; Monday                                   |\r\n| Hour        | 15 ( 24 hour time format ) ; 3 ; 03 (AM or PM) |\r\n| Minute      | 04 ; 4                                         |\r\n| Second      | 05 ; 5                                         |\r\n| AM/PM Mark  | PM                                             |\r\n| Day of Year | 002 ; \\_\\_2                                    |\r\n\r\nThe `time.Time` type has various methods for accessing a particular time. e.g. Hour : [`Time.Hour()`][hour] , Month : [`Time.Month()`][month]. More on how this works can be found in [ official documentation][time].\r\n\r\nThe [`time`][time] includes another type, [`Duration`][duration], representing elapsed time, plus support for locations/time zones, timers, and other related functionality that will be covered in another concept.\r\n\r\n[time]: https://golang.org/pkg/time/#Time\r\n[now]: https://golang.org/pkg/time/#Now\r\n[const]: https://pkg.go.dev/time#pkg-constants\r\n[format]: https://pkg.go.dev/time#Time.Format\r\n[hour]: https://pkg.go.dev/time#Time.Hour\r\n[month]: https://pkg.go.dev/time/#Time.Month\r\n[duration]: https://pkg.go.dev/time#Duration\r\n[parse]: https://golang.org/pkg/time/#Parse\r\n[article]: https://www.pauladamsmith.com/blog/2011/05/go_time.html\r\n",
    "instructions": "# Instructions\r\n\r\nIn this exercise you'll be working on an appointment scheduler for a beauty salon that opened on September 15th in 2012.\r\n\r\nYou have five tasks, which will all involve appointment dates.\r\n\r\n## 1. Parse appointment date\r\n\r\nImplement the `Schedule` function to parse a textual representation of an appointment date into the corresponding `time.Time` format:\r\n\r\n```go\r\nSchedule(\"7/25/2019 13:45:00\")\r\n// => 2019-07-25 13:45:00 +0000 UTC\r\n```\r\n\r\n## 2. Check if an appointment has already passed\r\n\r\nImplement the `HasPassed` function that takes an appointment date and checks if the appointment was somewhere in the past:\r\n\r\n```go\r\nHasPassed(\"July 25, 2019 13:45:00\")\r\n// => true\r\n```\r\n\r\n## 3. Check if appointment is in the afternoon\r\n\r\nImplement the `IsAfternoonAppointment` function that takes an appointment date and checks if the appointment is in the afternoon (>= 12:00 and < 18:00):\r\n\r\n```go\r\nIsAfternoonAppointment(\"Thursday, July 25, 2019 13:45:00\")\r\n// => true\r\n```\r\n\r\n## 4. Describe the time and date of the appointment\r\n\r\nImplement the `Description` function that takes an appointment date and returns a description of that date and time:\r\n\r\n```go\r\nDescription(\"7/25/2019 13:45:00\")\r\n// => \"You have an appointment on Thursday, July 25, 2019, at 13:45.\"\r\n```\r\n\r\n## 5. Return the anniversary date of the salon's opening\r\n\r\nImplement the `AnniversaryDate` function that returns the anniversary date of the salon's opening for the current year in UTC.\r\n\r\nAssuming the current year is 2020:\r\n\r\n```go\r\nAnniversaryDate()\r\n\r\n// => 2020-09-15 00:00:00 +0000 UTC\r\n```\r\n\r\n**Note:** the return value is a `time.Time` and the time of day doesn't matter.\r\n",
    "hints": "# Hints\r\n\r\n## General\r\n\r\n- [Use the methods found in the time package.][time]\r\n\r\n## 1. Parse appointment date\r\n\r\n- There is a [method][time.parse] for parsing a `string` into a `Time`.\r\n- Additional information for formatting parts of a date can be found in the constants section of the [time package documentation][time-package-constants].\r\n\r\n## 2. Check if an appointment has already passed\r\n\r\n- There are [methods][before] for [comparing][after] `Times` and [getting][now] the current date and time.\r\n\r\n## 3. Check if appointment is in the afternoon\r\n\r\n- There is a [method][hour] for getting the hour of a `Time`.\r\n\r\n## 4. Describe the time and date of the appointment\r\n\r\n- Convert the given string to a `Time` then format the answer string accordingly, using the appropriate [methods][time] to extract the needed constituents.\r\n\r\n## 5. Return the anniversary date of the salon's opening\r\n\r\n- Create a `Time` of the anniversary date of the salon's opening for the current year.\r\n\r\n[time]: https://golang.org/pkg/time/#pkg-index\r\n[time.parse]: https://golang.org/pkg/time/#Parse\r\n[before]: https://golang.org/pkg/time/#Time.Before\r\n[after]: https://golang.org/pkg/time/#Time.After\r\n[now]: https://golang.org/pkg/time/#Now\r\n[hour]: https://golang.org/pkg/time/#Time.Hour\r\n[time-package-constants]: https://pkg.go.dev/time#pkg-constants\r\n"
  },
  "starter_code": "package booking\r\n\r\nimport \"time\"\r\n\r\n// Schedule returns a time.Time from a string containing a date.\r\nfunc Schedule(date string) time.Time {\r\n\tpanic(\"Please implement the Schedule function\")\r\n}\r\n\r\n// HasPassed returns whether a date has passed.\r\nfunc HasPassed(date string) bool {\r\n\tpanic(\"Please implement the HasPassed function\")\r\n}\r\n\r\n// IsAfternoonAppointment returns whether a time is in the afternoon.\r\nfunc IsAfternoonAppointment(date string) bool {\r\n\tpanic(\"Please implement the IsAfternoonAppointment function\")\r\n}\r\n\r\n// Description returns a formatted string of the appointment time.\r\nfunc Description(date string) string {\r\n\tpanic(\"Please implement the Description function\")\r\n}\r\n\r\n// AnniversaryDate returns a Time with this year's anniversary.\r\nfunc AnniversaryDate() time.Time {\r\n\tpanic(\"Please implement the AnniversaryDate function\")\r\n}\r\n",
  "tests": "package booking\r\n\r\nimport (\r\n\t\"testing\"\r\n\t\"time\"\r\n)\r\n\r\nfunc TestSchedule(t *testing.T) {\r\n\ttests := map[string]struct {\r\n\t\tin   string\r\n\t\twant time.Time\r\n\t}{\r\n\t\t\"Schedule 1\": {in: \"7/13/2020 20:32:00\", want: time.Date(2020, time.July, 13, 20, 32, 0, 0, time.UTC)},\r\n\t\t\"Schedule 2\": {in: \"11/28/1984 2:02:02\", want: time.Date(1984, time.November, 28, 2, 2, 2, 0, time.UTC)},\r\n\t\t\"Schedule 3\": {in: \"2/29/2112 11:59:59\", want: time.Date(2112, time.February, 29, 11, 59, 59, 0, time.UTC)},\r\n\t}\r\n\tfor name, tc := range tests {\r\n\t\tt.Run(name, func(t *testing.T) {\r\n\t\t\tif got := Schedule(tc.in); !got.Equal(tc.want) {\r\n\t\t\t\tt.Errorf(\"Schedule(%s) = '%v', want '%v'\", tc.in, got, tc.want)\r\n\t\t\t}\r\n\t\t})\r\n\t}\r\n}\r\n\r\nfunc TestHasPassed(t *testing.T) {\r\n\ttests := map[string]struct {\r\n\t\tin   string\r\n\t\twant bool\r\n\t}{\r\n\t\t\"HasPassed 1\": {in: \"October 3, 2019 20:32:00\", want: true},\r\n\t\t\"HasPassed 2\": {in: \"January 28, 1974 2:02:02\", want: true},\r\n\t\t\"HasPassed 3\": {in: \"December 9, 2112 11:59:59\", want: false},\r\n\t}\r\n\tfor name, tc := range tests {\r\n\t\tt.Run(name, func(t *testing.T) {\r\n\t\t\tif got := HasPassed(tc.in); got != tc.want {\r\n\t\t\t\tt.Errorf(\"HasPassed(%s) = '%v', want '%v'\", tc.in, got, tc.want)\r\n\t\t\t}\r\n\t\t})\r\n\t}\r\n}\r\n\r\nfunc TestIsAfternoonAppointment(t *testing.T) {\r\n\ttests := map[string]struct {\r\n\t\tin   string\r\n\t\twant bool\r\n\t}{\r\n\t\t\"IsAfternoonAppointment 1\": {in: \"Thursday, May 13, 2010 20:32:00\", want: false},\r\n\t\t\"IsAfternoonAppointment 2\": {in: \"Friday, March 8, 1974 12:02:02\", want: true},\r\n\t\t\"IsAfternoonAppointment 3\": {in: \"Friday, September 9, 2112 11:59:59\", want: false},\r\n\t}\r\n\tfor name, tc := range tests {\r\n\t\tt.Run(name, func(t *testing.T) {\r\n\t\t\tif got := IsAfternoonAppointment(tc.in); got != tc.want {\r\n\t\t\t\tt.Errorf(\"IsAfternoonAppointment(%s) = '%v', want '%v'\", tc.in, got, tc.want)\r\n\t\t\t}\r\n\t\t})\r\n\t}\r\n}\r\n\r\nfunc TestDescription(t *testing.T) {\r\n\ttests := map[string]struct {\r\n\t\tin, want string\r\n\t}{\r\n\t\t\"Description 1\": {in: \"6/6/2005 10:30:00\", want: \"You have an appointment on Monday, June 6, 2005, at 10:30.\"},\r\n\t\t\"Description 2\": {in: \"9/19/1994 12:15:00\", want: \"You have an appointment on Monday, September 19, 1994, at 12:15.\"},\r\n\t\t\"Description 3\": {in: \"4/4/2012 16:45:00\", want: \"You have an appointment on Wednesday, April 4, 2012, at 16:45.\"},\r\n\t}\r\n\tfor name, tc := range tests {\r\n\t\tt.Run(name, func(t *testing.T) {\r\n\t\t\tif got := Description(tc.in); got != tc.want {\r\n\t\t\t\tt.Errorf(\"Description(%s) = '%v', want '%v'\", tc.in, got, tc.want)\r\n\t\t\t}\r\n\t\t})\r\n\t}\r\n}\r\n\r\nfunc TestAnniversaryDate(t *testing.T) {\r\n\ttests := map[string]struct {\r\n\t\tin   string\r\n\t\twant time.Time\r\n\t}{\r\n\t\t\"AnniversaryDate 1\": {want: time.Date(time.Now().Year(), time.September, 15, 0, 0, 0, 0, time.UTC)},\r\n\t}\r\n\tfor name, tc := range tests {\r\n\t\tt.Run(name, func(t *testing.T) {\r\n\t\t\tif got := AnniversaryDate(); !got.Equal(tc.want) {\r\n\t\t\t\tt.Errorf(\"AnniversaryDate(%s) = '%v', want '%v'\", tc.in, got, tc.want)\r\n\t\t\t}\r\n\t\t})\r\n\t}\r\n}\r\n"
}