{
  "language": "go",
  "type": "practice",
  "slug": "pov",
  "title": "Pov",
  "docs": {
    "instructions": "# Instructions\r\n\r\nReparent a tree on a selected node.\r\n\r\nA [tree][wiki-tree] is a special type of [graph][wiki-graph] where all nodes are connected but there are no cycles.\r\nThat means, there is exactly one path to get from one node to another for any pair of nodes.\r\n\r\nThis exercise is all about re-orientating a tree to see things from a different point of view.\r\nFor example family trees are usually presented from the ancestor's perspective:\r\n\r\n```text\r\n    +------0------+\r\n    |      |      |\r\n  +-1-+  +-2-+  +-3-+\r\n  |   |  |   |  |   |\r\n  4   5  6   7  8   9\r\n```\r\n\r\nBut there is no inherent direction in a tree.\r\nThe same information can be presented from the perspective of any other node in the tree, by pulling it up to the root and dragging its relationships along with it.\r\nSo the same tree from 6's perspective would look like:\r\n\r\n```text\r\n        6\r\n        |\r\n  +-----2-----+\r\n  |           |\r\n  7     +-----0-----+\r\n        |           |\r\n      +-1-+       +-3-+\r\n      |   |       |   |\r\n      4   5       8   9\r\n```\r\n\r\nThis lets us more simply describe the paths between two nodes.\r\nSo for example the path from 6-9 (which in the first tree goes up to the root and then down to a different leaf node) can be seen to follow the path 6-2-0-3-9.\r\n\r\nThis exercise involves taking an input tree and re-orientating it from the point of view of one of the nodes.\r\n\r\n[wiki-graph]: https://en.wikipedia.org/wiki/Tree_(graph_theory)\r\n[wiki-tree]: https://en.wikipedia.org/wiki/Graph_(discrete_mathematics)\r\n",
    "hints": ""
  },
  "starter_code": "package pov\r\n\r\ntype Tree struct {\r\n\t// Add the needed fields here\r\n}\r\n\r\n// New creates and returns a new Tree with the given root value and children.\r\nfunc New(value string, children ...*Tree) *Tree {\r\n\tpanic(\"Please implement this function\")\r\n}\r\n\r\n// Value returns the value at the root of a tree.\r\nfunc (tr *Tree) Value() string {\r\n\tpanic(\"Please implement this function\")\r\n}\r\n\r\n// Children returns a slice containing the children of a tree.\r\n// There is no need to sort the elements in the result slice,\r\n// they can be in any order.\r\nfunc (tr *Tree) Children() []*Tree {\r\n\tpanic(\"Please implement this function\")\r\n}\r\n\r\n// String describes a tree in a compact S-expression format.\r\n// This helps to make test outputs more readable.\r\n// Feel free to adapt this method as you see fit.\r\nfunc (tr *Tree) String() string {\r\n\tif tr == nil {\r\n\t\treturn \"nil\"\r\n\t}\r\n\tresult := tr.Value()\r\n\tif len(tr.Children()) == 0 {\r\n\t\treturn result\r\n\t}\r\n\tfor _, ch := range tr.Children() {\r\n\t\tresult += \" \" + ch.String()\r\n\t}\r\n\treturn \"(\" + result + \")\"\r\n}\r\n\r\n// POV problem-specific functions\r\n\r\n// FromPov returns the pov from the node specified in the argument.\r\nfunc (tr *Tree) FromPov(from string) *Tree {\r\n\tpanic(\"Please implement this function\")\r\n}\r\n\r\n// PathTo returns the shortest path between two nodes in the tree.\r\nfunc (tr *Tree) PathTo(from, to string) []string {\r\n\tpanic(\"Please implement this function\")\r\n}\r\n",
  "tests": "package pov\r\n\r\nimport (\r\n\t\"sort\"\r\n\t\"testing\"\r\n)\r\n\r\nfunc TestNewNotNil(t *testing.T) {\r\n\ttests := []struct {\r\n\t\tname string\r\n\t\ttree *Tree\r\n\t}{\r\n\t\t{\r\n\t\t\tname: \"singleton\",\r\n\t\t\ttree: New(\"x\"),\r\n\t\t},\r\n\t\t{\r\n\t\t\tname: \"parent and one sibling\",\r\n\t\t\ttree: New(\"parent\", New(\"x\"), New(\"sibling\")),\r\n\t\t},\r\n\t\t{\r\n\t\t\tname: \"parent and kids\",\r\n\t\t\ttree: New(\"parent\", New(\"x\", New(\"kid-0\"), New(\"kid-1\"))),\r\n\t\t},\r\n\t}\r\n\tfor _, tt := range tests {\r\n\t\tt.Run(tt.name, func(t *testing.T) {\r\n\t\t\tif tt.tree == nil {\r\n\t\t\t\tt.Fatalf(\"tree should not be nil\")\r\n\t\t\t}\r\n\t\t})\r\n\t}\r\n}\r\n\r\nfunc TestValue(t *testing.T) {\r\n\ttests := []struct {\r\n\t\tname     string\r\n\t\troot     string\r\n\t\tchildren []*Tree\r\n\t}{\r\n\t\t{\r\n\t\t\tname:     \"singleton\",\r\n\t\t\troot:     \"x\",\r\n\t\t\tchildren: nil,\r\n\t\t},\r\n\t\t{\r\n\t\t\tname:     \"parent and one sibling\",\r\n\t\t\troot:     \"parent\",\r\n\t\t\tchildren: []*Tree{New(\"x\"), New(\"sibling\")},\r\n\t\t},\r\n\t\t{\r\n\t\t\tname:     \"parent and kids\",\r\n\t\t\troot:     \"parent\",\r\n\t\t\tchildren: []*Tree{New(\"x\", New(\"kid-0\"), New(\"kid-1\"))},\r\n\t\t},\r\n\t}\r\n\r\n\tfor _, tt := range tests {\r\n\t\tt.Run(tt.name, func(t *testing.T) {\r\n\t\t\ttree := New(tt.root, tt.children...)\r\n\t\t\tgot := tree.Value()\r\n\t\t\twant := tt.root\r\n\t\t\tif want != got {\r\n\t\t\t\tt.Fatalf(\"expected: %v, got: %v\", want, got)\r\n\t\t\t}\r\n\t\t})\r\n\t}\r\n}\r\n\r\nfunc TestChildren(t *testing.T) {\r\n\ttests := []struct {\r\n\t\tname     string\r\n\t\troot     string\r\n\t\tchildren []*Tree\r\n\t}{\r\n\t\t{\r\n\t\t\tname:     \"singleton\",\r\n\t\t\troot:     \"x\",\r\n\t\t\tchildren: nil,\r\n\t\t},\r\n\t\t{\r\n\t\t\tname:     \"parent and one sibling\",\r\n\t\t\troot:     \"parent\",\r\n\t\t\tchildren: []*Tree{New(\"x\"), New(\"sibling\")},\r\n\t\t},\r\n\t\t{\r\n\t\t\tname:     \"parent and kids\",\r\n\t\t\troot:     \"parent\",\r\n\t\t\tchildren: []*Tree{New(\"x\", New(\"kid-0\"), New(\"kid-1\"))},\r\n\t\t},\r\n\t}\r\n\r\n\tfor _, tt := range tests {\r\n\t\tt.Run(tt.name, func(t *testing.T) {\r\n\t\t\ttree := New(tt.root, tt.children...)\r\n\t\t\tgot := tree.Children()\r\n\t\t\twant := tt.children\r\n\t\t\tif !treeSliceEqual(want, got) {\r\n\t\t\t\tt.Fatalf(\"expected: %v, got: %v\", want, got)\r\n\t\t\t}\r\n\t\t})\r\n\t}\r\n}\r\n\r\nfunc TestFromPov(t *testing.T) {\r\n\ttests := []struct {\r\n\t\tdescription string\r\n\t\ttree        *Tree\r\n\t\tfrom        string\r\n\t\texpected    *Tree\r\n\t}{\r\n\t\t{\r\n\t\t\tdescription: \"Results in the same tree if the input tree is a singleton\",\r\n\t\t\ttree:        New(\"x\"),\r\n\t\t\tfrom:        \"x\",\r\n\t\t\texpected:    New(\"x\"),\r\n\t\t},\r\n\t\t{\r\n\t\t\tdescription: \"Can reroot a tree with a parent and one sibling\",\r\n\t\t\ttree:        New(\"parent\", New(\"x\"), New(\"sibling\")),\r\n\t\t\tfrom:        \"x\",\r\n\t\t\texpected:    New(\"x\", New(\"parent\", New(\"sibling\"))),\r\n\t\t},\r\n\t\t{\r\n\t\t\tdescription: \"Can reroot a tree with a parent and many siblings\",\r\n\t\t\ttree:        New(\"parent\", New(\"a\"), New(\"x\"), New(\"b\"), New(\"c\")),\r\n\t\t\tfrom:        \"x\",\r\n\t\t\texpected:    New(\"x\", New(\"parent\", New(\"a\"), New(\"b\"), New(\"c\"))),\r\n\t\t},\r\n\t\t{\r\n\t\t\tdescription: \"Can reroot a tree with new root deeply nested in tree\",\r\n\t\t\ttree:        New(\"level-0\", New(\"level-1\", New(\"level-2\", New(\"level-3\", New(\"x\"))))),\r\n\t\t\tfrom:        \"x\",\r\n\t\t\texpected:    New(\"x\", New(\"level-3\", New(\"level-2\", New(\"level-1\", New(\"level-0\"))))),\r\n\t\t},\r\n\t\t{\r\n\t\t\tdescription: \"Moves children of the new root to same level as former parent\",\r\n\t\t\ttree:        New(\"parent\", New(\"x\", New(\"kid-0\"), New(\"kid-1\"))),\r\n\t\t\tfrom:        \"x\",\r\n\t\t\texpected:    New(\"x\", New(\"kid-0\"), New(\"kid-1\"), New(\"parent\")),\r\n\t\t},\r\n\t\t{\r\n\t\t\tdescription: \"Can reroot a complex tree with cousins\",\r\n\t\t\ttree: New(\"grandparent\", New(\"parent\",\r\n\t\t\t\tNew(\"x\", New(\"kid-0\"), New(\"kid-1\")), New(\"sibling-0\"),\r\n\t\t\t\tNew(\"sibling-1\")), New(\"uncle\", New(\"cousin-0\"), New(\"cousin-1\"))),\r\n\t\t\tfrom: \"x\",\r\n\t\t\texpected: New(\"x\", New(\"kid-0\"), New(\"kid-1\"),\r\n\t\t\t\tNew(\"parent\", New(\"sibling-0\"), New(\"sibling-1\"),\r\n\t\t\t\t\tNew(\"grandparent\", New(\"uncle\", New(\"cousin-0\"), New(\"cousin-1\"))))),\r\n\t\t},\r\n\t\t{\r\n\t\t\tdescription: \"Errors if target does not exist in a singleton tree\",\r\n\t\t\ttree:        New(\"x\"),\r\n\t\t\tfrom:        \"nonexistent\",\r\n\t\t\texpected:    nil,\r\n\t\t},\r\n\t\t{\r\n\t\t\tdescription: \"Errors if target does not exist in a large tree\",\r\n\t\t\ttree: New(\"parent\",\r\n\t\t\t\tNew(\"x\", New(\"kid-0\"), New(\"kid-1\")), New(\"sibling-0\"), New(\"sibling-1\")),\r\n\t\t\tfrom:     \"nonexistent\",\r\n\t\t\texpected: nil,\r\n\t\t},\r\n\t}\r\n\tfor _, tt := range tests {\r\n\t\tt.Run(tt.description, func(t *testing.T) {\r\n\t\t\tgot := tt.tree.FromPov(tt.from)\r\n\t\t\twant := tt.expected\r\n\t\t\tif !treeEqual(want, got) {\r\n\t\t\t\tt.Fatalf(\"expected: %v, got: %v\", want, got)\r\n\t\t\t}\r\n\t\t})\r\n\t}\r\n}\r\n\r\nfunc TestPathTo(t *testing.T) {\r\n\ttests := []struct {\r\n\t\tdescription string\r\n\t\ttree        *Tree\r\n\t\tfrom        string\r\n\t\tto          string\r\n\t\texpected    []string\r\n\t}{\r\n\t\t{\r\n\t\t\tdescription: \"Can find path to parent\",\r\n\t\t\ttree:        New(\"parent\", New(\"x\"), New(\"sibling\")),\r\n\t\t\tfrom:        \"x\",\r\n\t\t\tto:          \"parent\",\r\n\t\t\texpected:    []string{\"x\", \"parent\"},\r\n\t\t},\r\n\t\t{\r\n\t\t\tdescription: \"Can find path to sibling\",\r\n\t\t\ttree:        New(\"parent\", New(\"a\"), New(\"x\"), New(\"b\"), New(\"c\")),\r\n\t\t\tfrom:        \"x\",\r\n\t\t\tto:          \"b\",\r\n\t\t\texpected:    []string{\"x\", \"parent\", \"b\"},\r\n\t\t},\r\n\t\t{\r\n\t\t\tdescription: \"Can find path to cousin\",\r\n\t\t\ttree: New(\"grandparent\", New(\"parent\",\r\n\t\t\t\tNew(\"x\", New(\"kid-0\"), New(\"kid-1\")), New(\"sibling-0\"),\r\n\t\t\t\tNew(\"sibling-1\")), New(\"uncle\", New(\"cousin-0\"), New(\"cousin-1\"))),\r\n\t\t\tfrom:     \"x\",\r\n\t\t\tto:       \"cousin-1\",\r\n\t\t\texpected: []string{\"x\", \"parent\", \"grandparent\", \"uncle\", \"cousin-1\"},\r\n\t\t},\r\n\t\t{\r\n\t\t\tdescription: \"Can find path not involving root\",\r\n\t\t\ttree:        New(\"grandparent\", New(\"parent\", New(\"x\"), New(\"sibling-0\"), New(\"sibling-1\"))),\r\n\t\t\tfrom:        \"x\",\r\n\t\t\tto:          \"sibling-1\",\r\n\t\t\texpected:    []string{\"x\", \"parent\", \"sibling-1\"},\r\n\t\t},\r\n\t\t{\r\n\t\t\tdescription: \"Can find path from nodes other than x\",\r\n\t\t\ttree:        New(\"parent\", New(\"a\"), New(\"x\"), New(\"b\"), New(\"c\")),\r\n\t\t\tfrom:        \"a\",\r\n\t\t\tto:          \"c\",\r\n\t\t\texpected:    []string{\"a\", \"parent\", \"c\"},\r\n\t\t},\r\n\t\t{\r\n\t\t\tdescription: \"Errors if destination does not exist\",\r\n\t\t\ttree:        New(\"parent\", New(\"x\", New(\"kid-0\"), New(\"kid-1\")), New(\"sibling-0\"), New(\"sibling-1\")),\r\n\t\t\tfrom:        \"x\",\r\n\t\t\tto:          \"nonexistent\",\r\n\t\t\texpected:    nil,\r\n\t\t},\r\n\t\t{\r\n\t\t\tdescription: \"Errors if source does not exist\",\r\n\t\t\ttree:        New(\"parent\", New(\"x\", New(\"kid-0\"), New(\"kid-1\")), New(\"sibling-0\"), New(\"sibling-1\")),\r\n\t\t\tfrom:        \"nonexistent\",\r\n\t\t\tto:          \"x\",\r\n\t\t\texpected:    nil,\r\n\t\t},\r\n\t}\r\n\tfor _, tt := range tests {\r\n\t\tt.Run(tt.description, func(t *testing.T) {\r\n\t\t\tgot := tt.tree.PathTo(tt.from, tt.to)\r\n\t\t\twant := tt.expected\r\n\t\t\tif !stringSliceEqual(want, got) {\r\n\t\t\t\tt.Fatalf(\"expected: %v, got: %v\", want, got)\r\n\t\t\t}\r\n\t\t})\r\n\t}\r\n}\r\n\r\nvar benchmarkResultPov *Tree\r\n\r\nfunc BenchmarkFromPov(b *testing.B) {\r\n\tif testing.Short() {\r\n\t\tb.Skip(\"skipping benchmark in short mode.\")\r\n\t}\r\n\tvar result *Tree\r\n\tb.ResetTimer()\r\n\tfor i := 0; i < b.N; i++ {\r\n\t\ttree := New(\"grandparent\", New(\"parent\",\r\n\t\t\tNew(\"x\", New(\"kid-0\"), New(\"kid-1\")), New(\"sibling-0\"),\r\n\t\t\tNew(\"sibling-1\")), New(\"uncle\", New(\"cousin-0\"), New(\"cousin-1\")))\r\n\t\tfrom := \"x\"\r\n\t\tresult = tree.FromPov(from)\r\n\t}\r\n\tbenchmarkResultPov = result\r\n}\r\n\r\nvar benchmarkResultPathTo []string\r\n\r\nfunc BenchmarkPathTo(b *testing.B) {\r\n\tif testing.Short() {\r\n\t\tb.Skip(\"skipping benchmark in short mode.\")\r\n\t}\r\n\tvar result []string\r\n\tb.ResetTimer()\r\n\tfor i := 0; i < b.N; i++ {\r\n\t\ttree := New(\"grandparent\", New(\"parent\",\r\n\t\t\tNew(\"x\", New(\"kid-0\"), New(\"kid-1\")), New(\"sibling-0\"),\r\n\t\t\tNew(\"sibling-1\")), New(\"uncle\", New(\"cousin-0\"), New(\"cousin-1\")))\r\n\t\tfrom := \"x\"\r\n\t\tto := \"cousin-1\"\r\n\t\tresult = tree.PathTo(from, to)\r\n\t}\r\n\tbenchmarkResultPathTo = result\r\n}\r\n\r\nfunc treeEqual(tr1, tr2 *Tree) bool {\r\n\tswitch {\r\n\tcase tr1 == nil && tr2 == nil:\r\n\t\treturn true\r\n\tcase tr1 == nil && tr2 != nil:\r\n\t\treturn false\r\n\tcase tr1 != nil && tr2 == nil:\r\n\t\treturn false\r\n\tdefault:\r\n\t\treturn tr1.Value() == tr2.Value() && treeSliceEqual(tr1.Children(), tr2.Children())\r\n\t}\r\n}\r\n\r\nfunc treeSliceEqual(trs1, trs2 []*Tree) bool {\r\n\t// allows permutation of children\r\n\tif len(trs1) != len(trs2) {\r\n\t\treturn false\r\n\t}\r\n\tif len(trs1) == 0 && len(trs2) == 0 {\r\n\t\treturn true\r\n\t}\r\n\tsortByValue := func(xs []*Tree) func(int, int) bool {\r\n\t\treturn func(i, j int) bool {\r\n\t\t\treturn xs[i].Value() < xs[j].Value()\r\n\t\t}\r\n\t}\r\n\tsort.Slice(trs1, sortByValue(trs1))\r\n\tsort.Slice(trs2, sortByValue(trs2))\r\n\tfor i := range trs1 {\r\n\t\tif !treeEqual(trs1[i], trs2[i]) {\r\n\t\t\treturn false\r\n\t\t}\r\n\t}\r\n\treturn true\r\n}\r\n\r\nfunc stringSliceEqual(a, b []string) bool {\r\n\tif len(a) != len(b) {\r\n\t\treturn false\r\n\t}\r\n\tif len(a) == 0 {\r\n\t\treturn true\r\n\t}\r\n\tfor i := 0; i < len(a); i++ {\r\n\t\tif a[i] != b[i] {\r\n\t\t\treturn false\r\n\t\t}\r\n\t}\r\n\treturn true\r\n}\r\n"
}