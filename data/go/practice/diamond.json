{
  "language": "go",
  "type": "practice",
  "slug": "diamond",
  "title": "Diamond",
  "docs": {
    "instructions": "# Instructions\r\n\r\nThe diamond kata takes as its input a letter, and outputs it in a diamond shape.\r\nGiven a letter, it prints a diamond starting with 'A', with the supplied letter at the widest point.\r\n\r\n## Requirements\r\n\r\n- The first row contains one 'A'.\r\n- The last row contains one 'A'.\r\n- All rows, except the first and last, have exactly two identical letters.\r\n- All rows have as many trailing spaces as leading spaces. (This might be 0).\r\n- The diamond is horizontally symmetric.\r\n- The diamond is vertically symmetric.\r\n- The diamond has a square shape (width equals height).\r\n- The letters form a diamond shape.\r\n- The top half has the letters in ascending order.\r\n- The bottom half has the letters in descending order.\r\n- The four corners (containing the spaces) are triangles.\r\n\r\n## Examples\r\n\r\nIn the following examples, spaces are indicated by `·` characters.\r\n\r\nDiamond for letter 'A':\r\n\r\n```text\r\nA\r\n```\r\n\r\nDiamond for letter 'C':\r\n\r\n```text\r\n··A··\r\n·B·B·\r\nC···C\r\n·B·B·\r\n··A··\r\n```\r\n\r\nDiamond for letter 'E':\r\n\r\n```text\r\n····A····\r\n···B·B···\r\n··C···C··\r\n·D·····D·\r\nE·······E\r\n·D·····D·\r\n··C···C··\r\n···B·B···\r\n····A····\r\n```\r\n",
    "hints": ""
  },
  "starter_code": "package diamond\r\n\r\nfunc Gen(char byte) (string, error) {\r\n\tpanic(\"Please implement the Gen function\")\r\n}\r\n",
  "tests": "//nolint:gosec // In the context of this exercise, it is fine to use math.Rand instead of crypto.Rand.\r\npackage diamond\r\n\r\nimport (\r\n\t\"fmt\"\r\n\t\"math/rand\"\r\n\t\"reflect\"\r\n\t\"strings\"\r\n\t\"testing\"\r\n\t\"testing/quick\"\r\n\t\"time\"\r\n)\r\n\r\nvar config = &quick.Config{Rand: rand.New(rand.NewSource(time.Now().UnixNano()))}\r\n\r\ntype correctChar byte\r\n\r\nfunc (c correctChar) Generate(r *rand.Rand, _ int) reflect.Value {\r\n\treturn reflect.ValueOf(correctChar('A' + r.Intn('Z'-'A'+1)))\r\n}\r\n\r\nfunc checkCorrect(requirement func(byte, []string) bool, keepSeparator bool, t *testing.T) {\r\n\tassertion := func(char correctChar) bool {\r\n\t\td, err := Gen(byte(char))\r\n\t\tif err != nil {\r\n\t\t\treturn false\r\n\t\t}\r\n\t\tseparator := strings.Split\r\n\t\tif keepSeparator {\r\n\t\t\tseparator = strings.SplitAfter\r\n\t\t}\r\n\t\trows := separator(d, \"\\n\")\r\n\r\n\t\treturn requirement(byte(char), rows)\r\n\t}\r\n\tif err := quick.Check(assertion, config); err != nil {\r\n\t\tt.Error(err)\r\n\t}\r\n}\r\n\r\nfunc TestDiamond(t *testing.T) {\r\n\tfor _, testCase := range testCases {\r\n\t\tt.Run(testCase.description, func(t *testing.T) {\r\n\t\t\texpected := strings.Join(testCase.expected, \"\\n\")\r\n\t\t\tgot, err := Gen(testCase.input[0])\r\n\r\n\t\t\tif err != testCase.expectedError {\r\n\t\t\t\tt.Fatalf(\"Gen(%q)\\nExpected:%v\\nGot:%v\", testCase.input, testCase.expectedError, err)\r\n\t\t\t}\r\n\t\t\tif got != expected {\r\n\t\t\t\tif got == fmt.Sprintf(\"%s\\n\", expected) {\r\n\t\t\t\t\tt.Fatalf(\"Gen(%q): no \\\\n expected after last line\", testCase.input)\r\n\t\t\t\t}\r\n\t\t\t\tt.Fatalf(\"Gen(%q)\\nExpected:\\n%s\\n(len=%d)\\nGot:\\n%s\\n(len=%d)\", testCase.input, expected, len(expected), got, len(got))\r\n\t\t\t}\r\n\t\t})\r\n\t}\r\n}\r\n\r\nfunc TestFirstRowContainsOneA(t *testing.T) {\r\n\trequirement := func(char byte, rows []string) bool {\r\n\t\treturn len(rows) > 0 && strings.Count(rows[0], \"A\") == 1\r\n\t}\r\n\tcheckCorrect(requirement, false, t)\r\n}\r\n\r\nfunc TestLastRowContainsOneA(t *testing.T) {\r\n\trequirement := func(char byte, rows []string) bool {\r\n\t\treturn len(rows) > 0 && strings.Count(rows[len(rows)-1], \"A\") == 1\r\n\t}\r\n\tcheckCorrect(requirement, false, t)\r\n}\r\n\r\nfunc TestAllRowsIdenticalLettersExceptFirstAndLast(t *testing.T) {\r\n\trequirement := func(char byte, rows []string) bool {\r\n\t\tfor i, row := range rows {\r\n\t\t\tr := strings.TrimSpace(row)\r\n\t\t\tif r[0] != r[len(r)-1] {\r\n\t\t\t\treturn false\r\n\t\t\t}\r\n\t\t\tif len(r) < 2 && i != 0 && i != len(rows)-1 {\r\n\t\t\t\treturn false\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn true\r\n\t}\r\n\tcheckCorrect(requirement, false, t)\r\n}\r\n\r\nfunc TestAllRowsHaveSameTrailingSpaces(t *testing.T) {\r\n\trequirement := func(char byte, rows []string) bool {\r\n\t\tfor _, row := range rows {\r\n\t\t\tif row == \"\" {\r\n\t\t\t\treturn false\r\n\t\t\t}\r\n\t\t\tfor i, j := 0, len(row)-1; i < j && row[i] == ' '; i, j = i+1, j-1 {\r\n\t\t\t\tif row[j] != ' ' {\r\n\t\t\t\t\treturn false\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn true\r\n\t}\r\n\tcheckCorrect(requirement, false, t)\r\n}\r\n\r\nfunc TestDiamondIsHorizontallySymmetric(t *testing.T) {\r\n\trequirement := func(char byte, rows []string) bool {\r\n\t\tfor _, row := range rows {\r\n\t\t\tl := len(row)\r\n\t\t\tfor i := l/2 - 1; i >= 0; i-- {\r\n\t\t\t\tif row[i] != row[l-1-i] {\r\n\t\t\t\t\treturn false\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn true\r\n\t}\r\n\tcheckCorrect(requirement, false, t)\r\n}\r\n\r\nfunc TestDiamondIsVerticallySymmetric(t *testing.T) {\r\n\trequirement := func(char byte, rows []string) bool {\r\n\t\tfor i, j := 0, len(rows)-1; i < j; i, j = i+1, j-1 {\r\n\t\t\t// strings.TrimSuffix to ignore new lines\r\n\t\t\tif strings.TrimSuffix(rows[i], \"\\n\") != strings.TrimSuffix(rows[j], \"\\n\") {\r\n\t\t\t\treturn false\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn true\r\n\t}\r\n\tcheckCorrect(requirement, true, t)\r\n}\r\n\r\nfunc TestDiamondIsSquare(t *testing.T) {\r\n\trequirement := func(char byte, rows []string) bool {\r\n\t\tif int(char-'A')*2+1 != len(rows) {\r\n\t\t\treturn false\r\n\t\t}\r\n\t\tfor _, row := range rows {\r\n\t\t\tif len(row) != len(rows) {\r\n\t\t\t\treturn false\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn true\r\n\t}\r\n\tcheckCorrect(requirement, false, t)\r\n}\r\n\r\nfunc TestDiamondHasItsShape(t *testing.T) {\r\n\trequirement := func(char byte, rows []string) bool {\r\n\t\tvar n int\r\n\t\tfor i, row := range rows {\r\n\t\t\ts := len(strings.TrimSpace(row))\r\n\t\t\tif i > len(rows)/2 && n <= s {\r\n\t\t\t\treturn false\r\n\t\t\t} else if i <= len(rows)/2 && n >= s {\r\n\t\t\t\treturn false\r\n\t\t\t}\r\n\t\t\tn = s\r\n\t\t}\r\n\t\treturn true\r\n\t}\r\n\tcheckCorrect(requirement, false, t)\r\n}\r\n\r\nfunc TestTopHalfHasAscendingLetters(t *testing.T) {\r\n\trequirement := func(char byte, rows []string) bool {\r\n\t\tvar start byte = 'A' - 1\r\n\t\tfor i := 0; i <= len(rows)/2; i++ {\r\n\t\t\ts := strings.TrimLeft(rows[i], \" \")\r\n\t\t\tif s == \"\" || s[0] <= start {\r\n\t\t\t\treturn false\r\n\t\t\t}\r\n\t\t\tstart = s[0]\r\n\t\t}\r\n\t\treturn true\r\n\t}\r\n\tcheckCorrect(requirement, false, t)\r\n}\r\n\r\nfunc TestBottomHalfHasDescendingLetters(t *testing.T) {\r\n\trequirement := func(char byte, rows []string) bool {\r\n\t\tvar start byte = 'A' - 1\r\n\t\tfor i := len(rows) - 1; i > len(rows)/2; i-- {\r\n\t\t\ts := strings.TrimLeft(rows[i], \" \")\r\n\t\t\tif s == \"\" || s[0] <= start {\r\n\t\t\t\treturn false\r\n\t\t\t}\r\n\t\t\tstart = s[0]\r\n\t\t}\r\n\t\treturn true\r\n\t}\r\n\tcheckCorrect(requirement, false, t)\r\n}\r\n\r\nfunc TestDiamondFourCornersAreTriangle(t *testing.T) {\r\n\trequirement := func(char byte, rows []string) bool {\r\n\t\tnotSpace := func(r rune) bool { return r <= 'Z' && r >= 'A' }\r\n\t\tvar n int\r\n\t\tfor i, row := range rows {\r\n\t\t\ts := strings.IndexFunc(row, notSpace)\r\n\t\t\te := len(row) - strings.LastIndexFunc(row, notSpace) - 1\r\n\t\t\tswitch {\r\n\t\t\tcase s != e:\r\n\t\t\t\treturn false\r\n\t\t\tcase i == 0:\r\n\t\t\t\tn = s\r\n\t\t\tdefault:\r\n\t\t\t\tif i > len(rows)/2 && n >= s {\r\n\t\t\t\t\treturn false\r\n\t\t\t\t} else if i <= len(rows)/2 && n <= s {\r\n\t\t\t\t\treturn false\r\n\t\t\t\t}\r\n\t\t\t\tn = s\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn true\r\n\t}\r\n\tcheckCorrect(requirement, false, t)\r\n}\r\n\r\ntype wrongChar byte\r\n\r\nfunc (c wrongChar) Generate(r *rand.Rand, _ int) reflect.Value {\r\n\tb := rand.Intn(256)\r\n\tfor ; b >= 'A' && b <= 'Z'; b = r.Intn(256) {\r\n\t}\r\n\treturn reflect.ValueOf(wrongChar(b))\r\n}\r\n\r\nfunc TestCharOutOfRangeShouldGiveError(t *testing.T) {\r\n\tassertion := func(char wrongChar) bool {\r\n\t\t_, err := Gen(byte(char))\r\n\t\treturn err != nil\r\n\t}\r\n\tif err := quick.Check(assertion, config); err != nil {\r\n\t\tt.Error(err)\r\n\t}\r\n}\r\n"
}