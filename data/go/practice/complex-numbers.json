{
  "language": "go",
  "type": "practice",
  "slug": "complex-numbers",
  "title": "Complex Numbers",
  "docs": {
    "instructions": "# Instructions\r\n\r\nA **complex number** is expressed in the form `z = a + b * i`, where:\r\n\r\n- `a` is the **real part** (a real number),\r\n\r\n- `b` is the **imaginary part** (also a real number), and\r\n\r\n- `i` is the **imaginary unit** satisfying `i^2 = -1`.\r\n\r\n## Operations on Complex Numbers\r\n\r\n### Conjugate\r\n\r\nThe conjugate of the complex number `z = a + b * i` is given by:\r\n\r\n```text\r\nzc = a - b * i\r\n```\r\n\r\n### Absolute Value\r\n\r\nThe absolute value (or modulus) of `z` is defined as:\r\n\r\n```text\r\n|z| = sqrt(a^2 + b^2)\r\n```\r\n\r\nThe square of the absolute value is computed as the product of `z` and its conjugate `zc`:\r\n\r\n```text\r\n|z|^2 = z * zc = a^2 + b^2\r\n```\r\n\r\n### Addition\r\n\r\nThe sum of two complex numbers `z1 = a + b * i` and `z2 = c + d * i` is computed by adding their real and imaginary parts separately:\r\n\r\n```text\r\nz1 + z2 = (a + b * i) + (c + d * i)\r\n        = (a + c) + (b + d) * i\r\n```\r\n\r\n### Subtraction\r\n\r\nThe difference of two complex numbers is obtained by subtracting their respective parts:\r\n\r\n```text\r\nz1 - z2 = (a + b * i) - (c + d * i)\r\n        = (a - c) + (b - d) * i\r\n```\r\n\r\n### Multiplication\r\n\r\nThe product of two complex numbers is defined as:\r\n\r\n```text\r\nz1 * z2 = (a + b * i) * (c + d * i)\r\n        = (a * c - b * d) + (b * c + a * d) * i\r\n```\r\n\r\n### Reciprocal\r\n\r\nThe reciprocal of a non-zero complex number is given by:\r\n\r\n```text\r\n1 / z = 1 / (a + b * i)\r\n      = a / (a^2 + b^2) - b / (a^2 + b^2) * i\r\n```\r\n\r\n### Division\r\n\r\nThe division of one complex number by another is given by:\r\n\r\n```text\r\nz1 / z2 = z1 * (1 / z2)\r\n        = (a + b * i) / (c + d * i)\r\n        = (a * c + b * d) / (c^2 + d^2) + (b * c - a * d) / (c^2 + d^2) * i\r\n```\r\n\r\n### Exponentiation\r\n\r\nRaising _e_ (the base of the natural logarithm) to a complex exponent can be expressed using Euler's formula:\r\n\r\n```text\r\ne^(a + b * i) = e^a * e^(b * i)\r\n              = e^a * (cos(b) + i * sin(b))\r\n```\r\n\r\n## Implementation Requirements\r\n\r\nGiven that you should not use built-in support for complex numbers, implement the following operations:\r\n\r\n- **addition** of two complex numbers\r\n- **subtraction** of two complex numbers\r\n- **multiplication** of two complex numbers\r\n- **division** of two complex numbers\r\n- **conjugate** of a complex number\r\n- **absolute value** of a complex number\r\n- **exponentiation** of _e_ (the base of the natural logarithm) to a complex number\r\n",
    "hints": ""
  },
  "starter_code": "package complexnumbers\r\n\r\n// Define the Number type here.\r\n\r\nfunc (n Number) Real() float64 {\r\n\tpanic(\"Please implement the Real method\")\r\n}\r\n\r\nfunc (n Number) Imaginary() float64 {\r\n\tpanic(\"Please implement the Imaginary method\")\r\n}\r\n\r\nfunc (n1 Number) Add(n2 Number) Number {\r\n\tpanic(\"Please implement the Add method\")\r\n}\r\n\r\nfunc (n1 Number) Subtract(n2 Number) Number {\r\n\tpanic(\"Please implement the Subtract method\")\r\n}\r\n\r\nfunc (n1 Number) Multiply(n2 Number) Number {\r\n\tpanic(\"Please implement the Multiply method\")\r\n}\r\n\r\nfunc (n Number) Times(factor float64) Number {\r\n\tpanic(\"Please implement the Times method\")\r\n}\r\n\r\nfunc (n1 Number) Divide(n2 Number) Number {\r\n\tpanic(\"Please implement the Divide method\")\r\n}\r\n\r\nfunc (n Number) Conjugate() Number {\r\n\tpanic(\"Please implement the Conjugate method\")\r\n}\r\n\r\nfunc (n Number) Abs() float64 {\r\n\tpanic(\"Please implement the Abs method\")\r\n}\r\n\r\nfunc (n Number) Exp() Number {\r\n\tpanic(\"Please implement the Exp method\")\r\n}\r\n",
  "tests": "package complexnumbers\r\n\r\nimport (\r\n\t\"math\"\r\n\t\"testing\"\r\n)\r\n\r\nconst floatEqualityThreshold = 1e-5\r\n\r\nfunc floatingPointEquals(got, want float64) bool {\r\n\tabsoluteDifferenceBelowThreshold := math.Abs(got-want) <= floatEqualityThreshold\r\n\trelativeDifferenceBelowThreshold := math.Abs(got-want)/(math.Abs(got)+math.Abs(want)) <= floatEqualityThreshold\r\n\treturn absoluteDifferenceBelowThreshold || relativeDifferenceBelowThreshold\r\n}\r\n\r\nfunc TestNumber_Real(t *testing.T) {\r\n\tfor _, tt := range realTestCases {\r\n\t\tt.Run(tt.description, func(t *testing.T) {\r\n\t\t\tn := Number{tt.in.a, tt.in.b}\r\n\t\t\tif got := n.Real(); !floatingPointEquals(got, tt.want) {\r\n\t\t\t\tt.Errorf(\"Number%+v.Real() = %v, want %v\", tt.in, got, tt.want)\r\n\t\t\t}\r\n\t\t})\r\n\t}\r\n}\r\n\r\nfunc TestNumber_Imaginary(t *testing.T) {\r\n\tfor _, tt := range imaginaryTestCases {\r\n\t\tt.Run(tt.description, func(t *testing.T) {\r\n\t\t\tn := Number{tt.in.a, tt.in.b}\r\n\t\t\tif got := n.Imaginary(); !floatingPointEquals(got, tt.want) {\r\n\t\t\t\tt.Errorf(\"Number%+v.Imaginary() = %v, want %v\", tt.in, got, tt.want)\r\n\t\t\t}\r\n\t\t})\r\n\t}\r\n}\r\n\r\nfunc TestNumber_Add(t *testing.T) {\r\n\tfor _, tt := range addTestCases {\r\n\t\tt.Run(tt.description, func(t *testing.T) {\r\n\t\t\tn1 := Number{tt.n1.a, tt.n1.b}\r\n\t\t\tn2 := Number{tt.n2.a, tt.n2.b}\r\n\t\t\tif got := n1.Add(n2); !floatingPointEquals(got.Real(), tt.want.a) || !floatingPointEquals(got.Imaginary(), tt.want.b) {\r\n\t\t\t\tt.Errorf(\"Number%+v.Add%+v\\n got: %+v\\nwant: %+v\", tt.n1, tt.n2, got, tt.want)\r\n\t\t\t}\r\n\t\t})\r\n\t}\r\n}\r\n\r\nfunc TestNumber_Subtract(t *testing.T) {\r\n\tfor _, tt := range subtractTestCases {\r\n\t\tt.Run(tt.description, func(t *testing.T) {\r\n\t\t\tn1 := Number{tt.n1.a, tt.n1.b}\r\n\t\t\tn2 := Number{tt.n2.a, tt.n2.b}\r\n\t\t\tif got := n1.Subtract(n2); !floatingPointEquals(got.Real(), tt.want.a) || !floatingPointEquals(got.Imaginary(), tt.want.b) {\r\n\t\t\t\tt.Errorf(\"Number%+v.Subtract%+v\\n got: %+v\\nwant: %+v\", tt.n1, tt.n2, got, tt.want)\r\n\t\t\t}\r\n\t\t})\r\n\t}\r\n}\r\n\r\nfunc TestNumber_Multiply(t *testing.T) {\r\n\tfor _, tt := range multiplyTestCases {\r\n\t\tt.Run(tt.description, func(t *testing.T) {\r\n\t\t\tif tt.n2 == nil {\r\n\t\t\t\tt.Skip(\"skipping tests with factor used withNumber.Times()\")\r\n\t\t\t}\r\n\t\t\tn1 := Number{tt.n1.a, tt.n1.b}\r\n\t\t\tn2 := Number{tt.n2.a, tt.n2.b}\r\n\t\t\tif got := n1.Multiply(n2); !floatingPointEquals(got.Real(), tt.want.a) || !floatingPointEquals(got.Imaginary(), tt.want.b) {\r\n\t\t\t\tt.Errorf(\"Number%+v.Multiply%+v\\n got: %+v\\nwant: %+v\", tt.n1, tt.n2, got, tt.want)\r\n\t\t\t}\r\n\t\t})\r\n\t}\r\n}\r\n\r\nfunc TestNumber_Times(t *testing.T) {\r\n\tfor _, tt := range multiplyTestCases {\r\n\t\tt.Run(tt.description, func(t *testing.T) {\r\n\t\t\tif tt.n2 != nil {\r\n\t\t\t\tt.Skip(\"skipping tests with complex multiplier used withNumber.Multiply()\")\r\n\t\t\t}\r\n\t\t\tn := Number{tt.n1.a, tt.n1.b}\r\n\t\t\tif got := n.Times(tt.factor); !floatingPointEquals(got.Real(), tt.want.a) || !floatingPointEquals(got.Imaginary(), tt.want.b) {\r\n\t\t\t\tt.Errorf(\"Number%+v.Times(%v)\\n got: %+v\\nwant: %+v\", tt.n1, tt.factor, got, tt.want)\r\n\t\t\t}\r\n\t\t})\r\n\t}\r\n}\r\n\r\nfunc TestNumber_Divide(t *testing.T) {\r\n\tfor _, tt := range divideTestCases {\r\n\t\tt.Run(tt.description, func(t *testing.T) {\r\n\t\t\tn1 := Number{tt.n1.a, tt.n1.b}\r\n\t\t\tn2 := Number{tt.n2.a, tt.n2.b}\r\n\t\t\tif got := n1.Divide(n2); !floatingPointEquals(got.Real(), tt.want.a) || !floatingPointEquals(got.Imaginary(), tt.want.b) {\r\n\t\t\t\tt.Errorf(\"Number%+v.Divide%+v\\n got: %+v\\nwant: %+v\", tt.n1, tt.n2, got, tt.want)\r\n\t\t\t}\r\n\t\t})\r\n\t}\r\n}\r\n\r\nfunc TestNumber_Abs(t *testing.T) {\r\n\tfor _, tt := range absTestCases {\r\n\t\tt.Run(tt.description, func(t *testing.T) {\r\n\t\t\tn := Number{tt.in.a, tt.in.b}\r\n\t\t\tif got := n.Abs(); !floatingPointEquals(got, tt.want) {\r\n\t\t\t\tt.Errorf(\"Number.Abs%+v = %v, want %v\", tt.in, got, tt.want)\r\n\t\t\t}\r\n\t\t})\r\n\t}\r\n}\r\n\r\nfunc TestNumber_Conjugate(t *testing.T) {\r\n\tfor _, tt := range conjugateTestCases {\r\n\t\tt.Run(tt.description, func(t *testing.T) {\r\n\t\t\tn := Number{tt.in.a, tt.in.b}\r\n\t\t\tif got := n.Conjugate(); !floatingPointEquals(got.Real(), tt.want.a) || !floatingPointEquals(got.Imaginary(), tt.want.b) {\r\n\t\t\t\tt.Errorf(\"Number%+v.Conjugate()\\n got: %+v\\nwant: %+v\", tt.in, got, tt.want)\r\n\t\t\t}\r\n\t\t})\r\n\t}\r\n}\r\n\r\nfunc TestNumber_Exp(t *testing.T) {\r\n\tfor _, tt := range expTestCases {\r\n\t\tt.Run(tt.description, func(t *testing.T) {\r\n\t\t\tn := Number{tt.in.a, tt.in.b}\r\n\t\t\tif got := n.Exp(); !floatingPointEquals(got.Real(), tt.want.a) || !floatingPointEquals(got.Imaginary(), tt.want.b) {\r\n\t\t\t\tt.Errorf(\"Number%+v.Exp()\\n got: %+v\\nwant: %+v\", tt.in, got, tt.want)\r\n\t\t\t}\r\n\t\t})\r\n\t}\r\n}\r\n"
}