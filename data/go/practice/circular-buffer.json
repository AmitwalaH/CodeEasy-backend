{
  "language": "go",
  "type": "practice",
  "slug": "circular-buffer",
  "title": "Circular Buffer",
  "docs": {
    "instructions": "# Instructions\r\n\r\nA circular buffer, cyclic buffer or ring buffer is a data structure that uses a single, fixed-size buffer as if it were connected end-to-end.\r\n\r\nA circular buffer first starts empty and of some predefined length.\r\nFor example, this is a 7-element buffer:\r\n\r\n```text\r\n[ ][ ][ ][ ][ ][ ][ ]\r\n```\r\n\r\nAssume that a 1 is written into the middle of the buffer (exact starting location does not matter in a circular buffer):\r\n\r\n```text\r\n[ ][ ][ ][1][ ][ ][ ]\r\n```\r\n\r\nThen assume that two more elements are added — 2 & 3 — which get appended after the 1:\r\n\r\n```text\r\n[ ][ ][ ][1][2][3][ ]\r\n```\r\n\r\nIf two elements are then removed from the buffer, the oldest values inside the buffer are removed.\r\nThe two elements removed, in this case, are 1 & 2, leaving the buffer with just a 3:\r\n\r\n```text\r\n[ ][ ][ ][ ][ ][3][ ]\r\n```\r\n\r\nIf the buffer has 7 elements then it is completely full:\r\n\r\n```text\r\n[5][6][7][8][9][3][4]\r\n```\r\n\r\nWhen the buffer is full an error will be raised, alerting the client that further writes are blocked until a slot becomes free.\r\n\r\nWhen the buffer is full, the client can opt to overwrite the oldest data with a forced write.\r\nIn this case, two more elements — A & B — are added and they overwrite the 3 & 4:\r\n\r\n```text\r\n[5][6][7][8][9][A][B]\r\n```\r\n\r\n3 & 4 have been replaced by A & B making 5 now the oldest data in the buffer.\r\nFinally, if two elements are removed then what would be returned is 5 & 6 yielding the buffer:\r\n\r\n```text\r\n[ ][ ][7][8][9][A][B]\r\n```\r\n\r\nBecause there is space available, if the client again uses overwrite to store C & D then the space where 5 & 6 were stored previously will be used not the location of 7 & 8.\r\n7 is still the oldest element and the buffer is once again full.\r\n\r\n```text\r\n[C][D][7][8][9][A][B]\r\n```\r\n",
    "hints": ""
  },
  "starter_code": "package circular\r\n\r\n// Implement a circular buffer of bytes supporting both overflow-checked writes\r\n// and unconditional, possibly overwriting, writes.\r\n//\r\n// We chose the provided API so that Buffer implements io.ByteReader\r\n// and io.ByteWriter and can be used (size permitting) as a drop in\r\n// replacement for anything using that interface.\r\n\r\n// Define the Buffer type here.\r\n\r\nfunc NewBuffer(size int) *Buffer {\r\n\tpanic(\"Please implement the NewBuffer function\")\r\n}\r\n\r\nfunc (b *Buffer) ReadByte() (byte, error) {\r\n\tpanic(\"Please implement the ReadByte function\")\r\n}\r\n\r\nfunc (b *Buffer) WriteByte(c byte) error {\r\n\tpanic(\"Please implement the WriteByte function\")\r\n}\r\n\r\nfunc (b *Buffer) Overwrite(c byte) {\r\n\tpanic(\"Please implement the Overwrite function\")\r\n}\r\n\r\nfunc (b *Buffer) Reset() {\r\n\tpanic(\"Please implement the Reset function\")\r\n}\r\n",
  "tests": "package circular\r\n\r\nimport (\r\n\t\"io\"\r\n\t\"testing\"\r\n)\r\n\r\n// Here is one way you can have a test case verify that the expected\r\n// interfaces are implemented.\r\n\r\nvar (\r\n\t_ io.ByteReader = new(Buffer)\r\n\t_ io.ByteWriter = new(Buffer)\r\n)\r\n\r\n// testBuffer and methods support the tests, providing log and fail messages.\r\n\r\ntype testBuffer struct {\r\n\t*testing.T\r\n\tb *Buffer\r\n}\r\n\r\nfunc nb(size int, t *testing.T) testBuffer {\r\n\tt.Logf(\"NewBuffer(%d)\", size)\r\n\treturn testBuffer{t, NewBuffer(size)}\r\n}\r\n\r\nfunc (tb testBuffer) read(want byte) {\r\n\tswitch c, err := tb.b.ReadByte(); {\r\n\tcase err != nil:\r\n\t\tvar _ error = err\r\n\t\ttb.Fatalf(\"ReadByte() failed unexpectedly: %v\", err)\r\n\tcase c != want:\r\n\t\ttb.Fatalf(\"ReadByte() = %c, want %c.\", c, want)\r\n\t}\r\n\ttb.Logf(\"ReadByte %c\", want)\r\n}\r\n\r\nfunc (tb testBuffer) readFail() {\r\n\tc, err := tb.b.ReadByte()\r\n\tif err == nil {\r\n\t\ttb.Fatalf(\"ReadByte() = %c, expected a failure\", c)\r\n\t}\r\n\tvar _ error = err\r\n\ttb.Log(\"ReadByte() fails as expected\")\r\n}\r\n\r\nfunc (tb testBuffer) write(c byte) {\r\n\tif err := tb.b.WriteByte(c); err != nil {\r\n\t\tvar _ error = err\r\n\t\ttb.Fatalf(\"WriteByte(%c) failed unexpectedly: %v\", c, err)\r\n\t}\r\n\ttb.Logf(\"WriteByte(%c)\", c)\r\n}\r\n\r\nfunc (tb testBuffer) writeFail(c byte) {\r\n\terr := tb.b.WriteByte(c)\r\n\tif err == nil {\r\n\t\ttb.Fatalf(\"WriteByte(%c) succeeded, expected a failure\", c)\r\n\t}\r\n\tvar _ error = err\r\n\ttb.Logf(\"WriteByte(%c) fails as expected\", c)\r\n}\r\n\r\nfunc (tb testBuffer) reset() {\r\n\ttb.b.Reset()\r\n\ttb.Log(\"Reset()\")\r\n}\r\n\r\nfunc (tb testBuffer) overwrite(c byte) {\r\n\ttb.b.Overwrite(c)\r\n\ttb.Logf(\"Overwrite(%c)\", c)\r\n}\r\n\r\n// tests.  separate functions so log will have descriptive test name.\r\n\r\nfunc TestReadEmptyBuffer(t *testing.T) {\r\n\ttb := nb(1, t)\r\n\ttb.readFail()\r\n}\r\n\r\nfunc TestWriteAndReadOneItem(t *testing.T) {\r\n\ttb := nb(1, t)\r\n\ttb.write('1')\r\n\ttb.read('1')\r\n\ttb.readFail()\r\n}\r\n\r\nfunc TestWriteAndReadMultipleItems(t *testing.T) {\r\n\ttb := nb(2, t)\r\n\ttb.write('1')\r\n\ttb.write('2')\r\n\ttb.read('1')\r\n\ttb.read('2')\r\n\ttb.readFail()\r\n}\r\n\r\nfunc TestReset(t *testing.T) {\r\n\ttb := nb(3, t)\r\n\ttb.write('1')\r\n\ttb.write('2')\r\n\ttb.write('3')\r\n\ttb.reset()\r\n\ttb.write('1')\r\n\ttb.write('3')\r\n\ttb.read('1')\r\n\ttb.write('4')\r\n\ttb.read('3')\r\n}\r\n\r\nfunc TestAlternateWriteAndRead(t *testing.T) {\r\n\ttb := nb(2, t)\r\n\ttb.write('1')\r\n\ttb.read('1')\r\n\ttb.write('2')\r\n\ttb.read('2')\r\n}\r\n\r\nfunc TestReadOldestItem(t *testing.T) {\r\n\ttb := nb(3, t)\r\n\ttb.write('1')\r\n\ttb.write('2')\r\n\ttb.read('1')\r\n\ttb.write('3')\r\n\ttb.read('2')\r\n\ttb.read('3')\r\n}\r\n\r\nfunc TestWriteFullBuffer(t *testing.T) {\r\n\ttb := nb(2, t)\r\n\ttb.write('1')\r\n\ttb.write('2')\r\n\ttb.writeFail('A')\r\n}\r\n\r\nfunc TestOverwriteFull(t *testing.T) {\r\n\ttb := nb(2, t)\r\n\ttb.write('1')\r\n\ttb.write('2')\r\n\ttb.overwrite('A')\r\n\ttb.read('2')\r\n\ttb.read('A')\r\n\ttb.readFail()\r\n}\r\n\r\nfunc TestOverwriteNonFull(t *testing.T) {\r\n\ttb := nb(2, t)\r\n\ttb.write('1')\r\n\ttb.overwrite('2')\r\n\ttb.read('1')\r\n\ttb.read('2')\r\n\ttb.readFail()\r\n}\r\n\r\nfunc TestAlternateReadAndOverwrite(t *testing.T) {\r\n\ttb := nb(5, t)\r\n\ttb.write('1')\r\n\ttb.write('2')\r\n\ttb.write('3')\r\n\ttb.read('1')\r\n\ttb.read('2')\r\n\ttb.write('4')\r\n\ttb.read('3')\r\n\ttb.write('5')\r\n\ttb.write('6')\r\n\ttb.write('7')\r\n\ttb.write('8')\r\n\ttb.overwrite('A')\r\n\ttb.overwrite('B')\r\n\ttb.read('6')\r\n\ttb.read('7')\r\n\ttb.read('8')\r\n\ttb.read('A')\r\n\ttb.read('B')\r\n\ttb.readFail()\r\n}\r\n\r\nfunc BenchmarkOverwrite(b *testing.B) {\r\n\tif testing.Short() {\r\n\t\tb.Skip(\"skipping benchmark in short mode.\")\r\n\t}\r\n\tc := NewBuffer(100)\r\n\tb.ResetTimer()\r\n\tfor i := 0; i < b.N; i++ {\r\n\t\tc.Overwrite(0)\r\n\t}\r\n\tb.SetBytes(int64(b.N))\r\n}\r\n\r\nfunc BenchmarkWriteRead(b *testing.B) {\r\n\tif testing.Short() {\r\n\t\tb.Skip(\"skipping benchmark in short mode.\")\r\n\t}\r\n\tc := NewBuffer(100)\r\n\tb.ResetTimer()\r\n\tfor i := 0; i < b.N; i++ {\r\n\t\tc.WriteByte(0)\r\n\t\tc.ReadByte()\r\n\t}\r\n\tb.SetBytes(int64(b.N))\r\n}\r\n"
}