{
  "language": "go",
  "type": "practice",
  "slug": "custom-set",
  "title": "Custom Set",
  "docs": {
    "instructions": "# Instructions\r\n\r\nCreate a custom set type.\r\n\r\nSometimes it is necessary to define a custom data structure of some type, like a set.\r\nIn this exercise you will define your own set.\r\nHow it works internally doesn't matter, as long as it behaves like a set of unique elements.\r\n",
    "hints": ""
  },
  "starter_code": "package stringset\r\n\r\n// Implement Set as a collection of unique string values.\r\n//\r\n// For Set.String, use '{' and '}', output elements as double-quoted strings\r\n// safely escaped with Go syntax, and use a comma and a single space between\r\n// elements. For example, a set with 2 elements, \"a\" and \"b\", should be formatted as {\"a\", \"b\"}.\r\n// Format the empty set as {}.\r\n\r\n// Define the Set type here.\r\n\r\nfunc New() Set {\r\n\tpanic(\"Please implement the New function\")\r\n}\r\n\r\nfunc NewFromSlice(l []string) Set {\r\n\tpanic(\"Please implement the NewFromSlice function\")\r\n}\r\n\r\nfunc (s Set) String() string {\r\n\tpanic(\"Please implement the String function\")\r\n}\r\n\r\nfunc (s Set) IsEmpty() bool {\r\n\tpanic(\"Please implement the IsEmpty function\")\r\n}\r\n\r\nfunc (s Set) Has(elem string) bool {\r\n\tpanic(\"Please implement the Has function\")\r\n}\r\n\r\nfunc (s Set) Add(elem string) {\r\n\tpanic(\"Please implement the Add function\")\r\n}\r\n\r\nfunc Subset(s1, s2 Set) bool {\r\n\tpanic(\"Please implement the Subset function\")\r\n}\r\n\r\nfunc Disjoint(s1, s2 Set) bool {\r\n\tpanic(\"Please implement the Disjoint function\")\r\n}\r\n\r\nfunc Equal(s1, s2 Set) bool {\r\n\tpanic(\"Please implement the Equal function\")\r\n}\r\n\r\nfunc Intersection(s1, s2 Set) Set {\r\n\tpanic(\"Please implement the Intersection function\")\r\n}\r\n\r\nfunc Difference(s1, s2 Set) Set {\r\n\tpanic(\"Please implement the Difference function\")\r\n}\r\n\r\nfunc Union(s1, s2 Set) Set {\r\n\tpanic(\"Please implement the Union function\")\r\n}\r\n",
  "tests": "//nolint:gosec // In the context of this exercise, it is fine to use math.Rand instead of crypto.Rand.\r\npackage stringset\r\n\r\nimport (\r\n\t\"math/rand\"\r\n\t\"strconv\"\r\n\t\"testing\"\r\n)\r\n\r\n// A first set of tests uses Set.String() to judge correctness.\r\n\r\nfunc TestNew(t *testing.T) {\r\n\t// New must return an empty set.\r\n\twant := \"{}\"\r\n\tif got := New().String(); got != want {\r\n\t\tt.Fatalf(`New().String() = %s, want %s.`, got, want)\r\n\t}\r\n}\r\n\r\nfunc TestNewFromSlice(t *testing.T) {\r\n\t// nil slice should give empty set\r\n\twant := \"{}\"\r\n\tif got := NewFromSlice(nil).String(); got != want {\r\n\t\tt.Fatalf(`NewFromSlice(nil) = %s, want %s.`, got, want)\r\n\t}\r\n\r\n\t// slice with one element:\r\n\twant = `{\"a\"}`\r\n\tif got := NewFromSlice([]string{\"a\"}).String(); got != want {\r\n\t\tt.Fatalf(`NewFromSlice([]string{\"a\"}) = %s, want %s.`, got, want)\r\n\t}\r\n\r\n\t// slice with repeated element:\r\n\tif got := NewFromSlice([]string{\"a\", \"a\"}).String(); got != want {\r\n\t\tt.Fatalf(`NewFromSlice([]string{\"a\", \"a\"}) = %s, want %s.`, got, want)\r\n\t}\r\n\r\n\t// slice with two elements:\r\n\tgot := NewFromSlice([]string{\"a\", \"b\"}).String()\r\n\twant1 := `{\"a\", \"b\"}`\r\n\twant2 := `{\"b\", \"a\"}`\r\n\tif got != want1 && got != want2 { // order undefined\r\n\t\tt.Fatalf(`NewFromSlice([]string{\"a\", \"b\"}) = %s, want %s or (%s).`, got, want1, want2)\r\n\t}\r\n}\r\n\r\nfunc TestIsEmpty(t *testing.T) {\r\n\tfor _, tc := range emptyCases {\r\n\t\tt.Run(tc.description, func(t *testing.T) {\r\n\t\t\ts := NewFromSlice(tc.set)\r\n\t\t\tgot := s.IsEmpty()\r\n\t\t\tif got != tc.want {\r\n\t\t\t\tt.Errorf(\"%v IsEmpty = %t, want %t\", s, got, tc.want)\r\n\t\t\t}\r\n\t\t})\r\n\t}\r\n}\r\n\r\nfunc TestHas(t *testing.T) {\r\n\tfor _, tc := range containsCases {\r\n\t\tt.Run(tc.description, func(t *testing.T) {\r\n\t\t\ts := NewFromSlice(tc.set)\r\n\t\t\tgot := s.Has(tc.element)\r\n\t\t\tif got != tc.want {\r\n\t\t\t\tt.Fatalf(\"%v Has %q = %t, want %t\", s, tc.element, got, tc.want)\r\n\t\t\t}\r\n\t\t})\r\n\t}\r\n}\r\n\r\n// helper for testing Subset, Disjoint, Equal\r\nfunc testBinBool(name string, f func(Set, Set) bool, cases []binBoolCase, t *testing.T) {\r\n\tfor _, tc := range cases {\r\n\t\tt.Run(tc.description, func(t *testing.T) {\r\n\t\t\ts1 := NewFromSlice(tc.set1)\r\n\t\t\ts2 := NewFromSlice(tc.set2)\r\n\t\t\tgot := f(s1, s2)\r\n\t\t\tif got != tc.want {\r\n\t\t\t\tt.Errorf(\"%s(%v, %v) = %t, want %t\", name, s1, s2, got, tc.want)\r\n\t\t\t}\r\n\t\t})\r\n\t}\r\n}\r\n\r\nfunc TestSubset(t *testing.T) {\r\n\ttestBinBool(\"Subset\", Subset, subsetCases, t)\r\n}\r\n\r\nfunc TestDisjoint(t *testing.T) {\r\n\ttestBinBool(\"Disjoint\", Disjoint, disjointCases, t)\r\n}\r\n\r\nfunc TestEqual(t *testing.T) {\r\n\ttestBinBool(\"Equal\", Equal, equalCases, t)\r\n}\r\n\r\nfunc TestAdd(t *testing.T) {\r\n\tfor _, tc := range addCases {\r\n\t\tt.Run(tc.description, func(t *testing.T) {\r\n\t\t\ts := NewFromSlice(tc.set)\r\n\t\t\ts.Add(tc.element)\r\n\t\t\twant := NewFromSlice(tc.want)\r\n\t\t\tif !Equal(s, want) {\r\n\t\t\t\tt.Fatalf(\"%v Add %q = %v, want %v\", NewFromSlice(tc.set), tc.element, s, want)\r\n\t\t\t}\r\n\t\t})\r\n\t}\r\n}\r\n\r\n// helper for testing Intersection, Difference, Union\r\nfunc testBinOp(name string, f func(Set, Set) Set, cases []binOpCase, t *testing.T) {\r\n\tfor _, tc := range cases {\r\n\t\tt.Run(tc.description, func(t *testing.T) {\r\n\t\t\ts1 := NewFromSlice(tc.set1)\r\n\t\t\ts2 := NewFromSlice(tc.set2)\r\n\t\t\twant := NewFromSlice(tc.want)\r\n\t\t\tgot := f(s1, s2)\r\n\t\t\tif !Equal(got, want) {\r\n\t\t\t\tt.Fatalf(\"%s(%v, %v) = %v, want %v\", name, s1, s2, got, want)\r\n\t\t\t}\r\n\t\t})\r\n\t}\r\n}\r\n\r\nfunc TestIntersection(t *testing.T) {\r\n\ttestBinOp(\"Intersection\", Intersection, intersectionCases, t)\r\n}\r\n\r\nfunc TestDifference(t *testing.T) {\r\n\ttestBinOp(\"Difference\", Difference, differenceCases, t)\r\n}\r\n\r\nfunc TestUnion(t *testing.T) {\r\n\ttestBinOp(\"Union\", Union, unionCases, t)\r\n}\r\n\r\nfunc BenchmarkNewFromSlice1e1(b *testing.B) { bench(1e1, b) }\r\nfunc BenchmarkNewFromSlice1e2(b *testing.B) { bench(1e2, b) }\r\nfunc BenchmarkNewFromSlice1e3(b *testing.B) { bench(1e3, b) }\r\nfunc BenchmarkNewFromSlice1e4(b *testing.B) { bench(1e4, b) }\r\n\r\nfunc bench(nAdd int, b *testing.B) {\r\n\tif testing.Short() {\r\n\t\tb.Skip(\"skipping benchmark in short mode.\")\r\n\t}\r\n\ts := make([]string, nAdd)\r\n\tfor i := range s {\r\n\t\ts[i] = strconv.Itoa(rand.Intn(len(s)))\r\n\t}\r\n\tb.ResetTimer()\r\n\tfor i := 0; i < b.N; i++ {\r\n\t\tNewFromSlice(s)\r\n\t}\r\n}\r\n"
}