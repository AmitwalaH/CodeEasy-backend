{
  "language": "go",
  "type": "practice",
  "slug": "tournament",
  "title": "Tournament",
  "docs": {
    "instructions": "# Instructions\r\n\r\nTally the results of a small football competition.\r\n\r\nBased on an input file containing which team played against which and what the outcome was, create a file with a table like this:\r\n\r\n```text\r\nTeam                           | MP |  W |  D |  L |  P\r\nDevastating Donkeys            |  3 |  2 |  1 |  0 |  7\r\nAllegoric Alaskans             |  3 |  2 |  0 |  1 |  6\r\nBlithering Badgers             |  3 |  1 |  0 |  2 |  3\r\nCourageous Californians        |  3 |  0 |  1 |  2 |  1\r\n```\r\n\r\nWhat do those abbreviations mean?\r\n\r\n- MP: Matches Played\r\n- W: Matches Won\r\n- D: Matches Drawn (Tied)\r\n- L: Matches Lost\r\n- P: Points\r\n\r\nA win earns a team 3 points.\r\nA draw earns 1.\r\nA loss earns 0.\r\n\r\nThe outcome is ordered by points, descending.\r\nIn case of a tie, teams are ordered alphabetically.\r\n\r\n## Input\r\n\r\nYour tallying program will receive input that looks like:\r\n\r\n```text\r\nAllegoric Alaskans;Blithering Badgers;win\r\nDevastating Donkeys;Courageous Californians;draw\r\nDevastating Donkeys;Allegoric Alaskans;win\r\nCourageous Californians;Blithering Badgers;loss\r\nBlithering Badgers;Devastating Donkeys;loss\r\nAllegoric Alaskans;Courageous Californians;win\r\n```\r\n\r\nThe result of the match refers to the first team listed.\r\nSo this line:\r\n\r\n```text\r\nAllegoric Alaskans;Blithering Badgers;win\r\n```\r\n\r\nmeans that the Allegoric Alaskans beat the Blithering Badgers.\r\n\r\nThis line:\r\n\r\n```text\r\nCourageous Californians;Blithering Badgers;loss\r\n```\r\n\r\nmeans that the Blithering Badgers beat the Courageous Californians.\r\n\r\nAnd this line:\r\n\r\n```text\r\nDevastating Donkeys;Courageous Californians;draw\r\n```\r\n\r\nmeans that the Devastating Donkeys and Courageous Californians tied.\r\n",
    "hints": ""
  },
  "starter_code": "package tournament\r\n\r\nimport \"io\"\r\n\r\nfunc Tally(reader io.Reader, writer io.Writer) error {\r\n\tpanic(\"Please implement the Tally function\")\r\n}\r\n",
  "tests": "package tournament\r\n\r\nimport (\r\n\t\"bytes\"\r\n\t\"fmt\"\r\n\t\"strings\"\r\n\t\"testing\"\r\n)\r\n\r\n// Define a function Tally(io.Reader, io.Writer) error.\r\n//\r\n// Note that unlike other tracks the Go version of the tally function\r\n// should not ignore errors. It's not idiomatic Go to ignore errors.\r\n\r\n// These test what testers call the happy path, where there's no error.\r\nvar happyTestCases = []struct {\r\n\tdescription string\r\n\tinput       string\r\n\texpected    string\r\n}{\r\n\t{\r\n\t\tdescription: \"good\",\r\n\t\tinput: `\r\nAllegoric Alaskians;Blithering Badgers;win\r\nDevastating Donkeys;Courageous Californians;draw\r\nDevastating Donkeys;Allegoric Alaskians;win\r\nCourageous Californians;Blithering Badgers;loss\r\nBlithering Badgers;Devastating Donkeys;loss\r\nAllegoric Alaskians;Courageous Californians;win\r\n`,\r\n\t\texpected: `\r\nTeam                           | MP |  W |  D |  L |  P\r\nDevastating Donkeys            |  3 |  2 |  1 |  0 |  7\r\nAllegoric Alaskians            |  3 |  2 |  0 |  1 |  6\r\nBlithering Badgers             |  3 |  1 |  0 |  2 |  3\r\nCourageous Californians        |  3 |  0 |  1 |  2 |  1\r\n`[1:], // [1:] = strip initial readability newline\r\n\t},\r\n\t{\r\n\t\tdescription: \"ignore comments and newlines\",\r\n\t\tinput: `\r\n\r\nAllegoric Alaskians;Blithering Badgers;win\r\nDevastating Donkeys;Allegoric Alaskians;win\r\n# Catastrophic Loss of the Californians\r\nCourageous Californians;Blithering Badgers;loss\r\n\r\nBlithering Badgers;Devastating Donkeys;loss\r\nAllegoric Alaskians;Courageous Californians;win\r\nDevastating Donkeys;Courageous Californians;draw\r\n\r\n\r\n`,\r\n\t\texpected: `\r\nTeam                           | MP |  W |  D |  L |  P\r\nDevastating Donkeys            |  3 |  2 |  1 |  0 |  7\r\nAllegoric Alaskians            |  3 |  2 |  0 |  1 |  6\r\nBlithering Badgers             |  3 |  1 |  0 |  2 |  3\r\nCourageous Californians        |  3 |  0 |  1 |  2 |  1\r\n`[1:],\r\n\t},\r\n\t{\r\n\t\t// A complete competition has all teams play eachother once or twice.\r\n\t\tdescription: \"incomplete competition\",\r\n\t\tinput: `\r\nAllegoric Alaskians;Blithering Badgers;win\r\nDevastating Donkeys;Allegoric Alaskians;win\r\nCourageous Californians;Blithering Badgers;loss\r\nAllegoric Alaskians;Courageous Californians;win\r\n`,\r\n\t\texpected: `\r\nTeam                           | MP |  W |  D |  L |  P\r\nAllegoric Alaskians            |  3 |  2 |  0 |  1 |  6\r\nBlithering Badgers             |  2 |  1 |  0 |  1 |  3\r\nDevastating Donkeys            |  1 |  1 |  0 |  0 |  3\r\nCourageous Californians        |  2 |  0 |  0 |  2 |  0\r\n`[1:],\r\n\t},\r\n\t{\r\n\t\tdescription: \"tie for first and last place\",\r\n\t\tinput: `\r\nCourageous Californians;Devastating Donkeys;win\r\nAllegoric Alaskians;Blithering Badgers;win\r\nDevastating Donkeys;Allegoric Alaskians;loss\r\nCourageous Californians;Blithering Badgers;win\r\nBlithering Badgers;Devastating Donkeys;draw\r\nAllegoric Alaskians;Courageous Californians;draw\r\n`,\r\n\t\texpected: `\r\nTeam                           | MP |  W |  D |  L |  P\r\nAllegoric Alaskians            |  3 |  2 |  1 |  0 |  7\r\nCourageous Californians        |  3 |  2 |  1 |  0 |  7\r\nBlithering Badgers             |  3 |  0 |  1 |  2 |  1\r\nDevastating Donkeys            |  3 |  0 |  1 |  2 |  1\r\n`[1:],\r\n\t},\r\n}\r\n\r\nvar errorTestCases = []string{\r\n\t\"Bla;Bla;Bla\",\r\n\t\"Devastating Donkeys_Courageous Californians;draw\",\r\n\t\"Devastating Donkeys@Courageous Californians;draw\",\r\n\t\"Devastating Donkeys;Allegoric Alaskians;dra\",\r\n}\r\n\r\nfunc TestTallyHappy(t *testing.T) {\r\n\tfor _, tc := range happyTestCases {\r\n\t\tt.Run(tc.description, func(t *testing.T) {\r\n\t\t\treader := strings.NewReader(tc.input)\r\n\t\t\tvar buffer bytes.Buffer\r\n\t\t\terr := Tally(reader, &buffer)\r\n\t\t\t// We don't expect errors for any of the test cases\r\n\t\t\tif err != nil {\r\n\t\t\t\tt.Fatalf(\"Tally for input named %q returned unexpected error %v\", tc.description, err)\r\n\t\t\t}\r\n\t\t\tgot := buffer.String()\r\n\t\t\tif got != tc.expected {\r\n\t\t\t\tt.Fatalf(\"Tally for input named %q returned unexpected value\\ngot: %s\\nwant: %s\", tc.description, got, tc.expected)\r\n\t\t\t}\r\n\t\t})\r\n\t}\r\n}\r\n\r\nfunc TestTallyError(t *testing.T) {\r\n\tfor i, errorInput := range errorTestCases {\r\n\t\tt.Run(fmt.Sprintf(\"Error Input %d\", i), func(t *testing.T) {\r\n\t\t\treader := strings.NewReader(errorInput)\r\n\t\t\tvar buffer bytes.Buffer\r\n\t\t\terr := Tally(reader, &buffer)\r\n\t\t\tif err == nil {\r\n\t\t\t\tt.Fatalf(\"Tally for input %q expected error, got nil\", errorInput)\r\n\t\t\t}\r\n\t\t})\r\n\t}\r\n}\r\n\r\nfunc BenchmarkTally(b *testing.B) {\r\n\tif testing.Short() {\r\n\t\tb.Skip(\"skipping benchmark in short mode.\")\r\n\t}\r\n\tfor i := 0; i < b.N; i++ {\r\n\t\tfor _, tt := range happyTestCases {\r\n\t\t\tvar buffer bytes.Buffer\r\n\t\t\tTally(strings.NewReader(tt.input), &buffer)\r\n\t\t}\r\n\t\tfor _, s := range errorTestCases {\r\n\t\t\tvar buffer bytes.Buffer\r\n\t\t\tTally(strings.NewReader(s), &buffer)\r\n\t\t}\r\n\t}\r\n}\r\n"
}