{
  "language": "go",
  "type": "practice",
  "slug": "kindergarten-garden",
  "title": "Kindergarten Garden",
  "docs": {
    "instructions": "# Instructions\r\n\r\nYour task is to, given a diagram, determine which plants each child in the kindergarten class is responsible for.\r\n\r\nThere are 12 children in the class:\r\n\r\n- Alice, Bob, Charlie, David, Eve, Fred, Ginny, Harriet, Ileana, Joseph, Kincaid, and Larry.\r\n\r\nFour different types of seeds are planted:\r\n\r\n| Plant  | Diagram encoding |\r\n| ------ | ---------------- |\r\n| Grass  | G                |\r\n| Clover | C                |\r\n| Radish | R                |\r\n| Violet | V                |\r\n\r\nEach child gets four cups, two on each row:\r\n\r\n```text\r\n[window][window][window]\r\n........................ # each dot represents a cup\r\n........................\r\n```\r\n\r\nTheir teacher assigns cups to the children alphabetically by their names, which means that Alice comes first and Larry comes last.\r\n\r\nHere is an example diagram representing Alice's plants:\r\n\r\n```text\r\n[window][window][window]\r\nVR......................\r\nRG......................\r\n```\r\n\r\nIn the first row, nearest the windows, she has a violet and a radish.\r\nIn the second row she has a radish and some grass.\r\n\r\nYour program will be given the plants from left-to-right starting with the row nearest the windows.\r\nFrom this, it should be able to determine which plants belong to each student.\r\n\r\nFor example, if it's told that the garden looks like so:\r\n\r\n```text\r\n[window][window][window]\r\nVRCGVVRVCGGCCGVRGCVCGCGV\r\nVRCCCGCRRGVCGCRVVCVGCGCV\r\n```\r\n\r\nThen if asked for Alice's plants, it should provide:\r\n\r\n- Violets, radishes, violets, radishes\r\n\r\nWhile asking for Bob's plants would yield:\r\n\r\n- Clover, grass, clover, clover\r\n",
    "hints": ""
  },
  "starter_code": "package kindergarten\r\n\r\n// Define the Garden type here.\r\n\r\n// The diagram argument starts each row with a '\\n'.  This allows Go's\r\n// raw string literals to present diagrams in source code nicely as two\r\n// rows flush left, for example,\r\n//\r\n//     diagram := `\r\n//     VVCCGG\r\n//     VVCCGG`\r\n\r\nfunc NewGarden(diagram string, children []string) (*Garden, error) {\r\n\tpanic(\"Please implement the NewGarden function\")\r\n}\r\n\r\nfunc (g *Garden) Plants(child string) ([]string, bool) {\r\n\tpanic(\"Please implement the Plants function\")\r\n}\r\n",
  "tests": "package kindergarten\r\n\r\nimport (\r\n\t\"reflect\"\r\n\t\"sort\"\r\n\t\"testing\"\r\n)\r\n\r\ntype lookup struct {\r\n\tchild  string\r\n\tplants []string\r\n\tok     bool\r\n}\r\n\r\ntype gardenTest struct {\r\n\tdescription string\r\n\tdiagram     string\r\n\tchildren    []string\r\n\texpectError bool\r\n\tlookups     []lookup\r\n}\r\n\r\nvar tests = []gardenTest{\r\n\t{\r\n\t\tdescription: \"garden with single student\",\r\n\t\tdiagram:     \"\\nRC\\nGG\",\r\n\t\tchildren:    []string{\"Alice\"},\r\n\t\texpectError: false,\r\n\t\tlookups:     []lookup{{child: \"Alice\", plants: []string{\"radishes\", \"clover\", \"grass\", \"grass\"}, ok: true}},\r\n\t},\r\n\t{\r\n\t\tdescription: \"different garden with single student\",\r\n\t\tdiagram:     \"\\nVC\\nRC\",\r\n\t\tchildren:    []string{\"Alice\"},\r\n\t\texpectError: false,\r\n\t\tlookups:     []lookup{{child: \"Alice\", plants: []string{\"violets\", \"clover\", \"radishes\", \"clover\"}, ok: true}},\r\n\t},\r\n\t{\r\n\t\tdescription: \"garden with two students\",\r\n\t\tdiagram:     \"\\nVVCG\\nVVRC\",\r\n\t\tchildren:    []string{\"Alice\", \"Bob\"},\r\n\t\texpectError: false,\r\n\t\tlookups:     []lookup{{child: \"Bob\", plants: []string{\"clover\", \"grass\", \"radishes\", \"clover\"}, ok: true}},\r\n\t},\r\n\t{\r\n\t\tdescription: \"garden with three students\",\r\n\t\tdiagram:     \"\\nVVCCGG\\nVVCCGG\",\r\n\t\tchildren:    []string{\"Alice\", \"Bob\", \"Charlie\"},\r\n\t\texpectError: false,\r\n\t\tlookups: []lookup{\r\n\t\t\t{child: \"Bob\", plants: []string{\"clover\", \"clover\", \"clover\", \"clover\"}, ok: true},\r\n\t\t\t{child: \"Charlie\", plants: []string{\"grass\", \"grass\", \"grass\", \"grass\"}, ok: true},\r\n\t\t},\r\n\t},\r\n\ttest5,\r\n\ttest6,\r\n\t{\r\n\t\tdescription: \"lookup invalid name\",\r\n\t\tdiagram:     \"\\nRC\\nGG\",\r\n\t\tchildren:    []string{\"Alice\"},\r\n\t\texpectError: false,\r\n\t\tlookups:     []lookup{{child: \"Bob\", plants: []string{\"radishes\", \"clover\", \"grass\", \"grass\"}, ok: false}},\r\n\t},\r\n\t// failure tests\r\n\t{\r\n\t\tdescription: \"wrong diagram format\",\r\n\t\tdiagram:     \"RC\\nGG\",\r\n\t\tchildren:    []string{\"Alice\"},\r\n\t\texpectError: true,\r\n\t\tlookups:     nil,\r\n\t},\r\n\t{\r\n\t\tdescription: \"mismatched rows\",\r\n\t\tdiagram:     \"\\nRCCC\\nGG\",\r\n\t\tchildren:    []string{\"\"},\r\n\t\texpectError: true,\r\n\t\tlookups:     nil,\r\n\t},\r\n\t{\r\n\t\tdescription: \"odd number of cups\",\r\n\t\tdiagram:     \"\\nRCC\\nGGC\",\r\n\t\tchildren:    []string{\"Alice\"},\r\n\t\texpectError: true,\r\n\t\tlookups:     nil,\r\n\t},\r\n\t{\r\n\t\tdescription: \"duplicate name\",\r\n\t\tdiagram:     \"\\nRCCC\\nGGCC\",\r\n\t\tchildren:    []string{\"Alice\", \"Alice\"},\r\n\t\texpectError: true,\r\n\t\tlookups:     nil,\r\n\t},\r\n\t{\r\n\t\tdescription: \"invalid cup codes\",\r\n\t\tdiagram:     \"\\nrc\\ngg\",\r\n\t\tchildren:    []string{\"Alice\"},\r\n\t\texpectError: true,\r\n\t\tlookups:     nil,\r\n\t},\r\n}\r\n\r\nvar test5 = gardenTest{\r\n\tdescription: \"full garden\",\r\n\tdiagram:     \"\\nVRCGVVRVCGGCCGVRGCVCGCGV\\nVRCCCGCRRGVCGCRVVCVGCGCV\",\r\n\tchildren:    []string{\"Alice\", \"Bob\", \"Charlie\", \"David\", \"Eve\", \"Fred\", \"Ginny\", \"Harriet\", \"Ileana\", \"Joseph\", \"Kincaid\", \"Larry\"},\r\n\texpectError: false,\r\n\tlookups: []lookup{\r\n\t\t{child: \"Alice\", plants: []string{\"violets\", \"radishes\", \"violets\", \"radishes\"}, ok: true},\r\n\t\t{child: \"Bob\", plants: []string{\"clover\", \"grass\", \"clover\", \"clover\"}, ok: true},\r\n\t\t{child: \"Charlie\", plants: []string{\"violets\", \"violets\", \"clover\", \"grass\"}, ok: true},\r\n\t\t{child: \"David\", plants: []string{\"radishes\", \"violets\", \"clover\", \"radishes\"}, ok: true},\r\n\t\t{child: \"Eve\", plants: []string{\"clover\", \"grass\", \"radishes\", \"grass\"}, ok: true},\r\n\t\t{child: \"Fred\", plants: []string{\"grass\", \"clover\", \"violets\", \"clover\"}, ok: true},\r\n\t\t{child: \"Ginny\", plants: []string{\"clover\", \"grass\", \"grass\", \"clover\"}, ok: true},\r\n\t\t{child: \"Harriet\", plants: []string{\"violets\", \"radishes\", \"radishes\", \"violets\"}, ok: true},\r\n\t\t{child: \"Ileana\", plants: []string{\"grass\", \"clover\", \"violets\", \"clover\"}, ok: true},\r\n\t\t{child: \"Joseph\", plants: []string{\"violets\", \"clover\", \"violets\", \"grass\"}, ok: true},\r\n\t\t{child: \"Kincaid\", plants: []string{\"grass\", \"clover\", \"clover\", \"grass\"}, ok: true},\r\n\t\t{child: \"Larry\", plants: []string{\"grass\", \"violets\", \"clover\", \"violets\"}, ok: true},\r\n\t},\r\n}\r\n\r\nvar (\r\n\ttest6names = []string{\"Samantha\", \"Patricia\", \"Xander\", \"Roger\"}\r\n\ttest6      = gardenTest{\r\n\t\tdescription: \"names out of order\",\r\n\t\tdiagram:     \"\\nVCRRGVRG\\nRVGCCGCV\",\r\n\t\tchildren:    test6names,\r\n\t\texpectError: false,\r\n\t\tlookups: []lookup{\r\n\t\t\t{child: \"Patricia\", plants: []string{\"violets\", \"clover\", \"radishes\", \"violets\"}, ok: true},\r\n\t\t\t{child: \"Roger\", plants: []string{\"radishes\", \"radishes\", \"grass\", \"clover\"}, ok: true},\r\n\t\t\t{child: \"Samantha\", plants: []string{\"grass\", \"violets\", \"clover\", \"grass\"}, ok: true},\r\n\t\t\t{child: \"Xander\", plants: []string{\"radishes\", \"grass\", \"clover\", \"violets\"}, ok: true},\r\n\t\t},\r\n\t}\r\n)\r\n\r\nfunc TestGarden(t *testing.T) {\r\n\tfor _, test := range tests {\r\n\t\tt.Run(test.description, func(t *testing.T) {\r\n\t\t\tactual, err := NewGarden(test.diagram, test.children)\r\n\t\t\tswitch {\r\n\t\t\tcase test.expectError:\r\n\t\t\t\tif err == nil {\r\n\t\t\t\t\tt.Fatal(\"NewGarden expected error but got nil\")\r\n\t\t\t\t}\r\n\t\t\tcase err != nil:\r\n\t\t\t\tt.Fatalf(\"NewGarden returned unexpected error: %v \", err)\r\n\t\t\t}\r\n\t\t\tfor _, l := range test.lookups {\r\n\t\t\t\tswitch plants, ok := actual.Plants(l.child); {\r\n\t\t\t\tcase ok != l.ok:\r\n\t\t\t\t\tt.Fatalf(\"Lookup %s returned ok = %t, want %t\", l.child, ok, l.ok)\r\n\t\t\t\tcase ok && !reflect.DeepEqual(plants, l.plants):\r\n\t\t\t\t\tt.Fatalf(\"Lookup %s = %q, want: %q\", l.child, plants, l.plants)\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t})\r\n\t}\r\n}\r\n\r\n// The lazy way to meet the alphabetizing requirement is with sort.Strings\r\n// on the argument slice.  That's an in-place sort though and it's bad practice\r\n// to have a side effect.\r\nfunc TestNamesNotModified(t *testing.T) {\r\n\tcp := append([]string{}, test6names...)\r\n\t_, err := NewGarden(test6.diagram, cp)\r\n\tif err != nil || sort.StringsAreSorted(cp) {\r\n\t\tt.Fatalf(\"error in test setup: TestNamesNotModified requires valid garden and unsorted children\")\r\n\t}\r\n\tif !reflect.DeepEqual(cp, test6names) {\r\n\t\tt.Fatalf(\"NewGarden modified children argment. Arguments should not be modified.\")\r\n\t}\r\n}\r\n\r\n// A test taken from the Ruby tests.  It checks that Garden objects\r\n// are self-contained and do not rely on package variables.\r\nfunc TestTwoGardens(t *testing.T) {\r\n\tdiagram := `\r\nVCRRGVRG\r\nRVGCCGCV`\r\n\tg1, err1 := NewGarden(diagram, []string{\"Alice\", \"Bob\", \"Charlie\", \"Dan\"})\r\n\tg2, err2 := NewGarden(diagram, []string{\"Bob\", \"Charlie\", \"Dan\", \"Erin\"})\r\n\tif err1 != nil || err2 != nil {\r\n\t\tt.Fatalf(\"error in test setup: Two garden test needs valid gardens\")\r\n\t}\r\n\ttf := func(g *Garden, n int, child string, expPlants []string) {\r\n\t\tswitch plants, ok := g.Plants(child); {\r\n\t\tcase !ok:\r\n\t\t\tt.Fatalf(\"error in test setup: Garden %d lookup %s returned ok = false, want true. Check if the child exists in the garden\", n, child)\r\n\t\tcase !reflect.DeepEqual(plants, expPlants):\r\n\t\t\tt.Fatalf(\"Garden %d lookup %s = %q, want %q.\",\r\n\t\t\t\tn, child, plants, expPlants)\r\n\t\t}\r\n\t}\r\n\ttf(g1, 1, \"Bob\", []string{\"radishes\", \"radishes\", \"grass\", \"clover\"})\r\n\ttf(g2, 2, \"Bob\", []string{\"violets\", \"clover\", \"radishes\", \"violets\"})\r\n\ttf(g1, 1, \"Charlie\", []string{\"grass\", \"violets\", \"clover\", \"grass\"})\r\n\ttf(g2, 2, \"Charlie\", []string{\"radishes\", \"radishes\", \"grass\", \"clover\"})\r\n}\r\n\r\nfunc BenchmarkNewGarden(b *testing.B) {\r\n\tif testing.Short() {\r\n\t\tb.Skip(\"skipping benchmark in short mode.\")\r\n\t}\r\n\tfor i := 0; i < b.N; i++ {\r\n\t\tfor _, test := range tests {\r\n\t\t\tNewGarden(test.diagram, test.children)\r\n\t\t}\r\n\t}\r\n}\r\n\r\nfunc BenchmarkGarden_Plants(b *testing.B) {\r\n\tif testing.Short() {\r\n\t\tb.Skip(\"skipping benchmark in short mode.\")\r\n\t}\r\n\tg, err := NewGarden(test5.diagram, test5.children)\r\n\tif err != nil {\r\n\t\tb.Fatalf(\"error in benchmark setup: BenchmarkGarden_Plants requires valid garden\")\r\n\t}\r\n\tb.ResetTimer()\r\n\tfor i := 0; i < b.N; i++ {\r\n\t\tfor _, l := range test5.lookups {\r\n\t\t\tg.Plants(l.child)\r\n\t\t}\r\n\t}\r\n}\r\n"
}