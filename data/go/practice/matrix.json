{
  "language": "go",
  "type": "practice",
  "slug": "matrix",
  "title": "Matrix",
  "docs": {
    "instructions": "# Instructions\r\n\r\nGiven a string representing a matrix of numbers, return the rows and columns of that matrix.\r\n\r\nSo given a string with embedded newlines like:\r\n\r\n```text\r\n9 8 7\r\n5 3 2\r\n6 6 7\r\n```\r\n\r\nrepresenting this matrix:\r\n\r\n```text\r\n    1  2  3\r\n  |---------\r\n1 | 9  8  7\r\n2 | 5  3  2\r\n3 | 6  6  7\r\n```\r\n\r\nyour code should be able to spit out:\r\n\r\n- A list of the rows, reading each row left-to-right while moving top-to-bottom across the rows,\r\n- A list of the columns, reading each column top-to-bottom while moving from left-to-right.\r\n\r\nThe rows for our example matrix:\r\n\r\n- 9, 8, 7\r\n- 5, 3, 2\r\n- 6, 6, 7\r\n\r\nAnd its columns:\r\n\r\n- 9, 5, 6\r\n- 8, 3, 6\r\n- 7, 2, 7\r\n",
    "hints": ""
  },
  "starter_code": "package matrix\r\n\r\n// Define the Matrix type here.\r\n\r\nfunc New(s string) (Matrix, error) {\r\n\tpanic(\"Please implement the New function\")\r\n}\r\n\r\n// Cols and Rows must return the results without affecting the matrix.\r\nfunc (m Matrix) Cols() [][]int {\r\n\tpanic(\"Please implement the Cols function\")\r\n}\r\n\r\nfunc (m Matrix) Rows() [][]int {\r\n\tpanic(\"Please implement the Rows function\")\r\n}\r\n\r\nfunc (m Matrix) Set(row, col, val int) bool {\r\n\tpanic(\"Please implement the Set function\")\r\n}\r\n",
  "tests": "package matrix\r\n\r\nimport (\r\n\t\"reflect\"\r\n\t\"testing\"\r\n)\r\n\r\ntype testCase struct {\r\n\tdescription string\r\n\tin          string\r\n\tok          bool\r\n\trows        [][]int\r\n\tcols        [][]int\r\n}\r\n\r\nvar validTestCases = []testCase{\r\n\t{\r\n\t\tdescription: \"2 rows, 2 columns\",\r\n\t\tin:          \"1 2\\n10 20\",\r\n\t\tok:          true,\r\n\t\trows: [][]int{\r\n\t\t\t{1, 2},\r\n\t\t\t{10, 20},\r\n\t\t},\r\n\t\tcols: [][]int{\r\n\t\t\t{1, 10},\r\n\t\t\t{2, 20},\r\n\t\t},\r\n\t},\r\n\t{\r\n\t\tdescription: \"2 rows, 2 columns\",\r\n\t\tin:          \"9 7\\n8 6\",\r\n\t\tok:          true,\r\n\t\trows: [][]int{\r\n\t\t\t{9, 7},\r\n\t\t\t{8, 6},\r\n\t\t},\r\n\t\tcols: [][]int{\r\n\t\t\t{9, 8},\r\n\t\t\t{7, 6},\r\n\t\t},\r\n\t},\r\n\t{\r\n\t\tdescription: \"2 rows, 3 columns\",\r\n\t\tin:          \"9 8 7\\n19 18 17\",\r\n\t\tok:          true,\r\n\t\trows: [][]int{\r\n\t\t\t{9, 8, 7},\r\n\t\t\t{19, 18, 17},\r\n\t\t},\r\n\t\tcols: [][]int{\r\n\t\t\t{9, 19},\r\n\t\t\t{8, 18},\r\n\t\t\t{7, 17},\r\n\t\t},\r\n\t},\r\n\t{\r\n\t\tdescription: \"2 rows, 3 columns\",\r\n\t\tin:          \"1 4 9\\n16 25 36\",\r\n\t\tok:          true,\r\n\t\trows: [][]int{\r\n\t\t\t{1, 4, 9},\r\n\t\t\t{16, 25, 36},\r\n\t\t},\r\n\t\tcols: [][]int{\r\n\t\t\t{1, 16},\r\n\t\t\t{4, 25},\r\n\t\t\t{9, 36},\r\n\t\t},\r\n\t},\r\n\t{\r\n\t\tdescription: \"4 rows, 3 columns\",\r\n\t\tin:          \"1 2 3\\n4 5 6\\n7 8 9\\n 8 7 6\",\r\n\t\tok:          true,\r\n\t\trows: [][]int{\r\n\t\t\t{1, 2, 3},\r\n\t\t\t{4, 5, 6},\r\n\t\t\t{7, 8, 9},\r\n\t\t\t{8, 7, 6},\r\n\t\t},\r\n\t\tcols: [][]int{\r\n\t\t\t{1, 4, 7, 8},\r\n\t\t\t{2, 5, 8, 7},\r\n\t\t\t{3, 6, 9, 6},\r\n\t\t},\r\n\t},\r\n\t{\r\n\t\tdescription: \"3 rows, 3 columns\",\r\n\t\tin:          \"89 1903 3\\n18 3 1\\n9 4 800\",\r\n\t\tok:          true,\r\n\t\trows: [][]int{\r\n\t\t\t{89, 1903, 3},\r\n\t\t\t{18, 3, 1},\r\n\t\t\t{9, 4, 800},\r\n\t\t},\r\n\t\tcols: [][]int{\r\n\t\t\t{89, 18, 9},\r\n\t\t\t{1903, 3, 4},\r\n\t\t\t{3, 1, 800},\r\n\t\t},\r\n\t},\r\n\t{\r\n\t\tdescription: \"1 row, 3 columns\",\r\n\t\tin:          \"1 2 3\",\r\n\t\tok:          true,\r\n\t\trows: [][]int{\r\n\t\t\t{1, 2, 3},\r\n\t\t},\r\n\t\tcols: [][]int{\r\n\t\t\t{1},\r\n\t\t\t{2},\r\n\t\t\t{3},\r\n\t\t},\r\n\t},\r\n\t{\r\n\t\tdescription: \"3 rows, 1 column\",\r\n\t\tin:          \"1\\n2\\n3\",\r\n\t\tok:          true,\r\n\t\trows: [][]int{\r\n\t\t\t{1},\r\n\t\t\t{2},\r\n\t\t\t{3},\r\n\t\t},\r\n\t\tcols: [][]int{\r\n\t\t\t{1, 2, 3},\r\n\t\t},\r\n\t},\r\n\t{\r\n\t\tdescription: \"1 row, 1 column\",\r\n\t\tin:          \"0\",\r\n\t\tok:          true,\r\n\t\trows: [][]int{\r\n\t\t\t{0},\r\n\t\t},\r\n\t\tcols: [][]int{\r\n\t\t\t{0},\r\n\t\t},\r\n\t},\r\n\t// undefined\r\n\t// {\"\\n\\n\", // valid?, 3 rows, 0 columns\r\n\t// {\"\",     // valid?, 0 rows, 0 columns\r\n}\r\n\r\nvar invalidTestCases = []testCase{\r\n\t{description: \"int64 overflow\", in: \"9223372036854775808\", ok: false, rows: nil, cols: nil},\r\n\t{description: \"uneven rows\", in: \"1 2\\n10 20 30\", ok: false, rows: nil, cols: nil},\r\n\t{description: \"first row empty\", in: \"\\n3 4\\n5 6\", ok: false, rows: nil, cols: nil},\r\n\t{description: \"middle row empty\", in: \"1 2\\n\\n5 6\", ok: false, rows: nil, cols: nil},\r\n\t{description: \"last row empty\", in: \"1 2\\n3 4\\n\", ok: false, rows: nil, cols: nil},\r\n\t{description: \"non integer\", in: \"2.7\", ok: false, rows: nil, cols: nil},\r\n\t{description: \"non numeric\", in: \"cat\", ok: false, rows: nil, cols: nil},\r\n}\r\n\r\nfunc TestNew(t *testing.T) {\r\n\tfor _, tc := range append(validTestCases, invalidTestCases...) {\r\n\t\tt.Run(tc.description, func(t *testing.T) {\r\n\t\t\tgot, err := New(tc.in)\r\n\t\t\tswitch {\r\n\t\t\tcase !tc.ok:\r\n\t\t\t\tif err == nil {\r\n\t\t\t\t\tt.Fatalf(\"New(%q) expected error, got: %v\", tc.in, got)\r\n\t\t\t\t}\r\n\t\t\tcase err != nil:\r\n\t\t\t\tt.Fatalf(\"New(%q) returned error %q.  Error not expected\", tc.in, err)\r\n\t\t\tcase got == nil:\r\n\t\t\t\tt.Fatalf(\"New(%q) = %v, want non-nil *Matrix\", tc.in, got)\r\n\t\t\t}\r\n\t\t})\r\n\t}\r\n}\r\n\r\nfunc TestRows(t *testing.T) {\r\n\tfor _, tc := range validTestCases {\r\n\t\tt.Run(tc.description, func(t *testing.T) {\r\n\t\t\tgot, err := New(tc.in)\r\n\t\t\tif err != nil {\r\n\t\t\t\tt.Fatalf(\"error in test setup: TestRows needs working New and valid matrix\")\r\n\t\t\t}\r\n\t\t\trows := got.Rows()\r\n\t\t\tif len(rows) == 0 && len(tc.rows) == 0 {\r\n\t\t\t\treturn // agreement, and nothing more to test\r\n\t\t\t}\r\n\t\t\tif !reflect.DeepEqual(rows, tc.rows) {\r\n\t\t\t\tt.Fatalf(\"New(%q).Rows() = %v (type %T), want: %v (type %T)\", tc.in, rows, rows, tc.rows, tc.rows)\r\n\t\t\t}\r\n\t\t\tif len(rows[0]) == 0 {\r\n\t\t\t\treturn // not currently in test data, but anyway\r\n\t\t\t}\r\n\t\t\trows[0][0]++\r\n\t\t\tif !reflect.DeepEqual(got.Rows(), tc.rows) {\r\n\t\t\t\tt.Fatalf(\"Matrix.Rows() returned slice based on Matrix representation. Want independent copy of element data.\")\r\n\t\t\t}\r\n\t\t})\r\n\t}\r\n}\r\n\r\nfunc TestCols(t *testing.T) {\r\n\tfor _, tc := range validTestCases {\r\n\t\tt.Run(tc.description, func(t *testing.T) {\r\n\t\t\tm, err := New(tc.in)\r\n\t\t\tif err != nil {\r\n\t\t\t\tt.Fatalf(\"error in test setup: TestCols needs working New and valid matrix\")\r\n\t\t\t}\r\n\t\t\tcols := m.Cols()\r\n\t\t\tif len(cols) == 0 && len(tc.cols) == 0 {\r\n\t\t\t\treturn // agreement, and nothing more to test\r\n\t\t\t}\r\n\t\t\tif !reflect.DeepEqual(cols, tc.cols) {\r\n\t\t\t\tt.Fatalf(\"New(%q).Cols() = %v (type %T), want: %v (type %T)\", tc.in, cols, cols, tc.cols, tc.cols)\r\n\t\t\t}\r\n\t\t\tif len(cols[0]) == 0 {\r\n\t\t\t\treturn // not currently in test data, but anyway\r\n\t\t\t}\r\n\t\t\tcols[0][0]++\r\n\t\t\tif !reflect.DeepEqual(m.Cols(), tc.cols) {\r\n\t\t\t\tt.Fatalf(\"Matrix.Cols() returned slice based on Matrix representation. Want independent copy of element data.\")\r\n\t\t\t}\r\n\t\t})\r\n\t}\r\n}\r\n\r\nfunc TestSet(t *testing.T) {\r\n\ts := \"1 2 3\\n4 5 6\\n7 8 9\"\r\n\tm, err := New(s)\r\n\tif err != nil {\r\n\t\tt.Fatalf(\"error in test setup: TestSet needs working New and valid matrix\")\r\n\t}\r\n\txr := [][]int{{1, 2, 3}, {4, 5, 6}, {7, 8, 9}}\r\n\tif !reflect.DeepEqual(m.Rows(), xr) {\r\n\t\tt.Fatalf(\"error in test setup: TestSet needs working Rows\")\r\n\t}\r\n\txc := [][]int{{1, 4, 7}, {2, 5, 8}, {3, 6, 9}}\r\n\tif !reflect.DeepEqual(m.Cols(), xc) {\r\n\t\tt.Fatalf(\"error in test setup: TestSet needs working Cols and valid matrix\")\r\n\t}\r\n\t// test each corner, each side, and an interior element\r\n\tfor r := 0; r < 3; r++ {\r\n\t\tfor c := 0; c < 3; c++ {\r\n\t\t\tm, _ = New(s)\r\n\t\t\tval := 10 + r*3 + c\r\n\t\t\tif ok := m.Set(r, c, val); !ok {\r\n\t\t\t\tt.Fatalf(\"Matrix(%q).Set(%d, %d, %d) returned !ok, want ok.\",\r\n\t\t\t\t\ts, r, c, val)\r\n\t\t\t}\r\n\t\t\txr = [][]int{{1, 2, 3}, {4, 5, 6}, {7, 8, 9}}\r\n\t\t\txc = [][]int{{1, 4, 7}, {2, 5, 8}, {3, 6, 9}}\r\n\t\t\txr[r][c] = val\r\n\t\t\txc[c][r] = val\r\n\t\t\tif res := m.Rows(); !reflect.DeepEqual(res, xr) {\r\n\t\t\t\tt.Fatalf(\"Matrix(%q).Set(%d, %d, %d), Rows() = %v, want %v\",\r\n\t\t\t\t\ts, r, c, val, res, xr)\r\n\t\t\t}\r\n\t\t\tif res := m.Cols(); !reflect.DeepEqual(res, xc) {\r\n\t\t\t\tt.Fatalf(\"Matrix(%q).Set(%d, %d, %d), Cols() = %v, want %v\",\r\n\t\t\t\t\ts, r, c, val, res, xc)\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\t// test 1 and 2 off each corner and side\r\n\tm, _ = New(s)\r\n\tfor _, r := range []int{-2, -1, 0, 3, 4} {\r\n\t\tfor _, c := range []int{-2, -1, 0, 3, 4} {\r\n\t\t\tif r == 0 && c == 0 {\r\n\t\t\t\tcontinue\r\n\t\t\t}\r\n\t\t\tif ok := m.Set(r, c, 0); ok {\r\n\t\t\t\tt.Fatalf(\"Matrix(%q).Set(%d, %d, 0) = ok, want !ok\", s, r, c)\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n}\r\n\r\nfunc BenchmarkNew(b *testing.B) {\r\n\tif testing.Short() {\r\n\t\tb.Skip(\"skipping benchmark in short mode.\")\r\n\t}\r\n\tvar matrix Matrix\r\n\tfor i := 0; i < b.N; i++ {\r\n\t\tvar err error\r\n\t\tmatrix, err = New(\"1 2 3 10 11\\n4 5 6 11 12\\n7 8 9 12 13\\n 8 7 6 13 14\")\r\n\t\tif err != nil {\r\n\t\t\tb.Fatalf(\"Failed to create the matrix: %v\", err)\r\n\t\t}\r\n\t}\r\n\tif matrix == nil {\r\n\t\tb.Fatalf(\"No matrix parsed\")\r\n\t}\r\n}\r\n\r\nfunc BenchmarkRows(b *testing.B) {\r\n\tif testing.Short() {\r\n\t\tb.Skip(\"skipping benchmark in short mode.\")\r\n\t}\r\n\tmatrix, err := New(\"1 2 3\\n4 5 6\\n7 8 9\\n 8 7 6\")\r\n\tif err != nil {\r\n\t\tb.Fatalf(\"Failed to create the matrix: %v\", err)\r\n\t}\r\n\tb.ResetTimer()\r\n\tvar rows [][]int\r\n\tfor i := 0; i < b.N; i++ {\r\n\t\trows = matrix.Rows()\r\n\t}\r\n\tif len(rows) != 4 {\r\n\t\tb.Fatalf(\"Incorrect number of rows returned: %v\", rows)\r\n\t}\r\n}\r\n\r\nfunc BenchmarkCols(b *testing.B) {\r\n\tif testing.Short() {\r\n\t\tb.Skip(\"skipping benchmark in short mode.\")\r\n\t}\r\n\tmatrix, err := New(\"1 2 3 10 11\\n4 5 6 11 12\\n7 8 9 12 13\\n 8 7 6 13 14\")\r\n\tif err != nil {\r\n\t\tb.Fatalf(\"Failed to create the matrix: %v\", err)\r\n\t}\r\n\tb.ResetTimer()\r\n\tvar cols [][]int\r\n\tfor i := 0; i < b.N; i++ {\r\n\t\tcols = matrix.Cols()\r\n\t}\r\n\tif len(cols) != 5 {\r\n\t\tb.Fatalf(\"Incorrect number of columns returned: %v\", cols)\r\n\t}\r\n}\r\n"
}