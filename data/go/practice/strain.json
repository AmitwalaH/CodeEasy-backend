{
  "language": "go",
  "type": "practice",
  "slug": "strain",
  "title": "Strain",
  "docs": {
    "instructions": "# Instructions\r\n\r\nImplement the `keep` and `discard` operation on collections.\r\nGiven a collection and a predicate on the collection's elements, `keep` returns a new collection containing those elements where the predicate is true, while `discard` returns a new collection containing those elements where the predicate is false.\r\n\r\nFor example, given the collection of numbers:\r\n\r\n- 1, 2, 3, 4, 5\r\n\r\nAnd the predicate:\r\n\r\n- is the number even?\r\n\r\nThen your keep operation should produce:\r\n\r\n- 2, 4\r\n\r\nWhile your discard operation should produce:\r\n\r\n- 1, 3, 5\r\n\r\nNote that the union of keep and discard is all the elements.\r\n\r\nThe functions may be called `keep` and `discard`, or they may need different names in order to not clash with existing functions or concepts in your language.\r\n\r\n## Restrictions\r\n\r\nKeep your hands off that filter/reject/whatchamacallit functionality provided by your standard library!\r\nSolve this one yourself using other basic tools instead.\r\n",
    "hints": ""
  },
  "starter_code": "package strain\r\n\r\n// Implement the \"Keep\" and \"Discard\" function in this file.\r\n\r\n// You will need typed parameters (aka \"Generics\") to solve this exercise.\r\n// They are not part of the Exercism syllabus yet but you can learn about\r\n// them here: https://go.dev/tour/generics/1\r\n",
  "tests": "package strain\r\n\r\nimport (\r\n\t\"reflect\"\r\n\t\"strings\"\r\n\t\"testing\"\r\n)\r\n\r\ntype testCase[T any] struct {\r\n\tdescription string\r\n\tfilterFunc  func(T) bool\r\n\tlist        []T\r\n\texpected    []T\r\n}\r\n\r\nvar keepIntTests = []testCase[int]{\r\n\t{\r\n\t\tdescription: \"keep on empty list returns empty list\",\r\n\t\tfilterFunc:  func(int) bool { return true },\r\n\t\tlist:        []int{},\r\n\t\texpected:    []int{},\r\n\t},\r\n\t{\r\n\t\tdescription: \"keeps everything\",\r\n\t\tfilterFunc:  func(int) bool { return true },\r\n\t\tlist:        []int{1, 3, 5},\r\n\t\texpected:    []int{1, 3, 5},\r\n\t},\r\n\t{\r\n\t\tdescription: \"keeps nothing\",\r\n\t\tfilterFunc:  func(int) bool { return false },\r\n\t\tlist:        []int{1, 3, 5},\r\n\t\texpected:    []int{},\r\n\t},\r\n\t{\r\n\t\tdescription: \"keeps first and last\",\r\n\t\tfilterFunc:  func(x int) bool { return x%2 == 1 },\r\n\t\tlist:        []int{1, 2, 3},\r\n\t\texpected:    []int{1, 3},\r\n\t},\r\n\t{\r\n\t\tdescription: \"keeps neither first nor last\",\r\n\t\tfilterFunc:  func(x int) bool { return x%2 == 0 },\r\n\t\tlist:        []int{1, 2, 3},\r\n\t\texpected:    []int{2},\r\n\t},\r\n}\r\n\r\nfunc TestKeep(t *testing.T) {\r\n\tfor _, tc := range keepIntTests {\r\n\t\tt.Run(tc.description, func(t *testing.T) {\r\n\t\t\t// setup here copies test.list, preserving the nil value if it is nil\r\n\t\t\t// and making a fresh copy of the underlying array otherwise.\r\n\t\t\tcp := tc.list\r\n\t\t\tif len(cp) != 0 {\r\n\t\t\t\tcp = append([]int{}, cp...)\r\n\t\t\t}\r\n\r\n\t\t\tgot := Keep(cp, tc.filterFunc)\r\n\r\n\t\t\tswitch {\r\n\t\t\tcase len(tc.expected) == 0 && len(got) == 0:\r\n\t\t\t\t// We don't want to make this exercise about nil vs empty slice so we accept both.\r\n\t\t\t\treturn\r\n\t\t\tcase !reflect.DeepEqual(cp, tc.list):\r\n\t\t\t\tt.Fatalf(\"Keep(%#v, fn) should not modify its argument. %#v should stay %#v\", tc.list, cp, tc.list)\r\n\t\t\tcase !reflect.DeepEqual(got, tc.expected):\r\n\t\t\t\tt.Fatalf(\"Keep(%#v, fn)\\n got: %#v\\nwant: %#v\", tc.list, got, tc.expected)\r\n\t\t\t}\r\n\t\t})\r\n\t}\r\n\r\n\tt.Run(\"keeps strings\", func(t *testing.T) {\r\n\t\tzword := func(x string) bool { return strings.HasPrefix(x, \"z\") }\r\n\t\tlist := []string{\"apple\", \"zebra\", \"banana\", \"zombies\", \"cherimoya\", \"zealot\"}\r\n\t\texpected := []string{\"zebra\", \"zombies\", \"zealot\"}\r\n\r\n\t\tcp := append([]string{}, list...) // make copy, as with ints\r\n\t\tgot := Keep(cp, zword)\r\n\r\n\t\tswitch {\r\n\t\tcase !reflect.DeepEqual(cp, list):\r\n\t\t\tt.Fatalf(\"Keep(%#v, fn) should not modify its argument. %#v should stay %#v\", list, cp, list)\r\n\t\tcase !reflect.DeepEqual(got, expected):\r\n\t\t\tt.Fatalf(\"Keep(%#v, fn)\\n got: %#v\\nwant: %#v\", list, got, expected)\r\n\t\t}\r\n\t})\r\n\r\n\tt.Run(\"keeps lists\", func(t *testing.T) {\r\n\t\thas5 := func(list []int) bool {\r\n\t\t\tfor _, entry := range list {\r\n\t\t\t\tif entry == 5 {\r\n\t\t\t\t\treturn true\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\treturn false\r\n\t\t}\r\n\r\n\t\tlist := [][]int{\r\n\t\t\t{1, 2, 3},\r\n\t\t\t{5, 5, 5},\r\n\t\t\t{5, 1, 2},\r\n\t\t\t{2, 1, 2},\r\n\t\t\t{1, 5, 2},\r\n\t\t\t{2, 2, 1},\r\n\t\t\t{1, 2, 5},\r\n\t\t}\r\n\t\texpected := [][]int{\r\n\t\t\t{5, 5, 5},\r\n\t\t\t{5, 1, 2},\r\n\t\t\t{1, 5, 2},\r\n\t\t\t{1, 2, 5},\r\n\t\t}\r\n\r\n\t\tcp := append([][]int{}, list...)\r\n\t\tgot := Keep(cp, has5)\r\n\r\n\t\tswitch {\r\n\t\tcase !reflect.DeepEqual(cp, list):\r\n\t\t\tt.Fatalf(\"Keep(%#v, fn) should not modify its argument. %#v should stay %#v\", list, cp, list)\r\n\t\tcase !reflect.DeepEqual(got, expected):\r\n\t\t\tt.Fatalf(\"Keep(%#v, fn)\\n got: %#v\\nwant: %#v\", list, got, expected)\r\n\t\t}\r\n\t})\r\n}\r\n\r\nvar discardIntTests = []testCase[int]{\r\n\t{\r\n\t\tdescription: \"discard on empty list returns empty list\",\r\n\t\tfilterFunc:  func(int) bool { return true },\r\n\t\tlist:        []int{},\r\n\t\texpected:    []int{},\r\n\t},\r\n\t{\r\n\t\tdescription: \"discards everything\",\r\n\t\tfilterFunc:  func(int) bool { return true },\r\n\t\tlist:        []int{1, 3, 5},\r\n\t\texpected:    []int{},\r\n\t},\r\n\t{\r\n\t\tdescription: \"discards nothing\",\r\n\t\tfilterFunc:  func(int) bool { return false },\r\n\t\tlist:        []int{1, 3, 5},\r\n\t\texpected:    []int{1, 3, 5},\r\n\t},\r\n\t{\r\n\t\tdescription: \"discards first and last\",\r\n\t\tfilterFunc:  func(x int) bool { return x%2 == 1 },\r\n\t\tlist:        []int{1, 2, 3},\r\n\t\texpected:    []int{2},\r\n\t},\r\n\t{\r\n\t\tdescription: \"discards neither first nor last\",\r\n\t\tfilterFunc:  func(x int) bool { return x%2 == 0 },\r\n\t\tlist:        []int{1, 2, 3},\r\n\t\texpected:    []int{1, 3},\r\n\t},\r\n}\r\n\r\nfunc TestDiscard(t *testing.T) {\r\n\tfor _, tc := range discardIntTests {\r\n\t\tt.Run(tc.description, func(t *testing.T) {\r\n\t\t\t// setup here copies test.list, preserving the nil value if it is nil\r\n\t\t\t// and making a fresh copy of the underlying array otherwise.\r\n\t\t\tcp := tc.list\r\n\t\t\tif len(cp) != 0 {\r\n\t\t\t\tcp = append([]int{}, cp...)\r\n\t\t\t}\r\n\r\n\t\t\tgot := Discard(cp, tc.filterFunc)\r\n\r\n\t\t\tswitch {\r\n\t\t\tcase len(tc.expected) == 0 && len(got) == 0:\r\n\t\t\t\t// We don't want to make this exercise about nil vs empty slice so we accept both.\r\n\t\t\t\treturn\r\n\t\t\tcase !reflect.DeepEqual(cp, tc.list):\r\n\t\t\t\tt.Fatalf(\"Discard(%#v, fn) should not modify its argument. %#v should stay %#v\", tc.list, cp, tc.list)\r\n\t\t\tcase !reflect.DeepEqual(got, tc.expected):\r\n\t\t\t\tt.Fatalf(\"Discard(%#v, fn)\\n got: %#v\\nwant: %#v\", tc.list, got, tc.expected)\r\n\t\t\t}\r\n\t\t})\r\n\t}\r\n\r\n\tt.Run(\"discards strings\", func(t *testing.T) {\r\n\t\tzword := func(x string) bool { return strings.HasPrefix(x, \"z\") }\r\n\t\tlist := []string{\"apple\", \"zebra\", \"banana\", \"zombies\", \"cherimoya\", \"zealot\"}\r\n\t\texpected := []string{\"apple\", \"banana\", \"cherimoya\"}\r\n\r\n\t\tcp := append([]string{}, list...) // make copy, as with ints\r\n\t\tgot := Discard(cp, zword)\r\n\r\n\t\tswitch {\r\n\t\tcase !reflect.DeepEqual(cp, list):\r\n\t\t\tt.Fatalf(\"Discard(%#v, fn) should not modify its argument. %#v should stay %#v\", list, cp, list)\r\n\t\tcase !reflect.DeepEqual(got, expected):\r\n\t\t\tt.Fatalf(\"Discard(%#v, fn)\\n got: %#v\\nwant: %#v\", list, got, expected)\r\n\t\t}\r\n\t})\r\n\r\n\tt.Run(\"discards lists\", func(t *testing.T) {\r\n\t\thas5 := func(list []int) bool {\r\n\t\t\tfor _, entry := range list {\r\n\t\t\t\tif entry == 5 {\r\n\t\t\t\t\treturn true\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\treturn false\r\n\t\t}\r\n\r\n\t\tlist := [][]int{\r\n\t\t\t{1, 2, 3},\r\n\t\t\t{5, 5, 5},\r\n\t\t\t{5, 1, 2},\r\n\t\t\t{2, 1, 2},\r\n\t\t\t{1, 5, 2},\r\n\t\t\t{2, 2, 1},\r\n\t\t\t{1, 2, 5},\r\n\t\t}\r\n\t\texpected := [][]int{\r\n\t\t\t{1, 2, 3},\r\n\t\t\t{2, 1, 2},\r\n\t\t\t{2, 2, 1},\r\n\t\t}\r\n\r\n\t\tcp := append([][]int{}, list...)\r\n\t\tgot := Discard(cp, has5)\r\n\r\n\t\tswitch {\r\n\t\tcase !reflect.DeepEqual(cp, list):\r\n\t\t\tt.Fatalf(\"Discard(%#v, fn) should not modify its argument. %#v should stay %#v\", list, cp, list)\r\n\t\tcase !reflect.DeepEqual(got, expected):\r\n\t\t\tt.Fatalf(\"Discard(%#v, fn)\\n got: %#v\\nwant: %#v\", list, got, expected)\r\n\t\t}\r\n\t})\r\n}\r\n\r\nfunc BenchmarkKeep(b *testing.B) {\r\n\tif testing.Short() {\r\n\t\tb.Skip(\"skipping benchmark in short mode.\")\r\n\t}\r\n\tfor i := 0; i < b.N; i++ {\r\n\t\tfor _, test := range keepIntTests {\r\n\t\t\tKeep(test.list, test.filterFunc)\r\n\t\t}\r\n\t}\r\n}\r\n\r\nfunc BenchmarkDiscard(b *testing.B) {\r\n\tif testing.Short() {\r\n\t\tb.Skip(\"skipping benchmark in short mode.\")\r\n\t}\r\n\tfor i := 0; i < b.N; i++ {\r\n\t\tfor _, test := range keepIntTests {\r\n\t\t\tDiscard(test.list, test.filterFunc)\r\n\t\t}\r\n\t}\r\n}\r\n"
}