{
  "language": "go",
  "type": "practice",
  "slug": "paasio",
  "title": "Paasio",
  "docs": {
    "instructions": "# Instructions\r\n\r\nReport network IO statistics.\r\n\r\nYou are writing a [PaaS][paas], and you need a way to bill customers based on network and filesystem usage.\r\n\r\nCreate a wrapper for network connections and files that can report IO statistics.\r\nThe wrapper must report:\r\n\r\n- The total number of bytes read/written.\r\n- The total number of read/write operations.\r\n\r\n[paas]: https://en.wikipedia.org/wiki/Platform_as_a_service\r\n",
    "hints": ""
  },
  "starter_code": "package paasio\r\n\r\nimport \"io\"\r\n\r\n// Define readCounter and writeCounter types here.\r\n\r\n// For the return of the function NewReadWriteCounter, you must also define a type that satisfies the ReadWriteCounter interface.\r\n\r\nfunc NewWriteCounter(writer io.Writer) WriteCounter {\r\n\tpanic(\"Please implement the NewWriterCounter function\")\r\n}\r\n\r\nfunc NewReadCounter(reader io.Reader) ReadCounter {\r\n\tpanic(\"Please implement the NewReadCounter function\")\r\n}\r\n\r\nfunc NewReadWriteCounter(readwriter io.ReadWriter) ReadWriteCounter {\r\n\tpanic(\"Please implement the NewReadWriteCounter function\")\r\n}\r\n\r\nfunc (rc *readCounter) Read(p []byte) (int, error) {\r\n\tpanic(\"Please implement the Read function\")\r\n}\r\n\r\nfunc (rc *readCounter) ReadCount() (int64, int) {\r\n\tpanic(\"Please implement the ReadCount function\")\r\n}\r\n\r\nfunc (wc *writeCounter) Write(p []byte) (int, error) {\r\n\tpanic(\"Please implement the Write function\")\r\n}\r\n\r\nfunc (wc *writeCounter) WriteCount() (int64, int) {\r\n\tpanic(\"Please implement the WriteCount function\")\r\n}\r\n",
  "tests": "package paasio\r\n\r\nimport (\r\n\t\"bytes\"\r\n\t\"crypto/rand\"\r\n\t\"io\"\r\n\t\"runtime\"\r\n\t\"strings\"\r\n\t\"sync\"\r\n\t\"testing\"\r\n\t\"time\"\r\n)\r\n\r\nfunc TestMultiThreaded(t *testing.T) {\r\n\tmincpu := 2\r\n\tminproc := 2\r\n\tncpu := runtime.NumCPU()\r\n\tif ncpu < mincpu {\r\n\t\tt.Fatalf(\"at least %d cpu cores are required\", mincpu)\r\n\t}\r\n\tnproc := runtime.GOMAXPROCS(0)\r\n\tif nproc < minproc {\r\n\t\tt.Errorf(\"at least %d threads are required; rerun the tests\", minproc)\r\n\t\tt.Errorf(\"\")\r\n\t\tt.Errorf(\"\\tgo test -cpu %d ...\", minproc)\r\n\t}\r\n}\r\n\r\n// this test could be improved to test that error conditions are preserved.\r\nfunc testWrite(t *testing.T, writer func(io.Writer) WriteCounter) {\r\n\tfor i, test := range []struct {\r\n\t\twrites []string\r\n\t}{\r\n\t\t{nil},\r\n\t\t{[]string{\"\"}},\r\n\t\t{[]string{\"I\", \" \", \"never met \", \"\", \"a gohper\"}},\r\n\t} {\r\n\t\tvar buf bytes.Buffer\r\n\t\tbuft := writer(&buf)\r\n\t\tfor _, s := range test.writes {\r\n\t\t\tn, err := buft.Write([]byte(s))\r\n\t\t\tif err != nil {\r\n\t\t\t\tt.Errorf(\"test %d: Write(%q) unexpected error: %v\", i, s, err)\r\n\t\t\t\tcontinue\r\n\t\t\t}\r\n\t\t\tif n != len(s) {\r\n\t\t\t\tt.Errorf(\"test %d: Write(%q) unexpected number of bytes written: %v\", i, s, n)\r\n\t\t\t\tcontinue\r\n\t\t\t}\r\n\t\t}\r\n\t\tout := buf.String()\r\n\t\tif out != strings.Join(test.writes, \"\") {\r\n\t\t\tt.Errorf(\"test %d: unexpected content in underlying writer: %q\", i, out)\r\n\t\t}\r\n\t}\r\n}\r\n\r\nfunc TestWriteWriter(t *testing.T) {\r\n\ttestWrite(t, NewWriteCounter)\r\n}\r\n\r\nfunc TestWriteReadWriter(t *testing.T) {\r\n\ttestWrite(t, func(w io.Writer) WriteCounter {\r\n\t\tvar r nopReader\r\n\t\treturn NewReadWriteCounter(readWriter{r, w})\r\n\t})\r\n}\r\n\r\n// this test could be improved to test exact number of operations as well as\r\n// ensure that error conditions are preserved.\r\nfunc testRead(t *testing.T, reader func(io.Reader) ReadCounter) {\r\n\tchunkLen := 10 << 20 // 10MB\r\n\torig := make([]byte, 10<<20)\r\n\t_, err := rand.Read(orig)\r\n\tif err != nil {\r\n\t\tt.Fatalf(\"error reading random data\")\r\n\t}\r\n\tbuf := bytes.NewBuffer(orig)\r\n\trc := reader(buf)\r\n\tvar obuf bytes.Buffer\r\n\tncopy, err := io.Copy(&obuf, rc)\r\n\tif err != nil {\r\n\t\tt.Fatalf(\"error reading: %v\", err)\r\n\t}\r\n\tif ncopy != int64(chunkLen) {\r\n\t\tt.Fatalf(\"copied %d bytes instead of %d\", ncopy, chunkLen)\r\n\t}\r\n\tif string(orig) != obuf.String() {\r\n\t\tt.Fatalf(\"unexpected output from Read()\")\r\n\t}\r\n\tn, nops := rc.ReadCount()\r\n\tif n != int64(chunkLen) {\r\n\t\tt.Fatalf(\"reported %d bytes read instead of %d\", n, chunkLen)\r\n\t}\r\n\tif nops < 2 {\r\n\t\tt.Fatalf(\"unexpected number of reads: %v\", nops)\r\n\t}\r\n}\r\n\r\nfunc TestReadReader(t *testing.T) {\r\n\ttestRead(t, NewReadCounter)\r\n}\r\n\r\nfunc TestReadReadWriter(t *testing.T) {\r\n\ttestRead(t, func(r io.Reader) ReadCounter {\r\n\t\tvar w nopWriter\r\n\t\treturn NewReadWriteCounter(readWriter{r, w})\r\n\t})\r\n}\r\n\r\nfunc testReadTotal(t *testing.T, rc ReadCounter) {\r\n\tnumGo := 8000\r\n\tnumBytes := 50\r\n\ttotalBytes := int64(numGo) * int64(numBytes)\r\n\tp := make([]byte, numBytes)\r\n\r\n\tt.Logf(\"Calling Read() for %d*%d=%d bytes\", numGo, numBytes, totalBytes)\r\n\twg := new(sync.WaitGroup)\r\n\twg.Add(numGo)\r\n\tstart := make(chan struct{})\r\n\tfor i := 0; i < numGo; i++ {\r\n\t\tgo func() {\r\n\t\t\t<-start\r\n\t\t\trc.Read(p)\r\n\t\t\twg.Done()\r\n\t\t}()\r\n\t}\r\n\tclose(start)\r\n\r\n\twg.Wait()\r\n\tn, nops := rc.ReadCount()\r\n\tif n != totalBytes {\r\n\t\tt.Errorf(\"expected %d bytes read; %d bytes reported\", totalBytes, n)\r\n\t}\r\n\tif nops != numGo {\r\n\t\tt.Errorf(\"expected %d read operations; %d operations reported\", numGo, nops)\r\n\t}\r\n}\r\n\r\nfunc TestReadTotalReader(t *testing.T) {\r\n\tvar r nopReader\r\n\ttestReadTotal(t, NewReadCounter(r))\r\n}\r\n\r\nfunc TestReadTotalReadWriter(t *testing.T) {\r\n\tvar rw nopReadWriter\r\n\ttestReadTotal(t, NewReadWriteCounter(rw))\r\n}\r\n\r\nfunc testWriteTotal(t *testing.T, wt WriteCounter) {\r\n\tnumGo := 8000\r\n\tnumBytes := 50\r\n\ttotalBytes := int64(numGo) * int64(numBytes)\r\n\tp := make([]byte, numBytes)\r\n\r\n\tt.Logf(\"Calling Write() with %d*%d=%d bytes\", numGo, numBytes, totalBytes)\r\n\twg := new(sync.WaitGroup)\r\n\twg.Add(numGo)\r\n\tstart := make(chan struct{})\r\n\tfor i := 0; i < numGo; i++ {\r\n\t\tgo func() {\r\n\t\t\t<-start\r\n\t\t\twt.Write(p)\r\n\t\t\twg.Done()\r\n\t\t}()\r\n\t}\r\n\tclose(start)\r\n\r\n\twg.Wait()\r\n\tn, nops := wt.WriteCount()\r\n\tif n != totalBytes {\r\n\t\tt.Errorf(\"expected %d bytes written; %d bytes reported\", totalBytes, n)\r\n\t}\r\n\tif nops != numGo {\r\n\t\tt.Errorf(\"expected %d write operations; %d operations reported\", numGo, nops)\r\n\t}\r\n}\r\n\r\nfunc TestWriteTotalWriter(t *testing.T) {\r\n\tvar w nopWriter\r\n\ttestWriteTotal(t, NewWriteCounter(w))\r\n}\r\n\r\nfunc TestWriteTotalReadWriter(t *testing.T) {\r\n\tvar rw nopReadWriter\r\n\ttestWriteTotal(t, NewReadWriteCounter(rw))\r\n}\r\n\r\nfunc TestReadCountConsistencyReader(t *testing.T) {\r\n\tvar r nopReader\r\n\ttestReadCountConsistency(t, NewReadCounter(r))\r\n}\r\n\r\nfunc TestReadCountConsistencyReadWriter(t *testing.T) {\r\n\tvar rw nopReadWriter\r\n\ttestReadCountConsistency(t, NewReadWriteCounter(rw))\r\n}\r\n\r\nfunc testReadCountConsistency(t *testing.T, rc ReadCounter) {\r\n\tconst numGo = 4000\r\n\tconst numBytes = 50\r\n\tp := make([]byte, numBytes)\r\n\r\n\twg := new(sync.WaitGroup)\r\n\twg.Add(2 * numGo)\r\n\tstart := make(chan struct{})\r\n\tfor i := 0; i < numGo; i++ {\r\n\t\tgo func() {\r\n\t\t\t<-start\r\n\t\t\trc.Read(p)\r\n\t\t\twg.Done()\r\n\t\t}()\r\n\t\tgo func() {\r\n\t\t\t<-start\r\n\t\t\tn, nops := rc.ReadCount()\r\n\t\t\texpectedOps := n / numBytes\r\n\t\t\tif int64(nops) != expectedOps {\r\n\t\t\t\tt.Errorf(\"expected %d ops@%d bytes read; %d ops reported\", expectedOps, n, nops)\r\n\t\t\t}\r\n\t\t\twg.Done()\r\n\t\t}()\r\n\t}\r\n\tclose(start)\r\n\twg.Wait()\r\n}\r\n\r\nfunc TestWriteCountConsistencyWriter(t *testing.T) {\r\n\tvar w nopWriter\r\n\ttestWriteCountConsistency(t, NewWriteCounter(w))\r\n}\r\n\r\nfunc TestWriteCountConsistencyReadWriter(t *testing.T) {\r\n\tvar rw nopReadWriter\r\n\ttestWriteCountConsistency(t, NewReadWriteCounter(rw))\r\n}\r\n\r\nfunc testWriteCountConsistency(t *testing.T, wc WriteCounter) {\r\n\tconst numGo = 4000\r\n\tconst numBytes = 50\r\n\tp := make([]byte, numBytes)\r\n\r\n\twg := new(sync.WaitGroup)\r\n\twg.Add(2 * numGo)\r\n\tstart := make(chan struct{})\r\n\tfor i := 0; i < numGo; i++ {\r\n\t\tgo func() {\r\n\t\t\t<-start\r\n\t\t\twc.Write(p)\r\n\t\t\twg.Done()\r\n\t\t}()\r\n\t\tgo func() {\r\n\t\t\t<-start\r\n\t\t\tn, nops := wc.WriteCount()\r\n\t\t\texpectedOps := n / numBytes\r\n\t\t\tif int64(nops) != n/numBytes {\r\n\t\t\t\tt.Errorf(\"expected %d nops@%d bytes written; %d ops reported\", expectedOps, n, nops)\r\n\t\t\t}\r\n\t\t\twg.Done()\r\n\t\t}()\r\n\t}\r\n\tclose(start)\r\n\twg.Wait()\r\n}\r\n\r\ntype nopWriter struct{ error }\r\n\r\nfunc (w nopWriter) Write(p []byte) (int, error) {\r\n\ttime.Sleep(time.Nanosecond)\r\n\tif w.error != nil {\r\n\t\treturn 0, w.error\r\n\t}\r\n\treturn len(p), nil\r\n}\r\n\r\ntype nopReader struct{ error }\r\n\r\nfunc (r nopReader) Read(p []byte) (int, error) {\r\n\ttime.Sleep(time.Nanosecond)\r\n\tif r.error != nil {\r\n\t\treturn 0, r.error\r\n\t}\r\n\treturn len(p), nil\r\n}\r\n\r\ntype nopReadWriter struct {\r\n\tnopReader\r\n\tnopWriter\r\n}\r\n\r\ntype readWriter struct {\r\n\tio.Reader\r\n\tio.Writer\r\n}\r\n"
}