{
  "language": "go",
  "type": "practice",
  "slug": "bowling",
  "title": "Bowling",
  "docs": {
    "instructions": "# Instructions\r\n\r\nScore a bowling game.\r\n\r\nBowling is a game where players roll a heavy ball to knock down pins arranged in a triangle.\r\nWrite code to keep track of the score of a game of bowling.\r\n\r\n## Scoring Bowling\r\n\r\nThe game consists of 10 frames.\r\nA frame is composed of one or two ball throws with 10 pins standing at frame initialization.\r\nThere are three cases for the tabulation of a frame.\r\n\r\n- An open frame is where a score of less than 10 is recorded for the frame.\r\n  In this case the score for the frame is the number of pins knocked down.\r\n\r\n- A spare is where all ten pins are knocked down by the second throw.\r\n  The total value of a spare is 10 plus the number of pins knocked down in their next throw.\r\n\r\n- A strike is where all ten pins are knocked down by the first throw.\r\n  The total value of a strike is 10 plus the number of pins knocked down in the next two throws.\r\n  If a strike is immediately followed by a second strike, then the value of the first strike cannot be determined until the ball is thrown one more time.\r\n\r\nHere is a three frame example:\r\n\r\n|  Frame 1   |  Frame 2   |     Frame 3      |\r\n| :--------: | :--------: | :--------------: |\r\n| X (strike) | 5/ (spare) | 9 0 (open frame) |\r\n\r\nFrame 1 is (10 + 5 + 5) = 20\r\n\r\nFrame 2 is (5 + 5 + 9) = 19\r\n\r\nFrame 3 is (9 + 0) = 9\r\n\r\nThis means the current running total is 48.\r\n\r\nThe tenth frame in the game is a special case.\r\nIf someone throws a spare or a strike then they get one or two fill balls respectively.\r\nFill balls exist to calculate the total of the 10th frame.\r\nScoring a strike or spare on the fill ball does not give the player more fill balls.\r\nThe total value of the 10th frame is the total number of pins knocked down.\r\n\r\nFor a tenth frame of X1/ (strike and a spare), the total value is 20.\r\n\r\nFor a tenth frame of XXX (three strikes), the total value is 30.\r\n\r\n## Requirements\r\n\r\nWrite code to keep track of the score of a game of bowling.\r\nIt should support two operations:\r\n\r\n- `roll(pins : int)` is called each time the player rolls a ball.\r\n  The argument is the number of pins knocked down.\r\n- `score() : int` is called only at the very end of the game.\r\n  It returns the total score for that game.\r\n",
    "hints": ""
  },
  "starter_code": "package bowling\r\n\r\n// Define the Game type here.\r\n\r\nfunc NewGame() *Game {\r\n\tpanic(\"Please implement the NewGame function\")\r\n}\r\n\r\nfunc (g *Game) Roll(pins int) error {\r\n\tpanic(\"Please implement the Roll function\")\r\n}\r\n\r\nfunc (g *Game) Score() (int, error) {\r\n\tpanic(\"Please implement the Score function\")\r\n}\r\n",
  "tests": "package bowling\r\n\r\nimport \"testing\"\r\n\r\nconst previousRollErrorMessage = `\r\n\tUnexpected error occurred: %v\r\n\twhile applying the previous rolls for the\r\n\ttest case: %v\r\n\tThe error was returned from Roll(%d) for previousRolls[%d].`\r\n\r\nfunc applyPreviousRolls(g *Game, rolls []int) (index, pins int, err error) {\r\n\tfor index, pins := range rolls {\r\n\t\tif err := g.Roll(pins); err != nil {\r\n\t\t\treturn index, pins, err\r\n\t\t}\r\n\t}\r\n\treturn 0, 0, nil\r\n}\r\n\r\nfunc TestRoll(t *testing.T) {\r\n\tfor _, tc := range rollTestCases {\r\n\t\tt.Run(tc.description, func(t *testing.T) {\r\n\t\t\tg := NewGame()\r\n\t\t\tindex, pins, err := applyPreviousRolls(g, tc.previousRolls)\r\n\t\t\tif err != nil {\r\n\t\t\t\tt.Fatalf(previousRollErrorMessage, err, tc.previousRolls, pins, index)\r\n\t\t\t}\r\n\t\t\terr = g.Roll(tc.roll)\r\n\t\t\tif tc.valid && err != nil {\r\n\t\t\t\tt.Fatalf(\"Roll(%d) after Previous Rolls: %#v returned unexpected error: %v\", tc.roll, tc.previousRolls, err)\r\n\t\t\t} else if !tc.valid && err == nil {\r\n\t\t\t\tt.Fatalf(\"Roll(%d) after Previous Rolls: %#v expected an error, got nil\\n\\tExplanation: %s\", tc.roll, tc.previousRolls, tc.explainText)\r\n\t\t\t}\r\n\t\t})\r\n\t}\r\n}\r\n\r\nfunc TestScore(t *testing.T) {\r\n\tfor _, tc := range scoreTestCases {\r\n\t\tt.Run(tc.description, func(t *testing.T) {\r\n\t\t\tg := NewGame()\r\n\t\t\tindex, pins, err := applyPreviousRolls(g, tc.previousRolls)\r\n\t\t\tif err != nil {\r\n\t\t\t\tt.Fatalf(previousRollErrorMessage, err, tc.previousRolls, pins, index)\r\n\t\t\t}\r\n\t\t\tscore, err := g.Score()\r\n\t\t\tswitch {\r\n\t\t\tcase !tc.valid:\r\n\t\t\t\tif err == nil {\r\n\t\t\t\t\tt.Fatalf(\"Score() after Previous Rolls: %#v expected an error, got score %d\\n\\tExplanation: %s\", tc.previousRolls, score, tc.explainText)\r\n\t\t\t\t}\r\n\t\t\tcase err != nil:\r\n\t\t\t\tt.Fatalf(\"Score() after Previous Rolls: %#v returned error: %v, want: %d\", tc.previousRolls, err, tc.score)\r\n\t\t\tcase score != tc.score:\r\n\t\t\t\tt.Fatalf(\"Score() after Previous Rolls: %#v = %d, want: %d\", tc.previousRolls, score, tc.score)\r\n\t\t\t}\r\n\t\t})\r\n\t}\r\n}\r\n"
}