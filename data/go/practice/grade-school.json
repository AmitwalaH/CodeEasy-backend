{
  "language": "go",
  "type": "practice",
  "slug": "grade-school",
  "title": "Grade School",
  "docs": {
    "instructions": "# Instructions\r\n\r\nGiven students' names along with the grade they are in, create a roster for the school.\r\n\r\nIn the end, you should be able to:\r\n\r\n- Add a student's name to the roster for a grade:\r\n  - \"Add Jim to grade 2.\"\r\n  - \"OK.\"\r\n- Get a list of all students enrolled in a grade:\r\n  - \"Which students are in grade 2?\"\r\n  - \"We've only got Jim right now.\"\r\n- Get a sorted list of all students in all grades.\r\n  Grades should be sorted as 1, 2, 3, etc., and students within a grade should be sorted alphabetically by name.\r\n  - \"Who is enrolled in school right now?\"\r\n  - \"Let me think.\r\n    We have Anna, Barb, and Charlie in grade 1, Alex, Peter, and Zoe in grade 2, and Jim in grade 5.\r\n    So the answer is: Anna, Barb, Charlie, Alex, Peter, Zoe, and Jim.\"\r\n\r\nNote that all our students only have one name (it's a small town, what do you want?), and each student cannot be added more than once to a grade or the roster.\r\nIf a test attempts to add the same student more than once, your implementation should indicate that this is incorrect.\r\n",
    "hints": ""
  },
  "starter_code": "package school\r\n\r\n// Define the Grade and School types here.\r\n\r\nfunc New() *School {\r\n\tpanic(\"Please implement the New function\")\r\n}\r\n\r\nfunc (s *School) Add(student string, grade int) {\r\n\tpanic(\"Please implement the Add function\")\r\n}\r\n\r\nfunc (s *School) Grade(level int) []string {\r\n\tpanic(\"Please implement the Grade function\")\r\n}\r\n\r\nfunc (s *School) Enrollment() []Grade {\r\n\tpanic(\"Please implement the Enrollment function\")\r\n}\r\n",
  "tests": "//nolint:gosec // In the context of this exercise, it is fine to use math.Rand instead of crypto.Rand.\r\npackage school\r\n\r\nimport (\r\n\t\"fmt\"\r\n\t\"math/rand\"\r\n\t\"strconv\"\r\n\t\"testing\"\r\n)\r\n\r\nfunc TestNewSchoolIsEmpty(t *testing.T) {\r\n\tif len(New().Enrollment()) != 0 {\r\n\t\tt.Error(\"New school not empty\")\r\n\t}\r\n}\r\n\r\nfunc list(e []Grade) (s string) {\r\n\tfor _, l := range e {\r\n\t\ts += fmt.Sprintln(l)\r\n\t}\r\n\treturn s\r\n}\r\n\r\nfunc TestAddStudent(t *testing.T) {\r\n\texp := list([]Grade{{2, []string{\"Aimee\"}}})\r\n\ts := New()\r\n\ts.Add(\"Aimee\", 2)\r\n\tgot := list(s.Enrollment())\r\n\tif got != exp {\r\n\t\tt.Errorf(`Add Aimee level 2, got\r\n%sexpected:\r\n%s`, got, exp)\r\n\t}\r\n}\r\n\r\nfunc TestAddMoreSameGrade(t *testing.T) {\r\n\texp := list([]Grade{{2, []string{\"Blair James Paul\"}}})\r\n\ts := New()\r\n\ts.Add(\"Blair\", 2)\r\n\ts.Add(\"James\", 2)\r\n\ts.Add(\"Paul\", 2)\r\n\tgot := list(s.Enrollment())\r\n\tif got != exp {\r\n\t\tt.Errorf(`Add more same grade, got\r\n%sexpected:\r\n%s`, got, exp)\r\n\t}\r\n}\r\n\r\nfunc TestAddDifferentGrades(t *testing.T) {\r\n\texp := list([]Grade{\r\n\t\t{3, []string{\"Chelsea\"}},\r\n\t\t{7, []string{\"Logan\"}},\r\n\t})\r\n\ts := New()\r\n\ts.Add(\"Chelsea\", 3)\r\n\ts.Add(\"Logan\", 7)\r\n\tgot := list(s.Enrollment())\r\n\tif got != exp {\r\n\t\tt.Errorf(`Add different grades, got\r\n%sexpected:\r\n%s`, got, exp)\r\n\t}\r\n}\r\n\r\nfunc TestGetGrade(t *testing.T) {\r\n\texp := []string{\"Bradley\", \"Franklin\"}\r\n\ts := New()\r\n\ts.Add(\"Bradley\", 5)\r\n\ts.Add(\"Franklin\", 5)\r\n\ts.Add(\"Jeff\", 1)\r\n\tgot := s.Grade(5)\r\n\tif len(got) == len(exp) {\r\n\t\tif got[0] == exp[0] && got[1] == exp[1] ||\r\n\t\t\tgot[0] == exp[1] && got[1] == exp[0] { // accept out of order\r\n\t\t\treturn\r\n\t\t}\r\n\t}\r\n\tt.Errorf(`Get grade, got\r\n%q\r\nexpected\r\n%q`, got, exp)\r\n}\r\n\r\nfunc TestNonExistantGrade(t *testing.T) {\r\n\ts := New()\r\n\tgot := s.Grade(1)\r\n\tif len(got) != 0 {\r\n\t\tt.Errorf(`Get non-existent grade, got\r\n%q\r\nexpected\r\n[]`, got)\r\n\t}\r\n}\r\n\r\nfunc TestSortedEnrollment(t *testing.T) {\r\n\texp := list([]Grade{\r\n\t\t{3, []string{\"Kyle\"}},\r\n\t\t{4, []string{\"Christopher Jennifer\"}},\r\n\t\t{6, []string{\"Kareem\"}},\r\n\t})\r\n\ts := New()\r\n\ts.Add(\"Jennifer\", 4)\r\n\ts.Add(\"Kareem\", 6)\r\n\ts.Add(\"Christopher\", 4)\r\n\ts.Add(\"Kyle\", 3)\r\n\tgot := list(s.Enrollment())\r\n\tif got != exp {\r\n\t\tt.Errorf(`Sorted enrollment, got\r\n%sexpected:\r\n%s`, got, exp)\r\n\t}\r\n}\r\n\r\nconst (\r\n\tminLevel   = 1\r\n\tmaxLevel   = 9\r\n\tenrollment = 400\r\n)\r\n\r\nfunc BenchmarkAddStudents(b *testing.B) {\r\n\tif testing.Short() {\r\n\t\tb.Skip(\"skipping benchmark in short mode.\")\r\n\t}\r\n\tconst pool = 1e6 // pool of students\r\n\tnames := make([]string, pool)\r\n\tlevels := make([]int, pool)\r\n\tfor i := range names {\r\n\t\tnames[i] = strconv.Itoa(rand.Intn(1e5))\r\n\t\tlevels[i] = minLevel + rand.Intn(maxLevel-minLevel+1)\r\n\t}\r\n\tp := 0\r\n\tb.ResetTimer()\r\n\tfor i := 0; i < b.N; i++ {\r\n\t\t// bench combined time to create a school and add\r\n\t\t// a number of students, drawn from a pool of students\r\n\t\ts := New()\r\n\t\tfor t := 0; t < enrollment; t++ {\r\n\t\t\ts.Add(names[p], levels[p])\r\n\t\t\tp = (p + 1) % pool\r\n\t\t}\r\n\t}\r\n}\r\n\r\nfunc BenchmarkEnrollment(b *testing.B) {\r\n\tif testing.Short() {\r\n\t\tb.Skip(\"skipping benchmark in short mode.\")\r\n\t}\r\n\tconst pool = 1000 // pool of schools\r\n\tss := make([]*School, pool)\r\n\tfor i := range ss {\r\n\t\ts := New()\r\n\t\tfor t := 0; t < enrollment; t++ {\r\n\t\t\ts.Add(\r\n\t\t\t\tstrconv.Itoa(rand.Intn(1e5)),\r\n\t\t\t\tminLevel+rand.Intn(maxLevel-minLevel+1))\r\n\t\t}\r\n\t\tss[i] = s\r\n\t}\r\n\tp := 0\r\n\tb.ResetTimer()\r\n\tfor i := 0; i < b.N; i++ {\r\n\t\t// bench time to get enrollment of a full school,\r\n\t\t// averaged over a pool of schools.\r\n\t\tss[p].Enrollment()\r\n\t\tp = (p + 1) % pool\r\n\t}\r\n}\r\n"
}