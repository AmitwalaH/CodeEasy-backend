{
  "language": "go",
  "type": "practice",
  "slug": "palindrome-products",
  "title": "Palindrome Products",
  "docs": {
    "instructions": "# Instructions\r\n\r\nDetect palindrome products in a given range.\r\n\r\nA palindromic number is a number that remains the same when its digits are reversed.\r\nFor example, `121` is a palindromic number but `112` is not.\r\n\r\nGiven a range of numbers, find the largest and smallest palindromes which\r\nare products of two numbers within that range.\r\n\r\nYour solution should return the largest and smallest palindromes, along with the factors of each within the range.\r\nIf the largest or smallest palindrome has more than one pair of factors within the range, then return all the pairs.\r\n\r\n## Example 1\r\n\r\nGiven the range `[1, 9]` (both inclusive)...\r\n\r\nAnd given the list of all possible products within this range:\r\n`[1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 12, 14, 16, 18, 15, 21, 24, 27, 20, 28, 32, 36, 25, 30, 35, 40, 45, 42, 48, 54, 49, 56, 63, 64, 72, 81]`\r\n\r\nThe palindrome products are all single digit numbers (in this case):\r\n`[1, 2, 3, 4, 5, 6, 7, 8, 9]`\r\n\r\nThe smallest palindrome product is `1`.\r\nIts factors are `(1, 1)`.\r\nThe largest palindrome product is `9`.\r\nIts factors are `(1, 9)` and `(3, 3)`.\r\n\r\n## Example 2\r\n\r\nGiven the range `[10, 99]` (both inclusive)...\r\n\r\nThe smallest palindrome product is `121`.\r\nIts factors are `(11, 11)`.\r\nThe largest palindrome product is `9009`.\r\nIts factors are `(91, 99)`.\r\n",
    "hints": ""
  },
  "starter_code": "package palindrome\r\n\r\n// Define Product type here.\r\n\r\nfunc Products(fmin, fmax int) (Product, Product, error) {\r\n\tpanic(\"Please implement the Products function\")\r\n}\r\n",
  "tests": "package palindrome\r\n\r\nimport (\r\n\t\"fmt\"\r\n\t\"reflect\"\r\n\t\"strings\"\r\n\t\"testing\"\r\n)\r\n\r\ntype testCase struct {\r\n\tdescription string\r\n\t// input to Products(): range limits for factors of the palindrome\r\n\tfmin, fmax int\r\n\t// output from Products():\r\n\tpmin, pmax Product // min and max palandromic products\r\n\terrPrefix  string  // start of text if there is an error, \"\" otherwise\r\n}\r\n\r\nvar testCases = []testCase{\r\n\t{\r\n\t\tdescription: \"valid limits 1-9\",\r\n\t\tfmin:        1,\r\n\t\tfmax:        9,\r\n\t\tpmin:        Product{}, // zero value means don't bother to test it\r\n\t\tpmax:        Product{9, [][2]int{{1, 9}, {3, 3}}},\r\n\t\terrPrefix:   \"\",\r\n\t},\r\n\t{\r\n\t\tdescription: \"valid limits 10-99\",\r\n\t\tfmin:        10,\r\n\t\tfmax:        99,\r\n\t\tpmin:        Product{121, [][2]int{{11, 11}}},\r\n\t\tpmax:        Product{9009, [][2]int{{91, 99}}},\r\n\t\terrPrefix:   \"\",\r\n\t},\r\n\t{\r\n\t\tdescription: \"valid limits 100-999\",\r\n\t\tfmin:        100,\r\n\t\tfmax:        999,\r\n\t\tpmin:        Product{10201, [][2]int{{101, 101}}},\r\n\t\tpmax:        Product{906609, [][2]int{{913, 993}}},\r\n\t\terrPrefix:   \"\",\r\n\t},\r\n\t{\r\n\t\tdescription: \"no palindromes\",\r\n\t\tfmin:        4,\r\n\t\tfmax:        10,\r\n\t\tpmin:        Product{},\r\n\t\tpmax:        Product{},\r\n\t\terrPrefix:   \"no palindromes\",\r\n\t},\r\n\t{\r\n\t\tdescription: \"fmin > fmax\",\r\n\t\tfmin:        10,\r\n\t\tfmax:        4,\r\n\t\tpmin:        Product{},\r\n\t\tpmax:        Product{},\r\n\t\terrPrefix:   \"fmin > fmax\",\r\n\t},\r\n}\r\n\r\n// Bonus curiosities. Can a negative number be a palindrome? Most say no.\r\n/*\r\nvar bonusData = []testCase{\r\n\t// The following two test cases have the same input, but different expectations. Uncomment just one or the other.\r\n\t// Here you can test that you can reach the limit of the largest palindrome made of two 2-digit numbers.\r\n\t//{\r\n\t//\tdescription: \"bonus test 1: error for negative limits\",\r\n\t//\tfmin:        -99,\r\n\t//\tfmax:        -10,\r\n\t//\tpmin:        Product{},\r\n\t//\tpmax:        Product{},\r\n\t//\terrPrefix:   \"Negative limits\",\r\n\t//},\r\n\t// You can still get non-negative products from negative factors.\r\n\t{\r\n\t\tdescription: \"bonus test 1: no error for negative limits\",\r\n\t\tfmin:        -99,\r\n\t\tfmax:        -10,\r\n\t\tpmin:        Product{121, [][2]int{{-11, -11}}},\r\n\t\tpmax:        Product{9009, [][2]int{{-99, -91}}},\r\n\t\terrPrefix:   \"\",\r\n\t},\r\n\t// The following two test cases have the same input, but different expectations. Uncomment just one or the other.\r\n\t//In case you reverse the *digits* you could have the following cases:\r\n\t//- the zero has to be considered\r\n\t//{\r\n\t//\tdescription: \"bonus test 2\",\r\n\t//\tfmin:        -2,\r\n\t//\tfmax:        2,\r\n\t//\tpmin:        Product{0, [][2]int{{-2, 0}, {-1, 0}, {0, 0}, {0, 1}, {0, 2}}},\r\n\t//\tpmax:        Product{4, [][2]int{{-2, -2}, {2, 2}}},\r\n\t//\terrPrefix:   \"\",\r\n\t//},\r\n\t// - you can keep the minus sign in place\r\n\t{\r\n\t\tdescription: \"bonus test 2\",\r\n\t\tfmin:        -2,\r\n\t\tfmax:        2,\r\n\t\tpmin:        Product{-4, [][2]int{{-2, 2}}},\r\n\t\tpmax:        Product{4, [][2]int{{-2, -2}, {2, 2}}},\r\n\t\terrPrefix:   \"\",\r\n\t},\r\n}\r\n*/\r\n\r\nfunc TestPalindromeProducts(t *testing.T) {\r\n\t// Uncomment the following line and the bonusData var above to add the bonus test to the default tests\r\n\t// testData = append(testData, bonusData...)\r\n\tfor _, tc := range testCases {\r\n\t\tt.Run(tc.description, func(t *testing.T) {\r\n\t\t\tpmin, pmax, err := Products(tc.fmin, tc.fmax)\r\n\r\n\t\t\tswitch {\r\n\t\t\tcase tc.errPrefix != \"\":\r\n\t\t\t\tif err == nil {\r\n\t\t\t\t\tt.Fatalf(\"Products(%d, %d) expected error %q, got nil\", tc.fmin, tc.fmax, fmt.Sprintf(\"%s...\", tc.errPrefix))\r\n\t\t\t\t}\r\n\t\t\t\tif !strings.HasPrefix(err.Error(), tc.errPrefix) {\r\n\t\t\t\t\tt.Fatalf(\"Products(%d, %d) expected error with prefix %q, got: %q\", tc.fmin, tc.fmax, tc.errPrefix, err.Error())\r\n\t\t\t\t}\r\n\t\t\tcase err != nil:\r\n\t\t\t\tt.Fatalf(\"Products(%d, %d) returned unexpected error: %v\", tc.fmin, tc.fmax, err)\r\n\t\t\t}\r\n\r\n\t\t\tmatchProd := func(field string, have, want Product) {\r\n\t\t\t\tif len(want.Factorizations) > 0 && // option to skip test\r\n\t\t\t\t\t!reflect.DeepEqual(have, want) {\r\n\t\t\t\t\tt.Fatalf(\"Products(%d, %d) [%s] = %v, want: %v\", tc.fmin, tc.fmax, field, have, want)\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tmatchProd(\"pmin\", pmin, tc.pmin)\r\n\t\t\tmatchProd(\"pmax\", pmax, tc.pmax)\r\n\t\t})\r\n\t}\r\n}\r\n\r\nfunc BenchmarkPalindromeProducts(b *testing.B) {\r\n\tif testing.Short() {\r\n\t\tb.Skip(\"skipping benchmark in short mode.\")\r\n\t}\r\n\tfor i := 0; i < b.N; i++ {\r\n\t\tfor _, test := range testCases {\r\n\t\t\tProducts(test.fmin, test.fmax)\r\n\t\t}\r\n\t}\r\n}\r\n"
}