{
  "language": "go",
  "type": "practice",
  "slug": "saddle-points",
  "title": "Saddle Points",
  "docs": {
    "instructions": "# Instructions\r\n\r\nYour task is to find the potential trees where you could build your tree house.\r\n\r\nThe data company provides the data as grids that show the heights of the trees.\r\nThe rows of the grid represent the east-west direction, and the columns represent the north-south direction.\r\n\r\nAn acceptable tree will be the largest in its row, while being the smallest in its column.\r\n\r\nA grid might not have any good trees at all.\r\nOr it might have one, or even several.\r\n\r\nHere is a grid that has exactly one candidate tree.\r\n\r\n```text\r\n      ↓\r\n      1  2  3  4\r\n    |-----------\r\n  1 | 9  8  7  8\r\n→ 2 |[5] 3  2  4\r\n  3 | 6  6  7  1\r\n```\r\n\r\n- Row 2 has values 5, 3, 2, and 4. The largest value is 5.\r\n- Column 1 has values 9, 5, and 6. The smallest value is 5.\r\n\r\nSo the point at `[2, 1]` (row: 2, column: 1) is a great spot for a tree house.\r\n",
    "hints": ""
  },
  "starter_code": "package matrix\r\n\r\n// Define the Matrix and Pair types here.\r\n\r\nfunc New(s string) (*Matrix, error) {\r\n\tpanic(\"Please implement the New function\")\r\n}\r\n\r\nfunc (m *Matrix) Saddle() []Pair {\r\n\tpanic(\"Please implement the Saddle function\")\r\n}\r\n",
  "tests": "// Short cut!  Have you already done the matrix exercise?\r\n// If it seems helpful, copy your code from the matrix exercise\r\n// to this directory so you have access to it.  You can leave it as matrix.go\r\n// and start a new file saddle_points.go with additional code that completes\r\n// this exercise. If you do copy the matrix.go file, do not forget to submit both\r\n// saddle_points.go and matrix.go as part of your solution.\r\n\r\npackage matrix\r\n\r\nimport (\r\n\t\"strconv\"\r\n\t\"strings\"\r\n\t\"testing\"\r\n)\r\n\r\nfunc TestSaddle(t *testing.T) {\r\n\tfor _, tc := range testCases {\r\n\t\tt.Run(tc.description, func(t *testing.T) {\r\n\t\t\tin := generateString(tc.input)\r\n\t\t\tm, err := New(in)\r\n\t\t\tif err != nil {\r\n\t\t\t\tt.Fatalf(\"TestSaddle needs working New. New(%s) returned %q.  Error not expected.\", in, err)\r\n\t\t\t}\r\n\t\t\tif got := m.Saddle(); !eq(got, tc.expectedOutput) {\r\n\t\t\t\tt.Fatalf(\"%v.Saddle() = %v, want %v\", m, got, tc.expectedOutput)\r\n\t\t\t}\r\n\t\t})\r\n\t}\r\n}\r\n\r\nfunc generateString(in [][]int) string {\r\n\tvar parts []string\r\n\tfor _, numbersPerLine := range in {\r\n\t\tvar lineParts []string\r\n\t\tfor _, number := range numbersPerLine {\r\n\t\t\tlineParts = append(lineParts, strconv.Itoa(number))\r\n\t\t}\r\n\t\tparts = append(parts, strings.Join(lineParts, \" \"))\r\n\t}\r\n\treturn strings.Join(parts, \"\\n\")\r\n}\r\n\r\nfunc eq(got, exp []Pair) bool {\r\n\tif len(got) != len(exp) {\r\n\t\treturn false\r\n\t}\r\nexp:\r\n\tfor _, e := range exp {\r\n\t\tfor _, g := range got {\r\n\t\t\tif g == e {\r\n\t\t\t\tcontinue exp\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn false\r\n\t}\r\n\treturn true\r\n}\r\n\r\nfunc BenchmarkSaddle(b *testing.B) {\r\n\tif testing.Short() {\r\n\t\tb.Skip(\"skipping benchmark in short mode.\")\r\n\t}\r\n\tms := make([]*Matrix, len(testCases))\r\n\tvar err error\r\n\tfor i, tc := range testCases {\r\n\t\tin := generateString(tc.input)\r\n\t\tif ms[i], err = New(in); err != nil {\r\n\t\t\tb.Fatalf(\"BenchmarkSaddle needs working New. New(%s) returned %q.  Error not expected.\", in, err)\r\n\t\t}\r\n\t}\r\n\tb.ResetTimer()\r\n\tfor i := 0; i < b.N; i++ {\r\n\t\tfor _, m := range ms {\r\n\t\t\tm.Saddle()\r\n\t\t}\r\n\t}\r\n}\r\n"
}