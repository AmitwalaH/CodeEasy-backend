{
  "language": "go",
  "type": "practice",
  "slug": "etl",
  "title": "Etl",
  "docs": {
    "instructions": "# Instructions\r\n\r\nYour task is to change the data format of letters and their point values in the game.\r\n\r\nCurrently, letters are stored in groups based on their score, in a one-to-many mapping.\r\n\r\n- 1 point: \"A\", \"E\", \"I\", \"O\", \"U\", \"L\", \"N\", \"R\", \"S\", \"T\",\r\n- 2 points: \"D\", \"G\",\r\n- 3 points: \"B\", \"C\", \"M\", \"P\",\r\n- 4 points: \"F\", \"H\", \"V\", \"W\", \"Y\",\r\n- 5 points: \"K\",\r\n- 8 points: \"J\", \"X\",\r\n- 10 points: \"Q\", \"Z\",\r\n\r\nThis needs to be changed to store each individual letter with its score in a one-to-one mapping.\r\n\r\n- \"a\" is worth 1 point.\r\n- \"b\" is worth 3 points.\r\n- \"c\" is worth 3 points.\r\n- \"d\" is worth 2 points.\r\n- etc.\r\n\r\nAs part of this change, the team has also decided to change the letters to be lower-case rather than upper-case.\r\n\r\n~~~~exercism/note\r\nIf you want to look at how the data was previously structured and how it needs to change, take a look at the examples in the test suite.\r\n~~~~\r\n",
    "hints": ""
  },
  "starter_code": "package etl\r\n\r\nfunc Transform(in map[int][]string) map[string]int {\r\n\tpanic(\"Please implement the Transform function\")\r\n}\r\n",
  "tests": "package etl\r\n\r\nimport \"testing\"\r\n\r\nvar transformTests = []struct {\r\n\tdescription string\r\n\tinput       map[int][]string\r\n\texpect      map[string]int\r\n}{\r\n\t{\r\n\t\tdescription: \"single letter for one score\",\r\n\t\tinput:       map[int][]string{1: {\"A\"}},\r\n\t\texpect:      map[string]int{\"a\": 1},\r\n\t},\r\n\t{\r\n\t\tdescription: \"multiple letters for one score\",\r\n\t\tinput:       map[int][]string{1: {\"A\", \"E\", \"I\", \"O\", \"U\"}},\r\n\t\texpect:      map[string]int{\"a\": 1, \"e\": 1, \"i\": 1, \"o\": 1, \"u\": 1},\r\n\t},\r\n\t{\r\n\t\tdescription: \"multiple letters for multiple scores\",\r\n\t\tinput: map[int][]string{\r\n\t\t\t1: {\"A\", \"E\"},\r\n\t\t\t2: {\"D\", \"G\"},\r\n\t\t},\r\n\t\texpect: map[string]int{\r\n\t\t\t\"a\": 1,\r\n\t\t\t\"e\": 1,\r\n\t\t\t\"d\": 2,\r\n\t\t\t\"g\": 2,\r\n\t\t},\r\n\t},\r\n\t{\r\n\t\tdescription: \"all letters\",\r\n\t\tinput: map[int][]string{\r\n\t\t\t1:  {\"A\", \"E\", \"I\", \"O\", \"U\", \"L\", \"N\", \"R\", \"S\", \"T\"},\r\n\t\t\t2:  {\"D\", \"G\"},\r\n\t\t\t3:  {\"B\", \"C\", \"M\", \"P\"},\r\n\t\t\t4:  {\"F\", \"H\", \"V\", \"W\", \"Y\"},\r\n\t\t\t5:  {\"K\"},\r\n\t\t\t8:  {\"J\", \"X\"},\r\n\t\t\t10: {\"Q\", \"Z\"},\r\n\t\t},\r\n\t\texpect: map[string]int{\r\n\t\t\t\"a\": 1, \"e\": 1, \"i\": 1, \"o\": 1, \"u\": 1, \"l\": 1, \"n\": 1, \"r\": 1, \"s\": 1, \"t\": 1,\r\n\t\t\t\"d\": 2, \"g\": 2,\r\n\t\t\t\"b\": 3, \"c\": 3, \"m\": 3, \"p\": 3,\r\n\t\t\t\"f\": 4, \"h\": 4, \"v\": 4, \"w\": 4, \"y\": 4,\r\n\t\t\t\"k\": 5,\r\n\t\t\t\"j\": 8, \"x\": 8,\r\n\t\t\t\"q\": 10, \"z\": 10,\r\n\t\t},\r\n\t},\r\n}\r\n\r\nfunc equal(actual, expectation map[string]int) bool {\r\n\tif len(actual) != len(expectation) {\r\n\t\treturn false\r\n\t}\r\n\r\n\tfor k, actualVal := range actual {\r\n\t\texpectationVal, present := expectation[k]\r\n\r\n\t\tif !present || actualVal != expectationVal {\r\n\t\t\treturn false\r\n\t\t}\r\n\t}\r\n\r\n\treturn true\r\n}\r\n\r\nfunc TestTransform(t *testing.T) {\r\n\tfor _, tt := range transformTests {\r\n\t\tt.Run(tt.description, func(t *testing.T) {\r\n\t\t\tif actual := Transform(tt.input); !equal(actual, tt.expect) {\r\n\t\t\t\tt.Fatalf(\"Transform(%v)\\n got:%v\\nwant:%v\", tt.input, actual, tt.expect)\r\n\t\t\t}\r\n\t\t})\r\n\t}\r\n}\r\n\r\nfunc BenchmarkTransform(b *testing.B) {\r\n\tif testing.Short() {\r\n\t\tb.Skip(\"skipping benchmark in short mode.\")\r\n\t}\r\n\tfor i := 0; i < b.N; i++ {\r\n\t\tfor _, tt := range transformTests {\r\n\t\t\tTransform(tt.input)\r\n\t\t}\r\n\t}\r\n}\r\n"
}