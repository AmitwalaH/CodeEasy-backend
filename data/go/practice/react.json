{
  "language": "go",
  "type": "practice",
  "slug": "react",
  "title": "React",
  "docs": {
    "instructions": "# Instructions\r\n\r\nImplement a basic reactive system.\r\n\r\nReactive programming is a programming paradigm that focuses on how values are computed in terms of each other to allow a change to one value to automatically propagate to other values, like in a spreadsheet.\r\n\r\nImplement a basic reactive system with cells with settable values (\"input\" cells) and cells with values computed in terms of other cells (\"compute\" cells).\r\nImplement updates so that when an input value is changed, values propagate to reach a new stable system state.\r\n\r\nIn addition, compute cells should allow for registering change notification callbacks.\r\nCall a cell’s callbacks when the cell’s value in a new stable state has changed from the previous stable state.\r\n",
    "hints": ""
  },
  "starter_code": "package react\r\n\r\n// Define reactor, cell and canceler types here.\r\n// These types will implement the Reactor, Cell and Canceler interfaces, respectively.\r\n\r\nfunc (c *canceler) Cancel() {\r\n\tpanic(\"Please implement the Cancel function\")\r\n}\r\n\r\nfunc (c *cell) Value() int {\r\n\tpanic(\"Please implement the Value function\")\r\n}\r\n\r\nfunc (c *cell) SetValue(value int) {\r\n\tpanic(\"Please implement the SetValue function\")\r\n}\r\n\r\nfunc (c *cell) AddCallback(callback func(int)) Canceler {\r\n\tpanic(\"Please implement the AddCallback function\")\r\n}\r\n\r\nfunc New() Reactor {\r\n\tpanic(\"Please implement the New function\")\r\n}\r\n\r\nfunc (r *reactor) CreateInput(initial int) InputCell {\r\n\tpanic(\"Please implement the CreateInput function\")\r\n}\r\n\r\nfunc (r *reactor) CreateCompute1(dep Cell, compute func(int) int) ComputeCell {\r\n\tpanic(\"Please implement the CreateCompute1 function\")\r\n}\r\n\r\nfunc (r *reactor) CreateCompute2(dep1, dep2 Cell, compute func(int, int) int) ComputeCell {\r\n\tpanic(\"Please implement the CreateCompute2 function\")\r\n}\r\n",
  "tests": "package react\r\n\r\nimport (\r\n\t\"runtime\"\r\n\t\"testing\"\r\n)\r\n\r\n// Define a function New() Reactor and the stuff that follows from\r\n// implementing Reactor.\r\n\r\n// This is a compile time check to see if you've properly implemented New().\r\nvar _ Reactor = New()\r\n\r\nfunc assertCellValue(t *testing.T, c Cell, expected int, explanation string) {\r\n\tobserved := c.Value()\r\n\t_, _, line, _ := runtime.Caller(1)\r\n\tif observed != expected {\r\n\t\tt.Fatalf(\"(from line %d) %s: expected %d, got %d\", line, explanation, expected, observed)\r\n\t}\r\n}\r\n\r\n// Setting the value of an input cell changes the observable Value()\r\nfunc TestSetInput(t *testing.T) {\r\n\tr := New()\r\n\ti := r.CreateInput(1)\r\n\tassertCellValue(t, i, 1, \"i.Value() doesn't match initial value\")\r\n\ti.SetValue(2)\r\n\tassertCellValue(t, i, 2, \"i.Value() doesn't match changed value\")\r\n}\r\n\r\n// The value of a compute 1 cell is determined by the value of the dependencies.\r\nfunc TestBasicCompute1(t *testing.T) {\r\n\tr := New()\r\n\ti := r.CreateInput(1)\r\n\tc := r.CreateCompute1(i, func(v int) int { return v + 1 })\r\n\tassertCellValue(t, c, 2, \"c.Value() isn't properly computed based on initial input cell value\")\r\n\ti.SetValue(2)\r\n\tassertCellValue(t, c, 3, \"c.Value() isn't properly computed based on changed input cell value\")\r\n}\r\n\r\n// The value of a compute 2 cell is determined by the value of the dependencies.\r\nfunc TestBasicCompute2(t *testing.T) {\r\n\tr := New()\r\n\ti1 := r.CreateInput(1)\r\n\ti2 := r.CreateInput(2)\r\n\tc := r.CreateCompute2(i1, i2, func(v1, v2 int) int { return v1 | v2 })\r\n\tassertCellValue(t, c, 3, \"c.Value() isn't properly computed based on initial input cell values\")\r\n\ti1.SetValue(4)\r\n\tassertCellValue(t, c, 6, \"c.Value() isn't properly computed when first input cell value changes\")\r\n\ti2.SetValue(8)\r\n\tassertCellValue(t, c, 12, \"c.Value() isn't properly computed when second input cell value changes\")\r\n}\r\n\r\n// Compute 2 cells can depend on compute 1 cells.\r\nfunc TestCompute2Diamond(t *testing.T) {\r\n\tr := New()\r\n\ti := r.CreateInput(1)\r\n\tc1 := r.CreateCompute1(i, func(v int) int { return v + 1 })\r\n\tc2 := r.CreateCompute1(i, func(v int) int { return v - 1 })\r\n\tc3 := r.CreateCompute2(c1, c2, func(v1, v2 int) int { return v1 * v2 })\r\n\tassertCellValue(t, c3, 0, \"c3.Value() isn't properly computed based on initial input cell value\")\r\n\ti.SetValue(3)\r\n\tassertCellValue(t, c3, 8, \"c3.Value() isn't properly computed based on changed input cell value\")\r\n}\r\n\r\n// Compute 1 cells can depend on other compute 1 cells.\r\nfunc TestCompute1Chain(t *testing.T) {\r\n\tr := New()\r\n\tinp := r.CreateInput(1)\r\n\tvar c Cell = inp\r\n\tfor i := 2; i <= 8; i++ {\r\n\t\t// must save current value of loop variable i for correct behavior.\r\n\t\t// compute function has to use digitToAdd not i.\r\n\t\tdigitToAdd := i\r\n\t\tc = r.CreateCompute1(c, func(v int) int { return v*10 + digitToAdd })\r\n\t}\r\n\tassertCellValue(t, c, 12345678, \"c.Value() isn't properly computed based on initial input cell value\")\r\n\tinp.SetValue(9)\r\n\tassertCellValue(t, c, 92345678, \"c.Value() isn't properly computed based on changed input cell value\")\r\n}\r\n\r\n// Compute 2 cells can depend on other compute 2 cells.\r\nfunc TestCompute2Tree(t *testing.T) {\r\n\tr := New()\r\n\tins := make([]InputCell, 3)\r\n\tfor i, v := range []int{1, 10, 100} {\r\n\t\tins[i] = r.CreateInput(v)\r\n\t}\r\n\r\n\tadd := func(v1, v2 int) int { return v1 + v2 }\r\n\r\n\tfirstLevel := make([]ComputeCell, 2)\r\n\tfor i := 0; i < 2; i++ {\r\n\t\tfirstLevel[i] = r.CreateCompute2(ins[i], ins[i+1], add)\r\n\t}\r\n\r\n\toutput := r.CreateCompute2(firstLevel[0], firstLevel[1], add)\r\n\tassertCellValue(t, output, 121, \"output.Value() isn't properly computed based on initial input cell values\")\r\n\r\n\tfor i := 0; i < 3; i++ {\r\n\t\tins[i].SetValue(ins[i].Value() * 2)\r\n\t}\r\n\r\n\tassertCellValue(t, output, 242, \"output.Value() isn't properly computed based on changed input cell values\")\r\n}\r\n\r\n// Compute cells can have callbacks.\r\nfunc TestBasicCallback(t *testing.T) {\r\n\tr := New()\r\n\ti := r.CreateInput(1)\r\n\tc := r.CreateCompute1(i, func(v int) int { return v + 1 })\r\n\tvar observed []int\r\n\tc.AddCallback(func(v int) {\r\n\t\tobserved = append(observed, v)\r\n\t})\r\n\tif len(observed) != 0 {\r\n\t\tt.Fatalf(\"callback called before changes were made\")\r\n\t}\r\n\ti.SetValue(2)\r\n\tif len(observed) != 1 {\r\n\t\tt.Fatalf(\"callback not called when changes were made\")\r\n\t}\r\n\tif observed[0] != 3 {\r\n\t\tt.Fatalf(\"callback not called with proper value\")\r\n\t}\r\n}\r\n\r\n// Callbacks and only trigger on change.\r\nfunc TestOnlyCallOnChanges(t *testing.T) {\r\n\tr := New()\r\n\ti := r.CreateInput(1)\r\n\tc := r.CreateCompute1(i, func(v int) int {\r\n\t\tif v > 3 {\r\n\t\t\treturn v + 1\r\n\t\t}\r\n\t\treturn 2\r\n\t})\r\n\tvar observedCalled int\r\n\tc.AddCallback(func(int) {\r\n\t\tobservedCalled++\r\n\t})\r\n\ti.SetValue(1)\r\n\tif observedCalled != 0 {\r\n\t\tt.Fatalf(\"observe function called even though input didn't change\")\r\n\t}\r\n\ti.SetValue(2)\r\n\tif observedCalled != 0 {\r\n\t\tt.Fatalf(\"observe function called even though computed value didn't change\")\r\n\t}\r\n}\r\n\r\n// Callbacks can be added and removed.\r\nfunc TestCallbackAddRemove(t *testing.T) {\r\n\tr := New()\r\n\ti := r.CreateInput(1)\r\n\tc := r.CreateCompute1(i, func(v int) int { return v + 1 })\r\n\tvar observed1 []int\r\n\tcb1 := c.AddCallback(func(v int) {\r\n\t\tobserved1 = append(observed1, v)\r\n\t})\r\n\tvar observed2 []int\r\n\tc.AddCallback(func(v int) {\r\n\t\tobserved2 = append(observed2, v)\r\n\t})\r\n\ti.SetValue(2)\r\n\tif len(observed1) != 1 || observed1[0] != 3 {\r\n\t\tt.Fatalf(\"observed1 not properly called\")\r\n\t}\r\n\tif len(observed2) != 1 || observed2[0] != 3 {\r\n\t\tt.Fatalf(\"observed2 not properly called\")\r\n\t}\r\n\tcb1.Cancel()\r\n\ti.SetValue(3)\r\n\tif len(observed1) != 1 {\r\n\t\tt.Fatalf(\"observed1 called after removal\")\r\n\t}\r\n\tif len(observed2) != 2 || observed2[1] != 4 {\r\n\t\tt.Fatalf(\"observed2 not properly called after first callback removal\")\r\n\t}\r\n}\r\n\r\nfunc TestMultipleCallbackRemoval(t *testing.T) {\r\n\tr := New()\r\n\tinp := r.CreateInput(1)\r\n\tc := r.CreateCompute1(inp, func(v int) int { return v + 1 })\r\n\r\n\tnumCallbacks := 5\r\n\r\n\tcalls := make([]int, numCallbacks)\r\n\tcancelers := make([]Canceler, numCallbacks)\r\n\tfor i := 0; i < numCallbacks; i++ {\r\n\t\t// Rebind i, otherwise all callbacks will use i = numCallbacks\r\n\t\ti := i\r\n\t\tcancelers[i] = c.AddCallback(func(v int) { calls[i]++ })\r\n\t}\r\n\r\n\tinp.SetValue(2)\r\n\tfor i := 0; i < numCallbacks; i++ {\r\n\t\tif calls[i] != 1 {\r\n\t\t\tt.Fatalf(\"callback %d/%d should be called 1 time, was called %d times\", i+1, numCallbacks, calls[i])\r\n\t\t}\r\n\t\tcancelers[i].Cancel()\r\n\t}\r\n\r\n\tinp.SetValue(3)\r\n\tfor i := 0; i < numCallbacks; i++ {\r\n\t\tif calls[i] != 1 {\r\n\t\t\tt.Fatalf(\"callback %d/%d was called after it was removed\", i+1, numCallbacks)\r\n\t\t}\r\n\t}\r\n}\r\n\r\nfunc TestRemoveIdempotence(t *testing.T) {\r\n\tr := New()\r\n\tinp := r.CreateInput(1)\r\n\toutput := r.CreateCompute1(inp, func(v int) int { return v + 1 })\r\n\ttimesCalled := 0\r\n\tcb1 := output.AddCallback(func(int) {})\r\n\toutput.AddCallback(func(int) { timesCalled++ })\r\n\tfor i := 0; i < 10; i++ {\r\n\t\tcb1.Cancel()\r\n\t}\r\n\tinp.SetValue(2)\r\n\tif timesCalled != 1 {\r\n\t\tt.Fatalf(\"remaining callback function was not called\")\r\n\t}\r\n}\r\n\r\n// Callbacks should only be called once even though\r\n// multiple dependencies have changed.\r\nfunc TestOnlyCallOnceOnMultipleDepChanges(t *testing.T) {\r\n\tr := New()\r\n\ti := r.CreateInput(1)\r\n\tc1 := r.CreateCompute1(i, func(v int) int { return v + 1 })\r\n\tc2 := r.CreateCompute1(i, func(v int) int { return v - 1 })\r\n\tc3 := r.CreateCompute1(c2, func(v int) int { return v - 1 })\r\n\tc4 := r.CreateCompute2(c1, c3, func(v1, v3 int) int { return v1 * v3 })\r\n\tchanged4 := 0\r\n\tc4.AddCallback(func(int) { changed4++ })\r\n\ti.SetValue(3)\r\n\tif changed4 < 1 {\r\n\t\tt.Fatalf(\"callback function was not called\")\r\n\t} else if changed4 > 1 {\r\n\t\tt.Fatalf(\"callback function was called too often\")\r\n\t}\r\n}\r\n\r\n// Callbacks should not be called if dependencies change in such a way\r\n// that the final value of the compute cell does not change.\r\nfunc TestNoCallOnDepChangesResultingInNoChange(t *testing.T) {\r\n\tr := New()\r\n\tinp := r.CreateInput(0)\r\n\tplus1 := r.CreateCompute1(inp, func(v int) int { return v + 1 })\r\n\tminus1 := r.CreateCompute1(inp, func(v int) int { return v - 1 })\r\n\t// The output's value is always 2, no matter what the input is.\r\n\toutput := r.CreateCompute2(plus1, minus1, func(v1, v2 int) int { return v1 - v2 })\r\n\r\n\ttimesCalled := 0\r\n\toutput.AddCallback(func(int) { timesCalled++ })\r\n\r\n\tinp.SetValue(5)\r\n\tif timesCalled != 0 {\r\n\t\tt.Fatalf(\"callback function called even though computed value didn't change\")\r\n\t}\r\n}\r\n"
}