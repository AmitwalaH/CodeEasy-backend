{
  "language": "go",
  "type": "practice",
  "slug": "simple-cipher",
  "title": "Simple Cipher",
  "docs": {
    "instructions": "# Instructions\r\n\r\nCreate an implementation of the [Vigenère cipher][wiki].\r\nThe Vigenère cipher is a simple substitution cipher.\r\n\r\n## Cipher terminology\r\n\r\nA cipher is an algorithm used to encrypt, or encode, a string.\r\nThe unencrypted string is called the _plaintext_ and the encrypted string is called the _ciphertext_.\r\nConverting plaintext to ciphertext is called _encoding_ while the reverse is called _decoding_.\r\n\r\nIn a _substitution cipher_, each plaintext letter is replaced with a ciphertext letter which is computed with the help of a _key_.\r\n(Note, it is possible for replacement letter to be the same as the original letter.)\r\n\r\n## Encoding details\r\n\r\nIn this cipher, the key is a series of lowercase letters, such as `\"abcd\"`.\r\nEach letter of the plaintext is _shifted_ or _rotated_ by a distance based on a corresponding letter in the key.\r\nAn `\"a\"` in the key means a shift of 0 (that is, no shift).\r\nA `\"b\"` in the key means a shift of 1.\r\nA `\"c\"` in the key means a shift of 2, and so on.\r\n\r\nThe first letter of the plaintext uses the first letter of the key, the second letter of the plaintext uses the second letter of the key and so on.\r\nIf you run out of letters in the key before you run out of letters in the plaintext, start over from the start of the key again.\r\n\r\nIf the key only contains one letter, such as `\"dddddd\"`, then all letters of the plaintext are shifted by the same amount (three in this example), which would make this the same as a rotational cipher or shift cipher (sometimes called a Caesar cipher).\r\nFor example, the plaintext `\"iamapandabear\"` would become `\"ldpdsdqgdehdu\"`.\r\n\r\nIf the key only contains the letter `\"a\"` (one or more times), the shift distance is zero and the ciphertext is the same as the plaintext.\r\n\r\nUsually the key is more complicated than that, though!\r\nIf the key is `\"abcd\"` then letters of the plaintext would be shifted by a distance of 0, 1, 2, and 3.\r\nIf the plaintext is `\"hello\"`, we need 5 shifts so the key would wrap around, giving shift distances of 0, 1, 2, 3, and 0.\r\nApplying those shifts to the letters of `\"hello\"` we get `\"hfnoo\"`.\r\n\r\n## Random keys\r\n\r\nIf no key is provided, generate a key which consists of at least 100 random lowercase letters from the Latin alphabet.\r\n\r\n[wiki]: https://en.wikipedia.org/wiki/Vigen%C3%A8re_cipher\r\n",
    "hints": ""
  },
  "starter_code": "package cipher\r\n\r\n// Define the shift and vigenere types here.\r\n// Both types should satisfy the Cipher interface.\r\n\r\nfunc NewCaesar() Cipher {\r\n\tpanic(\"Please implement the NewCaesar function\")\r\n}\r\n\r\nfunc NewShift(distance int) Cipher {\r\n\tpanic(\"Please implement the NewShift function\")\r\n}\r\n\r\nfunc (c shift) Encode(input string) string {\r\n\tpanic(\"Please implement the Encode function\")\r\n}\r\n\r\nfunc (c shift) Decode(input string) string {\r\n\tpanic(\"Please implement the Decode function\")\r\n}\r\n\r\nfunc NewVigenere(key string) Cipher {\r\n\tpanic(\"Please implement the NewVigenere function\")\r\n}\r\n\r\nfunc (v vigenere) Encode(input string) string {\r\n\tpanic(\"Please implement the Encode function\")\r\n}\r\n\r\nfunc (v vigenere) Decode(input string) string {\r\n\tpanic(\"Please implement the Decode function\")\r\n}\r\n",
  "tests": "package cipher\r\n\r\nimport (\r\n\t\"fmt\"\r\n\t\"testing\"\r\n)\r\n\r\n// type for testing implementations of the Cipher interface\r\ntype cipherTest struct {\r\n\tsource string // source text, any UTF-8\r\n\tcipher string // cipher text, result of Encode(st)\r\n\tplain  string // decoded plain text, result of Decode(ct)\r\n}\r\n\r\nvar caesarPrepped = []cipherTest{\r\n\t{\"iamapandabear\", \"ldpdsdqgdehdu\", \"iamapandabear\"},\r\n\t{\"programmingisawesome\", \"surjudpplqjlvdzhvrph\", \"programmingisawesome\"},\r\n\t{\"todayisholiday\", \"wrgdblvkrolgdb\", \"todayisholiday\"},\r\n\t{\"venividivici\", \"yhqlylglylfl\", \"venividivici\"},\r\n}\r\n\r\nvar caesarTests = []cipherTest{\r\n\t{\"Go, go, gophers\", \"jrjrjrskhuv\", \"gogogophers\"},\r\n\t{\"I am a panda bear.\", \"ldpdsdqgdehdu\", \"iamapandabear\"},\r\n\t{\"Programming is AWESOME!\", \"surjudpplqjlvdzhvrph\", \"programmingisawesome\"},\r\n\t{\"today is holiday\", \"wrgdblvkrolgdb\", \"todayisholiday\"},\r\n\t{\"Twas the night before Christmas\", \"wzdvwkhqljkwehiruhfkulvwpdv\", \"twasthenightbeforechristmas\"},\r\n\t{\" -- @#!\", \"\", \"\"},\r\n\t{\"\", \"\", \"\"},\r\n}\r\n\r\nfunc TestCaesar(t *testing.T) {\r\n\tc := NewCaesar()\r\n\tt.Run(\"no extra symbols\", func(t *testing.T) {\r\n\t\ttestCipher(c, caesarPrepped, t)\r\n\t})\r\n\tt.Run(\"with extra symbols\", func(t *testing.T) {\r\n\t\ttestCipher(c, caesarTests, t)\r\n\t})\r\n}\r\n\r\nfunc testCipher(c Cipher, tests []cipherTest, t *testing.T) {\r\n\tfor _, test := range tests {\r\n\t\tt.Run(fmt.Sprintf(\"Encode(%s)\", test.source), func(tt *testing.T) {\r\n\t\t\tif enc := c.Encode(test.source); enc != test.cipher {\r\n\t\t\t\ttt.Fatalf(\"Encode(%s): got %q, want %q.\", test.source, enc, test.cipher)\r\n\t\t\t}\r\n\t\t})\r\n\t\tt.Run(fmt.Sprintf(\"Decode(%s)\", test.cipher), func(tt *testing.T) {\r\n\t\t\tif dec := c.Decode(test.cipher); dec != test.plain {\r\n\t\t\t\ttt.Fatalf(\"Decode(%s): got %q, want %q.\", test.cipher, dec, test.plain)\r\n\t\t\t}\r\n\t\t})\r\n\t}\r\n}\r\n\r\nvar NSATests = []cipherTest{\r\n\t{\"THE ENEMY IS NEAR\", \"qebbkbjvfpkbxo\", \"theenemyisnear\"},\r\n\t{\r\n\t\t\"SPIES SEND SECRET MESSAGES\",\r\n\t\t\"pmfbppbkapbzobqjbppxdbp\",\r\n\t\t\"spiessendsecretmessages\",\r\n\t},\r\n\t{\r\n\t\t\"THOMAS JEFFERSON DESIGNED A SUBSTITUTION CIPHER\",\r\n\t\t\"qeljxpgbccboplkabpfdkbaxprypqfqrqflkzfmebo\",\r\n\t\t\"thomasjeffersondesignedasubstitutioncipher\",\r\n\t},\r\n\t{\r\n\t\t\"the quick brown fox jumps over the lazy dog\",\r\n\t\t\"qebnrfzhyoltkclugrjmplsboqebixwvald\",\r\n\t\t\"thequickbrownfoxjumpsoverthelazydog\",\r\n\t},\r\n}\r\n\r\nfunc TestShift(t *testing.T) {\r\n\t// test shift(3) against Caesar cases.\r\n\tt.Run(fmt.Sprintf(\"key=%d\", 3), func(t *testing.T) {\r\n\t\tc := NewShift(3)\r\n\t\tif c == nil {\r\n\t\t\tt.Fatal(\"NewShift(3): got nil, want non-nil Cipher\")\r\n\t\t}\r\n\t\ttestCipher(c, caesarTests, t)\r\n\t})\r\n\r\n\t// NSA and WP say Caesar uses shift of -3\r\n\tt.Run(fmt.Sprintf(\"key=%d\", -3), func(t *testing.T) {\r\n\t\tc := NewShift(-3)\r\n\t\tif c == nil {\r\n\t\t\tt.Fatal(\"NewShift(-3): got nil, want non-nil Cipher\")\r\n\t\t}\r\n\t\ttestCipher(c, NSATests, t)\r\n\t})\r\n}\r\n\r\nfunc TestWrongShiftKey(t *testing.T) {\r\n\tfor _, s := range []int{-27, -26, 0, 26, 27} {\r\n\t\tif NewShift(s) != nil {\r\n\t\t\tt.Errorf(\"NewShift(%d): got non-nil, want nil\", s)\r\n\t\t}\r\n\t}\r\n}\r\n\r\nvar vtests = []struct {\r\n\tkey   string\r\n\ttests []cipherTest\r\n}{\r\n\t{\"lemon\", []cipherTest{{\"ATTACKATDAWN\", \"lxfopvefrnhr\", \"attackatdawn\"}}},\r\n\t{\"abcdefghij\", []cipherTest{\r\n\t\t{\"aaaaaaaaaa\", \"abcdefghij\", \"aaaaaaaaaa\"},\r\n\t\t{\"zzzzzzzzzz\", \"zabcdefghi\", \"zzzzzzzzzz\"},\r\n\t}},\r\n\t{\"iamapandabear\", []cipherTest{\r\n\t\t{\"I am a panda bear.\", \"qayaeaagaciai\", \"iamapandabear\"},\r\n\t}},\r\n\t{\"duxrceqyaimciuucnelkeoxjhdyduu\", []cipherTest{\r\n\t\t{\"Diffie Hellman\", \"gccwkixcltycv\", \"diffiehellman\"},\r\n\t}},\r\n\t{\"qgbvno\", []cipherTest{\r\n\t\t{\"cof-FEE, 123!\", \"sugars\", \"coffee\"},\r\n\t}},\r\n}\r\n\r\nfunc TestVigenere(t *testing.T) {\r\n\tfor _, test := range vtests {\r\n\t\tt.Run(fmt.Sprintf(\"key=%s\", test.key), func(t *testing.T) {\r\n\t\t\tv := NewVigenere(test.key)\r\n\t\t\tif v == nil {\r\n\t\t\t\tt.Fatalf(\"NewVigenere(%q): got nil, want non-nil Cipher\",\r\n\t\t\t\t\ttest.key)\r\n\t\t\t}\r\n\t\t\ttestCipher(v, test.tests, t)\r\n\t\t})\r\n\t}\r\n}\r\n\r\nfunc TestVigenereWrongKey(t *testing.T) {\r\n\tfor _, k := range []string{\"\", \"a\", \"aa\", \"no way\", \"CAT\", \"3\", \"and,\"} {\r\n\t\tif NewVigenere(k) != nil {\r\n\t\t\tt.Errorf(\"NewVigenere(%q): got non-nil, want nil\", k)\r\n\t\t}\r\n\t}\r\n}\r\n\r\n// Benchmark combined time to run all tests.\r\n// Note other ciphers test different data; times cannot be compared.\r\nfunc BenchmarkEncodeCaesar(b *testing.B) {\r\n\tif testing.Short() {\r\n\t\tb.Skip(\"skipping benchmark in short mode.\")\r\n\t}\r\n\tc := NewCaesar()\r\n\tb.ResetTimer()\r\n\tfor i := 0; i < b.N; i++ {\r\n\t\tfor _, test := range caesarTests {\r\n\t\t\tc.Encode(test.source)\r\n\t\t}\r\n\t}\r\n}\r\n\r\nfunc BenchmarkDecodeCaesar(b *testing.B) {\r\n\tif testing.Short() {\r\n\t\tb.Skip(\"skipping benchmark in short mode.\")\r\n\t}\r\n\tc := NewCaesar()\r\n\tb.ResetTimer()\r\n\tfor i := 0; i < b.N; i++ {\r\n\t\tfor _, test := range caesarTests {\r\n\t\t\tc.Decode(test.cipher)\r\n\t\t}\r\n\t}\r\n}\r\n\r\nfunc BenchmarkNewShift(b *testing.B) {\r\n\tif testing.Short() {\r\n\t\tb.Skip(\"skipping benchmark in short mode.\")\r\n\t}\r\n\tfor i := 0; i < b.N; i++ {\r\n\t\tfor s := -27; s <= 27; s++ {\r\n\t\t\tNewShift(s)\r\n\t\t}\r\n\t}\r\n}\r\n\r\nfunc BenchmarkEncodeShift(b *testing.B) {\r\n\tif testing.Short() {\r\n\t\tb.Skip(\"skipping benchmark in short mode.\")\r\n\t}\r\n\ts := NewShift(5)\r\n\tall := caesarTests\r\n\tall = append(all, NSATests...)\r\n\tb.ResetTimer()\r\n\tfor i := 0; i < b.N; i++ {\r\n\t\tfor _, test := range all {\r\n\t\t\ts.Encode(test.source)\r\n\t\t}\r\n\t}\r\n}\r\n\r\nfunc BenchmarkDecodeShift(b *testing.B) {\r\n\tif testing.Short() {\r\n\t\tb.Skip(\"skipping benchmark in short mode.\")\r\n\t}\r\n\ts := NewShift(5)\r\n\tall := caesarTests\r\n\tall = append(all, NSATests...)\r\n\tb.ResetTimer()\r\n\tfor i := 0; i < b.N; i++ {\r\n\t\tfor _, test := range all {\r\n\t\t\ts.Decode(test.cipher)\r\n\t\t}\r\n\t}\r\n}\r\n\r\nfunc BenchmarkNewVigenere(b *testing.B) {\r\n\tif testing.Short() {\r\n\t\tb.Skip(\"skipping benchmark in short mode.\")\r\n\t}\r\n\tfor i := 0; i < b.N; i++ {\r\n\t\tfor _, test := range vtests {\r\n\t\t\tNewVigenere(test.key)\r\n\t\t}\r\n\t}\r\n}\r\n\r\nfunc BenchmarkEncVigenere(b *testing.B) {\r\n\tif testing.Short() {\r\n\t\tb.Skip(\"skipping benchmark in short mode.\")\r\n\t}\r\n\tv := make([]Cipher, len(vtests))\r\n\tfor i, test := range vtests {\r\n\t\tv[i] = NewVigenere(test.key)\r\n\t\tif v[i] == nil {\r\n\t\t\tb.Skip(\"Benchmark requires valid Vigenere test cases\")\r\n\t\t}\r\n\t}\r\n\tb.ResetTimer()\r\n\tfor j := 0; j < b.N; j++ {\r\n\t\tfor i, test := range vtests {\r\n\t\t\tvi := v[i]\r\n\t\t\tfor _, test := range test.tests {\r\n\t\t\t\tvi.Encode(test.source)\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n}\r\n\r\nfunc BenchmarkDecVigenere(b *testing.B) {\r\n\tif testing.Short() {\r\n\t\tb.Skip(\"skipping benchmark in short mode.\")\r\n\t}\r\n\tv := make([]Cipher, len(vtests))\r\n\tfor i, test := range vtests {\r\n\t\tv[i] = NewVigenere(test.key)\r\n\t\tif v[i] == nil {\r\n\t\t\tb.Skip(\"Benchmark requires valid Vigenere test cases\")\r\n\t\t}\r\n\t}\r\n\tb.ResetTimer()\r\n\tfor j := 0; j < b.N; j++ {\r\n\t\tfor i, test := range vtests {\r\n\t\t\tvi := v[i]\r\n\t\t\tfor _, test := range test.tests {\r\n\t\t\t\tvi.Decode(test.cipher)\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n}\r\n"
}