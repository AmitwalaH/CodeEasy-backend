{
  "language": "go",
  "type": "practice",
  "slug": "ledger",
  "title": "Ledger",
  "docs": {
    "instructions": "# Instructions\r\n\r\nRefactor a ledger printer.\r\n\r\nThe ledger exercise is a refactoring exercise.\r\nThere is code that prints a nicely formatted ledger, given a locale (American or Dutch) and a currency (US dollar or euro).\r\nThe code however is rather badly written, though (somewhat surprisingly) it consistently passes the test suite.\r\n\r\nRewrite this code.\r\nRemember that in refactoring the trick is to make small steps that keep the tests passing.\r\nThat way you can always quickly go back to a working version.\r\nVersion control tools like git can help here as well.\r\n\r\nPlease keep a log of what changes you've made and make a comment on the exercise containing that log, this will help reviewers.\r\n",
    "hints": ""
  },
  "starter_code": "package ledger\r\n\r\nimport (\r\n\t\"errors\"\r\n\t\"strconv\"\r\n\t\"strings\"\r\n)\r\n\r\ntype Entry struct {\r\n\tDate        string // \"Y-m-d\"\r\n\tDescription string\r\n\tChange      int // in cents\r\n}\r\n\r\nfunc FormatLedger(currency string, locale string, entries []Entry) (string, error) {\r\n\tvar entriesCopy []Entry\r\n\tfor _, e := range entries {\r\n\t\tentriesCopy = append(entriesCopy, e)\r\n\t}\r\n\tif len(entries) == 0 {\r\n\t\tif _, err := FormatLedger(currency, \"en-US\", []Entry{{Date: \"2014-01-01\", Description: \"\", Change: 0}}); err != nil {\r\n\t\t\treturn \"\", err\r\n\t\t}\r\n\t}\r\n\tm1 := map[bool]int{true: 0, false: 1}\r\n\tm2 := map[bool]int{true: -1, false: 1}\r\n\tes := entriesCopy\r\n\tfor len(es) > 1 {\r\n\t\tfirst, rest := es[0], es[1:]\r\n\t\tsuccess := false\r\n\t\tfor !success {\r\n\t\t\tsuccess = true\r\n\t\t\tfor i, e := range rest {\r\n\t\t\t\tif (m1[e.Date == first.Date]*m2[e.Date < first.Date]*4 +\r\n\t\t\t\t\tm1[e.Description == first.Description]*m2[e.Description < first.Description]*2 +\r\n\t\t\t\t\tm1[e.Change == first.Change]*m2[e.Change < first.Change]*1) < 0 {\r\n\t\t\t\t\tes[0], es[i+1] = es[i+1], es[0]\r\n\t\t\t\t\tsuccess = false\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\tes = es[1:]\r\n\t}\r\n\r\n\tvar s string\r\n\tif locale == \"nl-NL\" {\r\n\t\ts = \"Datum\" +\r\n\t\t\tstrings.Repeat(\" \", 10-len(\"Datum\")) +\r\n\t\t\t\" | \" +\r\n\t\t\t\"Omschrijving\" +\r\n\t\t\tstrings.Repeat(\" \", 25-len(\"Omschrijving\")) +\r\n\t\t\t\" | \" + \"Verandering\" + \"\\n\"\r\n\t} else if locale == \"en-US\" {\r\n\t\ts = \"Date\" +\r\n\t\t\tstrings.Repeat(\" \", 10-len(\"Date\")) +\r\n\t\t\t\" | \" +\r\n\t\t\t\"Description\" +\r\n\t\t\tstrings.Repeat(\" \", 25-len(\"Description\")) +\r\n\t\t\t\" | \" + \"Change\" + \"\\n\"\r\n\t} else {\r\n\t\treturn \"\", errors.New(\"\")\r\n\t}\r\n\t// Parallelism, always a great idea\r\n\tco := make(chan struct {\r\n\t\ti int\r\n\t\ts string\r\n\t\te error\r\n\t})\r\n\tfor i, et := range entriesCopy {\r\n\t\tgo func(i int, entry Entry) {\r\n\t\t\tif len(entry.Date) != 10 {\r\n\t\t\t\tco <- struct {\r\n\t\t\t\t\ti int\r\n\t\t\t\t\ts string\r\n\t\t\t\t\te error\r\n\t\t\t\t}{e: errors.New(\"\")}\r\n\t\t\t}\r\n\t\t\td1, d2, d3, d4, d5 := entry.Date[0:4], entry.Date[4], entry.Date[5:7], entry.Date[7], entry.Date[8:10]\r\n\t\t\tif d2 != '-' {\r\n\t\t\t\tco <- struct {\r\n\t\t\t\t\ti int\r\n\t\t\t\t\ts string\r\n\t\t\t\t\te error\r\n\t\t\t\t}{e: errors.New(\"\")}\r\n\t\t\t}\r\n\t\t\tif d4 != '-' {\r\n\t\t\t\tco <- struct {\r\n\t\t\t\t\ti int\r\n\t\t\t\t\ts string\r\n\t\t\t\t\te error\r\n\t\t\t\t}{e: errors.New(\"\")}\r\n\t\t\t}\r\n\t\t\tde := entry.Description\r\n\t\t\tif len(de) > 25 {\r\n\t\t\t\tde = de[:22] + \"...\"\r\n\t\t\t} else {\r\n\t\t\t\tde = de + strings.Repeat(\" \", 25-len(de))\r\n\t\t\t}\r\n\t\t\tvar d string\r\n\t\t\tif locale == \"nl-NL\" {\r\n\t\t\t\td = d5 + \"-\" + d3 + \"-\" + d1\r\n\t\t\t} else if locale == \"en-US\" {\r\n\t\t\t\td = d3 + \"/\" + d5 + \"/\" + d1\r\n\t\t\t}\r\n\t\t\tnegative := false\r\n\t\t\tcents := entry.Change\r\n\t\t\tif cents < 0 {\r\n\t\t\t\tcents = cents * -1\r\n\t\t\t\tnegative = true\r\n\t\t\t}\r\n\t\t\tvar a string\r\n\t\t\tif locale == \"nl-NL\" {\r\n\t\t\t\tif currency == \"EUR\" {\r\n\t\t\t\t\ta += \"€\"\r\n\t\t\t\t} else if currency == \"USD\" {\r\n\t\t\t\t\ta += \"$\"\r\n\t\t\t\t} else {\r\n\t\t\t\t\tco <- struct {\r\n\t\t\t\t\t\ti int\r\n\t\t\t\t\t\ts string\r\n\t\t\t\t\t\te error\r\n\t\t\t\t\t}{e: errors.New(\"\")}\r\n\t\t\t\t}\r\n\t\t\t\ta += \" \"\r\n\t\t\t\tcentsStr := strconv.Itoa(cents)\r\n\t\t\t\tswitch len(centsStr) {\r\n\t\t\t\tcase 1:\r\n\t\t\t\t\tcentsStr = \"00\" + centsStr\r\n\t\t\t\tcase 2:\r\n\t\t\t\t\tcentsStr = \"0\" + centsStr\r\n\t\t\t\t}\r\n\t\t\t\trest := centsStr[:len(centsStr)-2]\r\n\t\t\t\tvar parts []string\r\n\t\t\t\tfor len(rest) > 3 {\r\n\t\t\t\t\tparts = append(parts, rest[len(rest)-3:])\r\n\t\t\t\t\trest = rest[:len(rest)-3]\r\n\t\t\t\t}\r\n\t\t\t\tif len(rest) > 0 {\r\n\t\t\t\t\tparts = append(parts, rest)\r\n\t\t\t\t}\r\n\t\t\t\tfor i := len(parts) - 1; i >= 0; i-- {\r\n\t\t\t\t\ta += parts[i] + \".\"\r\n\t\t\t\t}\r\n\t\t\t\ta = a[:len(a)-1]\r\n\t\t\t\ta += \",\"\r\n\t\t\t\ta += centsStr[len(centsStr)-2:]\r\n\t\t\t\tif negative {\r\n\t\t\t\t\ta += \"-\"\r\n\t\t\t\t} else {\r\n\t\t\t\t\ta += \" \"\r\n\t\t\t\t}\r\n\t\t\t} else if locale == \"en-US\" {\r\n\t\t\t\tif negative {\r\n\t\t\t\t\ta += \"(\"\r\n\t\t\t\t}\r\n\t\t\t\tif currency == \"EUR\" {\r\n\t\t\t\t\ta += \"€\"\r\n\t\t\t\t} else if currency == \"USD\" {\r\n\t\t\t\t\ta += \"$\"\r\n\t\t\t\t} else {\r\n\t\t\t\t\tco <- struct {\r\n\t\t\t\t\t\ti int\r\n\t\t\t\t\t\ts string\r\n\t\t\t\t\t\te error\r\n\t\t\t\t\t}{e: errors.New(\"\")}\r\n\t\t\t\t}\r\n\t\t\t\tcentsStr := strconv.Itoa(cents)\r\n\t\t\t\tswitch len(centsStr) {\r\n\t\t\t\tcase 1:\r\n\t\t\t\t\tcentsStr = \"00\" + centsStr\r\n\t\t\t\tcase 2:\r\n\t\t\t\t\tcentsStr = \"0\" + centsStr\r\n\t\t\t\t}\r\n\t\t\t\trest := centsStr[:len(centsStr)-2]\r\n\t\t\t\tvar parts []string\r\n\t\t\t\tfor len(rest) > 3 {\r\n\t\t\t\t\tparts = append(parts, rest[len(rest)-3:])\r\n\t\t\t\t\trest = rest[:len(rest)-3]\r\n\t\t\t\t}\r\n\t\t\t\tif len(rest) > 0 {\r\n\t\t\t\t\tparts = append(parts, rest)\r\n\t\t\t\t}\r\n\t\t\t\tfor i := len(parts) - 1; i >= 0; i-- {\r\n\t\t\t\t\ta += parts[i] + \",\"\r\n\t\t\t\t}\r\n\t\t\t\ta = a[:len(a)-1]\r\n\t\t\t\ta += \".\"\r\n\t\t\t\ta += centsStr[len(centsStr)-2:]\r\n\t\t\t\tif negative {\r\n\t\t\t\t\ta += \")\"\r\n\t\t\t\t} else {\r\n\t\t\t\t\ta += \" \"\r\n\t\t\t\t}\r\n\t\t\t} else {\r\n\t\t\t\tco <- struct {\r\n\t\t\t\t\ti int\r\n\t\t\t\t\ts string\r\n\t\t\t\t\te error\r\n\t\t\t\t}{e: errors.New(\"\")}\r\n\t\t\t}\r\n\t\t\tvar al int\r\n\t\t\tfor range a {\r\n\t\t\t\tal++\r\n\t\t\t}\r\n\t\t\tco <- struct {\r\n\t\t\t\ti int\r\n\t\t\t\ts string\r\n\t\t\t\te error\r\n\t\t\t}{i: i, s: d + strings.Repeat(\" \", 10-len(d)) + \" | \" + de + \" | \" +\r\n\t\t\t\tstrings.Repeat(\" \", 13-al) + a + \"\\n\"}\r\n\t\t}(i, et)\r\n\t}\r\n\tss := make([]string, len(entriesCopy))\r\n\tfor range entriesCopy {\r\n\t\tv := <-co\r\n\t\tif v.e != nil {\r\n\t\t\treturn \"\", v.e\r\n\t\t}\r\n\t\tss[v.i] = v.s\r\n\t}\r\n\tfor i := 0; i < len(entriesCopy); i++ {\r\n\t\ts += ss[i]\r\n\t}\r\n\treturn s, nil\r\n}\r\n",
  "tests": "package ledger\r\n\r\nimport (\r\n\t\"reflect\"\r\n\t\"testing\"\r\n)\r\n\r\nvar successTestCases = []struct {\r\n\tname     string\r\n\tcurrency string\r\n\tlocale   string\r\n\tentries  []Entry\r\n\texpected string\r\n}{\r\n\t{\r\n\t\tname:     \"empty ledger\",\r\n\t\tcurrency: \"USD\",\r\n\t\tlocale:   \"en-US\",\r\n\t\tentries:  nil,\r\n\t\texpected: `\r\nDate       | Description               | Change\r\n`,\r\n\t},\r\n\t{\r\n\t\tname:     \"one entry\",\r\n\t\tcurrency: \"USD\",\r\n\t\tlocale:   \"en-US\",\r\n\t\tentries: []Entry{\r\n\t\t\t{\r\n\t\t\t\tDate:        \"2015-01-01\",\r\n\t\t\t\tDescription: \"Buy present\",\r\n\t\t\t\tChange:      -1000,\r\n\t\t\t},\r\n\t\t},\r\n\t\texpected: `\r\nDate       | Description               | Change\r\n01/01/2015 | Buy present               |      ($10.00)\r\n`,\r\n\t},\r\n\t{\r\n\t\tname:     \"credit and debit\",\r\n\t\tcurrency: \"USD\",\r\n\t\tlocale:   \"en-US\",\r\n\t\tentries: []Entry{\r\n\t\t\t{\r\n\t\t\t\tDate:        \"2015-01-02\",\r\n\t\t\t\tDescription: \"Get present\",\r\n\t\t\t\tChange:      1000,\r\n\t\t\t},\r\n\t\t\t{\r\n\t\t\t\tDate:        \"2015-01-01\",\r\n\t\t\t\tDescription: \"Buy present\",\r\n\t\t\t\tChange:      -1000,\r\n\t\t\t},\r\n\t\t},\r\n\t\texpected: `\r\nDate       | Description               | Change\r\n01/01/2015 | Buy present               |      ($10.00)\r\n01/02/2015 | Get present               |       $10.00 \r\n`,\r\n\t},\r\n\t{\r\n\t\tname:     \"multiple entries on same date ordered by description\",\r\n\t\tcurrency: \"USD\",\r\n\t\tlocale:   \"en-US\",\r\n\t\tentries: []Entry{\r\n\t\t\t{\r\n\t\t\t\tDate:        \"2015-01-01\",\r\n\t\t\t\tDescription: \"Buy present\",\r\n\t\t\t\tChange:      -1000,\r\n\t\t\t},\r\n\t\t\t{\r\n\t\t\t\tDate:        \"2015-01-01\",\r\n\t\t\t\tDescription: \"Get present\",\r\n\t\t\t\tChange:      1000,\r\n\t\t\t},\r\n\t\t},\r\n\t\texpected: `\r\nDate       | Description               | Change\r\n01/01/2015 | Buy present               |      ($10.00)\r\n01/01/2015 | Get present               |       $10.00 \r\n`,\r\n\t},\r\n\t{\r\n\t\tname:     \"final order tie breaker is change\",\r\n\t\tcurrency: \"USD\",\r\n\t\tlocale:   \"en-US\",\r\n\t\tentries: []Entry{\r\n\t\t\t{\r\n\t\t\t\tDate:        \"2015-01-01\",\r\n\t\t\t\tDescription: \"Something\",\r\n\t\t\t\tChange:      0,\r\n\t\t\t},\r\n\t\t\t{\r\n\t\t\t\tDate:        \"2015-01-01\",\r\n\t\t\t\tDescription: \"Something\",\r\n\t\t\t\tChange:      -1,\r\n\t\t\t},\r\n\t\t\t{\r\n\t\t\t\tDate:        \"2015-01-01\",\r\n\t\t\t\tDescription: \"Something\",\r\n\t\t\t\tChange:      1,\r\n\t\t\t},\r\n\t\t},\r\n\t\texpected: `\r\nDate       | Description               | Change\r\n01/01/2015 | Something                 |       ($0.01)\r\n01/01/2015 | Something                 |        $0.00 \r\n01/01/2015 | Something                 |        $0.01 \r\n`,\r\n\t},\r\n\t{\r\n\t\tname:     \"overlong descriptions\",\r\n\t\tcurrency: \"USD\",\r\n\t\tlocale:   \"en-US\",\r\n\t\tentries: []Entry{\r\n\t\t\t{\r\n\t\t\t\tDate:        \"2015-01-01\",\r\n\t\t\t\tDescription: \"Freude schoner Gotterfunken\",\r\n\t\t\t\tChange:      -123456,\r\n\t\t\t},\r\n\t\t},\r\n\t\texpected: `\r\nDate       | Description               | Change\r\n01/01/2015 | Freude schoner Gotterf... |   ($1,234.56)\r\n`,\r\n\t},\r\n\t{\r\n\t\tname:     \"euros\",\r\n\t\tcurrency: \"EUR\",\r\n\t\tlocale:   \"en-US\",\r\n\t\tentries: []Entry{\r\n\t\t\t{\r\n\t\t\t\tDate:        \"2015-01-01\",\r\n\t\t\t\tDescription: \"Buy present\",\r\n\t\t\t\tChange:      -1000,\r\n\t\t\t},\r\n\t\t},\r\n\t\texpected: `\r\nDate       | Description               | Change\r\n01/01/2015 | Buy present               |      (€10.00)\r\n`,\r\n\t},\r\n\t{\r\n\t\tname:     \"Dutch locale\",\r\n\t\tcurrency: \"USD\",\r\n\t\tlocale:   \"nl-NL\",\r\n\t\tentries: []Entry{\r\n\t\t\t{\r\n\t\t\t\tDate:        \"2015-03-12\",\r\n\t\t\t\tDescription: \"Buy present\",\r\n\t\t\t\tChange:      123456,\r\n\t\t\t},\r\n\t\t},\r\n\t\texpected: `\r\nDatum      | Omschrijving              | Verandering\r\n12-03-2015 | Buy present               |   $ 1.234,56 \r\n`,\r\n\t},\r\n\t{\r\n\t\tname:     \"Dutch negative number with 3 digits before decimal point\",\r\n\t\tcurrency: \"USD\",\r\n\t\tlocale:   \"nl-NL\",\r\n\t\tentries: []Entry{\r\n\t\t\t{\r\n\t\t\t\tDate:        \"2015-03-12\",\r\n\t\t\t\tDescription: \"Buy present\",\r\n\t\t\t\tChange:      -12345,\r\n\t\t\t},\r\n\t\t},\r\n\t\texpected: `\r\nDatum      | Omschrijving              | Verandering\r\n12-03-2015 | Buy present               |     $ 123,45-\r\n`,\r\n\t},\r\n\t{\r\n\t\tname:     \"American negative number with 3 digits before decimal point\",\r\n\t\tcurrency: \"USD\",\r\n\t\tlocale:   \"en-US\",\r\n\t\tentries: []Entry{\r\n\t\t\t{\r\n\t\t\t\tDate:        \"2015-03-12\",\r\n\t\t\t\tDescription: \"Buy present\",\r\n\t\t\t\tChange:      -12345,\r\n\t\t\t},\r\n\t\t},\r\n\t\texpected: `\r\nDate       | Description               | Change\r\n03/12/2015 | Buy present               |     ($123.45)\r\n`,\r\n\t},\r\n}\r\n\r\nvar failureTestCases = []struct {\r\n\tname     string\r\n\tcurrency string\r\n\tlocale   string\r\n\tentries  []Entry\r\n}{\r\n\t{\r\n\t\tname:     \"empty currency\",\r\n\t\tcurrency: \"\",\r\n\t\tlocale:   \"en-US\",\r\n\t\tentries:  nil,\r\n\t},\r\n\t{\r\n\t\tname:     \"invalid currency\",\r\n\t\tcurrency: \"ABC\",\r\n\t\tlocale:   \"en-US\",\r\n\t\tentries:  nil,\r\n\t},\r\n\t{\r\n\t\tname:     \"empty locale\",\r\n\t\tcurrency: \"USD\",\r\n\t\tlocale:   \"\",\r\n\t\tentries:  nil,\r\n\t},\r\n\t{\r\n\t\tname:     \"invalid locale\",\r\n\t\tcurrency: \"USD\",\r\n\t\tlocale:   \"nl-US\",\r\n\t\tentries:  nil,\r\n\t},\r\n\t{\r\n\t\tname:     \"invalid date (way too high month)\",\r\n\t\tcurrency: \"USD\",\r\n\t\tlocale:   \"en-US\",\r\n\t\tentries: []Entry{\r\n\t\t\t{\r\n\t\t\t\tDate:        \"2015-131-11\",\r\n\t\t\t\tDescription: \"Buy present\",\r\n\t\t\t\tChange:      12345,\r\n\t\t\t},\r\n\t\t},\r\n\t},\r\n\t{\r\n\t\tname:     \"invalid date (wrong separator)\",\r\n\t\tcurrency: \"USD\",\r\n\t\tlocale:   \"en-US\",\r\n\t\tentries: []Entry{\r\n\t\t\t{\r\n\t\t\t\tDate:        \"2015-12/11\",\r\n\t\t\t\tDescription: \"Buy present\",\r\n\t\t\t\tChange:      12345,\r\n\t\t\t},\r\n\t\t},\r\n\t},\r\n}\r\n\r\nfunc TestFormatLedgerSuccess(t *testing.T) {\r\n\tfor _, tc := range successTestCases {\r\n\t\tt.Run(tc.name, func(t *testing.T) {\r\n\t\t\tactual, err := FormatLedger(tc.currency, tc.locale, tc.entries)\r\n\t\t\tif err != nil {\r\n\t\t\t\tt.Fatalf(\"FormatLedger for input named %q returned unexpected error %v\", tc.name, err)\r\n\t\t\t}\r\n\t\t\texpected := tc.expected[1:] // Strip initial newline\r\n\t\t\tif actual != expected {\r\n\t\t\t\tt.Fatalf(\"FormatLedger for input named %q failed\\ngot:\\n%s\\nwant:\\n%s\", tc.name, actual, expected)\r\n\t\t\t}\r\n\t\t})\r\n\t}\r\n}\r\n\r\nfunc TestFormatLedgerFailure(t *testing.T) {\r\n\tfor _, tt := range failureTestCases {\r\n\t\tt.Run(tt.name, func(t *testing.T) {\r\n\t\t\t_, err := FormatLedger(tt.currency, tt.locale, tt.entries)\r\n\t\t\tif err == nil {\r\n\t\t\t\tt.Fatalf(\"FormatLedger for input %q expected error, got nil\", tt.name)\r\n\t\t\t}\r\n\t\t})\r\n\t}\r\n}\r\n\r\nfunc TestFormatLedgerNotChangeInput(t *testing.T) {\r\n\tentries := []Entry{\r\n\t\t{\r\n\t\t\tDate:        \"2015-01-02\",\r\n\t\t\tDescription: \"Freude schöner Götterfunken\",\r\n\t\t\tChange:      1000,\r\n\t\t},\r\n\t\t{\r\n\t\t\tDate:        \"2015-01-01\",\r\n\t\t\tDescription: \"Buy present\",\r\n\t\t\tChange:      -1000,\r\n\t\t},\r\n\t}\r\n\tentriesCopy := make([]Entry, len(entries))\r\n\tcopy(entriesCopy, entries)\r\n\tFormatLedger(\"USD\", \"en-US\", entries)\r\n\tif !reflect.DeepEqual(entries, entriesCopy) {\r\n\t\tt.Fatalf(\"FormatLedger modifies the input entries array\")\r\n\t}\r\n}\r\n\r\nfunc BenchmarkFormatLedger(b *testing.B) {\r\n\tif testing.Short() {\r\n\t\tb.Skip(\"skipping benchmark in short mode.\")\r\n\t}\r\n\tfor i := 0; i < b.N; i++ {\r\n\t\tfor _, tt := range successTestCases {\r\n\t\t\tFormatLedger(tt.currency, tt.locale, tt.entries)\r\n\t\t}\r\n\t}\r\n}\r\n"
}