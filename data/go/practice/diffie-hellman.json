{
  "language": "go",
  "type": "practice",
  "slug": "diffie-hellman",
  "title": "Diffie Hellman",
  "docs": {
    "instructions": "# Instructions\r\n\r\nDiffie-Hellman key exchange.\r\n\r\nAlice and Bob use Diffie-Hellman key exchange to share secrets.\r\nThey start with prime numbers, pick private keys, generate and share public keys, and then generate a shared secret key.\r\n\r\n## Step 0\r\n\r\nThe test program supplies prime numbers p and g.\r\n\r\n## Step 1\r\n\r\nAlice picks a private key, a, greater than 1 and less than p.\r\nBob does the same to pick a private key b.\r\n\r\n## Step 2\r\n\r\nAlice calculates a public key A.\r\n\r\n    A = gᵃ mod p\r\n\r\nUsing the same p and g, Bob similarly calculates a public key B from his private key b.\r\n\r\n## Step 3\r\n\r\nAlice and Bob exchange public keys.\r\nAlice calculates secret key s.\r\n\r\n    s = Bᵃ mod p\r\n\r\nBob calculates\r\n\r\n    s = Aᵇ mod p\r\n\r\nThe calculations produce the same result!\r\nAlice and Bob now share secret s.\r\n",
    "hints": ""
  },
  "starter_code": "package diffiehellman\r\n\r\nimport \"math/big\"\r\n\r\n// Diffie-Hellman-Merkle key exchange\r\n// Private keys should be generated randomly.\r\n\r\nfunc PrivateKey(p *big.Int) *big.Int {\r\n\tpanic(\"Please implement the PrivateKey function\")\r\n}\r\n\r\nfunc PublicKey(private, p *big.Int, g int64) *big.Int {\r\n\tpanic(\"Please implement the PublicKey function\")\r\n}\r\n\r\nfunc NewPair(p *big.Int, g int64) (*big.Int, *big.Int) {\r\n\tpanic(\"Please implement the NewPair function\")\r\n}\r\n\r\nfunc SecretKey(private1, public2, p *big.Int) *big.Int {\r\n\tpanic(\"Please implement the SecretKey function\")\r\n}\r\n",
  "tests": "package diffiehellman\r\n\r\nimport (\r\n\t\"math/big\"\r\n\t\"testing\"\r\n)\r\n\r\ntype testCase struct {\r\n\tg    int64    // prime, generator\r\n\tp    *big.Int // prime, modulus\r\n\ta, b *big.Int // private keys\r\n\tA, B *big.Int // public keys\r\n\ts    *big.Int // secret key\r\n}\r\n\r\n// WP example\r\nvar smallTest = testCase{\r\n\t5,\r\n\tbig.NewInt(23),\r\n\tbig.NewInt(6), big.NewInt(15),\r\n\tbig.NewInt(8), big.NewInt(19),\r\n\tbig.NewInt(2),\r\n}\r\n\r\n// 1024 bit example modulus from cryptopp.com wiki, random private keys\r\nvar biggerTest = testCase{\r\n\t2,\r\n\tmph(\"ab359aa76a6773ed7a93b214db0c25d0160817b8a893c001c761e198a3694509\" +\r\n\t\t\"ebe87a5313e0349d95083e5412c9fc815bfd61f95ddece43376550fdc624e92f\" +\r\n\t\t\"f38a415783b97261204e05d65731bba1ccff0e84c8cd2097b75feca1029261ae\" +\r\n\t\t\"19a389a2e15d2939314b184aef707b82eb94412065181d23e04bf065f4ac413f\"),\r\n\r\n\tmph(\"2f6afe91cb53ecfa463d45cd800c948f7cb83bb9ddc62a07b5b3fd302d0cdf52\" +\r\n\t\t\"18ae53ad015a632d137001a3b34239d54715606a292b6cf895b09d7dcf1bdf7a\"),\r\n\r\n\tmph(\"3651007bfa8a8b1cbaed2ae9326327599249c3bb6e9d8744b7407f3d4732cb8a\" +\r\n\t\t\"0708d95c382747bad640d444f135e7e599618d11b15b9ef32e7ac7194e547f4b\"),\r\n\r\n\tmph(\"57d5489e3858cbd8fae75120907d1521f8e935cce2206d285b11762847e2a4c4\" +\r\n\t\t\"a341a4eea18bdd8b40036c8d0004ffc323d5ae19da55176b08ff6f2d0ac97c65\" +\r\n\t\t\"357c1f16756a6901ff926c8544c8af0a90ed2705966851f79a115cb77aac66be\" +\r\n\t\t\"ceff569aadd7f02859539c28d55c08c62a03e45613bc52d205ace0704ea7c610\"),\r\n\r\n\tmph(\"6b189a36db5ca3ff83b66fb2c226078294c323f4c7cef35c506c237b0db7906d\" +\r\n\t\t\"64cceb05af15a3603a30fd49834d3a6971d917f520d9a577c159d3b7d2bd8813\" +\r\n\t\t\"5d19db47a9618340e4a51ec8845dbf5d50a4c6f14d6161def1eeaacecee8018f\" +\r\n\t\t\"8816113a294959399989b759f4618e35dbffc570ab2a5a74ac59fccef35f684c\"),\r\n\r\n\tmph(\"64f74babc466f8e56d9b77ce2cc65d65fe1603b931c018b98a2a615d66172590\" +\r\n\t\t\"803a94ac230db02de4b8ae567497c1844a6f7bd5bed69b95d3137acc1a6462d5\" +\r\n\t\t\"aeba5b2b83a0e6b8ed4c072e5135a57c87b654ebe04cf128bbff49ee06df33b7\" +\r\n\t\t\"8615e0067fdc9df22f7673b1e0501fb57598c7bff9ff173ddff47270fbd6f98f\"),\r\n}\r\n\r\n// must parse hex, short name contrived just to make test data line up with\r\n// tab width 4.\r\nfunc mph(h string) *big.Int {\r\n\tp, ok := new(big.Int).SetString(h, 16)\r\n\tif !ok {\r\n\t\tpanic(\"invalid hex: \" + h)\r\n\t}\r\n\treturn p\r\n}\r\n\r\nvar tests = []testCase{\r\n\tsmallTest,\r\n\tbiggerTest,\r\n}\r\n\r\nvar _one = big.NewInt(1)\r\n\r\n// test that PrivateKey returns numbers in range, returns different numbers.\r\nfunc TestPrivateKey(t *testing.T) {\r\n\tpriv := func(p *big.Int) *big.Int {\r\n\t\ta := PrivateKey(p)\r\n\t\tif a.Cmp(_one) <= 0 || a.Cmp(p) >= 0 {\r\n\t\t\tt.Fatalf(\"PrivateKey(%s) = %s, out of range (1, %s)\", p.String(), a.String(), p.String())\r\n\t\t}\r\n\t\treturn a\r\n\t}\r\n\tms := map[string]bool{}\r\n\tmb := map[string]bool{}\r\n\tfor i := 0; i < 100; i++ {\r\n\t\tms[priv(smallTest.p).String()] = true\r\n\t\tmb[priv(biggerTest.p).String()] = true\r\n\t}\r\n\tif len(ms) == 1 {\r\n\t\tt.Fatalf(\"For prime %s same key generated every time.  \"+\r\n\t\t\t\"Want random keys.\", smallTest.p.String())\r\n\t}\r\n\tif len(mb) < 100 {\r\n\t\tt.Fatalf(\"For prime %s duplicate keys generated.  \"+\r\n\t\t\t\"Want unique keys.\", biggerTest.p.String())\r\n\t}\r\n}\r\n\r\n// test that PublicKey returns known results.\r\nfunc TestPublicKey(t *testing.T) {\r\n\ttp := func(a, A, p *big.Int, g int64) {\r\n\t\tif k := PublicKey(a, p, g); k.Cmp(A) != 0 {\r\n\t\t\tt.Fatalf(\"PublicKey(%x,\\n%x,\\n%d)\\n= %x,\\nwant %x.\",\r\n\t\t\t\ta, p, g, k, A)\r\n\t\t}\r\n\t}\r\n\tfor _, test := range tests {\r\n\t\ttp(test.a, test.A, test.p, test.g)\r\n\t\ttp(test.b, test.B, test.p, test.g)\r\n\t}\r\n}\r\n\r\n// test that SecretKey returns known results.\r\nfunc TestSecretKeys(t *testing.T) {\r\n\ttp := func(a, B, p, s *big.Int) {\r\n\t\tif k := SecretKey(a, B, p); k.Cmp(s) != 0 {\r\n\t\t\tt.Fatalf(\"SecretKey(%x,\\n%x,\\n%x)\\n= %x,\\nwant %x.\",\r\n\t\t\t\ta, B, p, k, s)\r\n\t\t}\r\n\t}\r\n\tfor _, test := range tests {\r\n\t\ttp(test.a, test.B, test.p, test.s)\r\n\t\ttp(test.b, test.A, test.p, test.s)\r\n\t}\r\n}\r\n\r\n// test that NewPair produces working keys\r\nfunc TestNewPair(t *testing.T) {\r\n\tp, g := biggerTest.p, biggerTest.g\r\n\ttest := func(a, A *big.Int) {\r\n\t\tif a.Cmp(_one) <= 0 || a.Cmp(p) >= 0 {\r\n\t\t\tt.Fatalf(\"NewPair(%s, %d) private key = %s, out of range (1, %s)\",\r\n\t\t\t\tp.String(), g, a.String(), p.String())\r\n\t\t}\r\n\t\tif A.Cmp(_one) <= 0 || A.Cmp(p) >= 0 {\r\n\t\t\tt.Fatalf(\"NewPair(%s, %d) public key = %s, out of range (1, %s)\",\r\n\t\t\t\tp.String(), g, A.String(), p.String())\r\n\t\t}\r\n\t}\r\n\ta, A := NewPair(p, g)\r\n\ttest(a, A)\r\n\tfor i := 0; i < 20; i++ {\r\n\t\tb, B := NewPair(p, g)\r\n\t\ttest(b, B)\r\n\t\tsa := SecretKey(a, B, p)\r\n\t\tsb := SecretKey(b, A, p)\r\n\t\tif sa.Cmp(sb) != 0 {\r\n\t\t\tt.Fatalf(\"NewPair() produced non-working keys.\")\r\n\t\t}\r\n\t\ta, A = b, B\r\n\t}\r\n}\r\n\r\nfunc BenchmarkPrivateKey(b *testing.B) {\r\n\tif testing.Short() {\r\n\t\tb.Skip(\"skipping benchmark in short mode.\")\r\n\t}\r\n\tfor i := 0; i < b.N; i++ {\r\n\t\tPrivateKey(biggerTest.p)\r\n\t}\r\n}\r\n\r\nfunc BenchmarkPublicKey(b *testing.B) {\r\n\tif testing.Short() {\r\n\t\tb.Skip(\"skipping benchmark in short mode.\")\r\n\t}\r\n\tfor i := 0; i < b.N; i++ {\r\n\t\tPublicKey(biggerTest.a, biggerTest.p, biggerTest.g)\r\n\t}\r\n}\r\n\r\nfunc BenchmarkNewPair(b *testing.B) {\r\n\tif testing.Short() {\r\n\t\tb.Skip(\"skipping benchmark in short mode.\")\r\n\t}\r\n\tfor i := 0; i < b.N; i++ {\r\n\t\tNewPair(biggerTest.p, biggerTest.g)\r\n\t}\r\n}\r\n\r\nfunc BenchmarkSecretKey(b *testing.B) {\r\n\tif testing.Short() {\r\n\t\tb.Skip(\"skipping benchmark in short mode.\")\r\n\t}\r\n\tfor i := 0; i < b.N; i++ {\r\n\t\tSecretKey(biggerTest.a, biggerTest.B, biggerTest.p)\r\n\t}\r\n}\r\n"
}