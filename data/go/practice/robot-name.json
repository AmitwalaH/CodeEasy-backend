{
  "language": "go",
  "type": "practice",
  "slug": "robot-name",
  "title": "Robot Name",
  "docs": {
    "instructions": "# Instructions\r\n\r\nManage robot factory settings.\r\n\r\nWhen a robot comes off the factory floor, it has no name.\r\n\r\nThe first time you turn on a robot, a random name is generated in the format of two uppercase letters followed by three digits, such as RX837 or BC811.\r\n\r\nEvery once in a while we need to reset a robot to its factory settings, which means that its name gets wiped.\r\nThe next time you ask, that robot will respond with a new random name.\r\n\r\nThe names must be random: they should not follow a predictable sequence.\r\nUsing random names means a risk of collisions.\r\nYour solution must ensure that every existing robot has a unique name.\r\n",
    "hints": ""
  },
  "starter_code": "package robotname\r\n\r\n// Define the Robot type here.\r\n\r\nfunc (r *Robot) Name() (string, error) {\r\n\tpanic(\"Please implement the Name function\")\r\n}\r\n\r\nfunc (r *Robot) Reset() {\r\n\tpanic(\"Please implement the Reset function\")\r\n}\r\n",
  "tests": "package robotname\r\n\r\nimport (\r\n\t\"regexp\"\r\n\t\"testing\"\r\n)\r\n\r\nvar (\r\n\tnamePat = regexp.MustCompile(`^[A-Z]{2}\\d{3}$`)\r\n\tseen    = map[string]int{}\r\n)\r\n\r\nfunc New() *Robot { return new(Robot) }\r\n\r\n// getName is a test helper function to facilitate optionally checking for seen\r\n// robot names.\r\nfunc (r *Robot) getName(t testing.TB, expectSeen bool) string {\r\n\tt.Helper()\r\n\tnewName, err := r.Name()\r\n\tif err != nil {\r\n\t\tt.Fatalf(\"Name() returned unexpected error: %v\", err)\r\n\t}\r\n\tif len(newName) != 5 {\r\n\t\tt.Fatalf(\"names should have 5 characters: name '%s' has %d character(s)\", newName, len(newName))\r\n\t}\r\n\r\n\t_, chk := seen[newName]\r\n\tif !expectSeen && chk {\r\n\t\tt.Fatalf(\"Name %s reissued after %d robots.\", newName, len(seen))\r\n\t}\r\n\tseen[newName] = 0\r\n\treturn newName\r\n}\r\n\r\nfunc TestNameValid(t *testing.T) {\r\n\tn := New().getName(t, false)\r\n\tif !namePat.MatchString(n) {\r\n\t\tt.Errorf(`Invalid robot name %q, want form \"AA###\".`, n)\r\n\t}\r\n}\r\n\r\nfunc TestNameSticks(t *testing.T) {\r\n\tr := New()\r\n\tn1 := r.getName(t, false)\r\n\tn2 := r.getName(t, true)\r\n\tif n2 != n1 {\r\n\t\tt.Errorf(`Robot name changed.  Now %s, was %s.`, n2, n1)\r\n\t}\r\n}\r\n\r\nfunc TestSuccessiveRobotsHaveDifferentNames(t *testing.T) {\r\n\tn1 := New().getName(t, false)\r\n\tn2 := New().getName(t, false)\r\n\tif n1 == n2 {\r\n\t\tt.Errorf(`Robots with same name.  Two %s's.`, n1)\r\n\t}\r\n}\r\n\r\nfunc TestResetName(t *testing.T) {\r\n\tr := New()\r\n\tn1 := r.getName(t, false)\r\n\tr.Reset()\r\n\tif r.getName(t, false) == n1 {\r\n\t\tt.Errorf(`Robot name not cleared on reset.  Still %s.`, n1)\r\n\t}\r\n}\r\n\r\n// Test 1000 names are unique - this should run reasonably quickly even with a solution that is not particularly fast.\r\nfunc TestMultipleNames(t *testing.T) {\r\n\t// Test uniqueness for new robots.\r\n\tfor i := len(seen); i <= 1000; i++ {\r\n\t\tNew().getName(t, false)\r\n\t}\r\n}\r\n\r\nvar maxNames = 26 * 26 * 10 * 10 * 10\r\n\r\nconst lotsOfNames = 76000\r\n\r\n// TestCollisions tests if unique names are generated by creating new robots until all names are used.\r\nfunc TestCollisions(t *testing.T) {\r\n\t// Remove the next line to make this test run\r\n\tt.Skip(\"skipping test as solutions that are not particularly fast can exceed testing time limits.\")\r\n\r\n\t// Test uniqueness for new robots.\r\n\tfor i := len(seen); i <= lotsOfNames; i++ {\r\n\t\tNew().getName(t, false)\r\n\t}\r\n\r\n\t// Test that names aren't recycled either.\r\n\t// Note that this runs till names are exhausted.\r\n\tr := New()\r\n\tfor i := len(seen); i < maxNames; i++ {\r\n\t\tr.Reset()\r\n\t\tr.getName(t, false)\r\n\t}\r\n\r\n\t// Test that name exhaustion is handled more or less correctly.\r\n\t_, err := New().Name()\r\n\tif err == nil {\r\n\t\tt.Fatalf(\"should return error if namespace is exhausted\")\r\n\t}\r\n}\r\n"
}