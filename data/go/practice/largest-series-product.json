{
  "language": "go",
  "type": "practice",
  "slug": "largest-series-product",
  "title": "Largest Series Product",
  "docs": {
    "instructions": "# Instructions\r\n\r\nYour task is to look for patterns in the long sequence of digits in the encrypted signal.\r\n\r\nThe technique you're going to use here is called the largest series product.\r\n\r\nLet's define a few terms, first.\r\n\r\n- **input**: the sequence of digits that you need to analyze\r\n- **series**: a sequence of adjacent digits (those that are next to each other) that is contained within the input\r\n- **span**: how many digits long each series is\r\n- **product**: what you get when you multiply numbers together\r\n\r\nLet's work through an example, with the input `\"63915\"`.\r\n\r\n- To form a series, take adjacent digits in the original input.\r\n- If you are working with a span of `3`, there will be three possible series:\r\n  - `\"639\"`\r\n  - `\"391\"`\r\n  - `\"915\"`\r\n- Then we need to calculate the product of each series:\r\n  - The product of the series `\"639\"` is 162 (`6 × 3 × 9 = 162`)\r\n  - The product of the series `\"391\"` is 27 (`3 × 9 × 1 = 27`)\r\n  - The product of the series `\"915\"` is 45 (`9 × 1 × 5 = 45`)\r\n- 162 is bigger than both 27 and 45, so the largest series product of `\"63915\"` is from the series `\"639\"`.\r\n  So the answer is **162**.\r\n",
    "hints": ""
  },
  "starter_code": "package lsproduct\r\n\r\nfunc LargestSeriesProduct(digits string, span int) (int64, error) {\r\n\tpanic(\"Please implement the LargestSeriesProduct function\")\r\n}\r\n",
  "tests": "package lsproduct\r\n\r\nimport \"testing\"\r\n\r\nfunc TestLargestSeriesProduct(t *testing.T) {\r\n\tfor _, tc := range testCases {\r\n\t\tt.Run(tc.description, func(t *testing.T) {\r\n\t\t\tactual, err := LargestSeriesProduct(tc.digits, tc.span)\r\n\t\t\tif tc.error == \"\" {\r\n\t\t\t\t// we do not expect error\r\n\t\t\t\tif err != nil {\r\n\t\t\t\t\tt.Fatalf(\"LargestSeriesProduct(%q, %d) returned error: %v\\nwant: %d\", tc.digits, tc.span, err, tc.expected)\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif actual != tc.expected {\r\n\t\t\t\t\tt.Fatalf(\"LargestSeriesProduct(%q, %d) = %d, want: %d\", tc.digits, tc.span, actual, tc.expected)\r\n\t\t\t\t}\r\n\t\t\t} else if err == nil {\r\n\t\t\t\t// expect error but got nil\r\n\t\t\t\tt.Fatalf(\"LargestSeriesProduct(%q, %d) = %d, want error: %q\", tc.digits, tc.span, actual, tc.error)\r\n\t\t\t}\r\n\t\t})\r\n\t}\r\n}\r\n\r\nfunc BenchmarkLargestSeriesProduct(b *testing.B) {\r\n\tif testing.Short() {\r\n\t\tb.Skip(\"skipping benchmark in short mode.\")\r\n\t}\r\n\tfor i := 0; i < b.N; i++ {\r\n\t\tfor _, test := range testCases {\r\n\t\t\tLargestSeriesProduct(test.digits, test.span)\r\n\t\t}\r\n\t}\r\n}\r\n"
}