{
  "language": "go",
  "type": "practice",
  "slug": "binary-search-tree",
  "title": "Binary Search Tree",
  "docs": {
    "instructions": "# Instructions\r\n\r\nInsert and search for numbers in a binary tree.\r\n\r\nWhen we need to represent sorted data, an array does not make a good data structure.\r\n\r\nSay we have the array `[1, 3, 4, 5]`, and we add 2 to it so it becomes `[1, 3, 4, 5, 2]`.\r\nNow we must sort the entire array again!\r\nWe can improve on this by realizing that we only need to make space for the new item `[1, nil, 3, 4, 5]`, and then adding the item in the space we added.\r\nBut this still requires us to shift many elements down by one.\r\n\r\nBinary Search Trees, however, can operate on sorted data much more efficiently.\r\n\r\nA binary search tree consists of a series of connected nodes.\r\nEach node contains a piece of data (e.g. the number 3), a variable named `left`, and a variable named `right`.\r\nThe `left` and `right` variables point at `nil`, or other nodes.\r\nSince these other nodes in turn have other nodes beneath them, we say that the left and right variables are pointing at subtrees.\r\nAll data in the left subtree is less than or equal to the current node's data, and all data in the right subtree is greater than the current node's data.\r\n\r\nFor example, if we had a node containing the data 4, and we added the data 2, our tree would look like this:\r\n\r\n![A graph with root node 4 and a single child node 2.](https://assets.exercism.org/images/exercises/binary-search-tree/tree-4-2.svg)\r\n\r\n```text\r\n      4\r\n     /\r\n    2\r\n```\r\n\r\nIf we then added 6, it would look like this:\r\n\r\n![A graph with root node 4 and two child nodes 2 and 6.](https://assets.exercism.org/images/exercises/binary-search-tree/tree-4-2-6.svg)\r\n\r\n```text\r\n      4\r\n     / \\\r\n    2   6\r\n```\r\n\r\nIf we then added 3, it would look like this\r\n\r\n![A graph with root node 4, two child nodes 2 and 6, and a grandchild node 3.](https://assets.exercism.org/images/exercises/binary-search-tree/tree-4-2-6-3.svg)\r\n\r\n```text\r\n       4\r\n     /   \\\r\n    2     6\r\n     \\\r\n      3\r\n```\r\n\r\nAnd if we then added 1, 5, and 7, it would look like this\r\n\r\n![A graph with root node 4, two child nodes 2 and 6, and four grandchild nodes 1, 3, 5 and 7.](https://assets.exercism.org/images/exercises/binary-search-tree/tree-4-2-6-1-3-5-7.svg)\r\n\r\n```text\r\n          4\r\n        /   \\\r\n       /     \\\r\n      2       6\r\n     / \\     / \\\r\n    1   3   5   7\r\n```\r\n\r\n## Credit\r\n\r\nThe images were created by [habere-et-dispertire][habere-et-dispertire] using [PGF/TikZ][pgf-tikz] by Till Tantau.\r\n\r\n[habere-et-dispertire]: https://exercism.org/profiles/habere-et-dispertire\r\n[pgf-tikz]: https://en.wikipedia.org/wiki/PGF/TikZ\r\n",
    "hints": ""
  },
  "starter_code": "package binarysearchtree\r\n\r\ntype BinarySearchTree struct {\r\n\tleft  *BinarySearchTree\r\n\tdata  int\r\n\tright *BinarySearchTree\r\n}\r\n\r\n// NewBst creates and returns a new BinarySearchTree.\r\nfunc NewBst(i int) *BinarySearchTree {\r\n\tpanic(\"Please implement the NewBst function\")\r\n}\r\n\r\n// Insert inserts an int into the BinarySearchTree.\r\n// Inserts happen based on the rules of a binary search tree\r\nfunc (bst *BinarySearchTree) Insert(i int) {\r\n\tpanic(\"Please implement the Insert method\")\r\n}\r\n\r\n// SortedData returns the ordered contents of BinarySearchTree as an []int.\r\n// The values are in increasing order starting with the lowest int value.\r\n// A BinarySearchTree that has the numbers [1,3,7,5] added will return the\r\n// []int [1,3,5,7].\r\nfunc (bst *BinarySearchTree) SortedData() []int {\r\n\tpanic(\"Please implement the SortedData function\")\r\n}\r\n",
  "tests": "package binarysearchtree\r\n\r\nimport (\r\n\t\"errors\"\r\n\t\"strings\"\r\n\t\"testing\"\r\n)\r\n\r\ntype DataTestCase struct {\r\n\tdescription string\r\n\tinput       []int\r\n\tpaths       []string\r\n\tdata        []int\r\n}\r\n\r\nvar newBstTestCase DataTestCase = DataTestCase{\r\n\tdescription: \"data is retained\",\r\n\tinput:       []int{4},\r\n\tpaths:       []string{\"\"},\r\n\tdata:        []int{4},\r\n}\r\n\r\nvar insertTestCases = []DataTestCase{\r\n\t{\r\n\t\tdescription: \"smaller number at left node\",\r\n\t\tinput:       []int{4, 2},\r\n\t\tpaths:       []string{\"\", \"l\"},\r\n\t\tdata:        []int{4, 2},\r\n\t},\r\n\t{\r\n\t\tdescription: \"same number at left node\",\r\n\t\tinput:       []int{4, 4},\r\n\t\tpaths:       []string{\"\", \"l\"},\r\n\t\tdata:        []int{4, 4},\r\n\t},\r\n\t{\r\n\t\tdescription: \"greater number at right node\",\r\n\t\tinput:       []int{4, 5},\r\n\t\tpaths:       []string{\"\", \"r\"},\r\n\t\tdata:        []int{4, 5},\r\n\t},\r\n\t{\r\n\t\tdescription: \"can create complex tree\",\r\n\t\tinput:       []int{4, 2, 6, 1, 3, 5, 7},\r\n\t\tpaths:       []string{\"\", \"l\", \"ll\", \"lr\", \"r\", \"rl\", \"rr\"},\r\n\t\tdata:        []int{4, 2, 1, 3, 6, 5, 7},\r\n\t},\r\n}\r\n\r\ntype SortedDataTestCase struct {\r\n\tdescription string\r\n\tinput       []int\r\n\texpected    []int\r\n}\r\n\r\nvar sortedDataTestCases = []SortedDataTestCase{\r\n\t{\r\n\t\tdescription: \"can sort single number\",\r\n\t\tinput:       []int{2},\r\n\t\texpected:    []int{2},\r\n\t},\r\n\t{\r\n\t\tdescription: \"can sort if second number is smaller than first\",\r\n\t\tinput:       []int{2, 1},\r\n\t\texpected:    []int{1, 2},\r\n\t},\r\n\t{\r\n\t\tdescription: \"can sort if second number is same as first\",\r\n\t\tinput:       []int{2, 2},\r\n\t\texpected:    []int{2, 2},\r\n\t},\r\n\t{\r\n\t\tdescription: \"can sort if second number is greater than first\",\r\n\t\tinput:       []int{2, 3},\r\n\t\texpected:    []int{2, 3},\r\n\t},\r\n\t{\r\n\t\tdescription: \"can sort complex tree\",\r\n\t\tinput:       []int{2, 1, 3, 6, 7, 5},\r\n\t\texpected:    []int{1, 2, 3, 5, 6, 7},\r\n\t},\r\n}\r\n\r\nfunc (bst *BinarySearchTree) Size() int {\r\n\tif bst == nil {\r\n\t\treturn 0\r\n\t} else {\r\n\t\treturn 1 + bst.left.Size() + bst.right.Size()\r\n\t}\r\n}\r\n\r\nfunc (bst *BinarySearchTree) Data(path []rune) (int, error) {\r\n\tif bst == nil {\r\n\t\treturn 0, errors.New(\"nil\")\r\n\t}\r\n\tif len(path) == 0 {\r\n\t\treturn bst.data, nil\r\n\t}\r\n\tswitch path[0] {\r\n\tcase 'l':\r\n\t\treturn bst.left.Data(path[1:])\r\n\tcase 'r':\r\n\t\treturn bst.right.Data(path[1:])\r\n\tdefault:\r\n\t\treturn 0, errors.New(\"Invalid path element:\" + string(path[0]))\r\n\t}\r\n}\r\n\r\nfunc slicesEqual(a, b []int) bool {\r\n\tif len(a) != len(b) {\r\n\t\treturn false\r\n\t}\r\n\tif len(a) == 0 {\r\n\t\treturn true\r\n\t}\r\n\tfor i := 0; i < len(a); i++ {\r\n\t\tif a[i] != b[i] {\r\n\t\t\treturn false\r\n\t\t}\r\n\t}\r\n\treturn true\r\n}\r\n\r\n// makeBst builds tree by calling user defined functions NewBst and Insert\r\nfunc makeBst(input []int) *BinarySearchTree {\r\n\tif len(input) == 0 {\r\n\t\treturn nil\r\n\t}\r\n\tresult := NewBst(input[0])\r\n\tfor i := 1; i < len(input); i++ {\r\n\t\tresult.Insert(input[i])\r\n\t}\r\n\treturn result\r\n}\r\n\r\nfunc expandPath(p string) string {\r\n\tparts := make([]string, len(p))\r\n\tfor i, c := range p {\r\n\t\tif c == 'l' {\r\n\t\t\tparts[i] = \"left\"\r\n\t\t} else {\r\n\t\t\tparts[i] = \"right\"\r\n\t\t}\r\n\t}\r\n\treturn strings.Join(append([]string{\"bst\"}, parts...), \".\")\r\n}\r\n\r\nfunc TestNewBst(t *testing.T) {\r\n\ttd := newBstTestCase\r\n\tt.Run(td.description, func(t *testing.T) {\r\n\t\ttree := NewBst(td.input[0])\r\n\t\tif tree == nil {\r\n\t\t\tt.Fatalf(\"bst should not be nil\")\r\n\t\t}\r\n\t\tif tree.Size() != len(td.input) {\r\n\t\t\tt.Fatalf(\"bst should have same number of elements as input, expected: %v, got: %v\",\r\n\t\t\t\tlen(td.input), tree.Size())\r\n\t\t}\r\n\t\texpected := td.data[0]\r\n\t\tgot := tree.data\r\n\t\tif got != expected {\r\n\t\t\tt.Fatalf(\"expected %d, got %d\", expected, got)\r\n\t\t}\r\n\t})\r\n}\r\n\r\nfunc TestInsert(t *testing.T) {\r\n\tfor _, td := range insertTestCases {\r\n\t\tt.Run(td.description, func(t *testing.T) {\r\n\t\t\ttree := makeBst(td.input)\r\n\t\t\tif tree == nil {\r\n\t\t\t\tt.Fatalf(\"bst should not be nil\")\r\n\t\t\t}\r\n\t\t\tif tree.Size() != len(td.input) {\r\n\t\t\t\tt.Fatalf(\"bst should have same number of elements as input, expected: %v, got: %v\",\r\n\t\t\t\t\tlen(td.input), tree.Size())\r\n\t\t\t}\r\n\t\t\tfor i, path := range td.paths {\r\n\t\t\t\texpected := td.data[i]\r\n\t\t\t\texpPath := expandPath(path)\r\n\t\t\t\tgot, err := tree.Data([]rune(path))\r\n\t\t\t\tif err != nil {\r\n\t\t\t\t\tt.Fatalf(\"%v should not be nil:\", expPath)\r\n\t\t\t\t}\r\n\t\t\t\tif got != expected {\r\n\t\t\t\t\tt.Fatalf(\"%v: expected %d, got %d\", expPath+\".data\", expected, got)\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t})\r\n\t}\r\n}\r\n\r\nfunc TestSortedData(t *testing.T) {\r\n\tfor _, td := range sortedDataTestCases {\r\n\t\tt.Run(td.description, func(t *testing.T) {\r\n\t\t\ttree := makeBst(td.input)\r\n\t\t\tif tree == nil {\r\n\t\t\t\tt.Fatalf(\"bst should not be nil\")\r\n\t\t\t}\r\n\t\t\tif tree.Size() != len(td.input) {\r\n\t\t\t\tt.Fatalf(\"bst should have same number of elements as input, expected: %v, got: %v\",\r\n\t\t\t\t\tlen(td.input), tree.Size())\r\n\t\t\t}\r\n\t\t\tgot := tree.SortedData()\r\n\t\t\tif !slicesEqual(got, td.expected) {\r\n\t\t\t\tt.Fatalf(\"expected %d, got %d\", td.expected, got)\r\n\t\t\t}\r\n\t\t})\r\n\t}\r\n}\r\n\r\nvar benchmarkResult []int\r\n\r\nfunc BenchmarkSortedData(b *testing.B) {\r\n\tif testing.Short() {\r\n\t\tb.Skip(\"skipping benchmark in short mode.\")\r\n\t}\r\n\tinput := []int{2, 1, 3, 6, 7, 5, 2, 1, 3, 6, 7, 5}\r\n\ttree := makeBst(input)\r\n\tvar result []int\r\n\tb.ResetTimer()\r\n\tfor i := 0; i < b.N; i++ {\r\n\t\tresult = tree.SortedData()\r\n\t}\r\n\tbenchmarkResult = result\r\n}\r\n"
}