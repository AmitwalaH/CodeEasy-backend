{
  "language": "go",
  "type": "practice",
  "slug": "hexadecimal",
  "title": "Hexadecimal",
  "docs": {
    "instructions": "# Instructions\r\n\r\nConvert a hexadecimal number, represented as a string (e.g. \"10af8c\"), to its decimal equivalent using first principles (i.e. no, you may not use built-in or external libraries to accomplish the conversion).\r\n\r\nOn the web we use hexadecimal to represent colors, e.g. green: 008000,\r\nteal: 008080, navy: 000080).\r\n\r\nThe program should handle invalid hexadecimal strings.\r\n",
    "hints": ""
  },
  "starter_code": "package hexadecimal\r\n\r\nfunc ParseHex(in string, out int64, errCase string) {\r\n\tpanic(\"Please implement the ParseHex function\")\r\n}\r\n",
  "tests": "// Your solution must include the following definitions:\r\n//\r\n// func ParseHex(string) (int64, error)\r\n// func HandleErrors([]string) []string\r\n//\r\n// HandleErrors takes a list of inputs for ParseHex and returns a matching list\r\n// of error cases.  It must call ParseHex on each input, handle the error result,\r\n// and put one of three strings, \"none\", \"syntax\", or \"range\" in the result list\r\n// according to the error.\r\n\r\npackage hexadecimal\r\n\r\nimport (\r\n\t\"strings\"\r\n\t\"testing\"\r\n)\r\n\r\nvar testCases = []struct {\r\n\tin      string\r\n\tout     int64\r\n\terrCase string\r\n}{\r\n\t{\"1\", 1, \"none\"},\r\n\t{\"10\", 0x10, \"none\"},\r\n\t{\"2d\", 0x2d, \"none\"},\r\n\t{\"012\", 0x12, \"none\"},\r\n\t{\"cfcfcf\", 0xcfcfcf, \"none\"},\r\n\t{\"CFCFCF\", 0xcfcfcf, \"none\"},\r\n\t{\"\", 0, \"syntax\"},\r\n\t{\"peanut\", 0, \"syntax\"},\r\n\t{\"2cg134\", 0, \"syntax\"},\r\n\t{\"8000000000000000\", 0, \"range\"},\r\n\t{\"9223372036854775809\", 0, \"range\"},\r\n}\r\n\r\nfunc TestParseHex(t *testing.T) {\r\n\tfor _, test := range testCases {\r\n\t\tout, err := ParseHex(test.in)\r\n\t\tif test.errCase != \"none\" {\r\n\t\t\t// check if err is of error type\r\n\t\t\tvar _ error = err\r\n\r\n\t\t\t// we expect error\r\n\t\t\tif err == nil {\r\n\t\t\t\tt.Errorf(\"ParseHex(%q): expected an error, but error is nil\",\r\n\t\t\t\t\ttest.in)\r\n\t\t\t\tcontinue\r\n\t\t\t}\r\n\r\n\t\t\tif !strings.Contains(strings.ToLower(err.Error()), test.errCase) {\r\n\t\t\t\tt.Errorf(\r\n\t\t\t\t\t\"ParseHex(%q) returned error %q. Expected error containing '%s'.\",\r\n\t\t\t\t\ttest.in, err, test.errCase)\r\n\t\t\t}\r\n\t\t} else {\r\n\t\t\tif out != test.out {\r\n\t\t\t\tt.Errorf(\"ParseHex(%q) = %d. Expected %d.\",\r\n\t\t\t\t\ttest.in, out, test.out)\r\n\t\t\t}\r\n\r\n\t\t\t// we dont expect error\r\n\t\t\tif err != nil {\r\n\t\t\t\tt.Errorf(\"ParseHex(%q) returned error %q.  Error not expected.\",\r\n\t\t\t\t\ttest.in, err)\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n}\r\n\r\nfunc TestHandleErrors(t *testing.T) {\r\n\ttests := make([]string, len(testCases))\r\n\tfor i, test := range testCases {\r\n\t\ttests[i] = test.in\r\n\t}\r\n\ter := HandleErrors(tests)\r\n\tif len(er) != len(tests) {\r\n\t\tt.Fatalf(\"For %d tests, HandleErrors returned %d results, want %d\",\r\n\t\t\tlen(tests), len(er), len(tests))\r\n\t}\r\n\tfor i, e := range er {\r\n\t\tif e != testCases[i].errCase {\r\n\t\t\tt.Errorf(\"For ParseHex(%q), HandleErrors reports %q, want %q\",\r\n\t\t\t\ttests[i], e, testCases[i].errCase)\r\n\t\t}\r\n\t}\r\n}\r\n\r\nfunc BenchmarkParseHex(b *testing.B) {\r\n\tif testing.Short() {\r\n\t\tb.Skip(\"skipping benchmark in short mode.\")\r\n\t}\r\n\tfor i := 0; i < b.N; i++ {\r\n\t\tfor _, test := range testCases {\r\n\t\t\tParseHex(test.in)\r\n\t\t}\r\n\t}\r\n}\r\n"
}