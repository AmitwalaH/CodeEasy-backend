{
  "language": "go",
  "type": "practice",
  "slug": "binary",
  "title": "Binary",
  "docs": {
    "instructions": "# Instructions\r\n\r\nConvert a binary number, represented as a string (e.g. '101010'), to its decimal equivalent using first principles.\r\n\r\nImplement binary to decimal conversion. Given a binary input\r\nstring, your program should produce a decimal output. The\r\nprogram should handle invalid inputs.\r\n\r\n## Note\r\n\r\n- Implement the conversion yourself.\r\n  Do not use something else to perform the conversion for you.\r\n\r\n## About Binary (Base-2)\r\n\r\nDecimal is a base-10 system.\r\n\r\nA number 23 in base 10 notation can be understood\r\nas a linear combination of powers of 10:\r\n\r\n- The rightmost digit gets multiplied by 10^0 = 1\r\n- The next number gets multiplied by 10^1 = 10\r\n- ...\r\n- The *n*th number gets multiplied by 10^*(n-1)*.\r\n- All these values are summed.\r\n\r\nSo: `23 => 2*10^1 + 3*10^0 => 2*10 + 3*1 = 23 base 10`\r\n\r\nBinary is similar, but uses powers of 2 rather than powers of 10.\r\n\r\nSo: `101 => 1*2^2 + 0*2^1 + 1*2^0 => 1*4 + 0*2 + 1*1 => 4 + 1 => 5 base 10`.\r\n",
    "hints": ""
  },
  "starter_code": "package binary\r\n\r\n// TODO: add solution stub\r\nfunc ParseBinary(binary string, expected int, ok bool) {\r\n\tpanic(\"Please implement the ParseBinary function\")\r\n}\r\n",
  "tests": "package binary\r\n\r\nimport (\r\n\t\"testing\"\r\n)\r\n\r\n// You must implement the function,\r\n//\r\n//    func ParseBinary(string) (int, error)\r\n//\r\n// It is standard for Go functions to return error values to report error conditions.\r\n// The test cases have some inputs that are invalid.\r\n// For invalid inputs, return an error that signals to the user why the error happened.\r\n// The test cases can only check that you return *some* error,\r\n// but it's still good practice to return useful errors.\r\n\r\nvar testCases = []struct {\r\n\tbinary   string\r\n\texpected int\r\n\tok       bool\r\n}{\r\n\t{\"1\", 1, true},\r\n\t{\"10\", 2, true},\r\n\t{\"11\", 3, true},\r\n\t{\"100\", 4, true},\r\n\t{\"1001\", 9, true},\r\n\t{\"11010\", 26, true},\r\n\t{\"10001101000\", 1128, true},\r\n\t{\"0\", 0, true},\r\n\t{\"foo101\", 0, false},\r\n\t{\"101bar\", 0, false},\r\n\t{\"101baz010\", 0, false},\r\n\t{\"22\", 0, false},\r\n}\r\n\r\nfunc TestParseBinary(t *testing.T) {\r\n\tfor _, tt := range testCases {\r\n\t\tactual, err := ParseBinary(tt.binary)\r\n\t\tif tt.ok {\r\n\t\t\tif err != nil {\r\n\t\t\t\tvar _ error = err\r\n\t\t\t\tt.Fatalf(\"ParseBinary(%v) returned error %q.  Error not expected.\",\r\n\t\t\t\t\ttt.binary, err)\r\n\t\t\t}\r\n\t\t\tif actual != tt.expected {\r\n\t\t\t\tt.Fatalf(\"ParseBinary(%v): actual %d, expected %v\",\r\n\t\t\t\t\ttt.binary, actual, tt.expected)\r\n\t\t\t}\r\n\t\t} else if err == nil {\r\n\t\t\tt.Fatalf(\"ParseBinary(%v) returned %d and no error.  Expected an error.\",\r\n\t\t\t\ttt.binary, actual)\r\n\t\t}\r\n\t}\r\n}\r\n\r\n// Benchmark combined time for all tests\r\nfunc BenchmarkBinary(b *testing.B) {\r\n\tif testing.Short() {\r\n\t\tb.Skip(\"skipping benchmark in short mode.\")\r\n\t}\r\n\tfor i := 0; i < b.N; i++ {\r\n\t\tfor _, tt := range testCases {\r\n\t\t\tParseBinary(tt.binary)\r\n\t\t}\r\n\t}\r\n}\r\n"
}