{
  "language": "go",
  "type": "practice",
  "slug": "tree-building",
  "title": "Tree Building",
  "docs": {
    "instructions": "# Instructions\r\n\r\nRefactor a tree building algorithm.\r\n\r\nSome web-forums have a tree layout, so posts are presented as a tree.\r\nHowever the posts are typically stored in a database as an unsorted set of records.\r\nThus when presenting the posts to the user the tree structure has to be reconstructed.\r\n\r\nYour job will be to refactor a working but slow and ugly piece of code that implements the tree building logic for highly abstracted records.\r\nThe records only contain an ID number and a parent ID number.\r\nThe ID number is always between 0 (inclusive) and the length of the record list (exclusive).\r\nAll records have a parent ID lower than their own ID, except for the root record, which has a parent ID that's equal to its own ID.\r\n\r\nAn example tree:\r\n\r\n```text\r\nroot (ID: 0, parent ID: 0)\r\n|-- child1 (ID: 1, parent ID: 0)\r\n|    |-- grandchild1 (ID: 2, parent ID: 1)\r\n|    +-- grandchild2 (ID: 4, parent ID: 1)\r\n+-- child2 (ID: 3, parent ID: 0)\r\n|    +-- grandchild3 (ID: 6, parent ID: 3)\r\n+-- child3 (ID: 5, parent ID: 0)\r\n```\r\n",
    "hints": ""
  },
  "starter_code": "package tree\r\n\r\ntype Record struct {\r\n\tID     int\r\n\tParent int\r\n\t// feel free to add fields as you see fit\r\n}\r\n\r\ntype Node struct {\r\n\tID       int\r\n\tChildren []*Node\r\n\t// feel free to add fields as you see fit\r\n}\r\n\r\nfunc Build(records []Record) (*Node, error) {\r\n\tpanic(\"Please implement the Build function\")\r\n}\r\n",
  "tests": "//nolint:gosec // In the context of this exercise, it is fine to use math.Rand instead of crypto.Rand.\r\npackage tree\r\n\r\nimport (\r\n\t\"fmt\"\r\n\t\"math/rand\"\r\n\t\"testing\"\r\n)\r\n\r\n// Define a function Build(records []Record) (*Node, error)\r\n// where Record is a struct containing int fields ID and Parent\r\n// and Node is a struct containing int field ID and []*Node field Children.\r\n\r\nvar successTestCases = []struct {\r\n\tname     string\r\n\tinput    []Record\r\n\texpected *Node\r\n}{\r\n\t{\r\n\t\tname:     \"empty input\",\r\n\t\tinput:    []Record{},\r\n\t\texpected: nil,\r\n\t},\r\n\t{\r\n\t\tname: \"one node\",\r\n\t\tinput: []Record{\r\n\t\t\t{ID: 0},\r\n\t\t},\r\n\t\texpected: &Node{\r\n\t\t\tID: 0,\r\n\t\t},\r\n\t},\r\n\t{\r\n\t\tname: \"three nodes in order\",\r\n\t\tinput: []Record{\r\n\t\t\t{ID: 0},\r\n\t\t\t{ID: 1, Parent: 0},\r\n\t\t\t{ID: 2, Parent: 0},\r\n\t\t},\r\n\t\texpected: &Node{\r\n\t\t\tID: 0,\r\n\t\t\tChildren: []*Node{\r\n\t\t\t\t{ID: 1},\r\n\t\t\t\t{ID: 2},\r\n\t\t\t},\r\n\t\t},\r\n\t},\r\n\t{\r\n\t\tname: \"three nodes in reverse order\",\r\n\t\tinput: []Record{\r\n\t\t\t{ID: 2, Parent: 0},\r\n\t\t\t{ID: 1, Parent: 0},\r\n\t\t\t{ID: 0},\r\n\t\t},\r\n\t\texpected: &Node{\r\n\t\t\tID: 0,\r\n\t\t\tChildren: []*Node{\r\n\t\t\t\t{ID: 1},\r\n\t\t\t\t{ID: 2},\r\n\t\t\t},\r\n\t\t},\r\n\t},\r\n\t{\r\n\t\tname: \"three levels of nesting\",\r\n\t\tinput: []Record{\r\n\t\t\t{ID: 2, Parent: 1},\r\n\t\t\t{ID: 1, Parent: 0},\r\n\t\t\t{ID: 3, Parent: 2},\r\n\t\t\t{ID: 0},\r\n\t\t},\r\n\t\texpected: &Node{\r\n\t\t\tID: 0,\r\n\t\t\tChildren: []*Node{\r\n\t\t\t\t{\r\n\t\t\t\t\tID: 1,\r\n\t\t\t\t\tChildren: []*Node{\r\n\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\tID: 2,\r\n\t\t\t\t\t\t\tChildren: []*Node{\r\n\t\t\t\t\t\t\t\t{ID: 3},\r\n\t\t\t\t\t\t\t},\r\n\t\t\t\t\t\t},\r\n\t\t\t\t\t},\r\n\t\t\t\t},\r\n\t\t\t},\r\n\t\t},\r\n\t},\r\n\t{\r\n\t\tname: \"more than two children\",\r\n\t\tinput: []Record{\r\n\t\t\t{ID: 3, Parent: 0},\r\n\t\t\t{ID: 2, Parent: 0},\r\n\t\t\t{ID: 1, Parent: 0},\r\n\t\t\t{ID: 0},\r\n\t\t},\r\n\t\texpected: &Node{\r\n\t\t\tID: 0,\r\n\t\t\tChildren: []*Node{\r\n\t\t\t\t{ID: 1},\r\n\t\t\t\t{ID: 2},\r\n\t\t\t\t{ID: 3},\r\n\t\t\t},\r\n\t\t},\r\n\t},\r\n\t{\r\n\t\tname: \"binary tree\",\r\n\t\tinput: []Record{\r\n\t\t\t{ID: 5, Parent: 1},\r\n\t\t\t{ID: 3, Parent: 2},\r\n\t\t\t{ID: 2, Parent: 0},\r\n\t\t\t{ID: 4, Parent: 1},\r\n\t\t\t{ID: 1, Parent: 0},\r\n\t\t\t{ID: 0},\r\n\t\t\t{ID: 6, Parent: 2},\r\n\t\t},\r\n\t\texpected: &Node{\r\n\t\t\tID: 0,\r\n\t\t\tChildren: []*Node{\r\n\t\t\t\t{\r\n\t\t\t\t\tID: 1,\r\n\t\t\t\t\tChildren: []*Node{\r\n\t\t\t\t\t\t{ID: 4},\r\n\t\t\t\t\t\t{ID: 5},\r\n\t\t\t\t\t},\r\n\t\t\t\t},\r\n\t\t\t\t{\r\n\t\t\t\t\tID: 2,\r\n\t\t\t\t\tChildren: []*Node{\r\n\t\t\t\t\t\t{ID: 3},\r\n\t\t\t\t\t\t{ID: 6},\r\n\t\t\t\t\t},\r\n\t\t\t\t},\r\n\t\t\t},\r\n\t\t},\r\n\t},\r\n\t{\r\n\t\tname: \"unbalanced tree\",\r\n\t\tinput: []Record{\r\n\t\t\t{ID: 5, Parent: 2},\r\n\t\t\t{ID: 3, Parent: 2},\r\n\t\t\t{ID: 2, Parent: 0},\r\n\t\t\t{ID: 4, Parent: 1},\r\n\t\t\t{ID: 1, Parent: 0},\r\n\t\t\t{ID: 0},\r\n\t\t\t{ID: 6, Parent: 2},\r\n\t\t},\r\n\t\texpected: &Node{\r\n\t\t\tID: 0,\r\n\t\t\tChildren: []*Node{\r\n\t\t\t\t{\r\n\t\t\t\t\tID: 1,\r\n\t\t\t\t\tChildren: []*Node{\r\n\t\t\t\t\t\t{ID: 4},\r\n\t\t\t\t\t},\r\n\t\t\t\t},\r\n\t\t\t\t{\r\n\t\t\t\t\tID: 2,\r\n\t\t\t\t\tChildren: []*Node{\r\n\t\t\t\t\t\t{ID: 3},\r\n\t\t\t\t\t\t{ID: 5},\r\n\t\t\t\t\t\t{ID: 6},\r\n\t\t\t\t\t},\r\n\t\t\t\t},\r\n\t\t\t},\r\n\t\t},\r\n\t},\r\n}\r\n\r\nvar failureTestCases = []struct {\r\n\tname  string\r\n\tinput []Record\r\n}{\r\n\t{\r\n\t\tname: \"one root node and has parent\",\r\n\t\tinput: []Record{\r\n\t\t\t{ID: 0, Parent: 1},\r\n\t\t},\r\n\t},\r\n\t{\r\n\t\tname: \"root node has parent\",\r\n\t\tinput: []Record{\r\n\t\t\t{ID: 0, Parent: 1},\r\n\t\t\t{ID: 1, Parent: 0},\r\n\t\t},\r\n\t},\r\n\t{\r\n\t\tname: \"no root node\",\r\n\t\tinput: []Record{\r\n\t\t\t{ID: 1, Parent: 0},\r\n\t\t},\r\n\t},\r\n\t{\r\n\t\tname: \"duplicate node\",\r\n\t\tinput: []Record{\r\n\t\t\t{ID: 0, Parent: 0},\r\n\t\t\t{ID: 1, Parent: 0},\r\n\t\t\t{ID: 1, Parent: 0},\r\n\t\t},\r\n\t},\r\n\t{\r\n\t\tname: \"duplicate root\",\r\n\t\tinput: []Record{\r\n\t\t\t{ID: 0, Parent: 0},\r\n\t\t\t{ID: 0, Parent: 0},\r\n\t\t},\r\n\t},\r\n\t{\r\n\t\tname: \"non-continuous\",\r\n\t\tinput: []Record{\r\n\t\t\t{ID: 2, Parent: 0},\r\n\t\t\t{ID: 4, Parent: 2},\r\n\t\t\t{ID: 1, Parent: 0},\r\n\t\t\t{ID: 0},\r\n\t\t},\r\n\t},\r\n\t{\r\n\t\tname: \"cycle directly\",\r\n\t\tinput: []Record{\r\n\t\t\t{ID: 5, Parent: 2},\r\n\t\t\t{ID: 3, Parent: 2},\r\n\t\t\t{ID: 2, Parent: 2},\r\n\t\t\t{ID: 4, Parent: 1},\r\n\t\t\t{ID: 1, Parent: 0},\r\n\t\t\t{ID: 0},\r\n\t\t\t{ID: 6, Parent: 3},\r\n\t\t},\r\n\t},\r\n\t{\r\n\t\tname: \"cycle indirectly\",\r\n\t\tinput: []Record{\r\n\t\t\t{ID: 5, Parent: 2},\r\n\t\t\t{ID: 3, Parent: 2},\r\n\t\t\t{ID: 2, Parent: 6},\r\n\t\t\t{ID: 4, Parent: 1},\r\n\t\t\t{ID: 1, Parent: 0},\r\n\t\t\t{ID: 0},\r\n\t\t\t{ID: 6, Parent: 3},\r\n\t\t},\r\n\t},\r\n\t{\r\n\t\tname: \"higher id parent of lower id\",\r\n\t\tinput: []Record{\r\n\t\t\t{ID: 0},\r\n\t\t\t{ID: 2, Parent: 0},\r\n\t\t\t{ID: 1, Parent: 2},\r\n\t\t},\r\n\t},\r\n}\r\n\r\nfunc (n Node) String() string {\r\n\treturn fmt.Sprintf(\"%d:%s\", n.ID, n.Children)\r\n}\r\n\r\nfunc TestMakeTreeSuccess(t *testing.T) {\r\n\tfor _, tt := range successTestCases {\r\n\t\tt.Run(tt.name, func(t *testing.T) {\r\n\t\t\tactual, err := Build(tt.input)\r\n\t\t\tif err != nil {\r\n\t\t\t\tvar _ error = err\r\n\t\t\t\tt.Fatalf(\"Build for test case %q returned error %q. Error not expected.\",\r\n\t\t\t\t\ttt.name, err)\r\n\t\t\t}\r\n\t\t\tif !nodeEqual(actual, tt.expected) {\r\n\t\t\t\tt.Fatalf(\"Build for test case %q returned %s but was expected to return %s.\",\r\n\t\t\t\t\ttt.name, actual, tt.expected)\r\n\t\t\t}\r\n\t\t})\r\n\t}\r\n}\r\n\r\nfunc TestMakeTreeFailure(t *testing.T) {\r\n\tfor _, tt := range failureTestCases {\r\n\t\tt.Run(tt.name, func(t *testing.T) {\r\n\t\t\tactual, err := Build(tt.input)\r\n\t\t\tif err == nil {\r\n\t\t\t\tt.Fatalf(\"Build for test case %q returned %s but was expected to fail.\",\r\n\t\t\t\t\ttt.name, actual)\r\n\t\t\t}\r\n\t\t})\r\n\t}\r\n}\r\n\r\nfunc shuffleRecords(records []Record) []Record {\r\n\tgen := rand.New(rand.NewSource(42))\r\n\tnewRecords := make([]Record, len(records))\r\n\tfor i, idx := range gen.Perm(len(records)) {\r\n\t\tnewRecords[i] = records[idx]\r\n\t}\r\n\treturn newRecords\r\n}\r\n\r\n// Binary tree\r\nfunc makeTwoTreeRecords() []Record {\r\n\trecords := make([]Record, 1<<16)\r\n\tfor i := range records {\r\n\t\tif i == 0 {\r\n\t\t\trecords[i] = Record{ID: 0}\r\n\t\t} else {\r\n\t\t\trecords[i] = Record{ID: i, Parent: i >> 1}\r\n\t\t}\r\n\t}\r\n\treturn shuffleRecords(records)\r\n}\r\n\r\nvar twoTreeRecords = makeTwoTreeRecords()\r\n\r\nfunc BenchmarkTwoTree(b *testing.B) {\r\n\tif testing.Short() {\r\n\t\tb.Skip(\"skipping benchmark in short mode.\")\r\n\t}\r\n\tfor i := 0; i < b.N; i++ {\r\n\t\tBuild(twoTreeRecords)\r\n\t}\r\n}\r\n\r\n// Each node but the root node and leaf nodes has ten children.\r\nfunc makeTenTreeRecords() []Record {\r\n\trecords := make([]Record, 10000)\r\n\tfor i := range records {\r\n\t\tif i == 0 {\r\n\t\t\trecords[i] = Record{ID: 0}\r\n\t\t} else {\r\n\t\t\trecords[i] = Record{ID: i, Parent: i / 10}\r\n\t\t}\r\n\t}\r\n\treturn shuffleRecords(records)\r\n}\r\n\r\nvar tenTreeRecords = makeTenTreeRecords()\r\n\r\nfunc BenchmarkTenTree(b *testing.B) {\r\n\tif testing.Short() {\r\n\t\tb.Skip(\"skipping benchmark in short mode.\")\r\n\t}\r\n\tfor i := 0; i < b.N; i++ {\r\n\t\tBuild(tenTreeRecords)\r\n\t}\r\n}\r\n\r\nfunc makeShallowRecords() []Record {\r\n\trecords := make([]Record, 10000)\r\n\tfor i := range records {\r\n\t\trecords[i] = Record{ID: i, Parent: 0}\r\n\t}\r\n\treturn shuffleRecords(records)\r\n}\r\n\r\nvar shallowRecords = makeShallowRecords()\r\n\r\nfunc BenchmarkShallowTree(b *testing.B) {\r\n\tif testing.Short() {\r\n\t\tb.Skip(\"skipping benchmark in short mode.\")\r\n\t}\r\n\tfor i := 0; i < b.N; i++ {\r\n\t\tBuild(shallowRecords)\r\n\t}\r\n}\r\n\r\nfunc nodeEqual(node1, node2 *Node) bool {\r\n\tswitch {\r\n\tcase node1 == nil && node2 == nil:\r\n\t\treturn true\r\n\tcase node1 == nil && node2 != nil:\r\n\t\treturn false\r\n\tcase node1 != nil && node2 == nil:\r\n\t\treturn false\r\n\tdefault:\r\n\t\treturn node1.ID == node2.ID && nodeSliceEqual(node1.Children, node2.Children)\r\n\t}\r\n}\r\n\r\nfunc nodeSliceEqual(nodes1, nodes2 []*Node) bool {\r\n\tif len(nodes1) == 0 && len(nodes2) == 0 {\r\n\t\treturn true\r\n\t}\r\n\tif len(nodes1) != len(nodes2) {\r\n\t\treturn false\r\n\t}\r\n\tfor i := range nodes1 {\r\n\t\tif !nodeEqual(nodes1[i], nodes2[i]) {\r\n\t\t\treturn false\r\n\t\t}\r\n\t}\r\n\treturn true\r\n}\r\n"
}