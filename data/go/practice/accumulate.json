{
  "language": "go",
  "type": "practice",
  "slug": "accumulate",
  "title": "Accumulate",
  "docs": {
    "instructions": "# Instructions\r\n\r\nImplement the `accumulate` operation, which, given a collection and an\r\noperation to perform on each element of the collection, returns a new\r\ncollection containing the result of applying that operation to each element of\r\nthe input collection.\r\n\r\nGiven the collection of strings:\r\n\r\n- \"cat\", \"Dog\", \"b4t\", \"gO\"\r\n\r\nAnd the operation:\r\n\r\n- upcase a string\r\n\r\nYour code should be able to produce the collection of strings:\r\n\r\n- \"CAT\", \"DOG\", \"B4T, \"GO\"\r\n\r\nCheck out the test suite to see the expected function signature.\r\n\r\n## Restrictions\r\n\r\nKeep your hands off that collect/map/fmap/whatchamacallit functionality\r\nprovided by your standard library!\r\nSolve this one yourself using other basic tools instead.\r\n",
    "hints": ""
  },
  "starter_code": "package accumulate\r\n\r\nfunc Accumulate(list []string, transform func(string) string) []string {\r\n\tpanic(\"Please implement the Accumulate function\")\r\n}\r\n",
  "tests": "package accumulate\r\n\r\nimport (\r\n\t\"fmt\"\r\n\t\"strings\"\r\n\t\"testing\"\r\n\t\"unicode\"\r\n)\r\n\r\n// Title is a copy of strings.Title function of the stdlib.\r\n// The copy is here because strings.Title is deprecated but we still\r\n// want to use this function as the alternative would require us to support\r\n// external dependencies which we don't yet (tracking issue https://github.com/exercism/go/issues/2379).\r\n// Students should still be able to use strings.Title if they want.\r\n// Since this exercise is currently deprecated, this shouldn't matter too much.\r\nfunc Title(s string) string {\r\n\t// Use a closure here to remember state.\r\n\t// Hackish but effective. Depends on Map scanning in order and calling\r\n\t// the closure once per rune.\r\n\tprev := ' '\r\n\treturn strings.Map(\r\n\t\tfunc(r rune) rune {\r\n\t\t\tif isSeparator(prev) {\r\n\t\t\t\tprev = r\r\n\t\t\t\treturn unicode.ToTitle(r)\r\n\t\t\t}\r\n\t\t\tprev = r\r\n\t\t\treturn r\r\n\t\t},\r\n\t\ts)\r\n}\r\n\r\n// Copy of strings.isSeparator function of the stdlib.\r\nfunc isSeparator(r rune) bool {\r\n\t// ASCII alphanumerics and underscore are not separators\r\n\tif r <= 0x7F {\r\n\t\tswitch {\r\n\t\tcase '0' <= r && r <= '9':\r\n\t\t\treturn false\r\n\t\tcase 'a' <= r && r <= 'z':\r\n\t\t\treturn false\r\n\t\tcase 'A' <= r && r <= 'Z':\r\n\t\t\treturn false\r\n\t\tcase r == '_':\r\n\t\t\treturn false\r\n\t\t}\r\n\t\treturn true\r\n\t}\r\n\t// Letters and digits are not separators\r\n\tif unicode.IsLetter(r) || unicode.IsDigit(r) {\r\n\t\treturn false\r\n\t}\r\n\t// Otherwise, all we can do for now is treat spaces as separators.\r\n\treturn unicode.IsSpace(r)\r\n}\r\n\r\nfunc echo(c string) string {\r\n\treturn c\r\n}\r\n\r\nfunc capitalize(word string) string {\r\n\treturn Title(word)\r\n}\r\n\r\nvar tests = []struct {\r\n\texpected    []string\r\n\tgiven       []string\r\n\tconverter   func(string) string\r\n\tdescription string\r\n}{\r\n\t{[]string{}, []string{}, echo, \"echo\"},\r\n\t{\r\n\t\t[]string{\"echo\", \"echo\", \"echo\", \"echo\"},\r\n\t\t[]string{\"echo\", \"echo\", \"echo\", \"echo\"},\r\n\t\techo,\r\n\t\t\"echo\",\r\n\t},\r\n\t{\r\n\t\t[]string{\"First\", \"Letter\", \"Only\"},\r\n\t\t[]string{\"first\", \"letter\", \"only\"},\r\n\t\tcapitalize,\r\n\t\t\"capitalize\",\r\n\t},\r\n\t{\r\n\t\t[]string{\"HELLO\", \"WORLD\"},\r\n\t\t[]string{\"hello\", \"world\"},\r\n\t\tstrings.ToUpper,\r\n\t\t\"strings.ToUpper\",\r\n\t},\r\n}\r\n\r\nfunc TestAccumulate(t *testing.T) {\r\n\tfor _, test := range tests {\r\n\t\tin := make([]string, len(test.given))\r\n\t\tcopy(in, test.given)\r\n\t\tactual := Accumulate(in, test.converter)\r\n\t\tif fmt.Sprintf(\"%q\", actual) != fmt.Sprintf(\"%q\", test.expected) {\r\n\t\t\tt.Fatalf(\"Accumulate(%q, %q): expected %q, actual %q\",\r\n\t\t\t\ttest.given, test.description, test.expected, actual)\r\n\t\t}\r\n\r\n\t\t// check in place replacement\r\n\t\tfor i, s := range in {\r\n\t\t\tif test.given[i] != s {\r\n\t\t\t\tt.Fatalf(\"Accumulate should return a new slice\")\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n}\r\n\r\nfunc BenchmarkAccumulate(b *testing.B) {\r\n\tif testing.Short() {\r\n\t\tb.Skip(\"skipping benchmark in short mode.\")\r\n\t}\r\n\tfor i := 0; i < b.N; i++ {\r\n\t\tfor _, test := range tests {\r\n\t\t\tAccumulate(test.given, test.converter)\r\n\t\t}\r\n\t}\r\n}\r\n"
}