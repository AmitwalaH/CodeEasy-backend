{
  "language": "go",
  "type": "practice",
  "slug": "triangle",
  "title": "Triangle",
  "docs": {
    "instructions": "# Instructions\r\n\r\nDetermine if a triangle is equilateral, isosceles, or scalene.\r\n\r\nAn _equilateral_ triangle has all three sides the same length.\r\n\r\nAn _isosceles_ triangle has at least two sides the same length.\r\n(It is sometimes specified as having exactly two sides the same length, but for the purposes of this exercise we'll say at least two.)\r\n\r\nA _scalene_ triangle has all sides of different lengths.\r\n\r\n## Note\r\n\r\nFor a shape to be a triangle at all, all sides have to be of length > 0, and the sum of the lengths of any two sides must be greater than or equal to the length of the third side.\r\n\r\nIn equations:\r\n\r\nLet `a`, `b`, and `c` be sides of the triangle.\r\nThen all three of the following expressions must be true:\r\n\r\n```text\r\na + b ≥ c\r\nb + c ≥ a\r\na + c ≥ b\r\n```\r\n\r\nSee [Triangle Inequality][triangle-inequality]\r\n\r\n[triangle-inequality]: https://en.wikipedia.org/wiki/Triangle_inequality\r\n",
    "hints": ""
  },
  "starter_code": "// This is a \"stub\" file.  It's a little start on your solution.\r\n// It's not a complete solution though; you have to write some code.\r\n\r\n// Package triangle should have a package comment that summarizes what it's about.\r\n// https://golang.org/doc/effective_go.html#commentary\r\npackage triangle\r\n\r\n// Notice KindFromSides() returns this type. Pick a suitable data type.\r\n// type Kind\r\n\r\nconst (\r\n\t// Pick values for the following identifiers used by the test program.\r\n\tNaT // not a triangle\r\n\tEqu // equilateral\r\n\tIso // isosceles\r\n\tSca // scalene\r\n)\r\n\r\n// KindFromSides should have a comment documenting it.\r\nfunc KindFromSides(a, b, c float64) Kind {\r\n\t// Write some code here to pass the test suite.\r\n\t// Then remove all the stock comments.\r\n\t// They're here to help you get started but they only clutter a finished solution.\r\n\t// If you leave them in, reviewers may protest!\r\n\tvar k Kind\r\n\treturn k\r\n}\r\n",
  "tests": "package triangle\r\n\r\nimport (\r\n\t\"testing\"\r\n)\r\n\r\ntype testCase struct {\r\n\tdescription string\r\n\texpected    Kind\r\n\ta, b, c     float64\r\n}\r\n\r\nvar testCases = []testCase{\r\n\t{description: \"same length (2)\", expected: Equ, a: 2, b: 2, c: 2},\r\n\t{description: \"same length (10)\", expected: Equ, a: 10, b: 10, c: 10},\r\n\t{description: \"b = c = 4\", expected: Iso, a: 3, b: 4, c: 4},\r\n\t{description: \"a = c = 4\", expected: Iso, a: 4, b: 3, c: 4},\r\n\t{description: \"a = b = 4\", expected: Iso, a: 4, b: 4, c: 3},\r\n\t{description: \"a = b = 10\", expected: Iso, a: 10, b: 10, c: 2},\r\n\t{description: \"no sides equal (3, 4, 5)\", expected: Sca, a: 3, b: 4, c: 5},\r\n\t{description: \"no sides equal (10, 11, 12)\", expected: Sca, a: 10, b: 11, c: 12},\r\n\t{description: \"no sides equal (5, 4, 2)\", expected: Sca, a: 5, b: 4, c: 2},\r\n\t{description: \"no sides equal (0.4, 0.6, 0.3)\", expected: Sca, a: .4, b: .6, c: .3},\r\n\t{description: \"no sides equal (5, 4, 6) | 2a=b+c\", expected: Sca, a: 5, b: 4, c: 6},\r\n\t{description: \"no sides equal (6, 4, 5) | 2c=a+b\", expected: Sca, a: 6, b: 4, c: 5},\r\n\t{description: \"all sides zero\", expected: NaT, a: 0, b: 0, c: 0},\r\n\t{description: \"negative length\", expected: NaT, a: 3, b: 4, c: -5},\r\n\t{description: \"not a triangle (1, 1, 3)\", expected: NaT, a: 1, b: 1, c: 3},\r\n\t{description: \"not a triangle (2, 5, 2)\", expected: NaT, a: 2, b: 5, c: 2},\r\n\t{description: \"not a triangle (7, 3, 2)\", expected: NaT, a: 7, b: 3, c: 2},\r\n}\r\n\r\n// Test that the kinds are not equal to each other.\r\n// If they are equal, then TestKind will return false positives.\r\nfunc TestKindsNotEqual(t *testing.T) {\r\n\tkindsAndNames := []struct {\r\n\t\tkind Kind\r\n\t\tname string\r\n\t}{\r\n\t\t{Equ, \"Equ\"},\r\n\t\t{Iso, \"Iso\"},\r\n\t\t{Sca, \"Sca\"},\r\n\t\t{NaT, \"NaT\"},\r\n\t}\r\n\r\n\tfor i, pair1 := range kindsAndNames {\r\n\t\tfor j := i + 1; j < len(kindsAndNames); j++ {\r\n\t\t\tpair2 := kindsAndNames[j]\r\n\t\t\tif pair1.kind == pair2.kind {\r\n\t\t\t\tt.Fatalf(\"the value of %s should not be equal to the value of %s\", pair1.name, pair2.name)\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n}\r\n\r\nfunc TestKind(t *testing.T) {\r\n\tfor _, test := range testCases {\r\n\t\tt.Run(test.description, func(t *testing.T) {\r\n\t\t\tgot := KindFromSides(test.a, test.b, test.c)\r\n\t\t\tif got != test.expected {\r\n\t\t\t\tt.Fatalf(\"KindFromSides(%v, %v, %v) = %v, want: %v\", test.a, test.b, test.c, got, test.expected)\r\n\t\t\t}\r\n\t\t})\r\n\t}\r\n}\r\n\r\nfunc BenchmarkKind(b *testing.B) {\r\n\tif testing.Short() {\r\n\t\tb.Skip(\"skipping benchmark in short mode.\")\r\n\t}\r\n\tfor i := 0; i < b.N; i++ {\r\n\t\tfor _, test := range testCases {\r\n\t\t\tKindFromSides(test.a, test.b, test.c)\r\n\t\t}\r\n\t}\r\n}\r\n"
}