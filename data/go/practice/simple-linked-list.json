{
  "language": "go",
  "type": "practice",
  "slug": "simple-linked-list",
  "title": "Simple Linked List",
  "docs": {
    "instructions": "# Instructions\r\n\r\nWrite a prototype of the music player application.\r\n\r\nFor the prototype, each song will simply be represented by a number.\r\nGiven a range of numbers (the song IDs), create a singly linked list.\r\n\r\nGiven a singly linked list, you should be able to reverse the list to play the songs in the opposite order.\r\n\r\n~~~~exercism/note\r\nThe linked list is a fundamental data structure in computer science, often used in the implementation of other data structures.\r\n\r\nThe simplest kind of linked list is a **singly** linked list.\r\nThat means that each element (or \"node\") contains data, along with something that points to the next node in the list.\r\n\r\nIf you want to dig deeper into linked lists, check out [this article][intro-linked-list] that explains it using nice drawings.\r\n\r\n[intro-linked-list]: https://medium.com/basecs/whats-a-linked-list-anyway-part-1-d8b7e6508b9d\r\n~~~~\r\n",
    "hints": ""
  },
  "starter_code": "package linkedlist\r\n\r\n// Define the List and Element types here.\r\n\r\nfunc New(elements []int) *List {\r\n\tpanic(\"Please implement the New function\")\r\n}\r\n\r\nfunc (l *List) Size() int {\r\n\tpanic(\"Please implement the Size function\")\r\n}\r\n\r\nfunc (l *List) Push(element int) {\r\n\tpanic(\"Please implement the Push function\")\r\n}\r\n\r\nfunc (l *List) Pop() (int, error) {\r\n\tpanic(\"Please implement the Pop function\")\r\n}\r\n\r\nfunc (l *List) Array() []int {\r\n\tpanic(\"Please implement the Array function\")\r\n}\r\n\r\nfunc (l *List) Reverse() *List {\r\n\tpanic(\"Please implement the Reverse function\")\r\n}\r\n",
  "tests": "package linkedlist\r\n\r\nimport (\r\n\t\"reflect\"\r\n\t\"testing\"\r\n)\r\n\r\nvar array1To10 = []int{1, 2, 3, 4, 5, 6, 7, 8, 9, 10}\r\n\r\nfunc TestEmptyListHasSizeZero(t *testing.T) {\r\n\tlist := New([]int{})\r\n\tif size := list.Size(); size != 0 {\r\n\t\tt.Fatalf(\"Size of empty list: %d, expected: %d\", size, 0)\r\n\t}\r\n\tlist = New(nil)\r\n\tif size := list.Size(); size != 0 {\r\n\t\tt.Fatalf(\"Size of empty list: %d, expected: %d\", size, 0)\r\n\t}\r\n}\r\n\r\nfunc TestSingletonListHasSizeOne(t *testing.T) {\r\n\tlist := New([]int{1})\r\n\tif size := list.Size(); size != 1 {\r\n\t\tt.Fatalf(\"Size of singleton list: %d, expected: %d\", size, 1)\r\n\t}\r\n}\r\n\r\nfunc TestNonEmptyListHasCorrectSize(t *testing.T) {\r\n\tlist := New([]int{1, 2, 3})\r\n\tif size := list.Size(); size != 3 {\r\n\t\tt.Fatalf(\"Size of list from [1, 2, 3]: %d, expected: %d\", size, 3)\r\n\t}\r\n}\r\n\r\nfunc TestListHasCorrectSizeAfterPop(t *testing.T) {\r\n\tlist := New([]int{1, 2, 3})\r\n\r\n\t_, _ = list.Pop()\r\n\t_, _ = list.Pop()\r\n\t_, _ = list.Pop()\r\n\r\n\tif size := list.Size(); size != 0 {\r\n\t\tt.Fatalf(\"Size of list from [1, 2, 3] after 3 calls to pop(): got %d, expected: %d\", size, 0)\r\n\t}\r\n}\r\n\r\nfunc TestListHasCorrectSizeAfterPush(t *testing.T) {\r\n\tlist := New([]int{})\r\n\r\n\tlist.Push(1)\r\n\tlist.Push(2)\r\n\tlist.Push(3)\r\n\r\n\tif size := list.Size(); size != 3 {\r\n\t\tt.Fatalf(\"Size of list from [] after 3 calls to push(): got %d, expected: %d\", size, 3)\r\n\t}\r\n}\r\n\r\nfunc TestEmptyListToEmptyArray(t *testing.T) {\r\n\tlist := New([]int{})\r\n\tif array := list.Array(); len(array) != 0 {\r\n\t\tt.Fatalf(\"Test empty list to array: %v, want empty array\", array)\r\n\t}\r\n\tlist = New(nil)\r\n\tif array := list.Array(); len(array) != 0 {\r\n\t\tt.Fatalf(\"Test empty list to array: %v, want empty array\", array)\r\n\t}\r\n}\r\n\r\nfunc TestNonEmptyListToArray(t *testing.T) {\r\n\texpected := []int{1, 2, 3}\r\n\tlist := New(expected)\r\n\tarray := list.Array()\r\n\tif !reflect.DeepEqual(array, expected) {\r\n\t\tt.Fatalf(\"Test non empty list to array: %v, want %v\", array, expected)\r\n\t}\r\n}\r\n\r\nfunc TestPopFromEmptyList(t *testing.T) {\r\n\tlist := New([]int{})\r\n\tif _, err := list.Pop(); err == nil {\r\n\t\tt.Fatalf(\"Pop from empty list: expected error but there was not\")\r\n\t}\r\n\tlist = New(nil)\r\n\tif _, err := list.Pop(); err == nil {\r\n\t\tt.Fatalf(\"Pop from empty list: expected error but there was not\")\r\n\t}\r\n}\r\n\r\nfunc TestPopFromNonEmptyList(t *testing.T) {\r\n\tlist := New([]int{1, 2, 3})\r\n\telem, err := list.Pop()\r\n\tif err != nil {\r\n\t\tt.Fatalf(\"Pop from non empty list: unexpected error %v\", err)\r\n\t}\r\n\tif elem != 3 {\r\n\t\tt.Fatalf(\"Pop from non empty list: %d, want %d\", elem, 3)\r\n\t}\r\n\tactual := list.Array()\r\n\texpected := []int{1, 2}\r\n\tif !reflect.DeepEqual(actual, expected) {\r\n\t\tt.Fatalf(\"Pop from non empty list: %v, want %v\", actual, expected)\r\n\t}\r\n}\r\n\r\nfunc TestPushToEmptyList(t *testing.T) {\r\n\tlist := New([]int{})\r\n\tlist.Push(1)\r\n\tactual := list.Array()\r\n\texpected := []int{1}\r\n\tif !reflect.DeepEqual(actual, expected) {\r\n\t\tt.Fatalf(\"Push to empty list: %v, want %v\", actual, expected)\r\n\t}\r\n\tlist = New(nil)\r\n\tlist.Push(1)\r\n\tactual = list.Array()\r\n\tif !reflect.DeepEqual(actual, expected) {\r\n\t\tt.Fatalf(\"Push to empty list: %v, want %v\", actual, expected)\r\n\t}\r\n}\r\n\r\nfunc TestPushToNonEmptyList(t *testing.T) {\r\n\tlist := New([]int{1, 2, 3})\r\n\tlist.Push(4)\r\n\tactual := list.Array()\r\n\texpected := []int{1, 2, 3, 4}\r\n\tif !reflect.DeepEqual(actual, expected) {\r\n\t\tt.Fatalf(\"Push to non empty list: %v, want %v\", actual, expected)\r\n\t}\r\n}\r\n\r\nfunc TestPushAndPop(t *testing.T) {\r\n\tlist := New([]int{1, 2, 3})\r\n\tlist.Pop()\r\n\tlist.Push(4)\r\n\tlist.Push(5)\r\n\tlist.Pop()\r\n\tlist.Push(6)\r\n\tactual := list.Array()\r\n\texpected := []int{1, 2, 4, 6}\r\n\tif !reflect.DeepEqual(actual, expected) {\r\n\t\tt.Fatalf(\"Test push and pop: %v, want %v\", actual, expected)\r\n\t}\r\n}\r\n\r\nfunc TestReverseEmptyList(t *testing.T) {\r\n\tlist := New([]int{})\r\n\tif reversed := list.Reverse().Array(); len(reversed) != 0 {\r\n\t\tt.Fatalf(\"Reverse empty list: %v, want empty list\", reversed)\r\n\t}\r\n\tlist = New(nil)\r\n\tif reversed := list.Reverse().Array(); len(reversed) != 0 {\r\n\t\tt.Fatalf(\"Reverse empty list: %v, want empty list\", reversed)\r\n\t}\r\n}\r\n\r\nfunc TestReverseNonEmptyList(t *testing.T) {\r\n\tlist := New([]int{1, 2, 3})\r\n\tactual := list.Reverse().Array()\r\n\texpected := []int{3, 2, 1}\r\n\tif !reflect.DeepEqual(actual, expected) {\r\n\t\tt.Fatalf(\"Reverse non empty list: %v, want %v\", actual, expected)\r\n\t}\r\n}\r\n\r\nfunc BenchmarkNewList(b *testing.B) {\r\n\tif testing.Short() {\r\n\t\tb.Skip(\"skipping benchmark in short mode.\")\r\n\t}\r\n\tfor i := 0; i < b.N; i++ {\r\n\t\t_ = New(array1To10)\r\n\t}\r\n}\r\n\r\nfunc BenchmarkListSize(b *testing.B) {\r\n\tif testing.Short() {\r\n\t\tb.Skip(\"skipping benchmark in short mode.\")\r\n\t}\r\n\tlist := New(array1To10)\r\n\tb.ResetTimer()\r\n\tfor i := 0; i < b.N; i++ {\r\n\t\t_ = list.Size()\r\n\t}\r\n}\r\n\r\nfunc BenchmarkListPush(b *testing.B) {\r\n\tif testing.Short() {\r\n\t\tb.Skip(\"skipping benchmark in short mode.\")\r\n\t}\r\n\tfor i := 0; i < b.N; i++ {\r\n\t\tb.StopTimer()\r\n\t\tlist := New([]int{})\r\n\t\tb.StartTimer()\r\n\t\tfor k := 0; k < 1000; k++ {\r\n\t\t\tlist.Push(k)\r\n\t\t}\r\n\t}\r\n}\r\n\r\nfunc BenchmarkListPop(b *testing.B) {\r\n\tif testing.Short() {\r\n\t\tb.Skip(\"skipping benchmark in short mode.\")\r\n\t}\r\n\tfor i := 0; i < b.N; i++ {\r\n\t\tb.StopTimer()\r\n\t\tlist := New([]int{})\r\n\t\tfor k := 0; k < 1000; k++ {\r\n\t\t\tlist.Push(k)\r\n\t\t}\r\n\t\tb.StartTimer()\r\n\t\tfor k := 0; k < 1000; k++ {\r\n\t\t\t_, _ = list.Pop()\r\n\t\t}\r\n\t}\r\n}\r\n\r\nfunc BenchmarkListToArray(b *testing.B) {\r\n\tif testing.Short() {\r\n\t\tb.Skip(\"skipping benchmark in short mode.\")\r\n\t}\r\n\tlist := New(array1To10)\r\n\tb.ResetTimer()\r\n\tfor i := 0; i < b.N; i++ {\r\n\t\t_ = list.Array()\r\n\t}\r\n}\r\n\r\nfunc BenchmarkListReverse(b *testing.B) {\r\n\tif testing.Short() {\r\n\t\tb.Skip(\"skipping benchmark in short mode.\")\r\n\t}\r\n\tlist := New(array1To10)\r\n\tb.ResetTimer()\r\n\tfor i := 0; i < b.N; i++ {\r\n\t\t_ = list.Reverse()\r\n\t}\r\n}\r\n"
}