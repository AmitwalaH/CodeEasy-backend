{
  "language": "go",
  "type": "practice",
  "slug": "list-ops",
  "title": "List Ops",
  "docs": {
    "instructions": "# Instructions\r\n\r\nImplement basic list operations.\r\n\r\nIn functional languages list operations like `length`, `map`, and `reduce` are very common.\r\nImplement a series of basic list operations, without using existing functions.\r\n\r\nThe precise number and names of the operations to be implemented will be track dependent to avoid conflicts with existing names, but the general operations you will implement include:\r\n\r\n- `append` (_given two lists, add all items in the second list to the end of the first list_);\r\n- `concatenate` (_given a series of lists, combine all items in all lists into one flattened list_);\r\n- `filter` (_given a predicate and a list, return the list of all items for which `predicate(item)` is True_);\r\n- `length` (_given a list, return the total number of items within it_);\r\n- `map` (_given a function and a list, return the list of the results of applying `function(item)` on all items_);\r\n- `foldl` (_given a function, a list, and initial accumulator, fold (reduce) each item into the accumulator from the left_);\r\n- `foldr` (_given a function, a list, and an initial accumulator, fold (reduce) each item into the accumulator from the right_);\r\n- `reverse` (_given a list, return a list with all the original items, but in reversed order_).\r\n\r\nNote, the ordering in which arguments are passed to the fold functions (`foldl`, `foldr`) is significant.\r\n",
    "hints": ""
  },
  "starter_code": "package listops\r\n\r\n// IntList is an abstraction of a list of integers which we can define methods on\r\ntype IntList []int\r\n\r\nfunc (s IntList) Foldl(fn func(int, int) int, initial int) int {\r\n\tpanic(\"Please implement the Foldl function\")\r\n}\r\n\r\nfunc (s IntList) Foldr(fn func(int, int) int, initial int) int {\r\n\tpanic(\"Please implement the Foldr function\")\r\n}\r\n\r\nfunc (s IntList) Filter(fn func(int) bool) IntList {\r\n\tpanic(\"Please implement the Filter function\")\r\n}\r\n\r\nfunc (s IntList) Length() int {\r\n\tpanic(\"Please implement the Length function\")\r\n}\r\n\r\nfunc (s IntList) Map(fn func(int) int) IntList {\r\n\tpanic(\"Please implement the Map function\")\r\n}\r\n\r\nfunc (s IntList) Reverse() IntList {\r\n\tpanic(\"Please implement the Reverse function\")\r\n}\r\n\r\nfunc (s IntList) Append(lst IntList) IntList {\r\n\tpanic(\"Please implement the Append function\")\r\n}\r\n\r\nfunc (s IntList) Concat(lists []IntList) IntList {\r\n\tpanic(\"Please implement the Concat function\")\r\n}\r\n",
  "tests": "package listops\r\n\r\nimport (\r\n\t\"reflect\"\r\n\t\"testing\"\r\n)\r\n\r\nvar foldTestCases = []struct {\r\n\tname     string\r\n\tproperty string\r\n\tfn       func(int, int) int\r\n\tinitial  int\r\n\tlist     IntList\r\n\twant     int\r\n}{\r\n\t{\r\n\t\tname:     \"empty list\",\r\n\t\tproperty: \"Foldl\",\r\n\t\tfn:       func(x, y int) int { return x * y },\r\n\t\tinitial:  2,\r\n\t\twant:     2,\r\n\t\tlist:     []int{},\r\n\t},\r\n\t{\r\n\t\tname:     \"direction independent function applied to non-empty list\",\r\n\t\tproperty: \"Foldl\",\r\n\t\tfn:       func(x, y int) int { return x + y },\r\n\t\tinitial:  5,\r\n\t\twant:     15,\r\n\t\tlist:     []int{1, 2, 3, 4},\r\n\t},\r\n\t{\r\n\t\tname:     \"direction dependent function applied to non-empty list\",\r\n\t\tproperty: \"Foldl\",\r\n\t\tfn:       func(x, y int) int { return x / y },\r\n\t\tinitial:  5,\r\n\t\twant:     0,\r\n\t\tlist:     []int{2, 5},\r\n\t},\r\n\t{\r\n\t\tname:     \"empty list\",\r\n\t\tproperty: \"Foldr\",\r\n\t\tfn:       func(x, y int) int { return x * y },\r\n\t\tinitial:  2,\r\n\t\twant:     2,\r\n\t\tlist:     []int{},\r\n\t},\r\n\t{\r\n\t\tname:     \"direction independent function applied to non-empty list\",\r\n\t\tproperty: \"Foldr\",\r\n\t\tfn:       func(x, y int) int { return x + y },\r\n\t\tinitial:  5,\r\n\t\twant:     15,\r\n\t\tlist:     []int{1, 2, 3, 4},\r\n\t},\r\n\t{\r\n\t\tname:     \"direction dependent function applied to non-empty list\",\r\n\t\tproperty: \"Foldr\",\r\n\t\tfn:       func(x, y int) int { return x / y },\r\n\t\tinitial:  5,\r\n\t\twant:     2,\r\n\t\tlist:     []int{2, 5},\r\n\t},\r\n}\r\n\r\nfunc TestFold(t *testing.T) {\r\n\tfor _, tc := range foldTestCases {\r\n\t\tt.Run(tc.name, func(t *testing.T) {\r\n\t\t\tvar got int\r\n\t\t\tif tc.property == \"Foldr\" {\r\n\t\t\t\tgot = tc.list.Foldr(tc.fn, tc.initial)\r\n\t\t\t} else {\r\n\t\t\t\tgot = tc.list.Foldl(tc.fn, tc.initial)\r\n\t\t\t}\r\n\t\t\tif got != tc.want {\r\n\t\t\t\tt.Fatalf(\"%s() = %d, want: %d\\ntestcase name: %s\", tc.property, got, tc.want, tc.name)\r\n\t\t\t}\r\n\t\t})\r\n\t}\r\n}\r\n\r\nvar filterTestCases = []struct {\r\n\tname     string\r\n\tproperty string\r\n\tfn       func(int) bool\r\n\tlist     IntList\r\n\twant     IntList\r\n}{\r\n\t{\r\n\t\tname:     \"empty list\",\r\n\t\tproperty: \"filter\",\r\n\t\tfn:       func(n int) bool { return n%2 == 1 },\r\n\t\tlist:     []int{},\r\n\t\twant:     []int{},\r\n\t},\r\n\t{\r\n\t\tname:     \"non-empty list\",\r\n\t\tproperty: \"filter\",\r\n\t\tfn:       func(n int) bool { return n%2 == 1 },\r\n\t\tlist:     []int{1, 2, 3, 4, 5},\r\n\t\twant:     []int{1, 3, 5},\r\n\t},\r\n}\r\n\r\nfunc TestFilterMethod(t *testing.T) {\r\n\tfor _, tc := range filterTestCases {\r\n\t\tt.Run(tc.name, func(t *testing.T) {\r\n\t\t\tgot := tc.list.Filter(tc.fn)\r\n\t\t\tif !reflect.DeepEqual(tc.want, got) {\r\n\t\t\t\tt.Fatalf(\"IntList(%v).Filter()\\n got: %v\\nwant: %v\\ntestcase name: %s\", tc.list, got, tc.want, tc.name)\r\n\t\t\t}\r\n\t\t})\r\n\t}\r\n}\r\n\r\nvar lengthTestCases = []struct {\r\n\tname     string\r\n\tproperty string\r\n\tlist     IntList\r\n\twant     int\r\n}{\r\n\t{\r\n\t\tname:     \"empty list\",\r\n\t\tproperty: \"length\",\r\n\t\tlist:     []int{},\r\n\t\twant:     0,\r\n\t},\r\n\t{\r\n\t\tname:     \"non-empty list\",\r\n\t\tproperty: \"length\",\r\n\t\tlist:     []int{1, 2, 3, 4},\r\n\t\twant:     4,\r\n\t},\r\n}\r\n\r\nfunc TestLengthMethod(t *testing.T) {\r\n\tfor _, tc := range lengthTestCases {\r\n\t\tt.Run(tc.name, func(t *testing.T) {\r\n\t\t\tif got := tc.list.Length(); tc.want != got {\r\n\t\t\t\tt.Fatalf(\"IntList(%v).Length() = %d, want: %d\", tc.list, got, tc.want)\r\n\t\t\t}\r\n\t\t})\r\n\t}\r\n}\r\n\r\nvar mapTestCases = []struct {\r\n\tname     string\r\n\tproperty string\r\n\tlist     IntList\r\n\tfn       func(int) int\r\n\twant     IntList\r\n}{\r\n\t{\r\n\t\tname:     \"empty list\",\r\n\t\tproperty: \"map\",\r\n\t\tlist:     []int{},\r\n\t\tfn:       func(x int) int { return x + 1 },\r\n\t\twant:     []int{},\r\n\t},\r\n\t{\r\n\t\tname:     \"non-empty list\",\r\n\t\tproperty: \"map\",\r\n\t\tlist:     []int{1, 3, 5, 7},\r\n\t\tfn:       func(x int) int { return x + 1 },\r\n\t\twant:     []int{2, 4, 6, 8},\r\n\t},\r\n}\r\n\r\nfunc TestMapMethod(t *testing.T) {\r\n\tfor _, tc := range mapTestCases {\r\n\t\tt.Run(tc.name, func(t *testing.T) {\r\n\t\t\tif got := tc.list.Map(tc.fn); !reflect.DeepEqual(tc.want, got) {\r\n\t\t\t\tt.Fatalf(\"IntList(%v).Map()\\n got: %v\\nwant: %v\\ntestcase name: %s\", tc.list, got, tc.want, tc.name)\r\n\t\t\t}\r\n\t\t})\r\n\t}\r\n}\r\n\r\nvar reverseTestCases = []struct {\r\n\tname     string\r\n\tproperty string\r\n\tlist     IntList\r\n\twant     IntList\r\n}{\r\n\t{\r\n\t\tname:     \"empty list\",\r\n\t\tproperty: \"reverse\",\r\n\t\tlist:     []int{},\r\n\t\twant:     []int{},\r\n\t},\r\n\t{\r\n\t\tname:     \"non-empty list\",\r\n\t\tproperty: \"reverse\",\r\n\t\tlist:     []int{1, 3, 5, 7},\r\n\t\twant:     []int{7, 5, 3, 1},\r\n\t},\r\n}\r\n\r\nfunc TestReverseMethod(t *testing.T) {\r\n\tfor _, tc := range reverseTestCases {\r\n\t\tt.Run(tc.name, func(t *testing.T) {\r\n\t\t\tgot := tc.list.Reverse()\r\n\t\t\tif !reflect.DeepEqual(tc.want, got) {\r\n\t\t\t\tt.Fatalf(\"IntList(%v).Reverse()\\n got: %v\\nwant: %v\", tc.list, got, tc.want)\r\n\t\t\t}\r\n\t\t})\r\n\t}\r\n}\r\n\r\nvar appendTestCases = []struct {\r\n\tname       string\r\n\tproperty   string\r\n\tlist       IntList\r\n\tappendThis IntList\r\n\twant       IntList\r\n}{\r\n\t{\r\n\t\tname:       \"empty list\",\r\n\t\tproperty:   \"append\",\r\n\t\tlist:       []int{},\r\n\t\tappendThis: []int{},\r\n\t\twant:       []int{},\r\n\t},\r\n\t{\r\n\t\tname:       \"empty list to list\",\r\n\t\tproperty:   \"append\",\r\n\t\tlist:       []int{},\r\n\t\tappendThis: []int{1, 2, 3, 4},\r\n\t\twant:       []int{1, 2, 3, 4},\r\n\t},\r\n\t{\r\n\t\tname:       \"non-empty lists\",\r\n\t\tproperty:   \"append\",\r\n\t\tlist:       []int{1, 2},\r\n\t\tappendThis: []int{2, 3, 4, 5},\r\n\t\twant:       []int{1, 2, 2, 3, 4, 5},\r\n\t},\r\n}\r\n\r\nfunc TestAppendMethod(t *testing.T) {\r\n\tfor _, tc := range appendTestCases {\r\n\t\tt.Run(tc.name, func(t *testing.T) {\r\n\t\t\tgot := tc.list.Append(tc.appendThis)\r\n\t\t\tif !reflect.DeepEqual(tc.want, got) {\r\n\t\t\t\tt.Fatalf(\"IntList(%v).Append()\\n got: %v\\nwant: %v\", tc.list, got, tc.want)\r\n\t\t\t}\r\n\t\t})\r\n\t}\r\n}\r\n\r\nvar concatTestCases = []struct {\r\n\tname     string\r\n\tproperty string\r\n\tlist     IntList\r\n\targs     []IntList\r\n\twant     IntList\r\n}{\r\n\t{\r\n\t\tname:     \"empty list\",\r\n\t\tproperty: \"concat\",\r\n\t\tlist:     []int{},\r\n\t\targs:     []IntList{},\r\n\t\twant:     []int{},\r\n\t},\r\n\t{\r\n\t\tname:     \"list of lists\",\r\n\t\tproperty: \"concat\",\r\n\t\tlist:     []int{1, 2},\r\n\t\targs:     []IntList{[]int{3}, []int{}, []int{4, 5, 6}},\r\n\t\twant:     []int{1, 2, 3, 4, 5, 6},\r\n\t},\r\n}\r\n\r\nfunc TestConcatMethod(t *testing.T) {\r\n\tfor _, tc := range concatTestCases {\r\n\t\tt.Run(tc.name, func(t *testing.T) {\r\n\t\t\tgot := tc.list.Concat(tc.args)\r\n\t\t\tif !reflect.DeepEqual(tc.want, got) {\r\n\t\t\t\tt.Fatalf(\"IntList(%v).Concat(%v)\\n got: %v\\nwant: %v\", tc.list, tc.args, got, tc.want)\r\n\t\t\t}\r\n\t\t})\r\n\t}\r\n}\r\n"
}