{
  "language": "go",
  "type": "practice",
  "slug": "bank-account",
  "title": "Bank Account",
  "docs": {
    "instructions": "# Instructions\r\n\r\nYour task is to implement bank accounts supporting opening/closing, withdrawals, and deposits of money.\r\n\r\nAs bank accounts can be accessed in many different ways (internet, mobile phones, automatic charges), your bank software must allow accounts to be safely accessed from multiple threads/processes (terminology depends on your programming language) in parallel.\r\nFor example, there may be many deposits and withdrawals occurring in parallel; you need to ensure there are no [race conditions][wikipedia] between when you read the account balance and set the new balance.\r\n\r\nIt should be possible to close an account; operations against a closed account must fail.\r\n\r\n[wikipedia]: https://en.wikipedia.org/wiki/Race_condition#In_software\r\n",
    "hints": ""
  },
  "starter_code": "package account\r\n\r\n// Define the Account type here.\r\n\r\nfunc Open(amount int64) *Account {\r\n\tpanic(\"Please implement the Open function\")\r\n}\r\n\r\nfunc (a *Account) Balance() (int64, bool) {\r\n\tpanic(\"Please implement the Balance function\")\r\n}\r\n\r\nfunc (a *Account) Deposit(amount int64) (int64, bool) {\r\n\tpanic(\"Please implement the Deposit function\")\r\n}\r\n\r\nfunc (a *Account) Close() (int64, bool) {\r\n\tpanic(\"Please implement the Close function\")\r\n}\r\n",
  "tests": "package account\r\n\r\nimport (\r\n\t\"runtime\"\r\n\t\"sync\"\r\n\t\"sync/atomic\"\r\n\t\"testing\"\r\n\t\"time\"\r\n)\r\n\r\nfunc TestSeqOpenBalanceClose(t *testing.T) {\r\n\t// open account\r\n\tconst amt = 10\r\n\ta := Open(amt)\r\n\tif a == nil {\r\n\t\tt.Fatalf(\"Open(%d) = nil, want non-nil *Account.\", amt)\r\n\t}\r\n\tt.Logf(\"Account 'a' opened with initial balance of %d.\", amt)\r\n\r\n\t// verify balance after open\r\n\tswitch b, ok := a.Balance(); {\r\n\tcase !ok:\r\n\t\tt.Fatal(\"a.Balance() returned !ok, want ok.\")\r\n\tcase b != amt:\r\n\t\tt.Fatalf(\"a.Balance() = %d, want %d\", b, amt)\r\n\t}\r\n\r\n\t// close account\r\n\tswitch p, ok := a.Close(); {\r\n\tcase !ok:\r\n\t\tt.Fatalf(\"a.Close() returned !ok, want ok.\")\r\n\tcase p != amt:\r\n\t\tt.Fatalf(\"a.Close() returned payout = %d, want %d.\", p, amt)\r\n\t}\r\n\tt.Log(\"Account 'a' closed.\")\r\n\r\n\t// verify balance no longer accessible\r\n\tif b, ok := a.Balance(); ok {\r\n\t\tt.Log(\"Balance still available on closed account.\")\r\n\t\tt.Fatalf(\"a.Balance() = %d, %t.  Want ok == false\", b, ok)\r\n\t}\r\n\r\n\t// verify closing balance is 0\r\n\tif b, _ := a.Balance(); b != 0 {\r\n\t\tt.Log(\"Balance after close is non-zero.\")\r\n\t\tt.Fatalf(\"After a.Close() balance is %d and not 0\", b)\r\n\t}\r\n}\r\n\r\nfunc TestSeqOpenDepositClose(t *testing.T) {\r\n\t// open account\r\n\tconst openAmt = 10\r\n\ta := Open(openAmt)\r\n\tif a == nil {\r\n\t\tt.Fatalf(\"Open(%d) = nil, want non-nil *Account.\", openAmt)\r\n\t}\r\n\tt.Logf(\"Account 'a' opened with initial balance of %d.\", openAmt)\r\n\r\n\t// deposit\r\n\tconst depAmt = 20\r\n\tconst newAmt = openAmt + depAmt\r\n\tswitch b, ok := a.Deposit(depAmt); {\r\n\tcase !ok:\r\n\t\tt.Fatalf(\"a.Deposit(%d) returned !ok, want ok.\", depAmt)\r\n\tcase b != openAmt+depAmt:\r\n\t\tt.Fatalf(\"a.Deposit(%d) = %d, want new balance = %d\", depAmt, b, newAmt)\r\n\t}\r\n\tt.Logf(\"Deposit of %d accepted to account 'a'\", depAmt)\r\n\r\n\t// close account\r\n\tswitch p, ok := a.Close(); {\r\n\tcase !ok:\r\n\t\tt.Fatalf(\"a.Close() returned !ok, want ok.\")\r\n\tcase p != newAmt:\r\n\t\tt.Fatalf(\"a.Close() returned payout = %d, want %d.\", p, newAmt)\r\n\t}\r\n\tt.Log(\"Account 'a' closed.\")\r\n\r\n\t// verify deposits no longer accepted\r\n\tif b, ok := a.Deposit(1); ok {\r\n\t\tt.Log(\"Deposit accepted on closed account.\")\r\n\t\tt.Fatalf(\"a.Deposit(1) = %d, %t.  Want ok == false\", b, ok)\r\n\t}\r\n}\r\n\r\nfunc TestMoreSeqCases(t *testing.T) {\r\n\t// open account 'a' as before\r\n\tconst openAmt = 10\r\n\ta := Open(openAmt)\r\n\tif a == nil {\r\n\t\tt.Fatalf(\"Open(%d) = nil, want non-nil *Account.\", openAmt)\r\n\t}\r\n\tt.Logf(\"Account 'a' opened with initial balance of %d.\", openAmt)\r\n\r\n\t// open account 'z' with zero balance\r\n\tz := Open(0)\r\n\tif z == nil {\r\n\t\tt.Fatal(\"Open(0) = nil, want non-nil *Account.\")\r\n\t}\r\n\tt.Log(\"Account 'z' opened with initial balance of 0.\")\r\n\r\n\t// attempt to open account with negative opening balance\r\n\tif Open(-10) != nil {\r\n\t\tt.Fatal(\"Open(-10) seemed to work, \" +\r\n\t\t\t\"want nil result for negative opening balance.\")\r\n\t}\r\n\r\n\t// verify both balances a and z still there\r\n\tswitch b, ok := a.Balance(); {\r\n\tcase !ok:\r\n\t\tt.Fatal(\"a.Balance() returned !ok, want ok.\")\r\n\tcase b != openAmt:\r\n\t\tt.Fatalf(\"a.Balance() = %d, want %d\", b, openAmt)\r\n\t}\r\n\tswitch b, ok := z.Balance(); {\r\n\tcase !ok:\r\n\t\tt.Fatal(\"z.Balance() returned !ok, want ok.\")\r\n\tcase b != 0:\r\n\t\tt.Fatalf(\"z.Balance() = %d, want 0\", b)\r\n\t}\r\n\r\n\t// withdrawals\r\n\tconst wAmt = 3\r\n\tconst newAmt = openAmt - wAmt\r\n\tswitch b, ok := a.Deposit(-wAmt); {\r\n\tcase !ok:\r\n\t\tt.Fatalf(\"a.Deposit(%d) returned !ok, want ok.\", -wAmt)\r\n\tcase b != newAmt:\r\n\t\tt.Fatalf(\"a.Deposit(%d) = %d, want new balance = %d\", -wAmt, b, newAmt)\r\n\t}\r\n\tt.Logf(\"Withdrawal of %d accepted from account 'a'\", wAmt)\r\n\tif _, ok := z.Deposit(-1); ok {\r\n\t\tt.Fatal(\"z.Deposit(-1) returned ok, want !ok.\")\r\n\t}\r\n\r\n\t// verify both balances\r\n\tswitch b, ok := a.Balance(); {\r\n\tcase !ok:\r\n\t\tt.Fatal(\"a.Balance() returned !ok, want ok.\")\r\n\tcase b != newAmt:\r\n\t\tt.Fatalf(\"a.Balance() = %d, want %d\", b, newAmt)\r\n\t}\r\n\tswitch b, ok := z.Balance(); {\r\n\tcase !ok:\r\n\t\tt.Fatal(\"z.Balance() returned !ok, want ok.\")\r\n\tcase b != 0:\r\n\t\tt.Fatalf(\"z.Balance() = %d, want 0\", b)\r\n\t}\r\n\r\n\t// close just z\r\n\tswitch p, ok := z.Close(); {\r\n\tcase !ok:\r\n\t\tt.Fatalf(\"z.Close() returned !ok, want ok.\")\r\n\tcase p != 0:\r\n\t\tt.Fatalf(\"z.Close() returned payout = %d, want 0.\", p)\r\n\t}\r\n\tt.Log(\"Account 'z' closed.\")\r\n\r\n\t// verify 'a' balance one more time\r\n\tswitch b, ok := a.Balance(); {\r\n\tcase !ok:\r\n\t\tt.Fatal(\"a.Balance() returned !ok, want ok.\")\r\n\tcase b != newAmt:\r\n\t\tt.Fatalf(\"a.Balance() = %d, want %d\", b, newAmt)\r\n\t}\r\n}\r\n\r\nfunc TestConcClose(t *testing.T) {\r\n\tif runtime.NumCPU() < 2 {\r\n\t\tt.Skip(\"Multiple CPU cores required for concurrency tests.\")\r\n\t}\r\n\tif runtime.GOMAXPROCS(0) < 2 {\r\n\t\truntime.GOMAXPROCS(2)\r\n\t}\r\n\r\n\t// test competing close attempts\r\n\tfor rep := 0; rep < 1000; rep++ {\r\n\t\tconst openAmt = 10\r\n\t\ta := Open(openAmt)\r\n\t\tif a == nil {\r\n\t\t\tt.Fatalf(\"Open(%d) = nil, want non-nil *Account.\", openAmt)\r\n\t\t}\r\n\t\tvar start sync.WaitGroup\r\n\t\tstart.Add(1)\r\n\t\tconst closeAttempts = 10\r\n\t\tres := make(chan string)\r\n\t\tfor i := 0; i < closeAttempts; i++ {\r\n\t\t\tgo func() { // on your mark,\r\n\t\t\t\tstart.Wait() // get set...\r\n\t\t\t\tswitch p, ok := a.Close(); {\r\n\t\t\t\tcase !ok:\r\n\t\t\t\t\tif p != 0 {\r\n\t\t\t\t\t\tt.Errorf(\"a.Close() = %d, %t.  \"+\r\n\t\t\t\t\t\t\t\"Want payout = 0 for unsuccessful close\", p, ok)\r\n\t\t\t\t\t\tres <- \"fail\"\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\tres <- \"already closed\"\r\n\t\t\t\t\t}\r\n\t\t\t\tcase p != openAmt:\r\n\t\t\t\t\tt.Errorf(\"a.Close() = %d, %t.  \"+\r\n\t\t\t\t\t\t\"Want payout = %d for successful close\", p, ok, openAmt)\r\n\t\t\t\t\tres <- \"fail\"\r\n\t\t\t\tdefault:\r\n\t\t\t\t\tres <- \"close\" // exactly one goroutine should reach here\r\n\t\t\t\t}\r\n\t\t\t}()\r\n\t\t}\r\n\t\tstart.Done() // ...go\r\n\t\tvar closes, fails int\r\n\t\tfor i := 0; i < closeAttempts; i++ {\r\n\t\t\tswitch <-res {\r\n\t\t\tcase \"close\":\r\n\t\t\t\tcloses++\r\n\t\t\tcase \"fail\":\r\n\t\t\t\tfails++\r\n\t\t\t}\r\n\t\t}\r\n\t\tswitch {\r\n\t\tcase fails > 0:\r\n\t\t\tt.FailNow() // error already logged by other goroutine\r\n\t\tcase closes == 0:\r\n\t\t\tt.Fatal(\"Concurrent a.Close() attempts all failed.  \" +\r\n\t\t\t\t\"Want one to succeed.\")\r\n\t\tcase closes > 1:\r\n\t\t\tt.Fatalf(\"%d concurrent a.Close() attempts succeeded, \"+\r\n\t\t\t\t\"each paying out %d!.  Want just one to succeed.\",\r\n\t\t\t\tcloses, openAmt)\r\n\t\t}\r\n\t}\r\n}\r\n\r\nfunc TestConcDeposit(t *testing.T) {\r\n\tif runtime.NumCPU() < 2 {\r\n\t\tt.Skip(\"Multiple CPU cores required for concurrency tests.\")\r\n\t}\r\n\tif runtime.GOMAXPROCS(0) < 2 {\r\n\t\truntime.GOMAXPROCS(2)\r\n\t}\r\n\ta := Open(0)\r\n\tif a == nil {\r\n\t\tt.Fatal(\"Open(0) = nil, want non-nil *Account.\")\r\n\t}\r\n\tconst amt = 10\r\n\tconst c = 1000\r\n\tvar negBal int32\r\n\tvar start, g sync.WaitGroup\r\n\tstart.Add(1)\r\n\tg.Add(3 * c)\r\n\tfor i := 0; i < c; i++ {\r\n\t\tgo func() { // deposit\r\n\t\t\tstart.Wait()\r\n\t\t\ta.Deposit(amt) // ignore return values\r\n\t\t\tg.Done()\r\n\t\t}()\r\n\t\tgo func() { // withdraw\r\n\t\t\tstart.Wait()\r\n\t\t\tfor {\r\n\t\t\t\tif _, ok := a.Deposit(-amt); ok {\r\n\t\t\t\t\tbreak\r\n\t\t\t\t}\r\n\t\t\t\ttime.Sleep(time.Microsecond) // retry\r\n\t\t\t}\r\n\t\t\tg.Done()\r\n\t\t}()\r\n\t\tgo func() { // watch that balance stays >= 0\r\n\t\t\tstart.Wait()\r\n\t\t\tif p, _ := a.Balance(); p < 0 {\r\n\t\t\t\tatomic.StoreInt32(&negBal, 1)\r\n\t\t\t}\r\n\t\t\tg.Done()\r\n\t\t}()\r\n\t}\r\n\tstart.Done()\r\n\tg.Wait()\r\n\tif negBal == 1 {\r\n\t\tt.Fatal(\"Balance went negative with concurrent deposits and \" +\r\n\t\t\t\"withdrawals.  Want balance always >= 0.\")\r\n\t}\r\n\tif p, ok := a.Balance(); !ok || p != 0 {\r\n\t\tt.Fatalf(\"After equal concurrent deposits and withdrawals, \"+\r\n\t\t\t\"a.Balance = %d, %t.  Want 0, true\", p, ok)\r\n\t}\r\n}\r\n\r\n// The benchmark operations are here to encourage you to try different\r\n// implementations to see which ones perform better. These are worth\r\n// exploring after the tests pass.\r\n//\r\n// There is a basic benchmark and a parallelized version of the same\r\n// benchmark. You run the benchmark using:\r\n// go test --bench=.\r\n//\r\n// The output will look something like this:\r\n// goos: linux\r\n// goarch: amd64\r\n// BenchmarkAccountOperations-8             10000000        130 ns/op\r\n// BenchmarkAccountOperationsParallel-8     3000000         488 ns/op\r\n// PASS\r\n//\r\n// You will notice that parallelism does not increase speed in this case, in\r\n// fact it makes things slower! This is because none of the operations in our\r\n// Account benefit from parallel processing. We are specifically protecting\r\n// the account balance internals from being accessed by multiple processes\r\n// simultaneously. Your protections will make the parallel processing slower\r\n// because there is some overhead in managing the processes and protections.\r\n//\r\n// The interesting thing to try here is to experiment with the protections\r\n// and see how their implementation changes the results of the parallel\r\n// benchmark.\r\nfunc BenchmarkAccountOperations(b *testing.B) {\r\n\tif testing.Short() {\r\n\t\tb.Skip(\"skipping benchmark in short mode.\")\r\n\t}\r\n\ta := Open(0)\r\n\tdefer a.Close()\r\n\tfor n := 0; n < b.N; n++ {\r\n\t\ta.Deposit(10)\r\n\t\ta.Deposit(-10)\r\n\t}\r\n}\r\n\r\nfunc BenchmarkAccountOperationsParallel(b *testing.B) {\r\n\tif testing.Short() {\r\n\t\tb.Skip(\"skipping benchmark in short mode.\")\r\n\t}\r\n\ta := Open(0)\r\n\tdefer a.Close()\r\n\tb.RunParallel(func(pb *testing.PB) {\r\n\t\tfor pb.Next() {\r\n\t\t\ta.Deposit(10)\r\n\t\t\ta.Deposit(-10)\r\n\t\t}\r\n\t})\r\n}\r\n"
}