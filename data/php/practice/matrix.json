{
  "language": "php",
  "slug": "matrix",
  "docs": {
    "instructions": "# Instructions\r\n\r\nGiven a string representing a matrix of numbers, return the rows and columns of\r\nthat matrix.\r\n\r\nSo given a string with embedded newlines like:\r\n\r\n```text\r\n9 8 7\r\n5 3 2\r\n6 6 7\r\n```\r\n\r\nrepresenting this matrix:\r\n\r\n```text\r\n    1  2  3\r\n  |---------\r\n1 | 9  8  7\r\n2 | 5  3  2\r\n3 | 6  6  7\r\n```\r\n\r\nyour code should be able to spit out:\r\n\r\n- A list of the rows, reading each row left-to-right while moving\r\n  top-to-bottom across the rows,\r\n- A list of the columns, reading each column top-to-bottom while moving\r\n  from left-to-right.\r\n\r\nThe rows for our example matrix:\r\n\r\n- 9, 8, 7\r\n- 5, 3, 2\r\n- 6, 6, 7\r\n\r\nAnd its columns:\r\n\r\n- 9, 5, 6\r\n- 8, 3, 6\r\n- 7, 2, 7\r\n",
    "instructions_append": "",
    "hints": ""
  },
  "starter_code": {
    "Matrix.php": "<?php\r\n\r\n/*\r\n * By adding type hints and enabling strict type checking, code can become\r\n * easier to read, self-documenting and reduce the number of potential bugs.\r\n * By default, type declarations are non-strict, which means they will attempt\r\n * to change the original type to match the type specified by the\r\n * type-declaration.\r\n *\r\n * In other words, if you pass a string to a function requiring a float,\r\n * it will attempt to convert the string value to a float.\r\n *\r\n * To enable strict mode, a single declare directive must be placed at the top\r\n * of the file.\r\n * This means that the strictness of typing is configured on a per-file basis.\r\n * This directive not only affects the type declarations of parameters, but also\r\n * a function's return type.\r\n *\r\n * For more info review the Concept on strict type checking in the PHP track\r\n * <link>.\r\n *\r\n * To disable strict typing, comment out the directive below.\r\n */\r\n\r\ndeclare(strict_types=1);\r\n\r\nclass Matrix\r\n{\r\n    public function __construct(string $matrix)\r\n    {\r\n        throw new \\BadFunctionCallException(\"Please implement the Matrix class!\");\r\n    }\r\n\r\n    public function getRow(int $rowId): array\r\n    {\r\n        throw new \\BadFunctionCallException(\"Please implement the getRow method!\");\r\n    }\r\n\r\n    public function getColumn(int $columnId): array\r\n    {\r\n        throw new \\BadFunctionCallException(\"Please implement the getColumn method!\");\r\n    }\r\n}\r\n"
  },
  "tests": {
    "MatrixTest.php": "<?php\r\n\r\n/*\r\n * By adding type hints and enabling strict type checking, code can become\r\n * easier to read, self-documenting and reduce the number of potential bugs.\r\n * By default, type declarations are non-strict, which means they will attempt\r\n * to change the original type to match the type specified by the\r\n * type-declaration.\r\n *\r\n * In other words, if you pass a string to a function requiring a float,\r\n * it will attempt to convert the string value to a float.\r\n *\r\n * To enable strict mode, a single declare directive must be placed at the top\r\n * of the file.\r\n * This means that the strictness of typing is configured on a per-file basis.\r\n * This directive not only affects the type declarations of parameters, but also\r\n * a function's return type.\r\n *\r\n * For more info review the Concept on strict type checking in the PHP track\r\n * <link>.\r\n *\r\n * To disable strict typing, comment out the directive below.\r\n */\r\n\r\ndeclare(strict_types=1);\r\n\r\nuse PHPUnit\\Framework\\TestCase;\r\n\r\nclass MatrixTest extends TestCase\r\n{\r\n    public static function setUpBeforeClass(): void\r\n    {\r\n        require_once 'Matrix.php';\r\n    }\r\n\r\n    public function testExtractRowFromOneNumberMatrix(): void\r\n    {\r\n        $matrix = new Matrix(\"1\");\r\n\r\n        $this->assertEquals([1], $matrix->getRow(1));\r\n    }\r\n\r\n    public function testExtractRow(): void\r\n    {\r\n        $matrix = new Matrix(\"1 2\\n3 4\");\r\n\r\n        $this->assertEquals([3, 4], $matrix->getRow(2));\r\n    }\r\n\r\n    public function testExtractRowWhereNumbersHaveDifferentWidths(): void\r\n    {\r\n        $matrix = new Matrix(\"1, 2\\n10 20\");\r\n\r\n        $this->assertEquals([10, 20], $matrix->getRow(2));\r\n    }\r\n\r\n    public function testExtractRowFromNonSquareMatrixWithNoMatchingColumn(): void\r\n    {\r\n        $matrix = new Matrix(\"1 2 3\\n4 5 6\\n7 8 9\\n8 7 6\");\r\n\r\n        $this->assertEquals([8, 7, 6], $matrix->getRow(4));\r\n    }\r\n\r\n    public function testExtractColumnFromOneNumberMatrix(): void\r\n    {\r\n        $matrix = new Matrix(\"1\");\r\n\r\n        $this->assertEquals([1], $matrix->getColumn(1));\r\n    }\r\n\r\n    public function testExtractColumn(): void\r\n    {\r\n        $matrix = new Matrix(\"1 2 3\\n4 5 6\\n7 8 9\");\r\n\r\n        $this->assertEquals([3, 6, 9], $matrix->getColumn(3));\r\n    }\r\n\r\n    public function testExtractColumnFromNonSquareMatrixWithNoMatchRow(): void\r\n    {\r\n        $matrix = new Matrix(\"1 2 3 4\\n5 6 7 8\\n9 8 7 6\");\r\n\r\n        $this->assertEquals([4, 8, 6], $matrix->getColumn(4));\r\n    }\r\n\r\n    public function testExtractColumnWhenNumbersHaveDifferentWidths(): void\r\n    {\r\n        $matrix = new Matrix(\"89 1903 3\\n18 3 1\\n9 41 800\");\r\n\r\n        $this->assertEquals([1903, 3, 41], $matrix->getColumn(2));\r\n    }\r\n}\r\n"
  }
}