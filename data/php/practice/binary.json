{
  "language": "php",
  "slug": "binary",
  "docs": {
    "instructions": "# Instructions\r\n\r\nConvert a binary number, represented as a string (e.g. '101010'), to its decimal equivalent using first principles.\r\n\r\nImplement binary to decimal conversion. Given a binary input\r\nstring, your program should produce a decimal output. The\r\nprogram should handle invalid inputs.\r\n\r\n## Note\r\n\r\n- Implement the conversion yourself.\r\n  Do not use something else to perform the conversion for you.\r\n\r\n## About Binary (Base-2)\r\n\r\nDecimal is a base-10 system.\r\n\r\nA number 23 in base 10 notation can be understood\r\nas a linear combination of powers of 10:\r\n\r\n- The rightmost digit gets multiplied by 10^0 = 1\r\n- The next number gets multiplied by 10^1 = 10\r\n- ...\r\n- The *n*th number gets multiplied by 10^*(n-1)*.\r\n- All these values are summed.\r\n\r\nSo: `23 => 2*10^1 + 3*10^0 => 2*10 + 3*1 = 23 base 10`\r\n\r\nBinary is similar, but uses powers of 2 rather than powers of 10.\r\n\r\nSo: `101 => 1*2^2 + 0*2^1 + 1*2^0 => 1*4 + 0*2 + 1*1 => 4 + 1 => 5 base 10`.\r\n",
    "instructions_append": "",
    "hints": ""
  },
  "starter_code": {
    "Binary.php": "<?php\r\n\r\n/*\r\n * By adding type hints and enabling strict type checking, code can become\r\n * easier to read, self-documenting and reduce the number of potential bugs.\r\n * By default, type declarations are non-strict, which means they will attempt\r\n * to change the original type to match the type specified by the\r\n * type-declaration.\r\n *\r\n * In other words, if you pass a string to a function requiring a float,\r\n * it will attempt to convert the string value to a float.\r\n *\r\n * To enable strict mode, a single declare directive must be placed at the top\r\n * of the file.\r\n * This means that the strictness of typing is configured on a per-file basis.\r\n * This directive not only affects the type declarations of parameters, but also\r\n * a function's return type.\r\n *\r\n * For more info review the Concept on strict type checking in the PHP track\r\n * <link>.\r\n *\r\n * To disable strict typing, comment out the directive below.\r\n */\r\n\r\ndeclare(strict_types=1);\r\n\r\nfunction parse_binary(string $binary): int\r\n{\r\n    throw new \\BadFunctionCallException(\"Implement the parse_binary function\");\r\n}\r\n"
  },
  "tests": {
    "BinaryTest.php": "<?php\r\n\r\n/*\r\n * By adding type hints and enabling strict type checking, code can become\r\n * easier to read, self-documenting and reduce the number of potential bugs.\r\n * By default, type declarations are non-strict, which means they will attempt\r\n * to change the original type to match the type specified by the\r\n * type-declaration.\r\n *\r\n * In other words, if you pass a string to a function requiring a float,\r\n * it will attempt to convert the string value to a float.\r\n *\r\n * To enable strict mode, a single declare directive must be placed at the top\r\n * of the file.\r\n * This means that the strictness of typing is configured on a per-file basis.\r\n * This directive not only affects the type declarations of parameters, but also\r\n * a function's return type.\r\n *\r\n * For more info review the Concept on strict type checking in the PHP track\r\n * <link>.\r\n *\r\n * To disable strict typing, comment out the directive below.\r\n */\r\n\r\ndeclare(strict_types=1);\r\n\r\nuse PHPUnit\\Framework\\TestCase;\r\nuse PHPUnit\\Framework\\Attributes\\DataProvider;\r\n\r\nclass BinaryTest extends TestCase\r\n{\r\n    public static function setUpBeforeClass(): void\r\n    {\r\n        require_once 'Binary.php';\r\n    }\r\n\r\n    public function testItParsesBinary0ToDecimal0(): void\r\n    {\r\n        $this->assertEquals(0, parse_binary('0'));\r\n    }\r\n\r\n    public function testItParsesBinary1ToDecimal1(): void\r\n    {\r\n        $this->assertEquals(1, parse_binary('1'));\r\n    }\r\n\r\n    public function testItParsesDigits(): void\r\n    {\r\n        $this->assertEquals(2, parse_binary('10'));\r\n        $this->assertEquals(3, parse_binary('11'));\r\n        $this->assertEquals(4, parse_binary('100'));\r\n        $this->assertEquals(9, parse_binary('1001'));\r\n    }\r\n\r\n    public function testItParsesHundreds(): void\r\n    {\r\n        $this->assertEquals(128, parse_binary('10000000'));\r\n        $this->assertEquals(315, parse_binary('100111011'));\r\n        $this->assertEquals(800, parse_binary('1100100000'));\r\n        $this->assertEquals(999, parse_binary('1111100111'));\r\n    }\r\n\r\n    public function testItParsesMaxInt(): void\r\n    {\r\n        $this->assertEquals(\r\n            9223372036854775807,\r\n            parse_binary('111111111111111111111111111111111111111111111111111111111111111')\r\n        );\r\n    }\r\n\r\n    public function testItParsesValuesWithLeadingZeros(): void\r\n    {\r\n        $this->assertEquals(1, parse_binary('01'));\r\n        $this->assertEquals(2, parse_binary('0010'));\r\n        $this->assertEquals(3, parse_binary('00011'));\r\n    }\r\n\r\n    #[DataProvider('invalidValues')]\r\n    public function testItOnlyAcceptsStringsContainingZerosAndOnes($value): void\r\n    {\r\n        $this->expectException(InvalidArgumentException::class);\r\n\r\n        parse_binary($value);\r\n    }\r\n\r\n    public static function invalidValues(): array\r\n    {\r\n        return [\r\n            ['2'], ['12345'], ['a'], ['0abcdef'],\r\n        ];\r\n    }\r\n}\r\n"
  }
}