{
  "language": "php",
  "slug": "resistor-color-duo",
  "docs": {
    "instructions": "# Instructions\r\n\r\nIf you want to build something using a Raspberry Pi, you'll probably use _resistors_.\r\nFor this exercise, you need to know two things about them:\r\n\r\n- Each resistor has a resistance value.\r\n- Resistors are small - so small in fact that if you printed the resistance value on them, it would be hard to read.\r\n\r\nTo get around this problem, manufacturers print color-coded bands onto the resistors to denote their resistance values.\r\nEach band has a position and a numeric value.\r\n\r\nThe first 2 bands of a resistor have a simple encoding scheme: each color maps to a single number.\r\nFor example, if they printed a brown band (value 1) followed by a green band (value 5), it would translate to the number 15.\r\n\r\nIn this exercise you are going to create a helpful program so that you don't have to remember the values of the bands.\r\nThe program will take color names as input and output a two digit number, even if the input is more than two colors!\r\n\r\nThe band colors are encoded as follows:\r\n\r\n- black: 0\r\n- brown: 1\r\n- red: 2\r\n- orange: 3\r\n- yellow: 4\r\n- green: 5\r\n- blue: 6\r\n- violet: 7\r\n- grey: 8\r\n- white: 9\r\n\r\nFrom the example above:\r\nbrown-green should return 15, and\r\nbrown-green-violet should return 15 too, ignoring the third color.\r\n",
    "instructions_append": "",
    "hints": ""
  },
  "starter_code": {
    "ResistorColorDuo.php": "<?php\r\n\r\n/*\r\n * By adding type hints and enabling strict type checking, code can become\r\n * easier to read, self-documenting and reduce the number of potential bugs.\r\n * By default, type declarations are non-strict, which means they will attempt\r\n * to change the original type to match the type specified by the\r\n * type-declaration.\r\n *\r\n * In other words, if you pass a string to a function requiring a float,\r\n * it will attempt to convert the string value to a float.\r\n *\r\n * To enable strict mode, a single declare directive must be placed at the top\r\n * of the file.\r\n * This means that the strictness of typing is configured on a per-file basis.\r\n * This directive not only affects the type declarations of parameters, but also\r\n * a function's return type.\r\n *\r\n * For more info review the Concept on strict type checking in the PHP track\r\n * <link>.\r\n *\r\n * To disable strict typing, comment out the directive below.\r\n */\r\n\r\ndeclare(strict_types=1);\r\n\r\nclass ResistorColorDuo\r\n{\r\n    public function getColorsValue(array $colors): int\r\n    {\r\n        throw new \\BadMethodCallException(sprintf('Implement the %s method', __FUNCTION__));\r\n    }\r\n}\r\n"
  },
  "tests": {
    "ResistorColorDuoTest.php": "<?php\r\n\r\n/*\r\n * By adding type hints and enabling strict type checking, code can become\r\n * easier to read, self-documenting and reduce the number of potential bugs.\r\n * By default, type declarations are non-strict, which means they will attempt\r\n * to change the original type to match the type specified by the\r\n * type-declaration.\r\n *\r\n * In other words, if you pass a string to a function requiring a float,\r\n * it will attempt to convert the string value to a float.\r\n *\r\n * To enable strict mode, a single declare directive must be placed at the top\r\n * of the file.\r\n * This means that the strictness of typing is configured on a per-file basis.\r\n * This directive not only affects the type declarations of parameters, but also\r\n * a function's return type.\r\n *\r\n * For more info review the Concept on strict type checking in the PHP track\r\n * <link>.\r\n *\r\n * To disable strict typing, comment out the directive below.\r\n */\r\n\r\ndeclare(strict_types=1);\r\n\r\nuse PHPUnit\\Framework\\TestCase;\r\n\r\nclass ResistorColorDuoTest extends TestCase\r\n{\r\n    private ResistorColorDuo $resistor;\r\n\r\n    public static function setUpBeforeClass(): void\r\n    {\r\n        require_once 'ResistorColorDuo.php';\r\n    }\r\n\r\n    public function setUp(): void\r\n    {\r\n        $this->resistor = new ResistorColorDuo();\r\n    }\r\n\r\n    public function testBrownAndBlack(): void\r\n    {\r\n        $this->assertEquals(10, $this->resistor->getColorsValue(['brown', 'black']));\r\n    }\r\n\r\n    public function testBlueAndGrey(): void\r\n    {\r\n        $this->assertEquals(68, $this->resistor->getColorsValue(['blue', 'grey']));\r\n    }\r\n\r\n    public function testYellowAndViolet(): void\r\n    {\r\n        $this->assertEquals(47, $this->resistor->getColorsValue(['yellow', 'violet']));\r\n    }\r\n\r\n    public function testWhiteAndRed(): void\r\n    {\r\n        $this->assertEquals(92, $this->resistor->getColorsValue(['white', 'red']));\r\n    }\r\n\r\n    public function testOrangeAndOrange(): void\r\n    {\r\n        $this->assertEquals(33, $this->resistor->getColorsValue(['orange', 'orange']));\r\n    }\r\n\r\n    public function testAdditionalColorsAreIgnored(): void\r\n    {\r\n        $this->assertEquals(51, $this->resistor->getColorsValue(['green', 'brown', 'orange']));\r\n    }\r\n\r\n    public function testBlackAndBrownSingleDigit(): void\r\n    {\r\n        $this->assertEquals(1, $this->resistor->getColorsValue(['black', 'brown']));\r\n    }\r\n}\r\n"
  }
}