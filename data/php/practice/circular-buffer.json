{
  "language": "php",
  "slug": "circular-buffer",
  "docs": {
    "instructions": "# Instructions\r\n\r\nA circular buffer, cyclic buffer or ring buffer is a data structure that uses a single, fixed-size buffer as if it were connected end-to-end.\r\n\r\nA circular buffer first starts empty and of some predefined length.\r\nFor example, this is a 7-element buffer:\r\n\r\n```text\r\n[ ][ ][ ][ ][ ][ ][ ]\r\n```\r\n\r\nAssume that a 1 is written into the middle of the buffer (exact starting location does not matter in a circular buffer):\r\n\r\n```text\r\n[ ][ ][ ][1][ ][ ][ ]\r\n```\r\n\r\nThen assume that two more elements are added — 2 & 3 — which get appended after the 1:\r\n\r\n```text\r\n[ ][ ][ ][1][2][3][ ]\r\n```\r\n\r\nIf two elements are then removed from the buffer, the oldest values inside the buffer are removed.\r\nThe two elements removed, in this case, are 1 & 2, leaving the buffer with just a 3:\r\n\r\n```text\r\n[ ][ ][ ][ ][ ][3][ ]\r\n```\r\n\r\nIf the buffer has 7 elements then it is completely full:\r\n\r\n```text\r\n[5][6][7][8][9][3][4]\r\n```\r\n\r\nWhen the buffer is full an error will be raised, alerting the client that further writes are blocked until a slot becomes free.\r\n\r\nWhen the buffer is full, the client can opt to overwrite the oldest data with a forced write.\r\nIn this case, two more elements — A & B — are added and they overwrite the 3 & 4:\r\n\r\n```text\r\n[5][6][7][8][9][A][B]\r\n```\r\n\r\n3 & 4 have been replaced by A & B making 5 now the oldest data in the buffer.\r\nFinally, if two elements are removed then what would be returned is 5 & 6 yielding the buffer:\r\n\r\n```text\r\n[ ][ ][7][8][9][A][B]\r\n```\r\n\r\nBecause there is space available, if the client again uses overwrite to store C & D then the space where 5 & 6 were stored previously will be used not the location of 7 & 8.\r\n7 is still the oldest element and the buffer is once again full.\r\n\r\n```text\r\n[C][D][7][8][9][A][B]\r\n```\r\n",
    "instructions_append": "",
    "hints": ""
  },
  "starter_code": {
    "CircularBuffer.php": "<?php\r\n\r\n/*\r\n * By adding type hints and enabling strict type checking, code can become\r\n * easier to read, self-documenting and reduce the number of potential bugs.\r\n * By default, type declarations are non-strict, which means they will attempt\r\n * to change the original type to match the type specified by the\r\n * type-declaration.\r\n *\r\n * In other words, if you pass a string to a function requiring a float,\r\n * it will attempt to convert the string value to a float.\r\n *\r\n * To enable strict mode, a single declare directive must be placed at the top\r\n * of the file.\r\n * This means that the strictness of typing is configured on a per-file basis.\r\n * This directive not only affects the type declarations of parameters, but also\r\n * a function's return type.\r\n *\r\n * For more info review the Concept on strict type checking in the PHP track\r\n * <link>.\r\n *\r\n * To disable strict typing, comment out the directive below.\r\n */\r\n\r\ndeclare(strict_types=1);\r\n\r\nclass CircularBuffer\r\n{\r\n    // You need to add more methods yourself!\r\n\r\n    public function read()\r\n    {\r\n        throw new \\BadMethodCallException(sprintf('Implement the %s method', __FUNCTION__));\r\n    }\r\n\r\n    public function write($item): void\r\n    {\r\n        throw new \\BadMethodCallException(sprintf('Implement the %s method', __FUNCTION__));\r\n    }\r\n}\r\n\r\nclass BufferFullError extends Exception\r\n{\r\n}\r\n\r\nclass BufferEmptyError extends Exception\r\n{\r\n}\r\n"
  },
  "tests": {
    "CircularBufferTest.php": "<?php\r\n\r\ndeclare(strict_types=1);\r\n\r\nuse PHPUnit\\Framework\\Attributes\\TestDox;\r\n\r\nrequire_once 'CircularBuffer.php';\r\n\r\nuse PHPUnit\\Framework\\TestCase;\r\n\r\nclass CircularBufferTest extends TestCase\r\n{\r\n    /**\r\n     * uuid: 28268ed4-4ff3-45f3-820e-895b44d53dfa\r\n     */\r\n    #[TestDox('reading empty buffer should fail')]\r\n    public function testReadingEmptyBufferShouldFail(): void\r\n    {\r\n        $buffer = new CircularBuffer(1);\r\n        $this->expectException(BufferEmptyError::class);\r\n        $buffer->read();\r\n    }\r\n\r\n    /**\r\n     * uuid: 2e6db04a-58a1-425d-ade8-ac30b5f318f3\r\n     */\r\n    #[TestDox('can read an item just written')]\r\n    public function testCanReadAnItemJustWritten(): void\r\n    {\r\n        $buffer = new CircularBuffer(1);\r\n        $buffer->write('1');\r\n        $this->assertSame('1', $buffer->read());\r\n    }\r\n\r\n    /**\r\n     * uuid: 90741fe8-a448-45ce-be2b-de009a24c144\r\n     */\r\n    #[TestDox('each item may only be read once')]\r\n    public function testEachItemMayOnlyBeReadOnce(): void\r\n    {\r\n        $buffer = new CircularBuffer(1);\r\n        $buffer->write('1');\r\n        $this->assertSame('1', $buffer->read());\r\n        $this->expectException(BufferEmptyError::class);\r\n        $buffer->read();\r\n    }\r\n\r\n    /**\r\n     * uuid: be0e62d5-da9c-47a8-b037-5db21827baa7\r\n     */\r\n    #[TestDox('items are read in the order they are written')]\r\n    public function testItemsAreReadInTheOrderTheyAreWritten(): void\r\n    {\r\n        $buffer = new CircularBuffer(2);\r\n        $buffer->write('1');\r\n        $buffer->write('2');\r\n        $this->assertSame('1', $buffer->read());\r\n        $this->assertSame('2', $buffer->read());\r\n    }\r\n\r\n    /**\r\n     * uuid: 2af22046-3e44-4235-bfe6-05ba60439d38\r\n     */\r\n    #[TestDox(\"full buffer can't be written to\")]\r\n    public function testFullBufferCantBeWrittenTo(): void\r\n    {\r\n        $buffer = new CircularBuffer(1);\r\n        $buffer->write('1');\r\n        $this->expectException(BufferFullError::class);\r\n        $buffer->write('2');\r\n    }\r\n\r\n    /**\r\n     * uuid: 547d192c-bbf0-4369-b8fa-fc37e71f2393\r\n     */\r\n    #[TestDox('a read frees up capacity for another write')]\r\n    public function testAReadFreesUpCapacityForAnotherWrite(): void\r\n    {\r\n        $buffer = new CircularBuffer(1);\r\n        $buffer->write('1');\r\n        $this->assertSame('1', $buffer->read());\r\n        $buffer->write('2');\r\n        $this->assertSame('2', $buffer->read());\r\n    }\r\n\r\n    /**\r\n     * uuid: 04a56659-3a81-4113-816b-6ecb659b4471\r\n     */\r\n    #[TestDox('read position is maintained even across multiple writes')]\r\n    public function testReadPositionIsMaintainedEvenAcrossMultipleWrites(): void\r\n    {\r\n        $buffer = new CircularBuffer(3);\r\n        $buffer->write('1');\r\n        $buffer->write('2');\r\n        $this->assertSame('1', $buffer->read());\r\n        $buffer->write('3');\r\n        $this->assertSame('2', $buffer->read());\r\n        $this->assertSame('3', $buffer->read());\r\n    }\r\n\r\n    /**\r\n     * uuid: 60c3a19a-81a7-43d7-bb0a-f07242b1111f\r\n     */\r\n    #[TestDox(\"items cleared out of buffer can't be read\")]\r\n    public function testItemsClearedOutOfBufferCantBeRead(): void\r\n    {\r\n        $buffer = new CircularBuffer(1);\r\n        $buffer->write('1');\r\n        $buffer->clear();\r\n        $this->expectException(BufferEmptyError::class);\r\n        $buffer->read();\r\n    }\r\n\r\n    /**\r\n     * uuid: 45f3ae89-3470-49f3-b50e-362e4b330a59\r\n     */\r\n    #[TestDox('clear frees up capacity for another write')]\r\n    public function testClearFreesUpCapacityForAnotherWrite(): void\r\n    {\r\n        $buffer = new CircularBuffer(1);\r\n        $buffer->write('1');\r\n        $buffer->clear();\r\n        $buffer->write('2');\r\n        $this->assertSame('2', $buffer->read());\r\n    }\r\n\r\n    /**\r\n     * uuid: e1ac5170-a026-4725-bfbe-0cf332eddecd\r\n     */\r\n    #[TestDox('clear does nothing on empty buffer')]\r\n    public function testClearDoesNothingOnEmptyBuffer(): void\r\n    {\r\n        $buffer = new CircularBuffer(1);\r\n        $buffer->clear();\r\n        $buffer->write('1');\r\n        $this->assertSame('1', $buffer->read());\r\n    }\r\n\r\n    /**\r\n     * uuid: 9c2d4f26-3ec7-453f-a895-7e7ff8ae7b5b\r\n     */\r\n    #[TestDox('overwrite acts like write on non-full buffer')]\r\n    public function testOverwriteActsLikeWriteOnNonFullBuffer(): void\r\n    {\r\n        $buffer = new CircularBuffer(2);\r\n        $buffer->write('1');\r\n        $buffer->forceWrite('2');\r\n        $this->assertSame('1', $buffer->read());\r\n        $this->assertSame('2', $buffer->read());\r\n    }\r\n\r\n    /**\r\n     * uuid: 880f916b-5039-475c-bd5c-83463c36a147\r\n     */\r\n    #[TestDox('overwrite replaces the oldest item on full buffer')]\r\n    public function testOverwriteReplacesTheOldestItemOnFullBuffer(): void\r\n    {\r\n        $buffer = new CircularBuffer(2);\r\n        $buffer->write('1');\r\n        $buffer->write('2');\r\n        $buffer->forceWrite('3');\r\n        $this->assertSame('2', $buffer->read());\r\n        $this->assertSame('3', $buffer->read());\r\n    }\r\n\r\n    /**\r\n     * uuid: bfecab5b-aca1-4fab-a2b0-cd4af2b053c3\r\n     */\r\n    #[TestDox('overwrite replaces the oldest item remaining in buffer following a read')]\r\n    public function testOverwriteReplacesTheOldestItemRemainingInBufferFollowingARead(): void\r\n    {\r\n        $buffer = new CircularBuffer(3);\r\n        $buffer->write('1');\r\n        $buffer->write('2');\r\n        $buffer->write('3');\r\n        $this->assertSame('1', $buffer->read());\r\n        $buffer->write('4');\r\n        $buffer->forceWrite('5');\r\n        $this->assertSame('3', $buffer->read());\r\n        $this->assertSame('4', $buffer->read());\r\n        $this->assertSame('5', $buffer->read());\r\n    }\r\n\r\n    /**\r\n     * uuid: 9cebe63a-c405-437b-8b62-e3fdc1ecec5a\r\n     */\r\n    #[TestDox('initial clear does not affect wrapping around')]\r\n    public function testInitialClearDoesNotAffectWrappingAround(): void\r\n    {\r\n        $buffer = new CircularBuffer(2);\r\n        $buffer->clear();\r\n        $buffer->write('1');\r\n        $buffer->write('2');\r\n        $buffer->forceWrite('3');\r\n        $buffer->forceWrite('4');\r\n        $this->assertSame('3', $buffer->read());\r\n        $this->assertSame('4', $buffer->read());\r\n        $this->expectException(BufferEmptyError::class);\r\n        $buffer->read();\r\n    }\r\n}\r\n"
  }
}