{
  "language": "php",
  "slug": "list-ops",
  "docs": {
    "instructions": "# Instructions\r\n\r\nImplement basic list operations.\r\n\r\nIn functional languages list operations like `length`, `map`, and `reduce` are very common.\r\nImplement a series of basic list operations, without using existing functions.\r\n\r\nThe precise number and names of the operations to be implemented will be track dependent to avoid conflicts with existing names, but the general operations you will implement include:\r\n\r\n- `append` (_given two lists, add all items in the second list to the end of the first list_);\r\n- `concatenate` (_given a series of lists, combine all items in all lists into one flattened list_);\r\n- `filter` (_given a predicate and a list, return the list of all items for which `predicate(item)` is True_);\r\n- `length` (_given a list, return the total number of items within it_);\r\n- `map` (_given a function and a list, return the list of the results of applying `function(item)` on all items_);\r\n- `foldl` (_given a function, a list, and initial accumulator, fold (reduce) each item into the accumulator from the left_);\r\n- `foldr` (_given a function, a list, and an initial accumulator, fold (reduce) each item into the accumulator from the right_);\r\n- `reverse` (_given a list, return a list with all the original items, but in reversed order_).\r\n\r\nNote, the ordering in which arguments are passed to the fold functions (`foldl`, `foldr`) is significant.\r\n",
    "instructions_append": "## Callable\r\n\r\nIn PHP there is a concept of [callable](https://www.php.net/manual/en/language.types.callable.php).\r\n\r\nThose can take multiple forms, but we will focus on [anonymous functions](https://www.php.net/manual/en/functions.anonymous.php).\r\n\r\nIt is possible to create an anonymous function in a variable and call it with parameters:\r\n\r\n```php\r\n$double = function ($number) {\r\n    return $number * 2;\r\n};\r\n\r\n$double(2); // returns 4\r\n$double(4); // returns 8\r\n```\r\n",
    "hints": ""
  },
  "starter_code": {
    "ListOps.php": "<?php\r\n\r\n/*\r\n * By adding type hints and enabling strict type checking, code can become\r\n * easier to read, self-documenting and reduce the number of potential bugs.\r\n * By default, type declarations are non-strict, which means they will attempt\r\n * to change the original type to match the type specified by the\r\n * type-declaration.\r\n *\r\n * In other words, if you pass a string to a function requiring a float,\r\n * it will attempt to convert the string value to a float.\r\n *\r\n * To enable strict mode, a single declare directive must be placed at the top\r\n * of the file.\r\n * This means that the strictness of typing is configured on a per-file basis.\r\n * This directive not only affects the type declarations of parameters, but also\r\n * a function's return type.\r\n *\r\n * For more info review the Concept on strict type checking in the PHP track\r\n * <link>.\r\n *\r\n * To disable strict typing, comment out the directive below.\r\n */\r\n\r\ndeclare(strict_types=1);\r\n\r\nclass ListOps\r\n{\r\n    public function append(array $list1, array $list2): array\r\n    {\r\n        throw new \\BadMethodCallException(\"Implement the append function\");\r\n    }\r\n\r\n    public function concat(array $list1, array ...$listn): array\r\n    {\r\n        throw new \\BadMethodCallException(\"Implement the concat function\");\r\n    }\r\n\r\n    /**\r\n     * @param callable(mixed $item): bool $predicate\r\n     */\r\n    public function filter(callable $predicate, array $list): array\r\n    {\r\n        throw new \\BadMethodCallException(\"Implement the filter function\");\r\n    }\r\n\r\n    public function length(array $list): int\r\n    {\r\n        throw new \\BadMethodCallException(\"Implement the length function\");\r\n    }\r\n\r\n    /**\r\n     * @param callable(mixed $item): mixed $function\r\n     */\r\n    public function map(callable $function, array $list): array\r\n    {\r\n        throw new \\BadMethodCallException(\"Implement the map function\");\r\n    }\r\n\r\n    /**\r\n     * @param callable(mixed $accumulator, mixed $item): mixed $function\r\n     */\r\n    public function foldl(callable $function, array $list, $accumulator)\r\n    {\r\n        throw new \\BadMethodCallException(\"Implement the foldl function\");\r\n    }\r\n\r\n    /**\r\n     * @param callable(mixed $accumulator, mixed $item): mixed $function\r\n     */\r\n    public function foldr(callable $function, array $list, $accumulator)\r\n    {\r\n        throw new \\BadMethodCallException(\"Implement the foldr function\");\r\n    }\r\n\r\n    public function reverse(array $list): array\r\n    {\r\n        throw new \\BadMethodCallException(\"Implement the reverse function\");\r\n    }\r\n}\r\n"
  },
  "tests": {
    "ListOpsTest.php": "<?php\r\n\r\ndeclare(strict_types=1);\r\n\r\nuse PHPUnit\\Framework\\TestCase;\r\nuse PHPUnit\\Framework\\Attributes\\TestDox;\r\n\r\nclass ListOpsTest extends TestCase\r\n{\r\n    public static function setUpBeforeClass(): void\r\n    {\r\n        require_once 'ListOps.php';\r\n    }\r\n\r\n    /**\r\n     * uuid 485b9452-bf94-40f7-a3db-c3cf4850066a\r\n     */\r\n    #[TestDox('append entries to a list and return the new list -> empty lists')]\r\n    public function testAppendEmptyLists()\r\n    {\r\n        $listOps = new ListOps();\r\n        $this->assertEquals([], $listOps->append([], []));\r\n    }\r\n\r\n    /**\r\n     * uuid 2c894696-b609-4569-b149-8672134d340a\r\n     */\r\n    #[TestDox('append entries to a list and return the new list -> list to empty list')]\r\n    public function testAppendNonEmptyListToEmptyList()\r\n    {\r\n        $listOps = new ListOps();\r\n        $this->assertEquals([1, 2, 3, 4], $listOps->append([1, 2, 3, 4], []));\r\n    }\r\n\r\n    /**\r\n     * uuid e842efed-3bf6-4295-b371-4d67a4fdf19c\r\n     */\r\n    #[TestDox('append entries to a list and return the new list -> empty list to list')]\r\n    public function testAppendEmptyListToNonEmptyList()\r\n    {\r\n        $listOps = new ListOps();\r\n        $this->assertEquals([1, 2, 3, 4], $listOps->append([], [1, 2, 3, 4]));\r\n    }\r\n\r\n    /**\r\n     * uuid 71dcf5eb-73ae-4a0e-b744-a52ee387922f\r\n     */\r\n    #[TestDox('append entries to a list and return the new list -> non-empty lists')]\r\n    public function testAppendNonEmptyLists()\r\n    {\r\n        $listOps = new ListOps();\r\n        $this->assertEquals([1, 2, 2, 3, 4, 5], $listOps->append([1, 2], [2, 3, 4, 5]));\r\n    }\r\n\r\n    /**\r\n     * uuid 28444355-201b-4af2-a2f6-5550227bde21\r\n     */\r\n    #[TestDox('concatenate a list of lists -> empty list')]\r\n    public function testConcatEmptyLists()\r\n    {\r\n        $listOps = new ListOps();\r\n        $this->assertEquals([], $listOps->concat([], []));\r\n    }\r\n\r\n    /**\r\n     * uuid 331451c1-9573-42a1-9869-2d06e3b389a9\r\n     */\r\n    #[TestDox('concatenate a list of lists -> list of lists')]\r\n    public function testConcatLists()\r\n    {\r\n        $listOps = new ListOps();\r\n        $this->assertEquals([1, 2, 3, 4, 5, 6], $listOps->concat([1, 2], [3], [], [4, 5, 6]));\r\n    }\r\n\r\n    /**\r\n     * uuid d6ecd72c-197f-40c3-89a4-aa1f45827e09\r\n     */\r\n    #[TestDox('concatenate a list of lists -> list of nested lists')]\r\n    public function testConcatNestedLists()\r\n    {\r\n        $listOps = new ListOps();\r\n        $this->assertEquals([[1], [2], [3], [], [4, 5, 6]], $listOps->concat([[1], [2]], [[3]], [[]], [[4, 5, 6]]));\r\n    }\r\n\r\n    /**\r\n     * uuid 0524fba8-3e0f-4531-ad2b-f7a43da86a16\r\n     */\r\n    #[TestDox('filter list returning only values that satisfy the filter function -> empty list')]\r\n    public function testFilterEmptyList()\r\n    {\r\n        $listOps = new ListOps();\r\n        $this->assertEquals(\r\n            [],\r\n            $listOps->filter(static fn ($el) => $el % 2 === 1, [])\r\n        );\r\n    }\r\n\r\n    /**\r\n     * uuid 88494bd5-f520-4edb-8631-88e415b62d24\r\n     */\r\n    #[TestDox('filter list returning only values that satisfy the filter function -> non empty list')]\r\n    public function testFilterNonEmptyList()\r\n    {\r\n        $listOps = new ListOps();\r\n        $this->assertEquals(\r\n            [1, 3, 5],\r\n            $listOps->filter(static fn ($el) => $el % 2 === 1, [1, 2, 3, 5])\r\n        );\r\n    }\r\n\r\n    /**\r\n     * uuid 1cf0b92d-8d96-41d5-9c21-7b3c37cb6aad\r\n     */\r\n    #[TestDox('returns the length of a list -> empty list')]\r\n    public function testLengthEmptyList()\r\n    {\r\n        $listOps = new ListOps();\r\n        $this->assertEquals(0, $listOps->length([]));\r\n    }\r\n\r\n    /**\r\n     * uuid d7b8d2d9-2d16-44c4-9a19-6e5f237cb71e\r\n     */\r\n    #[TestDox('returns the length of a list -> non-empty list')]\r\n    public function testLengthNonEmptyList()\r\n    {\r\n        $listOps = new ListOps();\r\n        $this->assertEquals(4, $listOps->length([1, 2, 3, 4]));\r\n    }\r\n\r\n    /**\r\n     * uuid c0bc8962-30e2-4bec-9ae4-668b8ecd75aa\r\n     */\r\n    #[TestDox('returns a list of elements whose values equal the list value transformed by the mapping function -> empty list')]\r\n    public function testMapEmptyList()\r\n    {\r\n        $listOps = new ListOps();\r\n        $this->assertEquals(\r\n            [],\r\n            $listOps->map(static fn ($el) => $el + 1, [])\r\n        );\r\n    }\r\n\r\n    /**\r\n     * uuid 11e71a95-e78b-4909-b8e4-60cdcaec0e91\r\n     */\r\n    #[TestDox('returns a list of elements whose values equal the list value transformed by the mapping function -> non-empty list')]\r\n    public function testMapNonEmptyList()\r\n    {\r\n        $listOps = new ListOps();\r\n        $this->assertEquals(\r\n            [2, 4, 6, 8],\r\n            $listOps->map(static fn ($el) => $el + 1, [1, 3, 5, 7])\r\n        );\r\n    }\r\n\r\n    /**\r\n     * uuid 36549237-f765-4a4c-bfd9-5d3a8f7b07d2\r\n     */\r\n    #[TestDox('folds (reduces) the given list from the left with a function -> empty list')]\r\n    public function testFoldlEmptyList()\r\n    {\r\n        $listOps = new ListOps();\r\n        $this->assertEquals(\r\n            2,\r\n            $listOps->foldl(static fn ($acc, $el) => $el * $acc, [], 2)\r\n        );\r\n    }\r\n\r\n    /**\r\n     * uuid 7a626a3c-03ec-42bc-9840-53f280e13067\r\n     */\r\n    #[TestDox('folds (reduces) the given list from the left with a function -> direction independent function applied to non-empty list')]\r\n    public function testFoldlDirectionIndependentNonEmptyList()\r\n    {\r\n        $listOps = new ListOps();\r\n        $this->assertEquals(\r\n            15,\r\n            $listOps->foldl(static fn ($acc, $el) => $acc + $el, [1, 2, 3, 4], 5)\r\n        );\r\n    }\r\n\r\n    /**\r\n     * uuid d7fcad99-e88e-40e1-a539-4c519681f390\r\n     */\r\n    #[TestDox('folds (reduces) the given list from the left with a function -> direction dependent function applied to non-empty list')]\r\n    public function testFoldlDirectionDependentNonEmptyList()\r\n    {\r\n        $listOps = new ListOps();\r\n        $this->assertEquals(\r\n            64,\r\n            $listOps->foldl(static fn ($acc, $el) => $el / $acc, [1, 2, 3, 4], 24)\r\n        );\r\n    }\r\n\r\n    /**\r\n     * uuid aeb576b9-118e-4a57-a451-db49fac20fdc\r\n     */\r\n    #[TestDox('folds (reduces) the given list from the right with a function -> empty list')]\r\n    public function testFoldrEmptyList()\r\n    {\r\n        $listOps = new ListOps();\r\n        $this->assertEquals(\r\n            2,\r\n            $listOps->foldr(static fn ($acc, $el) => $el * $acc, [], 2)\r\n        );\r\n    }\r\n\r\n    /**\r\n     * uuid e1c64db7-9253-4a3d-a7c4-5273b9e2a1bd\r\n     */\r\n    #[TestDox('folds (reduces) the given list from the right with a function -> direction independent function applied to non-empty list')]\r\n    public function testFoldrDirectionIndependentNonEmptyList()\r\n    {\r\n        $listOps = new ListOps();\r\n        $this->assertEquals(\r\n            15,\r\n            $listOps->foldr(static fn ($acc, $el) => $acc + $el, [1, 2, 3, 4], 5)\r\n        );\r\n    }\r\n\r\n    /**\r\n     * uuid 8066003b-f2ff-437e-9103-66e6df474844\r\n     */\r\n    #[TestDox('folds (reduces) the given list from the right with a function -> direction dependent function applied to non-empty list')]\r\n    public function testFoldrDirectionDependentNonEmptyList()\r\n    {\r\n        $listOps = new ListOps();\r\n        $this->assertEquals(\r\n            9,\r\n            $listOps->foldr(static fn ($acc, $el) => $el / $acc, [1, 2, 3, 4], 24)\r\n        );\r\n    }\r\n\r\n    /**\r\n     * uuid 94231515-050e-4841-943d-d4488ab4ee30\r\n     */\r\n    #[TestDox('reverse the elements of a list -> empty list')]\r\n    public function testReverseEmptyList()\r\n    {\r\n        $listOps = new ListOps();\r\n        $this->assertEquals([], $listOps->reverse([]));\r\n    }\r\n\r\n    /**\r\n     * uuid fcc03d1e-42e0-4712-b689-d54ad761f360\r\n     */\r\n    #[TestDox('reverse the elements of a list -> non-empty list')]\r\n    public function testReverseNonEmptyList()\r\n    {\r\n        $listOps = new ListOps();\r\n        $this->assertEquals([7, 5, 3, 1], $listOps->reverse([1, 3, 5, 7]));\r\n    }\r\n\r\n    /**\r\n     * uuid 40872990-b5b8-4cb8-9085-d91fc0d05d26\r\n     */\r\n    #[TestDox('reverse the elements of a list -> list of lists is not flattened')]\r\n    public function testReverseNonEmptyListIsNotFlattened()\r\n    {\r\n        $listOps = new ListOps();\r\n        $this->assertEquals([[4, 5, 6], [], [3], [1, 2]], $listOps->reverse([[1, 2], [3], [], [4, 5, 6]]));\r\n    }\r\n}\r\n"
  }
}