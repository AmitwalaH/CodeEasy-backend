{
  "language": "php",
  "slug": "largest-series-product",
  "docs": {
    "instructions": "# Instructions\r\n\r\nYour task is to look for patterns in the long sequence of digits in the encrypted signal.\r\n\r\nThe technique you're going to use here is called the largest series product.\r\n\r\nLet's define a few terms, first.\r\n\r\n- **input**: the sequence of digits that you need to analyze\r\n- **series**: a sequence of adjacent digits (those that are next to each other) that is contained within the input\r\n- **span**: how many digits long each series is\r\n- **product**: what you get when you multiply numbers together\r\n\r\nLet's work through an example, with the input `\"63915\"`.\r\n\r\n- To form a series, take adjacent digits in the original input.\r\n- If you are working with a span of `3`, there will be three possible series:\r\n  - `\"639\"`\r\n  - `\"391\"`\r\n  - `\"915\"`\r\n- Then we need to calculate the product of each series:\r\n  - The product of the series `\"639\"` is 162 (`6 × 3 × 9 = 162`)\r\n  - The product of the series `\"391\"` is 27 (`3 × 9 × 1 = 27`)\r\n  - The product of the series `\"915\"` is 45 (`9 × 1 × 5 = 45`)\r\n- 162 is bigger than both 27 and 45, so the largest series product of `\"63915\"` is from the series `\"639\"`.\r\n  So the answer is **162**.\r\n",
    "instructions_append": "",
    "hints": ""
  },
  "starter_code": {
    "LargestSeriesProduct.php": "<?php\r\n\r\n/*\r\n * By adding type hints and enabling strict type checking, code can become\r\n * easier to read, self-documenting and reduce the number of potential bugs.\r\n * By default, type declarations are non-strict, which means they will attempt\r\n * to change the original type to match the type specified by the\r\n * type-declaration.\r\n *\r\n * In other words, if you pass a string to a function requiring a float,\r\n * it will attempt to convert the string value to a float.\r\n *\r\n * To enable strict mode, a single declare directive must be placed at the top\r\n * of the file.\r\n * This means that the strictness of typing is configured on a per-file basis.\r\n * This directive not only affects the type declarations of parameters, but also\r\n * a function's return type.\r\n *\r\n * For more info review the Concept on strict type checking in the PHP track\r\n * <link>.\r\n *\r\n * To disable strict typing, comment out the directive below.\r\n */\r\n\r\ndeclare(strict_types=1);\r\n\r\nclass Series\r\n{\r\n    public function __construct(string $input)\r\n    {\r\n        throw new \\BadMethodCallException(\"Implement the constructor method\");\r\n    }\r\n\r\n    public function largestProduct(int $span): int\r\n    {\r\n        throw new \\BadMethodCallException(\"Implement the largestProduct method\");\r\n    }\r\n}\r\n"
  },
  "tests": {
    "LargestSeriesProductTest.php": "<?php\r\n\r\ndeclare(strict_types=1);\r\n\r\nuse PHPUnit\\Framework\\TestCase;\r\nuse PHPUnit\\Framework\\Attributes\\TestDox;\r\n\r\nclass LargestSeriesProductTest extends TestCase\r\n{\r\n    public static function setUpBeforeClass(): void\r\n    {\r\n        require_once 'LargestSeriesProduct.php';\r\n    }\r\n\r\n    /**\r\n     * Since PHP can only support Integers between +/- 9223372036854775807\r\n     * We will deal with the series of digits as strings to avoid having them cast to floats.\r\n     */\r\n    /**\r\n     * uuid: 7c82f8b7-e347-48ee-8a22-f672323324d4\r\n     */\r\n    #[TestDox('finds the largest product if span equals length')]\r\n    public function testFindsTheLargestProductIfSpanEqualsLength(): void\r\n    {\r\n        $series = new Series(\"29\");\r\n        $this->assertEquals(18, $series->largestProduct(2));\r\n    }\r\n\r\n    /**\r\n     * uuid: 88523f65-21ba-4458-a76a-b4aaf6e4cb5e\r\n     */\r\n    #[TestDox('can find the largest product of 2 with numbers in order')]\r\n    public function testCanFindTheLargestProductOf2WithNumbersInOrder(): void\r\n    {\r\n        // The number starts with a 0, qualifying it to be an octal\r\n        // So it needs to be a string so PHP doesn't complain\r\n        $series = new Series(\"0123456789\");\r\n        $this->assertEquals(72, $series->largestProduct(2));\r\n    }\r\n\r\n    /**\r\n     * uuid: f1376b48-1157-419d-92c2-1d7e36a70b8a\r\n     */\r\n    #[TestDox('can find the largest product of 2')]\r\n    public function testCanFindTheLargestProductOf2(): void\r\n    {\r\n        $series = new Series(\"576802143\");\r\n        $this->assertEquals(48, $series->largestProduct(2));\r\n    }\r\n\r\n    /**\r\n     * uuid: 46356a67-7e02-489e-8fea-321c2fa7b4a4\r\n     */\r\n    #[TestDox('can find the largest product of 3 with numbers in order')]\r\n    public function testCanFindTheLargestProductOf3WithNumbersInOrder(): void\r\n    {\r\n        $series = new Series(\"0123456789\");\r\n        $this->assertEquals(504, $series->largestProduct(3));\r\n    }\r\n\r\n    /**\r\n     * uuid: a2dcb54b-2b8f-4993-92dd-5ce56dece64a\r\n     */\r\n    #[TestDox('can find the largest product of 3')]\r\n    public function testCanFindTheLargestProductOf3(): void\r\n    {\r\n        $series = new Series(\"1027839564\");\r\n        $this->assertEquals(270, $series->largestProduct(3));\r\n    }\r\n\r\n    /**\r\n     * uuid: 673210a3-33cd-4708-940b-c482d7a88f9d\r\n     */\r\n    #[TestDox('can find the largest product of 5 with numbers in order')]\r\n    public function testCanFindTheLargestProductOf5WithNumbersInOrder(): void\r\n    {\r\n        $series = new Series(\"0123456789\");\r\n        $this->assertEquals(15120, $series->largestProduct(5));\r\n    }\r\n\r\n    /**\r\n     * uuid: 02acd5a6-3bbf-46df-8282-8b313a80a7c9\r\n     */\r\n    #[TestDox('can get the largest product of a big number')]\r\n    public function testCanGetTheLargestProductOfABigNumber(): void\r\n    {\r\n        $series = new Series(\"73167176531330624919225119674426574742355349194934\");\r\n        $this->assertEquals(23520, $series->largestProduct(6));\r\n    }\r\n\r\n    /**\r\n     * uuid: 76dcc407-21e9-424c-a98e-609f269622b5\r\n     */\r\n    #[TestDox('reports zero if the only digits are zero')]\r\n    public function testReportsZeroIfTheOnlyDigitsAreZero(): void\r\n    {\r\n        $series = new Series(\"0000\");\r\n        $this->assertEquals(0, $series->largestProduct(2));\r\n    }\r\n\r\n    /**\r\n     * uuid: 6ef0df9f-52d4-4a5d-b210-f6fae5f20e19\r\n     */\r\n    #[TestDox('reports zero if all spans include zero')]\r\n    public function testReportsZeroIfAllSpansIncludeZero(): void\r\n    {\r\n        $series = new Series(\"99099\");\r\n        $this->assertEquals(0, $series->largestProduct(3));\r\n    }\r\n\r\n    /**\r\n     * uuid: 0ae1ce53-d9ba-41bb-827f-2fceb64f058b\r\n     */\r\n    #[TestDox('rejects span longer than string length')]\r\n    public function testRejectsSpanLongerThanStringLength(): void\r\n    {\r\n        $this->expectException(InvalidArgumentException::class);\r\n\r\n        $series = new Series(\"123\");\r\n        $series->largestProduct(4);\r\n    }\r\n\r\n    /**\r\n     * uuid: 06bc8b90-0c51-4c54-ac22-3ec3893a079e\r\n     */\r\n    #[TestDox('reports 1 for empty string and empty product (0 span)')]\r\n    public function testReportsOneForEmptyStringAndEmptyProductSpanZero(): void\r\n    {\r\n        $series = new Series(\"\");\r\n        $this->assertEquals(1, $series->largestProduct(0));\r\n    }\r\n\r\n    /**\r\n     * uuid: 3ec0d92e-f2e2-4090-a380-70afee02f4c0\r\n     */\r\n    #[TestDox('reports 1 for nonempty string and empty product (0 span)')]\r\n    public function testReportsOneForNonemptyStringAndEmptyProductSpanZero(): void\r\n    {\r\n        $series = new Series(\"123\");\r\n        $this->assertEquals(1, $series->largestProduct(0));\r\n    }\r\n\r\n    /**\r\n     * uuid: 6cf66098-a6af-4223-aab1-26aeeefc7402\r\n     */\r\n    #[TestDox('rejects empty string and nonzero span')]\r\n    public function testRejectsEmptyStringAndNonzeroSpan(): void\r\n    {\r\n        $this->expectException(InvalidArgumentException::class);\r\n\r\n        $series = new Series(\"\");\r\n        $series->largestProduct(1);\r\n    }\r\n\r\n    /**\r\n     * uuid: 7a38f2d6-3c35-45f6-8d6f-12e6e32d4d74\r\n     */\r\n    #[TestDox('rejects invalid character in digits')]\r\n    public function testRejectsInvalidCharacterInDigits(): void\r\n    {\r\n        $this->expectException(InvalidArgumentException::class);\r\n\r\n        $series = new Series(\"1234a5\");\r\n        $series->largestProduct(2);\r\n    }\r\n\r\n    /**\r\n     * uuid: c859f34a-9bfe-4897-9c2f-6d7f8598e7f0\r\n     */\r\n    #[TestDox('rejects negative span')]\r\n    public function testRejectsNegativeSpan(): void\r\n    {\r\n        $this->expectException(InvalidArgumentException::class);\r\n\r\n        $series = new Series(\"12345\");\r\n        $series->largestProduct(-1);\r\n    }\r\n}\r\n"
  }
}