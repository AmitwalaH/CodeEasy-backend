{
  "language": "php",
  "slug": "robot-name",
  "docs": {
    "instructions": "# Instructions\r\n\r\nManage robot factory settings.\r\n\r\nWhen a robot comes off the factory floor, it has no name.\r\n\r\nThe first time you turn on a robot, a random name is generated in the format\r\nof two uppercase letters followed by three digits, such as RX837 or BC811.\r\n\r\nEvery once in a while we need to reset a robot to its factory settings,\r\nwhich means that its name gets wiped. The next time you ask, that robot will\r\nrespond with a new random name.\r\n\r\nThe names must be random: they should not follow a predictable sequence.\r\nUsing random names means a risk of collisions. Your solution must ensure that\r\nevery existing robot has a unique name.\r\n",
    "instructions_append": "",
    "hints": ""
  },
  "starter_code": {
    "RobotName.php": "<?php\r\n\r\n/*\r\n * By adding type hints and enabling strict type checking, code can become\r\n * easier to read, self-documenting and reduce the number of potential bugs.\r\n * By default, type declarations are non-strict, which means they will attempt\r\n * to change the original type to match the type specified by the\r\n * type-declaration.\r\n *\r\n * In other words, if you pass a string to a function requiring a float,\r\n * it will attempt to convert the string value to a float.\r\n *\r\n * To enable strict mode, a single declare directive must be placed at the top\r\n * of the file.\r\n * This means that the strictness of typing is configured on a per-file basis.\r\n * This directive not only affects the type declarations of parameters, but also\r\n * a function's return type.\r\n *\r\n * For more info review the Concept on strict type checking in the PHP track\r\n * <link>.\r\n *\r\n * To disable strict typing, comment out the directive below.\r\n */\r\n\r\ndeclare(strict_types=1);\r\n\r\nclass Robot\r\n{\r\n    public function getName(): string\r\n    {\r\n        throw new \\BadMethodCallException(\"Implement the getName method\");\r\n    }\r\n\r\n    public function reset(): void\r\n    {\r\n        throw new \\BadMethodCallException(\"Implement the reset method\");\r\n    }\r\n}\r\n"
  },
  "tests": {
    "RobotNameTest.php": "<?php\r\n\r\n/*\r\n * By adding type hints and enabling strict type checking, code can become\r\n * easier to read, self-documenting and reduce the number of potential bugs.\r\n * By default, type declarations are non-strict, which means they will attempt\r\n * to change the original type to match the type specified by the\r\n * type-declaration.\r\n *\r\n * In other words, if you pass a string to a function requiring a float,\r\n * it will attempt to convert the string value to a float.\r\n *\r\n * To enable strict mode, a single declare directive must be placed at the top\r\n * of the file.\r\n * This means that the strictness of typing is configured on a per-file basis.\r\n * This directive not only affects the type declarations of parameters, but also\r\n * a function's return type.\r\n *\r\n * For more info review the Concept on strict type checking in the PHP track\r\n * <link>.\r\n *\r\n * To disable strict typing, comment out the directive below.\r\n */\r\n\r\ndeclare(strict_types=1);\r\n\r\nuse PHPUnit\\Framework\\TestCase;\r\n\r\nclass RobotNameTest extends TestCase\r\n{\r\n    public static function setUpBeforeClass(): void\r\n    {\r\n        require_once 'RobotName.php';\r\n    }\r\n\r\n    /** @var Robot $robot */\r\n    protected $robot = null;\r\n\r\n    public function setUp(): void\r\n    {\r\n        $this->robot = new Robot();\r\n    }\r\n\r\n    public function testHasName(): void\r\n    {\r\n        $this->assertMatchesRegularExpression('/^[a-z]{2}\\d{3}$/i', $this->robot->getName());\r\n    }\r\n\r\n    public function testNameSticks(): void\r\n    {\r\n        $old = $this->robot->getName();\r\n\r\n        $this->assertSame($this->robot->getName(), $old);\r\n    }\r\n\r\n    public function testDifferentRobotsHaveDifferentNames(): void\r\n    {\r\n        $other_bot = new Robot();\r\n\r\n        $this->assertNotSame($other_bot->getName(), $this->robot->getName());\r\n\r\n        unset($other_bot);\r\n    }\r\n\r\n    public function testResetName(): void\r\n    {\r\n        $name1 = $this->robot->getName();\r\n\r\n        $this->robot->reset();\r\n\r\n        $name2 = $this->robot->getName();\r\n\r\n        $this->assertNotSame($name1, $name2);\r\n\r\n        $this->assertMatchesRegularExpression('/\\w{2}\\d{3}/', $name2);\r\n    }\r\n\r\n    public function testNamesArentRecycled(): void\r\n    {\r\n        $names = [];\r\n\r\n        for ($i = 0; $i < 10000; $i++) {\r\n            $name = $this->robot->getName();\r\n            $this->assertArrayNotHasKey($name, $names, sprintf('Name %s reissued after Reset.', $name));\r\n            $names[$name] = true;\r\n            $this->robot->reset();\r\n        }\r\n    }\r\n\r\n    // This test is optional.\r\n    public function testNameUniquenessManyRobots(): void\r\n    {\r\n        $names = [];\r\n\r\n        for ($i = 0; $i < 10000; $i++) {\r\n            $name = (new Robot())->getName();\r\n            $this->assertArrayNotHasKey($name, $names, sprintf('Name %s reissued after %d robots', $name, $i));\r\n            $names[$name] = true;\r\n        }\r\n    }\r\n}\r\n"
  }
}