{
  "language": "php",
  "slug": "series",
  "docs": {
    "instructions": "# Instructions\r\n\r\nGiven a string of digits, output all the contiguous substrings of length `n` in\r\nthat string in the order that they appear.\r\n\r\nFor example, the string \"49142\" has the following 3-digit series:\r\n\r\n- \"491\"\r\n- \"914\"\r\n- \"142\"\r\n\r\nAnd the following 4-digit series:\r\n\r\n- \"4914\"\r\n- \"9142\"\r\n\r\nAnd if you ask for a 6-digit series from a 5-digit string, you deserve\r\nwhatever you get.\r\n\r\nNote that these series are only required to occupy *adjacent positions*\r\nin the input; the digits need not be *numerically consecutive*.\r\n",
    "instructions_append": "",
    "hints": ""
  },
  "starter_code": {
    "Series.php": "<?php\r\n\r\n/*\r\n * By adding type hints and enabling strict type checking, code can become\r\n * easier to read, self-documenting and reduce the number of potential bugs.\r\n * By default, type declarations are non-strict, which means they will attempt\r\n * to change the original type to match the type specified by the\r\n * type-declaration.\r\n *\r\n * In other words, if you pass a string to a function requiring a float,\r\n * it will attempt to convert the string value to a float.\r\n *\r\n * To enable strict mode, a single declare directive must be placed at the top\r\n * of the file.\r\n * This means that the strictness of typing is configured on a per-file basis.\r\n * This directive not only affects the type declarations of parameters, but also\r\n * a function's return type.\r\n *\r\n * For more info review the Concept on strict type checking in the PHP track\r\n * <link>.\r\n *\r\n * To disable strict typing, comment out the directive below.\r\n */\r\n\r\ndeclare(strict_types=1);\r\n\r\nfunction slices(string $digits, int $series): array\r\n{\r\n    throw new \\BadFunctionCallException(\"Implement the slices function\");\r\n}\r\n"
  },
  "tests": {
    "SeriesTest.php": "<?php\r\n\r\n/*\r\n * By adding type hints and enabling strict type checking, code can become\r\n * easier to read, self-documenting and reduce the number of potential bugs.\r\n * By default, type declarations are non-strict, which means they will attempt\r\n * to change the original type to match the type specified by the\r\n * type-declaration.\r\n *\r\n * In other words, if you pass a string to a function requiring a float,\r\n * it will attempt to convert the string value to a float.\r\n *\r\n * To enable strict mode, a single declare directive must be placed at the top\r\n * of the file.\r\n * This means that the strictness of typing is configured on a per-file basis.\r\n * This directive not only affects the type declarations of parameters, but also\r\n * a function's return type.\r\n *\r\n * For more info review the Concept on strict type checking in the PHP track\r\n * <link>.\r\n *\r\n * To disable strict typing, comment out the directive below.\r\n */\r\n\r\ndeclare(strict_types=1);\r\n\r\nuse PHPUnit\\Framework\\TestCase;\r\n\r\nclass SeriesTest extends TestCase\r\n{\r\n    public static function setUpBeforeClass(): void\r\n    {\r\n        require_once 'Series.php';\r\n    }\r\n\r\n    public function testSlicesOfOne(): void\r\n    {\r\n        $this->assertEquals(\r\n            [\"0\", \"1\", \"2\", \"3\", \"4\"],\r\n            slices(\"01234\", 1)\r\n        );\r\n    }\r\n\r\n    public function testSlicesOfTwo(): void\r\n    {\r\n        $this->assertEquals(\r\n            [\"97\", \"78\", \"86\", \"67\", \"75\", \"56\", \"64\"],\r\n            slices(\"97867564\", 2)\r\n        );\r\n    }\r\n\r\n    public function testSlicesOfThree(): void\r\n    {\r\n        $this->assertEquals(\r\n            [\"978\", \"786\", \"867\", \"675\", \"756\", \"564\"],\r\n            slices(\"97867564\", 3)\r\n        );\r\n    }\r\n\r\n    public function testSlicesOfFour(): void\r\n    {\r\n        $this->assertEquals(\r\n            [\"0123\", \"1234\"],\r\n            slices(\"01234\", 4)\r\n        );\r\n    }\r\n\r\n    public function testSlicesOfFive(): void\r\n    {\r\n        $this->assertEquals(\r\n            [\"01234\"],\r\n            slices(\"01234\", 5)\r\n        );\r\n    }\r\n\r\n    public function testOverlyLongSlice(): void\r\n    {\r\n        $this->expectException(Exception::class);\r\n        slices(\"012\", 4);\r\n    }\r\n\r\n    public function testOverlyShortSlice(): void\r\n    {\r\n        $this->expectException(Exception::class);\r\n        slices(\"01234\", 0);\r\n    }\r\n}\r\n"
  }
}