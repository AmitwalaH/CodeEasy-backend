{
  "language": "php",
  "slug": "accumulate",
  "docs": {
    "instructions": "# Instructions\r\n\r\nImplement the `accumulate` operation, which, given a collection and an\r\noperation to perform on each element of the collection, returns a new\r\ncollection containing the result of applying that operation to each element of\r\nthe input collection.\r\n\r\nGiven the collection of numbers:\r\n\r\n- 1, 2, 3, 4, 5\r\n\r\nAnd the operation:\r\n\r\n- square a number (`x => x * x`)\r\n\r\nYour code should be able to produce the collection of squares:\r\n\r\n- 1, 4, 9, 16, 25\r\n\r\nCheck out the test suite to see the expected function signature.\r\n\r\n## Restrictions\r\n\r\nKeep your hands off that collect/map/fmap/whatchamacallit functionality\r\nprovided by your standard library!\r\nSolve this one yourself using other basic tools instead.\r\n",
    "instructions_append": "",
    "hints": ""
  },
  "starter_code": {
    "Accumulate.php": "<?php\r\n\r\n/*\r\n * By adding type hints and enabling strict type checking, code can become\r\n * easier to read, self-documenting and reduce the number of potential bugs.\r\n * By default, type declarations are non-strict, which means they will attempt\r\n * to change the original type to match the type specified by the\r\n * type-declaration.\r\n *\r\n * In other words, if you pass a string to a function requiring a float,\r\n * it will attempt to convert the string value to a float.\r\n *\r\n * To enable strict mode, a single declare directive must be placed at the top\r\n * of the file.\r\n * This means that the strictness of typing is configured on a per-file basis.\r\n * This directive not only affects the type declarations of parameters, but also\r\n * a function's return type.\r\n *\r\n * For more info review the Concept on strict type checking in the PHP track\r\n * <link>.\r\n *\r\n * To disable strict typing, comment out the directive below.\r\n */\r\n\r\ndeclare(strict_types=1);\r\n\r\nfunction accumulate(array $input, callable $accumulator): array\r\n{\r\n    throw new \\BadFunctionCallException(\"Implement the accumulate function\");\r\n}\r\n"
  },
  "tests": {
    "AccumulateTest.php": "<?php\r\n\r\n/*\r\n * By adding type hints and enabling strict type checking, code can become\r\n * easier to read, self-documenting and reduce the number of potential bugs.\r\n * By default, type declarations are non-strict, which means they will attempt\r\n * to change the original type to match the type specified by the\r\n * type-declaration.\r\n *\r\n * In other words, if you pass a string to a function requiring a float,\r\n * it will attempt to convert the string value to a float.\r\n *\r\n * To enable strict mode, a single declare directive must be placed at the top\r\n * of the file.\r\n * This means that the strictness of typing is configured on a per-file basis.\r\n * This directive not only affects the type declarations of parameters, but also\r\n * a function's return type.\r\n *\r\n * For more info review the Concept on strict type checking in the PHP track\r\n * <link>.\r\n *\r\n * To disable strict typing, comment out the directive below.\r\n */\r\n\r\ndeclare(strict_types=1);\r\n\r\nuse PHPUnit\\Framework\\TestCase;\r\n\r\nclass AccumulateTest extends TestCase\r\n{\r\n    public static function setUpBeforeClass(): void\r\n    {\r\n        require_once 'Accumulate.php';\r\n    }\r\n\r\n    public function testAccumulateEmpty(): void\r\n    {\r\n        $accumulator = function ($value) {\r\n            return $value ** 2;\r\n        };\r\n\r\n        $this->assertEquals([], accumulate([], $accumulator));\r\n    }\r\n\r\n    public function testAccumulateSquares(): void\r\n    {\r\n        $accumulator = function ($value) {\r\n            return $value ** 2;\r\n        };\r\n\r\n        $this->assertEquals([1, 4, 9], accumulate([1, 2, 3], $accumulator));\r\n    }\r\n\r\n    public function testAccumulateUpperCases(): void\r\n    {\r\n        $accumulator = function ($string) {\r\n            return mb_strtoupper($string);\r\n        };\r\n\r\n        $this->assertEquals(['HELLO', 'WORLD!'], accumulate(['Hello', 'World!'], $accumulator));\r\n    }\r\n\r\n    public function testAccumulateReversedStrings(): void\r\n    {\r\n        $accumulator = function ($string) {\r\n            return strrev($string);\r\n        };\r\n\r\n        $this->assertEquals(['Hello', 'World!'], accumulate(['olleH', '!dlroW'], $accumulator));\r\n    }\r\n\r\n    public function testAccumulateConstants(): void\r\n    {\r\n        $accumulator = function () {\r\n            return 1;\r\n        };\r\n\r\n        $this->assertEquals([1, 1], accumulate(['Hello', 'World!'], $accumulator));\r\n    }\r\n\r\n    public function testAccumulateWithinAccumulate(): void\r\n    {\r\n        $chars = ['a', 'b', 'c'];\r\n        $digits = [1, 2, 3];\r\n        $expected = [['a1', 'a2', 'a3'], ['b1', 'b2', 'b3'], ['c1', 'c2', 'c3']];\r\n\r\n        $this->assertEquals(\r\n            $expected,\r\n            accumulate($chars, function ($char) use ($digits) {\r\n                return accumulate($digits, function ($digit) use ($char) {\r\n                    return $char . $digit;\r\n                });\r\n            })\r\n        );\r\n    }\r\n\r\n    // Additional points for making the following tests pass\r\n\r\n    public function testAccumulateUsingBuiltInFunction(): void\r\n    {\r\n        $this->assertEquals(['Hello', 'World!'], accumulate([\" Hello\\t\", \"\\t World!\\n \"], 'trim'));\r\n    }\r\n\r\n    public function testAccumulateUsingStaticMethod(): void\r\n    {\r\n        $this->assertEquals([5, 6], accumulate(['Hello', 'World!'], 'Str::len'));\r\n    }\r\n\r\n    public function testAccumulateUsingInvoke(): void\r\n    {\r\n        $this->assertEquals([['f', 'o', 'o']], accumulate(['foo'], new StrSpliter()));\r\n    }\r\n\r\n    public function testAccumulateUsingObjectAndArrayNotation(): void\r\n    {\r\n        $this->assertEquals([true, false, false], accumulate(['Yes', 0, []], [new Is(), 'truthy']));\r\n    }\r\n}\r\n\r\nclass Str\r\n{\r\n    public static function len($string): int\r\n    {\r\n        return strlen($string);\r\n    }\r\n}\r\n\r\nclass StrSpliter\r\n{\r\n    public function __invoke($value)\r\n    {\r\n        return str_split($value);\r\n    }\r\n}\r\n\r\nclass Is\r\n{\r\n    public function truthy($value): bool\r\n    {\r\n        return boolval($value);\r\n    }\r\n}\r\n"
  }
}