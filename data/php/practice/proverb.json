{
  "language": "php",
  "slug": "proverb",
  "docs": {
    "instructions": "# Instructions\r\n\r\nFor want of a horseshoe nail, a kingdom was lost, or so the saying goes.\r\n\r\nGiven a list of inputs, generate the relevant proverb. For example, given the list `[\"nail\", \"shoe\", \"horse\", \"rider\", \"message\", \"battle\", \"kingdom\"]`, you will output the full text of this proverbial rhyme:\r\n\r\n```text\r\nFor want of a nail the shoe was lost.\r\nFor want of a shoe the horse was lost.\r\nFor want of a horse the rider was lost.\r\nFor want of a rider the message was lost.\r\nFor want of a message the battle was lost.\r\nFor want of a battle the kingdom was lost.\r\nAnd all for the want of a nail.\r\n```\r\n\r\nNote that the list of inputs may vary; your solution should be able to handle lists of arbitrary length and content. **No line of the output text should be a static**, unchanging string; all should vary according to the input given.\r\n",
    "instructions_append": "",
    "hints": ""
  },
  "starter_code": {
    "Proverb.php": "<?php\r\n\r\n/*\r\n * By adding type hints and enabling strict type checking, code can become\r\n * easier to read, self-documenting and reduce the number of potential bugs.\r\n * By default, type declarations are non-strict, which means they will attempt\r\n * to change the original type to match the type specified by the\r\n * type-declaration.\r\n *\r\n * In other words, if you pass a string to a function requiring a float,\r\n * it will attempt to convert the string value to a float.\r\n *\r\n * To enable strict mode, a single declare directive must be placed at the top\r\n * of the file.\r\n * This means that the strictness of typing is configured on a per-file basis.\r\n * This directive not only affects the type declarations of parameters, but also\r\n * a function's return type.\r\n *\r\n * For more info review the Concept on strict type checking in the PHP track\r\n * <link>.\r\n *\r\n * To disable strict typing, comment out the directive below.\r\n */\r\n\r\ndeclare(strict_types=1);\r\n\r\nclass Proverb\r\n{\r\n    public function recite()\r\n    {\r\n        throw new \\BadMethodCallException(sprintf('Implement the %s method', __FUNCTION__));\r\n    }\r\n}\r\n"
  },
  "tests": {
    "ProverbTest.php": "<?php\r\n\r\n/*\r\n * By adding type hints and enabling strict type checking, code can become\r\n * easier to read, self-documenting and reduce the number of potential bugs.\r\n * By default, type declarations are non-strict, which means they will attempt\r\n * to change the original type to match the type specified by the\r\n * type-declaration.\r\n *\r\n * In other words, if you pass a string to a function requiring a float,\r\n * it will attempt to convert the string value to a float.\r\n *\r\n * To enable strict mode, a single declare directive must be placed at the top\r\n * of the file.\r\n * This means that the strictness of typing is configured on a per-file basis.\r\n * This directive not only affects the type declarations of parameters, but also\r\n * a function's return type.\r\n *\r\n * For more info review the Concept on strict type checking in the PHP track\r\n * <link>.\r\n *\r\n * To disable strict typing, comment out the directive below.\r\n */\r\n\r\ndeclare(strict_types=1);\r\n\r\nuse PHPUnit\\Framework\\TestCase;\r\n\r\nclass ProverbTest extends TestCase\r\n{\r\n    private Proverb $proverb;\r\n\r\n    public static function setUpBeforeClass(): void\r\n    {\r\n        require_once 'Proverb.php';\r\n    }\r\n\r\n    public function setUp(): void\r\n    {\r\n        $this->proverb = new Proverb();\r\n    }\r\n\r\n    public function testNoVerses(): void\r\n    {\r\n        $pieces   = [];\r\n        $expected = [];\r\n        $this->assertEquals($expected, $this->proverb->recite($pieces));\r\n    }\r\n\r\n    public function testOneVerse(): void\r\n    {\r\n        $pieces   = ['nail'];\r\n        $expected = ['And all for the want of a nail.'];\r\n        $this->assertEquals($expected, $this->proverb->recite($pieces));\r\n    }\r\n\r\n    public function testTwoVerses(): void\r\n    {\r\n        $pieces   = ['nail', 'shoe'];\r\n        $expected = ['For want of a nail the shoe was lost.', 'And all for the want of a nail.'];\r\n        $this->assertEquals($expected, $this->proverb->recite($pieces));\r\n    }\r\n\r\n    public function testThreeVerses(): void\r\n    {\r\n        $pieces   = ['nail', 'shoe', 'horse'];\r\n        $expected = [\r\n            'For want of a nail the shoe was lost.',\r\n            'For want of a shoe the horse was lost.',\r\n            'And all for the want of a nail.'\r\n        ];\r\n        $this->assertEquals($expected, $this->proverb->recite($pieces));\r\n    }\r\n\r\n    public function testFullProverb(): void\r\n    {\r\n        $pieces   = ['nail', 'shoe', 'horse', 'rider', 'message', 'battle', 'kingdom'];\r\n        $expected = [\r\n            'For want of a nail the shoe was lost.',\r\n            'For want of a shoe the horse was lost.',\r\n            'For want of a horse the rider was lost.',\r\n            'For want of a rider the message was lost.',\r\n            'For want of a message the battle was lost.',\r\n            'For want of a battle the kingdom was lost.',\r\n            'And all for the want of a nail.'\r\n        ];\r\n        $this->assertEquals($expected, $this->proverb->recite($pieces));\r\n    }\r\n\r\n    public function testFourModernizedVerses(): void\r\n    {\r\n        $pieces   = ['pin', 'gun', 'soldier', 'battle'];\r\n        $expected = [\r\n            'For want of a pin the gun was lost.',\r\n            'For want of a gun the soldier was lost.',\r\n            'For want of a soldier the battle was lost.',\r\n            'And all for the want of a pin.'\r\n        ];\r\n        $this->assertEquals($expected, $this->proverb->recite($pieces));\r\n    }\r\n}\r\n"
  }
}