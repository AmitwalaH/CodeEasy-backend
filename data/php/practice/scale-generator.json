{
  "language": "php",
  "slug": "scale-generator",
  "docs": {
    "instructions": "# Instructions\r\n\r\nGiven a tonic, or starting note, and a set of intervals, generate\r\nthe musical scale starting with the tonic and following the\r\nspecified interval pattern.\r\n\r\nScales in Western music are based on the chromatic (12-note) scale. This\r\nscale can be expressed as the following group of pitches:\r\n\r\nA, A#, B, C, C#, D, D#, E, F, F#, G, G#\r\n\r\nA given sharp note (indicated by a #) can also be expressed as the flat\r\nof the note above it (indicated by a b) so the chromatic scale can also be\r\nwritten like this:\r\n\r\nA, Bb, B, C, Db, D, Eb, E, F, Gb, G, Ab\r\n\r\nThe major and minor scale and modes are subsets of this twelve-pitch\r\ncollection. They have seven pitches, and are called diatonic scales.\r\nThe collection of notes in these scales is written with either sharps or\r\nflats, depending on the tonic. Here is a list of which are which:\r\n\r\nNo Sharps or Flats:\r\nC major\r\na minor\r\n\r\nUse Sharps:\r\nG, D, A, E, B, F# major\r\ne, b, f#, c#, g#, d# minor\r\n\r\nUse Flats:\r\nF, Bb, Eb, Ab, Db, Gb major\r\nd, g, c, f, bb, eb minor\r\n\r\nThe diatonic scales, and all other scales that derive from the\r\nchromatic scale, are built upon intervals. An interval is the space\r\nbetween two pitches.\r\n\r\nThe simplest interval is between two adjacent notes, and is called a\r\n\"half step\", or \"minor second\" (sometimes written as a lower-case \"m\").\r\nThe interval between two notes that have an interceding note is called\r\na \"whole step\" or \"major second\" (written as an upper-case \"M\"). The\r\ndiatonic scales are built using only these two intervals between\r\nadjacent notes.\r\n\r\nNon-diatonic scales can contain other intervals.  An \"augmented first\"\r\ninterval, written \"A\", has two interceding notes (e.g., from A to C or\r\nDb to E). There are also smaller and larger intervals, but they will not\r\nfigure into this exercise.\r\n",
    "instructions_append": "",
    "hints": ""
  },
  "starter_code": {
    "ScaleGenerator.php": "<?php\r\n\r\n/*\r\n * By adding type hints and enabling strict type checking, code can become\r\n * easier to read, self-documenting and reduce the number of potential bugs.\r\n * By default, type declarations are non-strict, which means they will attempt\r\n * to change the original type to match the type specified by the\r\n * type-declaration.\r\n *\r\n * In other words, if you pass a string to a function requiring a float,\r\n * it will attempt to convert the string value to a float.\r\n *\r\n * To enable strict mode, a single declare directive must be placed at the top\r\n * of the file.\r\n * This means that the strictness of typing is configured on a per-file basis.\r\n * This directive not only affects the type declarations of parameters, but also\r\n * a function's return type.\r\n *\r\n * For more info review the Concept on strict type checking in the PHP track\r\n * <link>.\r\n *\r\n * To disable strict typing, comment out the directive below.\r\n */\r\n\r\ndeclare(strict_types=1);\r\n\r\nclass Scale\r\n{\r\n    public function __construct(string $tonic, string $scaleName, string $pattern)\r\n    {\r\n        throw new \\BadFunctionCallException(\"Please implement the Scale class!\");\r\n    }\r\n}\r\n"
  },
  "tests": {
    "ScaleGeneratorTest.php": "<?php\r\n\r\n/*\r\n * By adding type hints and enabling strict type checking, code can become\r\n * easier to read, self-documenting and reduce the number of potential bugs.\r\n * By default, type declarations are non-strict, which means they will attempt\r\n * to change the original type to match the type specified by the\r\n * type-declaration.\r\n *\r\n * In other words, if you pass a string to a function requiring a float,\r\n * it will attempt to convert the string value to a float.\r\n *\r\n * To enable strict mode, a single declare directive must be placed at the top\r\n * of the file.\r\n * This means that the strictness of typing is configured on a per-file basis.\r\n * This directive not only affects the type declarations of parameters, but also\r\n * a function's return type.\r\n *\r\n * For more info review the Concept on strict type checking in the PHP track\r\n * <link>.\r\n *\r\n * To disable strict typing, comment out the directive below.\r\n */\r\n\r\ndeclare(strict_types=1);\r\n\r\nuse PHPUnit\\Framework\\TestCase;\r\n\r\nclass ScaleGeneratorTest extends TestCase\r\n{\r\n    public static function setUpBeforeClass(): void\r\n    {\r\n        require_once 'ScaleGenerator.php';\r\n    }\r\n\r\n    public function testNamingScale(): void\r\n    {\r\n        $chromatic = new Scale('c', \"chromatic\");\r\n        $expected = 'C chromatic';\r\n        $actual = $chromatic->name;\r\n        $this->assertEquals($expected, $actual);\r\n    }\r\n\r\n    public function testChromaticScale(): void\r\n    {\r\n        $chromatic = new Scale('C', \"chromatic\");\r\n        $expected = [\"C\", \"C#\", \"D\", \"D#\", \"E\", \"F\", \"F#\", \"G\", \"G#\", \"A\", \"A#\", \"B\"];\r\n        $actual = $chromatic->pitches;\r\n        $this->assertEquals($expected, $actual);\r\n    }\r\n\r\n    public function testAnotherChromaticScale(): void\r\n    {\r\n        $chromatic = new Scale(\"F\", \"chromatic\");\r\n        $expected = [\"F\", \"Gb\", \"G\", \"Ab\", \"A\", \"Bb\", \"B\", \"C\", \"Db\", \"D\", \"Eb\", \"E\"];\r\n        $actual = $chromatic->pitches;\r\n        $this->assertEquals($expected, $actual);\r\n    }\r\n\r\n    public function testNamingMajorScale(): void\r\n    {\r\n        $major = new Scale('G', \"major\", 'MMmMMMm');\r\n        $expected = 'G major';\r\n        $actual = $major->name;\r\n        $this->assertEquals($expected, $actual);\r\n    }\r\n\r\n    public function testMajorScale(): void\r\n    {\r\n        $major = new Scale('C', \"major\", 'MMmMMMm');\r\n        $expected = [\"C\", \"D\", \"E\", \"F\", \"G\", \"A\", \"B\"];\r\n        $actual = $major->pitches;\r\n        $this->assertEquals($expected, $actual);\r\n    }\r\n\r\n    public function testAnotherMajorScale(): void\r\n    {\r\n        $major = new Scale('G', \"major\", 'MMmMMMm');\r\n        $expected = [\"G\", \"A\", \"B\", \"C\", \"D\", \"E\", \"F#\"];\r\n        $actual = $major->pitches;\r\n        $this->assertEquals($expected, $actual);\r\n    }\r\n\r\n    public function testMinorScale(): void\r\n    {\r\n        $minor = new Scale('f#', \"minor\", 'MmMMmMM');\r\n        $expected = [\"F#\", \"G#\", \"A\", \"B\", \"C#\", \"D\", \"E\"];\r\n        $actual = $minor->pitches;\r\n        $this->assertEquals($expected, $actual);\r\n    }\r\n\r\n    public function testAnotherMinorScale(): void\r\n    {\r\n        $minor = new Scale('bb', \"minor\", 'MmMMmMM');\r\n        $expected = [\"Bb\", \"C\", \"Db\", \"Eb\", \"F\", \"Gb\", \"Ab\"];\r\n        $actual = $minor->pitches;\r\n        $this->assertEquals($expected, $actual);\r\n    }\r\n\r\n    public function testDorianMode(): void\r\n    {\r\n        $dorian = new Scale('d', \"dorian\", 'MmMMMmM');\r\n        $expected = [\"D\", \"E\", \"F\", \"G\", \"A\", \"B\", \"C\"];\r\n        $actual = $dorian->pitches;\r\n        $this->assertEquals($expected, $actual);\r\n    }\r\n\r\n    public function testMixolydianMode(): void\r\n    {\r\n        $mixolydian = new Scale('Eb', \"mixolydian\", 'MMmMMmM');\r\n        $expected = [\"Eb\", \"F\", \"G\", \"Ab\", \"Bb\", \"C\", \"Db\"];\r\n        $actual = $mixolydian->pitches;\r\n        $this->assertEquals($expected, $actual);\r\n    }\r\n\r\n    public function testLydianMode(): void\r\n    {\r\n        $lydian = new Scale('a', \"lydian\", 'MMMmMMm');\r\n        $expected = [\"A\", \"B\", \"C#\", \"D#\", \"E\", \"F#\", \"G#\"];\r\n        $actual = $lydian->pitches;\r\n        $this->assertEquals($expected, $actual);\r\n    }\r\n\r\n    public function testPhrygianMode(): void\r\n    {\r\n        $phrygian = new Scale('e', \"phrygian\", 'mMMMmMM');\r\n        $expected = [\"E\", \"F\", \"G\", \"A\", \"B\", \"C\", \"D\"];\r\n        $actual = $phrygian->pitches;\r\n        $this->assertEquals($expected, $actual);\r\n    }\r\n\r\n    public function testLocrianMode(): void\r\n    {\r\n        $locrian = new Scale('g', \"locrian\", 'mMMmMMM');\r\n        $expected = [\"G\", \"Ab\", \"Bb\", \"C\", \"Db\", \"Eb\", \"F\"];\r\n        $actual = $locrian->pitches;\r\n        $this->assertEquals($expected, $actual);\r\n    }\r\n\r\n    public function testHarmonicMinor(): void\r\n    {\r\n        $harmonicMinor = new Scale('d', \"harmonic_minor\", 'MmMMmAm');\r\n        $expected = [\"D\", \"E\", \"F\", \"G\", \"A\", \"Bb\", \"Db\"];\r\n        $actual = $harmonicMinor->pitches;\r\n        $this->assertEquals($expected, $actual);\r\n    }\r\n\r\n    public function testOctatonic(): void\r\n    {\r\n        $octatonic = new Scale('C', \"octatonic\", 'MmMmMmMm');\r\n        $expected = [\"C\", \"D\", \"D#\", \"F\", \"F#\", \"G#\", \"A\", \"B\"];\r\n        $actual = $octatonic->pitches;\r\n        $this->assertEquals($expected, $actual);\r\n    }\r\n\r\n    public function testHexatonic(): void\r\n    {\r\n        $hexatonic = new Scale('Db', \"hexatonic\", 'MMMMMM');\r\n        $expected = [\"Db\", \"Eb\", \"F\", \"G\", \"A\", \"B\"];\r\n        $actual = $hexatonic->pitches;\r\n        $this->assertEquals($expected, $actual);\r\n    }\r\n\r\n    public function testPentatonic(): void\r\n    {\r\n        $pentatonic = new Scale('A', \"pentatonic\", 'MMAMA');\r\n        $expected = [\"A\", \"B\", \"C#\", \"E\", \"F#\"];\r\n        $actual = $pentatonic->pitches;\r\n        $this->assertEquals($expected, $actual);\r\n    }\r\n\r\n    public function testEnigmatic(): void\r\n    {\r\n        $enigmatic = new Scale('G', \"enigma\", 'mAMMMmM');\r\n        $expected = [\"G\", \"G#\", \"B\", \"C#\", \"D#\", \"F\", \"F#\"];\r\n        $actual = $enigmatic->pitches;\r\n        $this->assertEquals($expected, $actual);\r\n    }\r\n}\r\n"
  }
}