{
  "language": "php",
  "slug": "simple-cipher",
  "docs": {
    "instructions": "# Description\r\n\r\nCreate an implementation of the [Vigenère cipher][wiki].\r\nThe Vigenère cipher is a simple substitution cipher.\r\n\r\n## Cipher terminology\r\n\r\nA cipher is an algorithm used to encrypt, or encode, a string.\r\nThe unencrypted string is called the _plaintext_ and the encrypted string is called the _ciphertext_.\r\nConverting plaintext to ciphertext is called _encoding_ while the reverse is called _decoding_.\r\n\r\nIn a _substitution cipher_, each plaintext letter is replaced with a ciphertext letter which is computed with the help of a _key_.\r\n(Note, it is possible for replacement letter to be the same as the original letter.)\r\n\r\n## Encoding details\r\n\r\nIn this cipher, the key is a series of lowercase letters, such as `\"abcd\"`.\r\nEach letter of the plaintext is _shifted_ or _rotated_ by a distance based on a corresponding letter in the key.\r\nAn `\"a\"` in the key means a shift of 0 (that is, no shift).\r\nA `\"b\"` in the key means a shift of 1.\r\nA `\"c\"` in the key means a shift of 2, and so on.\r\n\r\nThe first letter of the plaintext uses the first letter of the key, the second letter of the plaintext uses the second letter of the key and so on.\r\nIf you run out of letters in the key before you run out of letters in the plaintext, start over from the start of the key again.\r\n\r\nIf the key only contains one letter, such as `\"dddddd\"`, then all letters of the plaintext are shifted by the same amount (three in this example), which would make this the same as a rotational cipher or shift cipher (sometimes called a Caesar cipher).\r\nFor example, the plaintext `\"iamapandabear\"` would become `\"ldpdsdqgdehdu\"`.\r\n\r\nIf the key only contains the letter `\"a\"` (one or more times), the shift distance is zero and the ciphertext is the same as the plaintext.\r\n\r\nUsually the key is more complicated than that, though!\r\nIf the key is `\"abcd\"` then letters of the plaintext would be shifted by a distance of 0, 1, 2, and 3.\r\nIf the plaintext is `\"hello\"`, we need 5 shifts so the key would wrap around, giving shift distances of 0, 1, 2, 3, and 0.\r\nApplying those shifts to the letters of `\"hello\"` we get `\"hfnoo\"`.\r\n\r\n## Random keys\r\n\r\nIf no key is provided, generate a key which consists of at least 100 random lowercase letters from the Latin alphabet.\r\n\r\n[wiki]: https://en.wikipedia.org/wiki/Vigen%C3%A8re_cipher\r\n",
    "instructions_append": "",
    "hints": ""
  },
  "starter_code": {
    "SimpleCipher.php": "<?php\r\n\r\n/*\r\n * By adding type hints and enabling strict type checking, code can become\r\n * easier to read, self-documenting and reduce the number of potential bugs.\r\n * By default, type declarations are non-strict, which means they will attempt\r\n * to change the original type to match the type specified by the\r\n * type-declaration.\r\n *\r\n * In other words, if you pass a string to a function requiring a float,\r\n * it will attempt to convert the string value to a float.\r\n *\r\n * To enable strict mode, a single declare directive must be placed at the top\r\n * of the file.\r\n * This means that the strictness of typing is configured on a per-file basis.\r\n * This directive not only affects the type declarations of parameters, but also\r\n * a function's return type.\r\n *\r\n * For more info review the Concept on strict type checking in the PHP track\r\n * <link>.\r\n *\r\n * To disable strict typing, comment out the directive below.\r\n */\r\n\r\ndeclare(strict_types=1);\r\n\r\nclass SimpleCipher\r\n{\r\n    public function __construct(string $key = null)\r\n    {\r\n        throw new \\BadFunctionCallException(\"Please implement the SimpleCipher class!\");\r\n    }\r\n\r\n    public function encode(string $plainText): string\r\n    {\r\n    }\r\n\r\n    public function decode(string $cipherText): string\r\n    {\r\n    }\r\n}\r\n"
  },
  "tests": {
    "SimpleCipherTest.php": "<?php\r\n\r\n/*\r\n * By adding type hints and enabling strict type checking, code can become\r\n * easier to read, self-documenting and reduce the number of potential bugs.\r\n * By default, type declarations are non-strict, which means they will attempt\r\n * to change the original type to match the type specified by the\r\n * type-declaration.\r\n *\r\n * In other words, if you pass a string to a function requiring a float,\r\n * it will attempt to convert the string value to a float.\r\n *\r\n * To enable strict mode, a single declare directive must be placed at the top\r\n * of the file.\r\n * This means that the strictness of typing is configured on a per-file basis.\r\n * This directive not only affects the type declarations of parameters, but also\r\n * a function's return type.\r\n *\r\n * For more info review the Concept on strict type checking in the PHP track\r\n * <link>.\r\n *\r\n * To disable strict typing, comment out the directive below.\r\n */\r\n\r\ndeclare(strict_types=1);\r\n\r\nuse PHPUnit\\Framework\\TestCase;\r\n\r\nclass SimpleCipherTest extends TestCase\r\n{\r\n    public static function setUpBeforeClass(): void\r\n    {\r\n        require_once 'SimpleCipher.php';\r\n    }\r\n\r\n    public function testRandomCipherKeyIsLetters(): void\r\n    {\r\n        $cipher = new SimpleCipher();\r\n        $this->assertMatchesRegularExpression('/\\A[a-z]+\\z/', $cipher->key);\r\n    }\r\n\r\n    /**\r\n     * Here we take advantage of the fact that plaintext of \"aaa...\" doesn't\r\n     * output the key. This is a critical problem with shift ciphers, some\r\n     * characters will always output the key verbatim.\r\n     */\r\n    public function testRandomKeyCipherEncode(): void\r\n    {\r\n        $cipher = new SimpleCipher();\r\n        $plaintext = 'aaaaaaaaaa';\r\n        $this->assertEquals(substr($cipher->key, 0, 10), $cipher->encode($plaintext));\r\n    }\r\n\r\n    public function testRandomKeyCipherDecode(): void\r\n    {\r\n        $cipher = new SimpleCipher();\r\n        $plaintext = 'aaaaaaaaaa';\r\n        $this->assertEquals($plaintext, $cipher->decode(substr($cipher->key, 0, 10)));\r\n    }\r\n\r\n    public function testRandomKeyCipherReversible(): void\r\n    {\r\n        $cipher = new SimpleCipher();\r\n        $plaintext = 'abcdefghij';\r\n        $this->assertEquals($plaintext, $cipher->decode($cipher->encode($plaintext)));\r\n    }\r\n\r\n    public function testCipherWithCapsKey(): void\r\n    {\r\n        $this->expectException(InvalidArgumentException::class);\r\n        $cipher = new SimpleCipher('ABCDEF');\r\n    }\r\n\r\n    public function testCipherWithNumericKey(): void\r\n    {\r\n        $this->expectException(InvalidArgumentException::class);\r\n        $cipher = new SimpleCipher('12345');\r\n    }\r\n\r\n    public function testCipherWithEmptyKey(): void\r\n    {\r\n        $this->expectException(InvalidArgumentException::class);\r\n        $cipher = new SimpleCipher('');\r\n    }\r\n\r\n    public function testCipherKeyIsAsSubmitted(): void\r\n    {\r\n        $cipher = new SimpleCipher('abcdefghij');\r\n        $this->assertEquals($cipher->key, 'abcdefghij');\r\n    }\r\n\r\n    public function testCipherEncode(): void\r\n    {\r\n        $cipher = new SimpleCipher('abcdefghij');\r\n        $plaintext = 'aaaaaaaaaa';\r\n        $ciphertext = 'abcdefghij';\r\n        $this->assertEquals($ciphertext, $cipher->encode($plaintext));\r\n    }\r\n\r\n    public function testCipherDecode(): void\r\n    {\r\n        $cipher = new SimpleCipher('abcdefghij');\r\n        $plaintext = 'aaaaaaaaaa';\r\n        $ciphertext = 'abcdefghij';\r\n        $this->assertEquals($plaintext, $cipher->decode($ciphertext));\r\n    }\r\n\r\n    public function testCipherReversible(): void\r\n    {\r\n        $cipher = new SimpleCipher('abcdefghij');\r\n        $plaintext = 'abcdefghij';\r\n        $this->assertEquals($plaintext, $cipher->decode($cipher->encode($plaintext)));\r\n    }\r\n\r\n    public function testDoubleShiftEncode(): void\r\n    {\r\n        $cipher = new SimpleCipher('iamapandabear');\r\n        $plaintext = 'iamapandabear';\r\n        $ciphertext = 'qayaeaagaciai';\r\n        $this->assertEquals($ciphertext, $cipher->encode($plaintext));\r\n    }\r\n\r\n    public function testCipherEncodeWrap(): void\r\n    {\r\n        $cipher = new SimpleCipher('abcdefghij');\r\n        $plaintext = 'zzzzzzzzzz';\r\n        $ciphertext = 'zabcdefghi';\r\n        $this->assertEquals($ciphertext, $cipher->encode($plaintext));\r\n    }\r\n\r\n    public function testShiftCipherEncode(): void\r\n    {\r\n        $cipher = new SimpleCipher('dddddddddd');\r\n        $plaintext = 'aaaaaaaaaa';\r\n        $ciphertext = 'dddddddddd';\r\n        $this->assertEquals($ciphertext, $cipher->encode($plaintext));\r\n    }\r\n\r\n    public function testShiftCipherDecode(): void\r\n    {\r\n        $cipher = new SimpleCipher('dddddddddd');\r\n        $plaintext = 'aaaaaaaaaa';\r\n        $ciphertext = 'dddddddddd';\r\n        $this->assertEquals($plaintext, $cipher->decode($ciphertext));\r\n    }\r\n\r\n    public function testShiftCipherReversible(): void\r\n    {\r\n        $cipher = new SimpleCipher('dddddddddd');\r\n        $plaintext = 'abcdefghij';\r\n        $this->assertEquals($plaintext, $cipher->decode($cipher->encode($plaintext)));\r\n    }\r\n}\r\n"
  }
}