{
  "language": "php",
  "slug": "markdown",
  "docs": {
    "instructions": "# Instructions\r\n\r\nRefactor a Markdown parser.\r\n\r\nThe markdown exercise is a refactoring exercise. There is code that parses a\r\ngiven string with [Markdown\r\nsyntax](https://guides.github.com/features/mastering-markdown/) and returns the\r\nassociated HTML for that string. Even though this code is confusingly written\r\nand hard to follow, somehow it works and all the tests are passing! Your\r\nchallenge is to re-write this code to make it easier to read and maintain\r\nwhile still making sure that all the tests keep passing.\r\n\r\nIt would be helpful if you made notes of what you did in your refactoring in\r\ncomments so reviewers can see that, but it isn't strictly necessary. The most\r\nimportant thing is to make the code better!\r\n",
    "instructions_append": "",
    "hints": ""
  },
  "starter_code": {
    "Markdown.php": "<?php\r\n\r\n/*\r\n * By adding type hints and enabling strict type checking, code can become\r\n * easier to read, self-documenting and reduce the number of potential bugs.\r\n * By default, type declarations are non-strict, which means they will attempt\r\n * to change the original type to match the type specified by the\r\n * type-declaration.\r\n *\r\n * In other words, if you pass a string to a function requiring a float,\r\n * it will attempt to convert the string value to a float.\r\n *\r\n * To enable strict mode, a single declare directive must be placed at the top\r\n * of the file.\r\n * This means that the strictness of typing is configured on a per-file basis.\r\n * This directive not only affects the type declarations of parameters, but also\r\n * a function's return type.\r\n *\r\n * For more info review the Concept on strict type checking in the PHP track\r\n * <link>.\r\n *\r\n * To disable strict typing, comment out the directive below.\r\n */\r\n\r\ndeclare(strict_types=1);\r\n\r\nfunction parseMarkdown($markdown)\r\n{\r\n    $lines = explode(\"\\n\", $markdown);\r\n\r\n    $isInList = false;\r\n\r\n    foreach ($lines as &$line) {\r\n        if (preg_match('/^######(.*)/', $line, $matches)) {\r\n            $line = \"<h6>\" . trim($matches[1]) . \"</h6>\";\r\n        } elseif (preg_match('/^##(.*)/', $line, $matches)) {\r\n            $line = \"<h2>\" . trim($matches[1]) . \"</h2>\";\r\n        } elseif (preg_match('/^#(.*)/', $line, $matches)) {\r\n            $line = \"<h1>\" . trim($matches[1]) . \"</h1>\";\r\n        }\r\n\r\n        if (preg_match('/\\*(.*)/', $line, $matches)) {\r\n            if (!$isInList) {\r\n                $isInList = true;\r\n                $isBold = false;\r\n                $isItalic = false;\r\n                if (preg_match('/(.*)__(.*)__(.*)/', $matches[1], $matches2)) {\r\n                    $matches[1] = $matches2[1] . '<em>' . $matches2[2] . '</em>' . $matches2[3];\r\n                    $isBold = true;\r\n                }\r\n\r\n                if (preg_match('/(.*)_(.*)_(.*)/', $matches[1], $matches3)) {\r\n                    $matches[1] = $matches3[1] . '<i>' . $matches3[2] . '</i>' . $matches3[3];\r\n                    $isItalic = true;\r\n                }\r\n\r\n                if ($isItalic || $isBold) {\r\n                    $line = \"<ul><li>\" . trim($matches[1]) . \"</li>\";\r\n                } else {\r\n                    $line = \"<ul><li><p>\" . trim($matches[1]) . \"</p></li>\";\r\n                }\r\n            } else {\r\n                $isBold = false;\r\n                $isItalic = false;\r\n                if (preg_match('/(.*)__(.*)__(.*)/', $matches[1], $matches2)) {\r\n                    $matches[1] = $matches2[1] . '<em>' . $matches2[2] . '</em>' . $matches2[3];\r\n                    $isBold = true;\r\n                }\r\n\r\n                if (preg_match('/(.*)_(.*)_(.*)/', $matches[1], $matches3)) {\r\n                    $matches[1] = $matches3[1] . '<i>' . $matches3[2] . '</i>' . $matches3[3];\r\n                    $isItalic = true;\r\n                }\r\n\r\n                if ($isItalic || $isBold) {\r\n                    $line = \"<li>\" . trim($matches[1]) . \"</li>\";\r\n                } else {\r\n                    $line = \"<li><p>\" . trim($matches[1]) . \"</p></li>\";\r\n                }\r\n            }\r\n        } else {\r\n            if ($isInList) {\r\n                $line = \"</ul>\" . $line;\r\n                $isInList = false;\r\n            }\r\n        }\r\n\r\n        if (!preg_match('/<h|<ul|<p|<li/', $line)) {\r\n            $line = \"<p>$line</p>\";\r\n        }\r\n\r\n        if (preg_match('/(.*)__(.*)__(.*)/', $line, $matches)) {\r\n            $line = $matches[1] . '<em>' . $matches[2] . '</em>' . $matches[3];\r\n        }\r\n\r\n        if (preg_match('/(.*)_(.*)_(.*)/', $line, $matches)) {\r\n            $line = $matches[1] . '<i>' . $matches[2] . '</i>' . $matches[3];\r\n        }\r\n    }\r\n    $html = join($lines);\r\n    if ($isInList) {\r\n        $html .= '</ul>';\r\n    }\r\n    return $html;\r\n}\r\n"
  },
  "tests": {
    "MarkdownTest.php": "<?php\r\n\r\n/*\r\n * By adding type hints and enabling strict type checking, code can become\r\n * easier to read, self-documenting and reduce the number of potential bugs.\r\n * By default, type declarations are non-strict, which means they will attempt\r\n * to change the original type to match the type specified by the\r\n * type-declaration.\r\n *\r\n * In other words, if you pass a string to a function requiring a float,\r\n * it will attempt to convert the string value to a float.\r\n *\r\n * To enable strict mode, a single declare directive must be placed at the top\r\n * of the file.\r\n * This means that the strictness of typing is configured on a per-file basis.\r\n * This directive not only affects the type declarations of parameters, but also\r\n * a function's return type.\r\n *\r\n * For more info review the Concept on strict type checking in the PHP track\r\n * <link>.\r\n *\r\n * To disable strict typing, comment out the directive below.\r\n */\r\n\r\ndeclare(strict_types=1);\r\n\r\nuse PHPUnit\\Framework\\TestCase;\r\n\r\nclass MarkdownTest extends TestCase\r\n{\r\n    public static function setUpBeforeClass(): void\r\n    {\r\n        require_once 'Markdown.php';\r\n    }\r\n\r\n    public function testParsingParagraph(): void\r\n    {\r\n        $this->assertEquals('<p>This will be a paragraph</p>', parseMarkdown('This will be a paragraph'));\r\n    }\r\n\r\n    public function testParsingItalics(): void\r\n    {\r\n        $this->assertEquals('<p><i>This will be italic</i></p>', parseMarkdown('_This will be italic_'));\r\n    }\r\n\r\n    public function testParsingBoldText(): void\r\n    {\r\n        $this->assertEquals('<p><em>This will be bold</em></p>', parseMarkdown('__This will be bold__'));\r\n    }\r\n\r\n    public function testMixedNormalItalicsAndBoldText(): void\r\n    {\r\n        $this->assertEquals('<p>This will <i>be</i> <em>mixed</em></p>', parseMarkdown('This will _be_ __mixed__'));\r\n    }\r\n\r\n    public function testWithH1Headerlevel(): void\r\n    {\r\n        $this->assertEquals('<h1>This will be an h1</h1>', parseMarkdown('# This will be an h1'));\r\n    }\r\n\r\n    public function testWithH2Headerlevel(): void\r\n    {\r\n        $this->assertEquals('<h2>This will be an h2</h2>', parseMarkdown('## This will be an h2'));\r\n    }\r\n\r\n    public function testWithH6Headerlevel(): void\r\n    {\r\n        $this->assertEquals('<h6>This will be an h6</h6>', parseMarkdown('###### This will be an h6'));\r\n    }\r\n\r\n    public function testUnorderedLists(): void\r\n    {\r\n        $this->assertEquals(\r\n            '<ul><li><p>Item 1</p></li><li><p>Item 2</p></li></ul>',\r\n            parseMarkdown(\"* Item 1\\n* Item 2\")\r\n        );\r\n    }\r\n\r\n    public function testWithALittleBitOfEverything(): void\r\n    {\r\n        $this->assertEquals(\r\n            '<h1>Header!</h1><ul><li><em>Bold Item</em></li><li><i>Italic Item</i></li></ul>',\r\n            parseMarkdown(\"# Header!\\n* __Bold Item__\\n* _Italic Item_\")\r\n        );\r\n    }\r\n}\r\n"
  }
}