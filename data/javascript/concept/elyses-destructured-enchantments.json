{
  "language": "javascript",
  "slug": "elyses-destructured-enchantments",
  "title": "Elyses Destructured Enchantments",
  "docs": {
    "introduction": "# Introduction\n\n## Array destructuring\n\nJavaScript's array destructuring syntax is a concise way to extract values from an array and assign them to distinct variables.\n\nIn this example, each value in the `numberOfMoons` array is assigned to its corresponding planet:\n\n```javascript\nconst numberOfMoons = [0, 2, 14];\nconst [venus, mars, neptune] = numberOfMoons;\n\nneptune;\n// => 14\n```\n\nIn short:\n\n- The syntax allows for naming _positioned_ elements in an array, as well as swapping variables using re-assignment.\n- Destructuring syntax is available inside function parameters, and is available on any iterable.\n- Leaving a position unnamed (by not writing _any_ variable name) silently ignores that position.\n\n## Object destructuring\n\nIn JavaScript, there is also destructuring syntax to extract properties from an object and assign them to distinct variables.\n\nIn this example, weather symbols are extracted from the object `weather`:\n\n```javascript\nconst weather = {\n  sun: '‚òÄÔ∏è',\n  sun_behind_small_cloud: 'üå§Ô∏è',\n  sun_behind_cloud: '‚õÖ',\n  sun_behind_large_cloud: 'üå•Ô∏è',\n  sun_behind_rain_cloud: 'üå¶Ô∏è',\n  cloud: '‚òÅÔ∏è',\n  cloud_with_rain: 'üåßÔ∏è',\n  cloud_with_snow: 'üå®Ô∏è',\n  cloud_with_lightning: 'üå©Ô∏è',\n  cloud_with_lightning_and_rain: '‚õàÔ∏è',\n};\n\nconst { sun, cloud, cloud_with_lightning: thunder } = weather;\n\nsun;\n// => '‚òÄÔ∏è'\n\ncloud;\n// => '‚òÅÔ∏è'\n\nthunder;\n// => 'üå©Ô∏è'\n```\n\nIn short:\n\n- The syntax allows for both extracting properties as well as extracting and renaming them.\n- Destructuring syntax is available inside function parameters.\n",
    "instructions": "# Instructions\n\nElyse, magician-to-be, continues her training.\nShe has a deck of cards she wants to manipulate.\n\nTo make things easier, she usually only starts with cards numbered 2 to 10, although some of the tricks may involve additional (face) cards.\n\n<!-- prettier-ignore-start -->\n~~~~exercism/note\nThere are **many** ways to shuffle the cards around, but to keep up the illusion of magic, it is vital that *no single method is used*, e.g. Elyse doesn't use `splice`, `slice`, `shift`, `unshift`, `push`, `at`.\nThe array accessor `array[index]` and object accessor (`object[key]` and `object.key`) are also never to be used.\n~~~~\n<!-- prettier-ignore-end -->\n\nWant to help Elyse level up her magic?\n\n<!-- prettier-ignore-start -->\n~~~~exercism/advanced\nEvery function can be implemented using the parameters and a function body with a single `return expression`.\n~~~~\n<!-- prettier-ignore-end -->\n\n## 1. Get the first card\n\nElyse will summon the first card in the deck without using the `array[index]`, `.at(index)`, or `.shift()`.\nIt's just like magic.\n\n```javascript\nconst deck = [5, 9, 7, 1, 8];\n\ngetFirstCard(deck);\n// => 5\n```\n\n## 2. Get the second card\n\nElyse performs sleight of hand and summons the second card in the deck without using the `array[index]` or `.shift()`.\n\n```javascript\nconst deck = [3, 2, 10, 6, 7];\n\ngetSecondCard(deck);\n// => 2\n```\n\n## 3. Swap two cards\n\nElyse will make the two cards of the deck switch places.\nShe doesn't need to call a single function.\n\n```javascript\nconst deck = [10, 7];\n\nswapTwoCards(deck);\n// => [7, 10]\n```\n\n## 4. Shift three cards around\n\nIn order to perform some more sleight of hand, Elyse takes three cards and quickly moves the top card to the back, making the middle card the first card and the old bottom card the middle card.\nShe doesn't need to call a single function.\n\n```javascript\nconst deck = [2, 6, 10];\n\nshiftThreeCardsAround(deck);\n// => [6, 10, 2]\n```\n\n## 5. Pick the named pile\n\nElyse will separate the deck into two piles.\nShe then asks the observer to pick one of the two piles, which we'll name `chosen`.\nThe `disregarded` pile is no longer relevant, which she makes disappear.\nShe doesn't need to call a single function.\n\n```javascript\nconst deck = [5, 4, 7, 10];\nconst chosen = [5, 4];\nconst disregarded = [7, 10];\n\npickNamedPile({ chosen, disregarded });\n// => [5, 4]\n```\n\n## 5. Swap the picked pile\n\nUnfortunately the observer keeps picking the \"wrong\" pile, but with some clever fast magic, Elyse renames the `chosen` pile to be `disregarded` and the `disregarded` pile to be the `chosen` pile.\nShe doesn't need to call a single function.\n\n```javascript\nconst deck = [5, 4, 7, 10];\nconst chosen = [5, 4];\nconst disregarded = [7, 10];\n\nswapNamedPile({ chosen, disregarded });\n// => { chosen: [7, 10], disregarded: [5, 4] }\n```\n",
    "hints": "# Hints\n\n## 1. Get the first card\n\n- [This article][mdn-destructuring] has a good overview of array destructuring. You can find an example of basic variable assignment in the 'Basic Array Destructuring' section.\n\n## 2. Get the second card\n\n- You can use placeholders to ignore one or more values in the array.\n- You can find an example [on MDN][mdn-destructuring-ignore-value].\n\n## 3. Swap the two cards\n\n- It's possible to swap two values in a single destructuring expression.\n- You can find an example [on MDN][mdn-destructuring-swapping].\n\n## 4. Shift three cards around\n\n- It's possible to change the position of three values in a single destructuring expression.\n- This is the same as swapping two values, but then with three (or more).\n\n## 5. Pick named pile\n\n- Objects can be destructured just like arrays.\n- You can find an example [on MDN][mdn-object-destructuring-basic-assignment].\n\n## 6. Swap named piles\n\n- When a property is extracted from an object, it can be renamed using specific syntax.\n- You can find an example [on MDN][mdn-object-destructuring-object-rename].\n\n[mdn-destructuring]: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Destructuring_assignment#Basic_variable_assignment\n[mdn-destructuring-ignore-value]: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Destructuring_assignment#Ignoring_some_returned_values\n[mdn-destructuring-swapping]: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Destructuring_assignment#Swapping_variables\n[mdn-object-destructuring-basic-assignment]: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Destructuring#basic_assignment\n[mdn-object-destructuring-object-rename]: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Destructuring#assigning_to_new_variable_names\n"
  },
  "starter_code": "/// <reference path=\"../global.d.ts\" />\n// @ts-check\n\n/**\n * Get the first card in the given deck\n *\n * @param {Card[]} deck\n *\n * @returns {Card} the first card in the deck\n */\nexport function getFirstCard([first]) {\n  return first;\n}\n\n/**\n * Get the second card in the given deck\n *\n * @param {Card[]} deck\n *\n * @returns {Card} the second card in the deck\n */\nexport function getSecondCard([, second]) {\n  return second;\n}\n\n/**\n * Switch the position of the two cards\n *\n * @param {[Card, Card]} deck\n *\n * @returns {[Card, Card]} new deck with the 2 cards swapped\n */\nexport function swapTwoCards([a, b]) {\n  return [b, a];\n}\n\n/**\n * Rotate (shift) the position of the three cards (by one place)\n *\n * @param {[Card, Card, Card]} deck\n *\n * @returns {[Card, Card, Card]} new deck with the 3 cards shifted by one position\n */\nexport function shiftThreeCardsAround([a, b, c]) {\n  return [b, c, a];\n}\n\n/**\n * Grab the chosen pile from the available piles\n *\n * @param {{ chosen: Card[], disregarded: Card[] }} piles\n *\n * @returns {Card[]} the pile named chosen\n */\nexport function pickNamedPile({ chosen }) {\n  // üö® Do NOT write piles.chosen or piles.disregarded.\n  return chosen;\n}\n\n/**\n * Swap the chosen pile for the disregarded pile and the disregarded pile for the chosen pile\n *\n * @param {{ chosen: Card[], disregarded: Card[] }} piles\n * @returns {{ chosen: Card[], disregarded: Card[] }} new piles where the two piles are swapped\n */\nexport function swapNamedPile({ chosen: disregarded, disregarded: chosen }) {\n  // ü™Ñ Don't break the magic.\n  // üö® Do NOT write piles.chosen or piles.disregarded.\n  // üö® Do NOT touch the next line or Elyse will accidentally reveal the trick.\n  return { chosen, disregarded };\n}\n",
  "tests": "import { describe, expect, test } from '@jest/globals';\nimport {\n  getFirstCard,\n  getSecondCard,\n  swapTwoCards,\n  shiftThreeCardsAround,\n  pickNamedPile,\n  swapNamedPile,\n} from './enchantments';\n\nconst customInspectSymbol = Symbol.for('nodejs.util.inspect.custom');\nconst customLogSymbol = Symbol.for('exercism.javascript.util.log');\n\n// Follow the instructions in case you are stuck on \"list.method is not a function\"\nclass LimitedDeck {\n  constructor(values) {\n    this.values = values;\n  }\n\n  // Enables rest syntax and spread operator, as wel as for of, etc.\n  [Symbol.iterator]() {\n    return this.values[Symbol.iterator]();\n  }\n\n  // Log value in non-upgraded environments\n  toString() {\n    return this.values.toString();\n  }\n\n  // Overrides logging in node (ie. students working locally)\n  [customInspectSymbol](depth, inspectOptions, inspect) {\n    const inner = this.values[customInspectSymbol]\n      ? this.values[customInspectSymbol](depth, inspectOptions, inspect)\n      : this.values.toString();\n\n    return `List of (${inner})`;\n  }\n\n  // Overrides log overrides in web environment (ie. students working in editor)\n  [customLogSymbol](depth, inspectOptions, inspect) {\n    const inner = this.values[customLogSymbol]\n      ? this.values[customLogSymbol](depth, inspectOptions, inspect)\n      : this.values.toString();\n\n    return `List of (${inner})`;\n  }\n}\n\nfunction deck(...values) {\n  return new LimitedDeck(values);\n}\n\ndescribe('getFirstCard', () => {\n  test('from a deck with a single card', () => {\n    expect(getFirstCard(deck(3))).toBe(3);\n  });\n\n  test('from a deck with many cards', () => {\n    expect(getFirstCard(deck(8, 3, 9, 5))).toBe(8);\n  });\n\n  test('from an empty deck', () => {\n    expect(getFirstCard(deck())).toBe(undefined);\n  });\n});\n\ndescribe('getSecondCard', () => {\n  test('from a deck with two cards', () => {\n    expect(getSecondCard(deck(10, 4))).toBe(4);\n  });\n\n  test('from a deck with many cards', () => {\n    expect(getSecondCard(deck(2, 5, 7, 6))).toBe(5);\n  });\n\n  test('from an empty deck', () => {\n    expect(getSecondCard(deck())).toBe(undefined);\n  });\n\n  test('from a deck with one card', () => {\n    expect(getSecondCard(deck(8))).toBe(undefined);\n  });\n});\n\ndescribe('swapTwoCards', () => {\n  test('swapping two numbered cards', () => {\n    expect(swapTwoCards(deck(3, 6))).toStrictEqual([6, 3]);\n  });\n\n  test('swapping a high card with a low card', () => {\n    expect(swapTwoCards(deck(10, 2))).toStrictEqual([2, 10]);\n  });\n\n  test('swapping a face card with a low card', () => {\n    expect(swapTwoCards(deck('king', 3))).toStrictEqual([3, 'king']);\n  });\n});\n\ndescribe('shiftThreeCardsAround', () => {\n  test('consecutive numbers', () => {\n    expect(shiftThreeCardsAround(deck(6, 4, 5))).toStrictEqual([4, 5, 6]);\n  });\n\n  test('drop the face card to the bottom', () => {\n    expect(shiftThreeCardsAround(deck('king', 5, 2))).toStrictEqual([\n      5,\n      2,\n      'king',\n    ]);\n  });\n});\n\ndescribe('pickNamedPile', () => {\n  test('keeps the chosen pile', () => {\n    const chosen = deck(3, 'jack', 'queen', 'king', 10, 7);\n    const disregarded = deck(4, 5, 6, 8, 9);\n    const piles = { chosen, disregarded };\n\n    expect(pickNamedPile(piles)).toStrictEqual(chosen);\n  });\n\n  test('returns the actual pile without recreating it', () => {\n    const chosen = deck(3, 'jack', 'queen', 'king', 10, 7);\n    const disregarded = deck(4, 5, 6, 8, 9);\n    const piles = { chosen, disregarded };\n\n    const result = pickNamedPile(piles);\n\n    chosen.values.push('joker');\n\n    expect(result).toStrictEqual(chosen);\n  });\n});\n\ndescribe('swapNamedPile', () => {\n  test('renames the piles', () => {\n    const face_pile = deck(3, 'jack', 'queen', 'king', 10, 7);\n    const numbers_pile = deck(4, 5, 6, 8, 9);\n    const piles = { chosen: numbers_pile, disregarded: face_pile };\n\n    expect(swapNamedPile(piles)).toStrictEqual({\n      chosen: face_pile,\n      disregarded: numbers_pile,\n    });\n  });\n\n  test('returns the actual piles without recreating them', () => {\n    const face_pile = deck(3, 'jack', 'queen', 'king', 10, 7);\n    const numbers_pile = deck(4, 5, 6, 8, 9);\n    const piles = { chosen: numbers_pile, disregarded: face_pile };\n\n    const result = swapNamedPile(piles);\n\n    face_pile.values.push('joker');\n    numbers_pile.values.push(2);\n\n    expect(result).toStrictEqual({\n      chosen: face_pile,\n      disregarded: numbers_pile,\n    });\n  });\n});\n"
}
