{
  "language": "javascript",
  "slug": "translation-service",
  "title": "Translation Service",
  "docs": {
    "introduction": "# Introduction\n\nThe [`Promise`][promise-docs] object represents the eventual completion (or failure) of an asynchronous operation and its resulting value.\n\n<!-- prettier-ignore -->\n~~~exercism/note\nThis is a hard topic for many people, specially if you know programming in a language that is completely _synchronous_.\nIf you feel overwhelmed, or you would like to learn more about **concurrency** and **parallelism**, [watch (via go.dev)][talk-blog] or [watch directly via vimeo][talk-video] and [read the slides][talk-slides] of the brilliant talk \"Concurrency is not parallelism\".\n\n[talk-slides]: https://go.dev/talks/2012/waza.slide#1\n[talk-blog]: https://go.dev/blog/waza-talk\n[talk-video]: https://vimeo.com/49718712\n~~~\n\n## Lifecycle of a promise\n\nA `Promise` has three states:\n\n1. pending\n2. fulfilled\n3. rejected\n\nWhen it is created, a promise is pending.\nAt some point in the future it may _resolve_ or _reject_.\nOnce a promise is resolved or rejected once, it can never be resolved or rejected again, nor can its state change.\n\nIn other words:\n\n1. When pending, a promise:\n   - may transition to either the fulfilled or rejected state.\n2. When fulfilled, a promise:\n   - must not transition to any other state.\n   - must have a value, which must not change.\n3. When rejected, a promise:\n   - must not transition to any other state.\n   - must have a reason, which must not change.\n\n## Resolving a promise\n\nA promise may be resolved in various ways:\n\n```javascript\n// Creates a promise that is immediately resolved\nPromise.resolve(value);\n\n// Creates a promise that is immediately resolved\nnew Promise((resolve) => {\n  resolve(value);\n});\n\n// Chaining a promise leads to a resolved promise\nsomePromise.then(() => {\n  // ...\n  return value;\n});\n```\n\nIn the examples above `value` can be _anything_, including an error, `undefined`, `null` or another promise.\nUsually you want to resolve with a value that's not an error.\n\n## Rejecting a promise\n\nA promise may be rejected in various ways:\n\n```javascript\n// Creates a promise that is immediately rejected\nPromise.reject(reason)\n\n// Creates a promise that is immediately rejected\nnew Promise((_, reject) {\n  reject(reason)\n})\n\n// Chaining a promise with an error leads to a rejected promise\nsomePromise.then(() => {\n  // ...\n  throw reason\n})\n```\n\nIn the examples above `reason` can be _anything_, including an error, `undefined` or `null`.\nUsually you want to reject with an error.\n\n## Chaining a promise\n\nA promise may be _continued_ with a future action once it resolves or rejects.\n\n- [`promise.then()`][promise-then] is called once `promise` resolves\n- [`promise.catch()`][promise-catch] is called once `promise` rejects\n- [`promise.finally()`][promise-finally] is called once `promise` either resolves or rejects\n\n### **then**\n\nEvery promise is \"thenable\".\nThat means that there is a function `then` available that will be executed once the original promise is resolves.\nGiven `promise.then(onResolved)`, the callback `onResolved` receives the value the original promise was resolved with.\nThis will always return a _new_ \"chained\" promise.\n\nReturning a `value` from `then` resolves the \"chained\" promise.\nThrowing a `reason` in `then` rejects the \"chained\" promise.\n\n```javascript\nconst promise1 = new Promise(function (resolve, reject) {\n  setTimeout(() => {\n    resolve('Success!');\n  }, 1000);\n});\n\nconst promise2 = promise1.then(function (value) {\n  console.log(value);\n  // expected output: \"Success!\"\n\n  return true;\n});\n```\n\nThis will log `\"Success!\"` after approximately 1000 ms.\nThe state & value of `promise1` will be `resolved` and `\"Success!\"`.\nThe state & value of `promise2` will be `resolved` and `true`.\n\nThere is a second argument available that runs when the original promise rejects.\nGiven `promise.then(onResolved, onRejected)`, the callback `onResolved` receives the value the original promise was resolved with, or the callback `onRejected` receives the reason the promise was rejected.\n\n```javascript\nconst promise1 = new Promise(function (resolve, reject) {\n  setTimeout(() => {\n    resolve('Success!');\n  }, 1000);\n\n  if (Math.random() < 0.5) {\n    reject('Nope!');\n  }\n});\n\nfunction log(value) {\n  console.log(value);\n  return true;\n}\n\nfunction shout(reason) {\n  console.error(reason.toUpperCase());\n  return false;\n}\n\nconst promise2 = promise1.then(log, shout);\n```\n\n- In about 1/2 of the cases, this will log `\"Success!\"` after approximately 1000 ms.\n  - The state & value of `promise1` will be `resolved` and `\"Success!\"`.\n  - The state & value of `promise2` will be `resolved` and `true`.\n- In about 1/2 of the cases, this will immediately log `\"NOPE!\"`.\n  - The state & value of `promise1` will be `rejected` and `Nope!`.\n  - The state & value of `promise2` will be `resolved` and `false`.\n\nIt is important to understand that because of the rules of the lifecycle, when it `reject`s, the `resolve` that comes in ~1000ms later is silently ignored, as the internal state cannot change once it has rejected or resolved.\nIt is important to understand that returning a value from a promise resolves it, and throwing a value rejects it.\nWhen `promise1` resolves and there is a chained `onResolved`: `then(onResolved)`, then that follow-up is a new promise that can resolve or reject.\nWhen `promise1` rejects but there is a chained `onRejected`: `then(, onRejected)`, then that follow-up is a new promise that can resolve or reject.\n\n### **catch**\n\nSometimes you want to capture errors and only continue when the original promise `reject`s.\nGiven `promise.catch(onCatch)`, the callback `onCatch` receives the reason the original promise was rejected.\nThis will always return a _new_ \"chained\" promise.\n\nReturning a `value` from `catch` resolves the \"chained\" promise.\nThrowing a `reason` in `catch` rejects the \"chained\" promise.\n\n```javascript\nconst promise1 = new Promise(function (resolve, reject) {\n  setTimeout(() => {\n    resolve('Success!');\n  }, 1000);\n\n  if (Math.random() < 0.5) {\n    reject('Nope!');\n  }\n});\n\nfunction log(value) {\n  console.log(value);\n  return 'done';\n}\n\nfunction recover(reason) {\n  console.error(reason.toUpperCase());\n  return 42;\n}\n\nconst promise2 = promise1.catch(recover).then(log);\n```\n\nIn about 1/2 of the cases, this will log `\"Success!\"` after approximately 1000 ms.\nIn the other 1/2 of the cases, this will immediately log `42`.\n\n- If `promise1` resolves, `catch` is skipped and it reaches `then`, and logs the value.\n  - The state & value of `promise1` will be `resolved` and `\"Success!\"`.\n  - The state & value of `promise2` will be `resolved` and `\"done\"`;\n- If `promise1` rejects, `catch` is executed, which _returns a value_, and thus the chain is now `resolved`, and it reaches `then`, and logs the value.\n  - The state & value of `promise1` will be `rejected` and `\"Nope!\"`.\n  - The state & value of `promise2` will be `resolved` and `\"done\"`;\n\n### **finally**\n\nSometimes you want to execute code after a promise settles, regardless if the promise resolves or rejects.\nGiven `promise.finally(onSettled)`, the callback `onSettled` receives nothing.\nThis will always return a _new_ \"chained\" promise.\n\nReturning a `value` from `finally` copies the status & value from the original promise, ignoring the `value`.\nThrowing a `reason` in `finally` rejects the \"chained\" promise, overwriting any status & value or reason from the original promise.\n\n## Example\n\nVarious of the methods together:\n\n```javascript\nconst myPromise = new Promise(function (resolve, reject) {\n  const sampleData = [2, 4, 6, 8];\n  const randomNumber = Math.round(Math.random() * 5);\n\n  if (sampleData[randomNumber]) {\n    resolve(sampleData[randomNumber]);\n  } else {\n    reject('Sampling did not result in a sample');\n  }\n});\n\nconst finalPromise = myPromise\n  .then(function (sampled) {\n    // If the random number was 0, 1, 2, or 3, this will be\n    // reached and the number 2, 4, 6, or 8 will be logged.\n    console.log(`Sampled data: ${sampled}`);\n    return 'yay';\n  })\n  .catch(function (reason) {\n    // If the random number was 4 or 5, this will be reached and\n    // reason will be \"An error occurred\". The entire chain will\n    // then reject with an Error with the reason as message.\n    throw new Error(reason);\n  })\n  .finally(function () {\n    // This will always log after either the sampled data is\n    // logged or the error is raised.\n    console.log('Promise completed');\n  });\n```\n\n- In the cases `randomNumber` is `0-3`:\n  - `myPromise` will be resolved with the value `2, 4, 6, or 8`\n  - `finalPromise` will be resolved with the value `'yay'`\n  - There will be two logs:\n    - `Sampled data: ...`\n    - `Promise completed`\n- In the cases `randomNumber` is `4-5`:\n  - `myPromise` will be rejected with the reason `'Sampling did not result in a sample'`\n  - `finalPromise` will be rejected with the reason `Error('Sampling did not result in a sample')`\n  - There will be one log:\n    - `Promise completed`\n    - _in some environments_ this will yield an `\"uncaught rejected promise: Error('Sampling did not result in a sample')\"` log\n\nAs shown above, `reject` works with a string, and a promise can also reject with an `Error`.\n\n<!-- prettier-ignore -->\n~~~exercism/note\nIf chaining promises or general usage is unclear, the [tutorial on MDN][mdn-promises] is a good resource to consume.\n\n[mdn-promises]: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Using_promises\n~~~\n\n[promise-docs]: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise\n[promise-catch]: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise/catch\n[promise-then]: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise/then\n[promise-finally]: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise/finally\n",
    "instructions": "# Instructions\n\nIn this exercise, you'll be providing a `TranslationService` that provides basic translation services to free members, and advanced translation to premium members with quality assurances.\n\n**The API**\n\nYou have found an outer space translation API that fulfills any translation `request` in a reasonable amount of time.\nYou want to capitalize on this.\nThe space translators are extremely fickle and hate redundancy, so they also provide _API storage_ satellites where you can `fetch` past translations without bothering them.\n\n**_Fetching a translation_**\n\n`api.fetch(text)` fetches a translation of `text` from the _API storage_ and returns a `promise` that provides two values:\n\n- `translation`: the actual translation\n- `quality`: the quality expressed as a number\n\nIf a translation is not found in the _API storage_, the API throws a `NotAvailable` error.\nTranslations can be added using the `api.request` method.\nIf 'text' is not translatable, the API throws an `Untranslatable` error.\n\n```javascript\napi.fetch('jIyaj');\n// => Promise({ resolved: 'I understand' })\n```\n\n**_Requesting a translation_**\n\nSome translations are sure to exist, but haven't been added to the _API storage_ yet. That's the difference between `NotAvailable` ( not in storage, but can be requested ) and `Untranslatable` ( cannot be translated ).\n\n`api.request(text, callback)` requests that a translation of `text` be performed and added into the _API storage_.\nOn completion the `callback` function is called.\n\n- On success `callback` is passed `undefined`: this indicates the translation was successful and is accessible using the `api.fetch` method.\n- On failure `callback` is passed an `error`: this indicates something went wrong.\n  The outspace API is _unstable_, which means that the API fails often.\n  If that happens, it is okay to `api.request` again.\n\n```javascript\napi.request('majQa’', callback);\n// => undefined\n//\n// later: the passed callback is called with undefined\n//        because it was successful.\n```\n\n**⚠ Warning! ⚠**\n\n<!-- prettier-ignore-start -->\n~~~~exercism/caution\nThe API works its magic by teleporting in the various translators when a `request` comes in.\nThis is a very costly action, so it shouldn't be called when a translation *is* available.\nUnfortunately, not everyone reads the manual, so there is a system in place to kick-out bad actors.\n\nIf an `api.request` is called for `text` is available, the API throws an `AbusiveClientError` for this call, **and every call after that**.\nEnsure that you *never* request a translation if something has already been translated.\n~~~~\n<!-- prettier-ignore-end -->\n\n## 1. Fetch a translation, ignoring the quality\n\nThe free service only provides translations that are currently in the _API storage_.\n\nImplement a method `free(text)` that provides free members with translation that already exist in the _API storage_.\nIgnore the quality and forward any errors thrown by the API.\n\n- Returns the translation if it can be retrieved, regardless of its quality\n- Forwards any error from the translation API\n- Uses the `api.fetch` method (`api.fetch` returns a `promise`)\n\n```javascript\nservice.free('jIyaj');\n// => Promise<...> resolves \"I understand.\"\n\nservice.free(\"jIyajbe'\");\n// => Promise<...> rejects Error(\"Not yet translated\")\n```\n\n## 2. Fetch a batch of translations, all-or-nothing\n\nImplement a method `batch([text, text, ...])` for free members that translates an array of text using the free service, returning all the translations, or a single error.\n\n- Resolves with all the translations (in the same order), if they are all available\n- Rejects with the first error that is encountered\n- Rejects with a `BatchIsEmpty` error if no texts are given\n\n```javascript\nservice.batch(['jIyaj', \"majQa'\"]);\n// => Promise<...> resolves [\"I understand.\", \"Well done!\"]\n\nservice.batch(['jIyaj', \"jIyajbe'\"]);\n// => Promise<...> rejects new Error(\"Not yet translated\")\n\nservice.batch([]);\n// => Promise<...> rejects BatchIsEmpty()\n```\n\n## 3. Request a translation, retrying at most 2 times\n\nImplement a premium user method `request(text)`, that _requests_ a translation be added to the _API storage_.\nThe request should automatically retry if a failure occurs.\nIt should perform no more than **3 calls** for the same request (_don't upset the space translators!!!_).\n\n- If `api.request` does not return an error, resolve with `undefined`\n- If `api.request` returns an error, retry at most two times\n- If you run out of retries, reject with the last error received\n\n```javascript\nservice.request(\"jIyajbe'\");\n// => Promise<...> resolves (with nothing), can now be retrieved using the fetch API\n```\n\n## 4. Fetch a translation, inspect the quality, or request it\n\nImplement a premium user method `premium(text, quality)` to fetch a translation.\nIf a translation is `NotAvailable`, request the translation and fetch it after its been added to the _API storage_.\nThe method should only return the translation if it meets a certain `quality` threshold.\n\n- If `api.fetch` resolves, check the quality before resolving\n- If `api.fetch` rejects, _request_ the translation instead\n- If `api.request` rejects, forward the error\n\n```javascript\nservice.premium(\"jIyajbe'\", 100);\n// => Promise<...> resolves \"I don't understand.\"\n\nservice.premium(\"'arlogh Qoylu'pu'?\", 100);\n// => Promise<...> rejects QualityThresholdNotMet()\n\nservice.premium(\"'arlogh Qoylu'pu'?\", 40);\n// => Promise<...> resolves \"What time is it?\"\n```\n\n**N.B.**\n\n<!-- prettier-ignore-start -->\n~~~~exercism/note\nThe correct translation of `'arlogh Qoylu'pu'?` is **How many times has it been heard?**.\n~~~~\n<!-- prettier-ignore-end -->\n",
    "hints": "# Hints\n\n## 1. Fetch a translation, ignoring the quality\n\n- Promises are chainable, for example by using `.then`.\n- Promises will forward any value.\n  That means that if a promise resolves, it will forward that value until it reaches the end of the chain or a `.then`, which receives the value as its argument.\n- Promises will forward any error.\n  That means that if a promise rejects, it will forward that rejection until it reaches the end of the chain or a `.catch`, which receives the value as its argument and can handle it.\n\n## 2. Fetch a batch of translations, all-or-nothing\n\n- To return a promise with an error, create a `Promise` that is `rejected` from the start.\n- There is a helper method on `Promise` that waits for an array of promises to resolve before it resolves itself.\n\n## 3. Request a translation, retrying at most 2 times\n\n- Convert the `callback` to a promise using the `new Promise` constructor.\n\n## 4. Fetch a translation, inspect the quality, or request it\n\n- Instead of nesting `.then` and/or `.catch`, `.then` takes a second argument which catches everything _before_ (earlier in the chain), ignoring errors in the first argument of `.then`.\n"
  },
  "starter_code": "/** @format */\n\n/// <reference path=\"./global.d.ts\" />\n// @ts-check\n\nexport class TranslationService {\n  /**\n   * Creates a new service\n   * @param {ExternalApi} api the original api\n   */\n  constructor(api) {\n    this.api = api;\n  }\n\n  /**\n   * Attempts to retrieve the translation for the given text.\n   *\n   * - Returns whichever translation can be retrieved, regardless the quality\n   * - Forwards any error from the translation api\n   *\n   * @param {string} text\n   * @returns {Promise<string>}\n   */\n  free(text) {\n    return this.api.fetch(text).then((res) => res.translation);\n  }\n\n  /**\n   * Batch translates the given texts using the free service.\n   *\n   * - Resolves all the translations (in the same order), if they all succeed\n   * - Rejects with the first error that is encountered\n   * - Rejects with a BatchIsEmpty error if no texts are given\n   *\n   * @param {string[]} texts\n   * @returns {Promise<string[]>}\n   */\n  batch(texts) {\n    if (texts.length === 0) return Promise.reject(new BatchIsEmpty());\n    return Promise.all(texts.map((text) => this.free(text)));\n  }\n\n  /**\n   * Requests the service for some text to be translated.\n   *\n   * Note: the request service is flaky, and it may take up to three times for\n   *       it to accept the request.\n   *\n   * @param {string} text\n   * @returns {Promise<void>}\n   */\n  request(text) {\n    const api = this.api;\n    function requestAsPromise(txt) {\n      return new Promise((resolve, reject) => {\n        api.request(txt, (err) => (err ? reject(err) : resolve()));\n      });\n    }\n\n    return requestAsPromise(text)\n      .catch(() => requestAsPromise(text))\n      .catch(() => requestAsPromise(text));\n  }\n\n  /**\n   * Retrieves the translation for the given text\n   *\n   * - Rejects with an error if the quality can not be met\n   * - Requests a translation if the translation is not available, then retries\n   *\n   * @param {string} text\n   * @param {number} minimumQuality\n   * @returns {Promise<string>}\n   */\n  premium(text, minimumQuality) {\n    return this.api\n      .fetch(text)\n      .catch(() => {\n        return this.request(text).then(() => this.api.fetch(text));\n      })\n      .then((res) => {\n        if (res.quality < minimumQuality)\n          throw new QualityThresholdNotMet(text);\n        return res.translation;\n      });\n  }\n}\n\n/**\n * This error is used to indicate a translation was found, but its quality does\n * not meet a certain threshold. Do not change the name of this error.\n */\nexport class QualityThresholdNotMet extends Error {\n  /**\n   * @param {string} text\n   */\n  constructor(text) {\n    super(\n      `The translation of ${text} does not meet the requested quality threshold.`,\n    );\n\n    this.text = text;\n  }\n}\n\n/**\n * This error is used to indicate the batch service was called without any\n * texts to translate (it was empty). Do not change the name of this error.\n */\nexport class BatchIsEmpty extends Error {\n  constructor() {\n    super(\n      `Requested a batch translation, but there are no texts in the batch.`,\n    );\n  }\n}\n",
  "tests": "import { beforeEach, describe, expect, test } from '@jest/globals';\nimport {\n  BatchIsEmpty,\n  QualityThresholdNotMet,\n  TranslationService,\n} from './service';\n\nimport { ExternalApi } from './api';\nimport { ConnectionError, NotAvailable, Untranslatable } from './errors';\n\ndescribe('Free service', () => {\n  /** @type {TranslationService} */\n  let service;\n\n  beforeEach(() => {\n    const api = new ExternalApi()\n      .register('jIyaj', 'I understand', 100)\n      .register('jIyajbe’', null)\n      .register('jIyajbe’', \"I don't understand\", 100);\n\n    service = new TranslationService(api);\n  });\n\n  test('it can translate a known word group', async () => {\n    const actual = service.free('jIyaj');\n    const expected = 'I understand';\n\n    await expect(actual).resolves.toBe(expected);\n  });\n\n  test('it forwards NotAvailable errors from the API, unaltered', async () => {\n    const actual = service.free('jIyajbe’');\n    const expected = NotAvailable;\n\n    await expect(actual).rejects.toThrow(expected);\n  });\n\n  test('it forwards Untranslatable errors from the API, unaltered', async () => {\n    const actual = service.free('majQa’');\n    const expected = Untranslatable;\n\n    await expect(actual).rejects.toThrow(expected);\n  });\n});\n\ndescribe('Batch service', () => {\n  /** @type {TranslationService} */\n  let service;\n\n  beforeEach(() => {\n    // jIyajbe’ will be marked as not yet translated, but is not translatable\n    const api = new ExternalApi({ 'jIyajbe’': [] })\n      .register('jIyaj', 'I understand', 100)\n      .register('majQa’', 'Well done!', 100);\n\n    service = new TranslationService(api);\n  });\n\n  test('it can translate a batch', async () => {\n    const actual = service.batch(['jIyaj', 'majQa’']);\n    const expected = ['I understand', 'Well done!'];\n\n    await expect(actual).resolves.toStrictEqual(expected);\n  });\n\n  test('it maintains the order of batch input', async () => {\n    const actual = service.batch(['majQa’', 'jIyaj']);\n    const expected = ['Well done!', 'I understand'];\n\n    await expect(actual).resolves.toStrictEqual(expected);\n  });\n\n  test('it works with just one item to translate', async () => {\n    const actual = service.batch(['jIyaj']);\n    const expected = ['I understand'];\n\n    await expect(actual).resolves.toStrictEqual(expected);\n  });\n\n  test('it throws if one or more translations fail', async () => {\n    const actual = service.batch(['jIyaj', 'jIyajbe’', 'majQa’']);\n    const expected = NotAvailable;\n\n    await expect(actual).rejects.toThrow(expected);\n  });\n\n  test('it throws on an empty input', async () => {\n    const actual = service.batch([]);\n    const expected = BatchIsEmpty;\n\n    await expect(actual).rejects.toThrow(expected);\n  });\n});\n\ndescribe('Request service', () => {\n  /** @type {TranslationService} */\n  let service;\n\n  beforeEach(() => {\n    const api = new ExternalApi()\n      .register('majQa’', null)\n      .register('majQa’', 'Well done!', 100)\n      .register('jIyajbe’', null)\n      .register('jIyajbe’', null)\n      .register('jIyajbe’', null)\n      .register('jIyajbe’', \"I don't understand\", 100)\n      .register('ghobe’', null)\n      .register('ghobe’', null)\n      .register('ghobe’', null)\n      .register('ghobe’', null)\n      .register('ghobe’', 'No!', 100);\n\n    service = new TranslationService(api);\n  });\n\n  test('it can request something that is not available, but eventually is', async () => {\n    const actual = service.request('majQa’');\n    await expect(actual).resolves.toBeUndefined();\n  });\n\n  test('it eventually rejects when something is not translatable', async () => {\n    const actual = service.request('foo');\n    const expected = Untranslatable;\n\n    await expect(actual).rejects.toThrow(expected);\n  });\n\n  test('it requests up to three times (retries once or twice)', async () => {\n    const actual = service.request('jIyajbe’');\n    await expect(actual).resolves.toBeUndefined();\n  });\n\n  test('it requests at most three times (does not retry thrice or more)', async () => {\n    const actual = service.request('ghobe’');\n\n    await expect(actual).rejects.toThrow(ConnectionError);\n  });\n});\n\ndescribe('Premium service', () => {\n  /** @type {TranslationService} */\n  let service;\n\n  beforeEach(() => {\n    const api = new ExternalApi()\n      .register('majQa’', 'Well done', 90)\n      .register('jIyajbe’', null)\n      .register('jIyajbe’', \"I don't understand\", 100)\n      .register('ghobe’', null)\n      .register('ghobe’', null)\n      .register('ghobe’', null)\n      .register('ghobe’', null)\n      .register('ghobe’', 'No!', 100)\n      .register('‘arlogh Qoylu’pu’?', null)\n      .register('‘arlogh Qoylu’pu’?', 'What time is it?', 75);\n\n    service = new TranslationService(api);\n  });\n\n  test('it can resolve a translation', async () => {\n    const actual = service.premium('majQa’', 0);\n    const expected = 'Well done';\n\n    await expect(actual).resolves.toBe(expected);\n  });\n\n  test('it requests unavailable translations and then resolves', async () => {\n    const actual = service.premium('jIyajbe’', 0);\n    const expected = \"I don't understand\";\n\n    await expect(actual).resolves.toBe(expected);\n  });\n\n  test('it rejects with Untranslatable if the premium service fails to translate', async () => {\n    const actual = service.premium('foo', 0);\n    const expected = Untranslatable;\n\n    await expect(actual).rejects.toThrow(expected);\n  });\n\n  test('it requests at most three times (does not retry thrice or more)', async () => {\n    const actual = service.premium('ghobe’', 0);\n\n    await expect(actual).rejects.toThrow(ConnectionError);\n  });\n\n  test('it recognizes sufficient quality', async () => {\n    const actual = service.premium('‘arlogh Qoylu’pu’?', 40);\n    const expected = 'What time is it?';\n\n    await expect(actual).resolves.toBe(expected);\n  });\n\n  test('it recognizes insufficient quality', async () => {\n    const actual = service.premium('majQa’', 100);\n    const expected = QualityThresholdNotMet;\n\n    await expect(actual).rejects.toThrow(expected);\n  });\n\n  test('it ensures the quality even after a request', async () => {\n    const actualQuality = service.premium('‘arlogh Qoylu’pu’?', 100);\n    const expectedQuality = QualityThresholdNotMet;\n    await expect(actualQuality).rejects.toThrow(expectedQuality);\n  });\n});\n"
}