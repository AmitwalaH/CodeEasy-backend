{
  "language": "javascript",
  "slug": "pizza-order",
  "title": "Pizza Order",
  "docs": {
    "introduction": "# Understanding Recursion in JavaScript\n\nRecursion is a powerful concept in programming that involves a function calling itself.\nIt can be a bit tricky to grasp at first, but once you understand the fundamentals, it becomes a valuable tool in solving complex problems.\nIn this tutorial, we'll explore recursion in JavaScript with easy-to-understand examples.\n\n## What is Recursion?\n\nRecursion occurs when a function calls itself, either directly or indirectly.\nIt's similar to a loop, but it involves breaking a problem down into smaller, more manageable sub-problems.\n\n### Example 1: Countdown\n\nLet's start with a simple example: a countdown function.\n\n```javascript\nfunction countdown(num) {\n  // Base case\n  if (num <= 0) {\n    console.log('Blastoff!');\n    return;\n  }\n\n  // Recursive case\n  console.log(num);\n  countdown(num - 1);\n}\n\n// Call the function\ncountdown(5);\n```\n\nIn this example:\n\n- **Base case**: When `num` becomes less than or equal to 0, the function prints \"Blastoff!\" and stops calling itself.\n- **Recursive case**: The function prints the current `num` and calls itself with `num - 1`.\n\n### Example 2: Factorial\n\nNow, let's look at a classic example of recursion: calculating the factorial of a number.\n\n```javascript\nfunction factorial(n) {\n  // Base case\n  if (n === 0 || n === 1) {\n    return 1;\n  }\n\n  // Recursive case\n  return n * factorial(n - 1);\n}\n\n// Test the function\nconsole.log(factorial(5)); // Output: 120\n```\n\nIn this example:\n\n- **Base case**: When `n` is 0 or 1, the function returns 1.\n- **Recursive case**: The function multiplies `n` by the factorial of `n - 1`.\n\n## Key Concepts\n\n### Base Case\n\nEvery recursive function must have at least one base case, a condition where the function stops calling itself.\nWithout a base case, the recursion would continue indefinitely, leading to a stack overflow.\n\n### Recursive Case\n\nThe recursive case defines how the function calls itself with a smaller or simpler version of the problem.\n\n## Pros and Cons of Recursion\n\n**Pros:**\n\n- Elegant solution for certain problems.\n- Mimics the mathematical induction concept.\n\n**Cons:**\n\n- Can be less efficient than iterative solutions.\n- May lead to stack overflow for deep recursion.\n\n## Conclusion\n\nRecursion is a valuable technique that can simplify complex problems by breaking them into smaller, more manageable sub-problems.\nUnderstanding base cases and recursive cases is crucial for implementing effective recursive solutions in JavaScript.\n\n**Learn More:**\n\n- [MDN: Recursion in JavaScript](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Functions#recursion)\n- [Eloquent JavaScript: Chapter 3 - Functions](https://eloquentjavascript.net/03_functions.html)\n",
    "instructions": "# Instructions\n\nYou run a pizza shop, and offer three types of pizzas:\n\n- Margherita: $7\n- Caprese: $9\n- Formaggio: $10\n\nIf customers want, they can add an unlimited number of extra options: either \"ExtraSauce\" for $1 or \"ExtraToppings\" for $2.\n\nYour task is to write code that assists the customer in figuring out the cost to them.\n\n## Calculate the price of a pizza\n\nProvided the pizza's name as the first argument, and an unlimited number of added options, calculate the price of the pizza in dollars.\n\n```js\npizzaPrice('Margherita');\n// => 7\n\npizzaPrice('Caprese', 'ExtraSauce', 'ExtraToppings');\n// => 12\n\npizzaPrice(\n  'Caprese',\n  'ExtraToppings',\n  'ExtraToppings',\n  'ExtraToppings',\n  'ExtraToppings',\n);\n// => 17\n```\n\n## Calculate the total price of an order\n\nYour function is called with a list of `PizzaOrder`s and should return the total price of the order in dollars.\nEach `PizzaOrder` has a `pizza` property - the pizza's name, and an `extras` property - the list of extra options.\n\n```js\nconst margherita = new PizzaOrder('Margherita');\nconst caprese = new PizzaOrder('Caprese', 'ExtraToppings');\norderPrice([margherita, caprese]);\n// => 18\n```\n\nYou'll realize that you can't write this using recursion, as one test with a tremendous amount of orders will raise a `Maximum call stack size exceeded`.\nNo worries, this is intentional - try implementing this function using an imperative loop!\nYou have many options, such as, but not limited to using `reduce` or a `for` loop.\n\n<!-- prettier-ignore-start -->\n~~~~exercism/advanced\nWhen the JavaScript interpreter is running the JavaScript code, it will keep track of which functions it has entered (started to call) on a data structure called \"a stack\".\nWhen the function returns (ends), it is removed from the stack.\n\nHowever, this stack has a limited size.\nThe most common mistake made is a recursive function that never ends.\nEach call is placed on the stack, but before it returns, another call is placed on the stack.\n\n```javascript\nfunction kaboom() {\n  kaboom()\n}\n\nkaboom()\n// => RangeError: Maximum call stack size exceeded\n```\n\nThe stacktrace of this error shows the same line over and over, which makes sense, because the function calls itself.\nWhilst it has no real practical application in most cases, you can find out how tall that stack can get.\n\n```javascript\nlet calls = 0;\nfunction kaboom() {\n  calls +=1 ;\n  kaboom()\n}\n\nkaboom()\n// => RangeError: Maximum call stack size exceeded\n\nconsole.log(calls)\n// => a number, generally higher than 10.000\n```\n\nThere are only two viable solutions to a call stack error caused by a synchronous recursive function:\n- ensure the functions return before the stack limit is reached, usually by adding or fixing a base case.\n- rewrite the recursive function to an imperative loop, which will execute the body of the loop, without having to enter a function, thus without increasing the stack.\n~~~~\n<!-- prettier-ignore-end -->\n",
    "hints": "# Hints\n\n## 1. Calculate the price of a pizza\n\n- Set up a recursive function that returns the price of one extra option added to the price of the pizza without that extra topping.\n- If `Maximum call stack size exceeded` error is raised, check if you've missed out on the base case.\n- If you're getting a `Memory Allocation Error`, check if you're duplicating the input array of toppings instead of mutating it.\n\n## 2. Calculate the total price of an order\n\n- Using `pizzaPrice`, calculate the price of each pizza in the array, and add it to a sum.\n- If `Maximum call stack size exceeded` error is raised, and more than one test is failing, check if you've missed out on the base case. If only one test is failing, try implementing this with a loop!\n- If you're getting a `Memory Allocation Error`, check if you're duplicating the input array instead of mutating it.\n"
  },
  "starter_code": "/// <reference path=\"../global.d.ts\" />\n// @ts-check\n\n/**\n * @type {Record<Pizza, number>}\n */\nconst PIZZA_PRICES = {\n  Margherita: 7,\n  Caprese: 9,\n  Formaggio: 10,\n};\n\n/**\n * Determine the prize of the pizza given the pizza and optional extras\n *\n * @param {Pizza} pizza name of the pizza to be made\n * @param {Extra[]} extras list of extras\n *\n * @returns {number} the price of the pizza\n */\nexport function pizzaPrice(pizza, ...[extra, ...otherExtras]) {\n  switch (extra) {\n    case 'ExtraSauce': {\n      return 1 + pizzaPrice(pizza, ...otherExtras);\n    }\n    case 'ExtraToppings': {\n      return 2 + pizzaPrice(pizza, ...otherExtras);\n    }\n    default: {\n      return PIZZA_PRICES[pizza];\n    }\n  }\n}\n\n/**\n * Calculate the prize of the total order, given individual orders\n *\n * @param {PizzaOrder[]} pizzaOrders a list of pizza orders\n * @returns {number} the price of the total order\n */\nexport function orderPrice(pizzaOrders) {\n  return pizzaOrders.reduce(\n    (result, order) => result + pizzaPrice(order.pizza, ...order.extras),\n    0,\n  );\n}\n",
  "tests": "import { describe, expect, test } from '@jest/globals';\nimport { orderPrice, pizzaPrice } from './pizza-order';\n\nclass PizzaOrder {\n  /**\n   *\n   * @param {Pizza} pizza\n   * @param  {Extra[]} extras\n   */\n  constructor(pizza, ...extras) {\n    this.pizza = pizza;\n    this.extras = Object.freeze(extras);\n\n    Object.freeze(this);\n  }\n}\n\ndescribe('Price for pizza margherita', () => {\n  test(\"pizzaPrice('Margherita')\", () => {\n    expect(pizzaPrice('Margherita')).toBe(7);\n  });\n});\n\ndescribe('Price for pizza formaggio', () => {\n  test(\"pizzaPrice('Formaggio')\", () => {\n    expect(pizzaPrice('Formaggio')).toBe(10);\n  });\n});\n\ndescribe('Price for pizza caprese', () => {\n  test(\"pizzaPrice('Caprese')\", () => {\n    expect(pizzaPrice('Caprese')).toBe(9);\n  });\n});\n\ndescribe('Price for pizza margherita with extra sauce', () => {\n  test(\"pizzaPrice('Margherita', 'ExtraSauce')\", () => {\n    expect(pizzaPrice('Margherita', 'ExtraSauce')).toBe(8);\n  });\n});\n\ndescribe('Price for pizza caprese with extra toppings', () => {\n  test(\"pizzaPrice('Caprese', 'ExtraToppings')\", () => {\n    expect(pizzaPrice('Caprese', 'ExtraToppings')).toBe(11);\n  });\n});\n\ndescribe('Price for pizza formaggio with extra sauce and toppings', () => {\n  test(\"pizzaPrice('Formaggio', 'ExtraSauce', 'ExtraToppings')\", () => {\n    expect(pizzaPrice('Formaggio', 'ExtraSauce', 'ExtraToppings')).toBe(13);\n  });\n});\n\ndescribe('Price for pizza caprese with extra sauce and toppings', () => {\n  test(\"pizzaPrice('Caprese', 'ExtraSauce', 'ExtraToppings')\", () => {\n    expect(pizzaPrice('Caprese', 'ExtraSauce', 'ExtraToppings')).toBe(12);\n  });\n});\n\ndescribe('Price for pizza caprese with a lot of extra toppings', () => {\n  test(\"pizzaPrice('Caprese', 'ExtraToppings', 'ExtraToppings', 'ExtraToppings', 'ExtraToppings')\", () => {\n    expect(\n      pizzaPrice(\n        'Caprese',\n        'ExtraToppings',\n        'ExtraToppings',\n        'ExtraToppings',\n        'ExtraToppings',\n      ),\n    ).toBe(17);\n  });\n});\n\ndescribe('Order price for no pizzas', () => {\n  test('orderPrice([])', () => {\n    expect(orderPrice([])).toBe(0);\n  });\n});\n\ndescribe('Order price for a single pizza caprese', () => {\n  test(\"orderPrice([PizzaOrder('Caprese')])\", () => {\n    const order = new PizzaOrder('Caprese');\n    expect(orderPrice([order])).toBe(9);\n  });\n});\n\ndescribe('Order price for a single pizza formaggio with extra sauce', () => {\n  test(\"orderPrice([PizzaOrder('Formaggio', 'ExtraSauce')])\", () => {\n    const order = new PizzaOrder('Formaggio', 'ExtraSauce');\n    expect(orderPrice([order])).toBe(11);\n  });\n});\n\ndescribe('Order price for one pizza margherita and one pizza caprese with extra toppings', () => {\n  test(\"orderPrice([PizzaOrder('Margherita'), PizzaOrder('Caprese', 'ExtraToppings')])\", () => {\n    const margherita = new PizzaOrder('Margherita');\n    const caprese = new PizzaOrder('Caprese', 'ExtraToppings');\n\n    expect(orderPrice([margherita, caprese])).toBe(18);\n\n    // Also test that the order doesn't matter\n    expect(orderPrice([caprese, margherita])).toBe(18);\n  });\n});\n\ndescribe('Order price for one pizza margherita with a LOT of sauce and one pizza caprese with a LOT of toppings', () => {\n  test(\"orderPrice([PizzaOrder('Margherita', 'ExtraSauce', 'ExtraSauce', 'ExtraSauce'), PizzaOrder('Caprese', 'ExtraToppings', 'ExtraToppings', 'ExtraToppings', 'ExtraToppings')])\", () => {\n    const saucyMargherita = new PizzaOrder(\n      'Margherita',\n      'ExtraSauce',\n      'ExtraSauce',\n      'ExtraSauce',\n    );\n    const toppedCaprese = new PizzaOrder(\n      'Caprese',\n      'ExtraToppings',\n      'ExtraToppings',\n      'ExtraToppings',\n      'ExtraToppings',\n    );\n\n    expect(orderPrice([saucyMargherita, toppedCaprese])).toBe(27);\n\n    // Also test that the order doesn't matter\n    expect(orderPrice([toppedCaprese, saucyMargherita])).toBe(27);\n  });\n});\n\ndescribe('Order price for very large order', () => {\n  test('orderPrice([/* lots of */])', () => {\n    const margherita = new PizzaOrder('Margherita');\n    const margherita2 = new PizzaOrder('Margherita', 'ExtraSauce');\n    const caprese = new PizzaOrder('Caprese');\n    const caprese2 = new PizzaOrder('Caprese', 'ExtraToppings');\n    const formaggio = new PizzaOrder('Formaggio');\n    const formaggio2 = new PizzaOrder('Formaggio', 'ExtraSauce');\n    const formaggio3 = new PizzaOrder(\n      'Formaggio',\n      'ExtraSauce',\n      'ExtraToppings',\n    );\n    const formaggio4 = new PizzaOrder(\n      'Formaggio',\n      'ExtraToppings',\n      'ExtraSauce',\n      'ExtraToppings',\n      'ExtraSauce',\n    );\n\n    const actual = orderPrice([\n      margherita,\n      margherita2,\n      caprese,\n      caprese2,\n      formaggio,\n      formaggio2,\n      formaggio3,\n      formaggio4,\n    ]);\n    expect(actual).toBe(85);\n  });\n});\n\ndescribe('Order price for a gigantic order', () => {\n  test('orderPrice([/* lots of */])', () => {\n    const allTheMargheritas = Array(100 * 1000).fill(\n      new PizzaOrder('Margherita'),\n    );\n    const actual = orderPrice(allTheMargheritas);\n    expect(actual).toBe(700 * 1000);\n  });\n});\n"
}