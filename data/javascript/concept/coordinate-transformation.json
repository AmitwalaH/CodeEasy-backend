{
  "language": "javascript",
  "slug": "coordinate-transformation",
  "title": "Coordinate Transformation",
  "docs": {
    "introduction": "# Introduction\n\n**Closures** are a programming pattern in JavaScript which allows variables from an outer [lexical scope][wiki-lexical-scope] to be used inside of a nested block of code.\nJavaScript supports closures transparently, and they are often used without knowing what they are.\n\n```javascript\n// Top-level declarations are global-scope\nconst dozen = 12;\n\n{\n  // Braces create a new block-scope\n  // Referencing the outer variable is a closure.\n  const twoDozen = dozen * 2;\n}\n\n// Because of the block-scope declaration, twoDozen is not available here.\ntwoDozen;\n// => Uncaught ReferenceError: twoDozen is not defined\n```\n\nExcept for braces `{}`, functions (and classes) als create new scopes, which can _enclose_ values:\n\n```javascript\nconst dozen = 12;\n\n// Functions create a new function-scope and block-scope.\n// Referencing the outer variable here is a closure.\nfunction nDozen(n) {\n  // This is declared inside the function scope, and uses the top-level scope.\n  // This works, and encloses the value 12.\n  const twoDozen = dozen * 2;\n\n  // This only uses the locally declared variable and the passed argument to the parameter `n`\n  return (twoDozen / 2) * n;\n}\n\n// Because of the function-scope declaration, twoDozen is not available here.\ntwoDozen;\n// => Uncaught ReferenceError: twoDozen is not defined\n```\n\nAs the `twoDozen` examples show, values can be enclosed in a _nested_ scope (function, block, etc.), but cannot be pulled out of that context.\nIn the majority of cases, it is intended in Modern JavaScript that a value does not _leak_ to an outside scope.\n\n## Closures to save state and pass along values\n\nUsing a mutable variable declaration (like `let` or `var`) allows for some state to be preserved:\n\n```javascript\nlet counter = 0;\n\n// This function closure increments the counter's state in the outer lexical context.\n// This way the counter can be shared between many calling contexts.\nexport function increment() {\n  counter += 1;\n  return counter;\n}\n\nincrement();\n// => 1\n\ncounter;\n// => 1\n```\n\n## Enclosing values without leaking the state\n\nCombining the two ideas: enclosing a value to preserve state, and enclosed values do not leak to the outside, it's possible to create private values.\n\nThe most common method is to make a function that returns a function which encloses some state.\n\n```javascript\nexport function makeCounter() {\n  let counter = 0;\n\n  // This returns a new function that encloses the local variable counter\n  return function increment() {\n    counter += 1;\n    return counter;\n  };\n}\n\n// Counter did not leak\ncounter;\n// => Uncaught ReferenceError: counter is not defined\n\n// This creates a new counter.\n// This assigns the increment function to the variable myFirstCounter.\nconst myFirstCounter = makeCounter();\n\ntypeof myFirstCounter;\n// => function\n\nmyFirstCounter.name;\n// => increment\n\nmyFirstCounter();\n// => 1\nmyFirstCounter();\n// => 2\n\n// This creates new counter (with new, separate local state / enclosed counter variable)\nconst mySecondCounter = makeCounter();\n\nmySecondCounter();\n// => 1\n\n// It does not affect the first counter.\n\nmyFirstCounter();\n// => 3\n```\n\n```exercism/note\nMany programmers find closures a hard concept, and returning a function from a function is not common or not even possible in all programming languages.\nIf you want more reading material, the [guide on MDN on Closures][mdn-closures] is quite comprehensive.\n\n[mdn-closures]: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Closures\n```\n\n[wiki-lexical-scope]: https://en.wikipedia.org/wiki/Scope_(computer_science)#Lexical_scoping\n",
    "instructions": "# Instructions\n\nYour design company has primarily been working with CSS transformations to build web pages. After some discussion, a decision is made\nto start using JavaScript to perform some calculations dynamically. Some of your teammates are less experienced with JavaScript,\nso you decide to use a function closure to create reusable transformation for `{x, y}` coordinate pairs.\n\n## 1. Translate the coordinates\n\nImplement the `translate2d` function that returns a function making use of a closure to perform a repeatable 2d translation of a coordinate pair.\n\n> In Geometry, [translation][wiki-translate] refers to moving points, vectors or shapes the same distance in one direction.\n> It can be interpreted as addition of a constant to every point.\n\n```javascript\nconst moveCoordinatesRight2Px = translate2d(2, 0);\nconst result = moveCoordinatesRight2Px(4, 8);\n// result => [6, 8]\n```\n\n## 2. Scale the coordinates\n\nImplement the `scale2d` function that returns a function making use of a closure to perform a repeatable 2d scale of a coordinate pair.\n\n> In geometry, uniform [scaling][wiki-scale] refers to enlarging or shrinking vectors or shapes in the same direction.\n> It can be interpreted as multiplying every point by a constant (scaling factor).\n>\n> For this exercise, assume only positive scaling values.\n\n```javascript\nconst doubleScale = scale2d(2, 2);\nconst result = doubleScale(6, -3);\n// result => [12, -6]\n```\n\n## 3. Compose transformation functions\n\nCombine two transformation functions to perform a repeatable transformation. This is often called _function composition_, where the result of the first function _'f(x)'_ is used as the input to the second function _'g(x)'_.\n\n```javascript\nconst moveCoordinatesRight2Px = translate2d(2, 0);\nconst doubleCoordinates = scale2d(2, 2);\nconst composedTransformations = composeTransform(\n  moveCoordinatesRight2Px,\n  doubleCoordinates,\n);\nconst result = composedTransformations(0, 1);\n// result => [4, 2]\n```\n\n## 4. Save the results of functions\n\nImplement the `memoizeTransform` function. It takes a function to _memoize_, then returns a new function that remembers the inputs to the supplied function so that the last return value can be \"remembered\" and only calculated once if it is called again with the same arguments.\n\n> Memoizing is sometimes used in _dynamic programming_.\n> It allows for expensive operations to be done only once since their results are remembered.\n> **Note** that in this exercise only the last result is remembered, unlike some solutions in dynamic programming that memoize _all_ results.\n\n```javascript\nconst tripleScale = scale2d(3, 3);\nconst memoizedScale = memoizeTransform(tripleScale);\n\nmemoizedScale(4, 3); // => [12, 9], this is computed since it hasn't been computed before for the arguments\nmemoizedScale(4, 3); // => [12, 9], this is remembered, since it was computed already\n```\n\n[wiki-translate]: https://en.wikipedia.org/wiki/Translation_(geometry)\n[wiki-scale]: https://en.wikipedia.org/wiki/Scaling_(geometry)\n",
    "hints": "# Hints\n\n## General\n\n- For each task, each function should return a function closure, using the supplied arguments.\n\n## 1. Translate the coordinates\n\n- The supplied arguments provide the amount to translate the coordinate pair along the _x_ and _y_ axis.\n\n## 2. Scale the coordinates\n\n- The supplied arguments provide the amount to scale the coordinate pair for the _x_ and _y_ axis.\n\n## 3. Compose transformation functions\n\n- The result of the first transformation is an array, but the transformation functions take two number arguments. You will have to get the values from the array.\n- Remember that the order in which the functions are performed matters.\n\n## 4. Save the results of functions\n\n- For this function, you only have to memoize the result of the last transformation.\n- In order to send back the result of the last transformation, you will have to check if the input arguments are the same.\n"
  },
  "starter_code": "// @ts-check\n\n/**\n * Create a function that returns a function making use of a closure to\n * perform a repeatable 2d translation of a coordinate pair.\n *\n * @param {number} dx the translate x component\n * @param {number} dy the translate y component\n *\n * @returns {function} a function which takes an x, y argument, returns the\n *  translated coordinate pair in the form [x, y]\n */\nexport function translate2d(dx, dy) {\n  return function (x, y) {\n    return [x + dx, y + dy];\n  };\n}\n\n/**\n * Create a function that returns a function making use of a closure to\n * perform a repeatable 2d scale of a coordinate pair.\n *\n * @param {number} sx the amount to scale the x component\n * @param {number} sy the amount to scale the y component\n *\n * @returns {function} a function which takes an x, y argument, returns the\n *  scaled coordinate pair in the form [x, y]\n */\nexport function scale2d(sx, sy) {\n  return function (x, y) {\n    return [x * sx, y * sy];\n  };\n}\n\n/**\n * Create a composition function that returns a function that combines two\n * functions to perform a repeatable transformation\n *\n * @param {function} f the first function to apply\n * @param {function} g the second function to apply\n *\n * @returns {function} a function which takes an x, y argument, returns the\n *  transformed coordinate pair in the form [x, y]\n */\nexport function composeTransform(f, g) {\n  return function (x, y) {\n    const fResult = f(x, y);\n    return g(fResult[0], fResult[1]);\n  };\n}\n\n/**\n * Return a function that memoizes the last result.  If arguments are the same,\n * then memoized result returned.\n *\n * @param {function} f the transformation function to memoize, assumes takes two arguments 'x' and 'y'\n *\n * @returns {function} a function which takes x and y arguments, and will either return the saved result\n *  if the arguments are the same on subsequent calls, or compute a new result if they are different.\n */\nexport function memoizeTransform(f) {\n  let lastX = undefined;\n  let lastY = undefined;\n  let lastResult = undefined;\n\n  return function (x, y) {\n    if (x === lastX && y === lastY) {\n      return lastResult;\n    }\n\n    lastX = x;\n    lastY = y;\n    lastResult = f(x, y);\n    return lastResult;\n  };\n}\n",
  "tests": "import { describe, expect, test, jest } from '@jest/globals';\nimport {\n  composeTransform,\n  memoizeTransform,\n  scale2d,\n  translate2d,\n} from './coordinate-transformation';\n\nconst fakeTransform = () => {\n  let first = true;\n\n  return () => {\n    if (first) {\n      first = false;\n      return [1, 1];\n    }\n\n    return false;\n  };\n};\n\ndescribe('translate2d', () => {\n  test('should return a function', () => {\n    expect(typeof translate2d(0, 0)).toBe('function');\n  });\n\n  const dx = 3;\n  const dy = -5;\n  const x1 = 0;\n  const y1 = 0;\n  const expected = [3, -5];\n  test('should be predictable', () => {\n    const translator = translate2d(dx, dy);\n    expect(translator(x1, y1)).toEqual(expected);\n  });\n\n  const x2 = 4;\n  const y2 = 5;\n  const reusedExpected = [7, 0];\n  test('should be reusable', () => {\n    const translator = translate2d(dx, dy);\n    translator(x1, y1);\n    expect(translator(x2, y2)).toEqual(reusedExpected);\n  });\n});\n\ndescribe('scale2d', () => {\n  test('should return a function', () => {\n    expect(typeof scale2d(0, 0)).toBe('function');\n  });\n\n  const dx = 4;\n  const dy = 2;\n  const x1 = 1;\n  const y1 = 1;\n  const expected = [4, 2];\n  test('should be predictable', () => {\n    const scaler = scale2d(dx, dy);\n    expect(scaler(x1, y1)).toEqual(expected);\n  });\n\n  const x2 = -2;\n  const y2 = 5;\n  const reusedExpected = [-8, 10];\n  test('should be reusable', () => {\n    const scaler = scale2d(dx, dy);\n    scaler(x1, y1);\n    expect(scaler(x2, y2)).toEqual(reusedExpected);\n  });\n});\n\ndescribe('composeTransform', () => {\n  const dx = -6;\n  const dy = 10;\n  const sx = 3;\n  const sy = 2;\n\n  test('should return a function', () => {\n    const translator = translate2d(dx, dy);\n    const scaler = scale2d(sx, sy);\n    expect(typeof composeTransform(translator, scaler)).toBe('function');\n  });\n\n  test('should compose two translate functions', () => {\n    const translator = translate2d(dx, dy);\n    const composeTranslate = composeTransform(translator, translator);\n    expect(composeTranslate(0, 0)).toEqual([-12, 20]);\n  });\n\n  test('should compose two scale functions', () => {\n    const scaler = scale2d(sx, sy);\n    const composeScale = composeTransform(scaler, scaler);\n    expect(composeScale(1, 1)).toEqual([9, 4]);\n  });\n\n  test('should compose in the correct order: g(f(x))', () => {\n    const translator = translate2d(dx, dy);\n    const scaler = scale2d(sx, sy);\n    const composed = composeTransform(scaler, translator);\n    expect(composed(0, 0)).toEqual([-6, 10]);\n  });\n\n  test('should compose in the opposite order: f(g(x))', () => {\n    const translator = translate2d(dx, dy);\n    const scaler = scale2d(sx, sy);\n    const composed = composeTransform(translator, scaler);\n    expect(composed(0, 0)).toEqual([-18, 20]);\n  });\n});\n\ndescribe('memoizeTransform', () => {\n  test('should return a function', () => {\n    expect(typeof memoizeTransform(translate2d(0, 0))).toBe('function');\n  });\n\n  test('should return the same result if given the same input', () => {\n    const memoizedTranslate = memoizeTransform(translate2d(2, 2));\n    expect(memoizedTranslate(2, 2)).toEqual([4, 4]);\n    expect(memoizedTranslate(2, 2)).toEqual([4, 4]);\n  });\n\n  test('should return different results for different inputs', () => {\n    const memoizedTranslate = memoizeTransform(translate2d(1, 2));\n    expect(memoizedTranslate(2, 2)).toEqual([3, 4]);\n    expect(memoizedTranslate(2, 1)).toEqual([3, 3]);\n    expect(memoizedTranslate(6, 6)).toEqual([7, 8]);\n  });\n\n  test('should not call the memoized function if the input is the same', () => {\n    const memoizedTransform = memoizeTransform(fakeTransform());\n    expect(memoizedTransform(5, 5)).toEqual([1, 1]);\n    expect(memoizedTransform(5, 5)).toEqual([1, 1]);\n  });\n\n  test('should only remember the last result', () => {\n    const mockFunction = jest.fn((x, y) => [x * 2, y * 2]);\n    const memoizedTransform = memoizeTransform(mockFunction);\n    expect(memoizedTransform(1, 1)).toEqual([2, 2]);\n    expect(memoizedTransform(2, 2)).toEqual([4, 4]);\n    expect(memoizedTransform(1, 1)).toEqual([2, 2]);\n    expect(mockFunction).toHaveBeenCalledTimes(3);\n  });\n\n  test('should recalculate when a new function is passed in', () => {\n    const sumFunction = (x, y) => x + y;\n    const differenceFunction = (x, y) => x - y;\n    const memoizedSum = memoizeTransform(sumFunction);\n    const memoizedDifference = memoizeTransform(differenceFunction);\n\n    expect(memoizedSum(1, 2)).toEqual(3);\n    expect(memoizedDifference(1, 2)).toEqual(-1);\n  });\n});\n"
}