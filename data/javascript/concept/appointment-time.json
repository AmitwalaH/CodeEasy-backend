{
  "language": "javascript",
  "slug": "appointment-time",
  "title": "Appointment Time",
  "docs": {
    "introduction": "# Introduction\n\nJavaScript has a built-in object `Date` which stores date and time, and provides methods for their management.\n\n<!-- prettier-ignore -->\n~~~exercism/caution\nIt was based on Java's `java.util.Date` class, which was replaced in the early 2010s, but for backwards compatibility, JavaScript's `Date` sticks around.\n\nBecause of how hard it is to work with Dates in general and because of how bad or non-existing timezone handling is, many libraries exist such as `moment.js`, `day.js`, `date-fns` and `luxon`.\nNone of these are available on Exercism.\n\nIn your own projects, do not use a deprecated / unmaintained package such as `moment.js` but rely on more modern alternatives like `luxon`, or the not yet widely available [Temporal][mdn-temporal].\nThis exercise focusses on `Date`, which will remain relevant until the end of JavaScript.\n\n[mdn-temporal]: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Temporal\n~~~\n\n## Creation\n\nA `Date` object is an instance of the `Date` class.\nIt can be created without passing any arguments to the constructor function.\nThis results in a `Date` object that represents the current date and time:\n\n```javascript\nconst now = new Date();\n// => Thu Apr 14 2022 11:46:08 GMT+0530 (India Standard Time)\n// Shows current day, date and time (in your time zone).\n```\n\n### **Unix timestamp (number)**\n\nIf a number is passed in, this will be interpreted as a `timestamp`.\nA timestamp is an integer number representing the number of **milliseconds** that has passed since **1 January 1970 [UTC][defn-utc]+0**.\n\n```javascript\nconst epoch = new Date(0);\n// Thu Jan 01 1970 01:00:00 GMT+0100 (Central European Standard Time)\n\nconst another = new Date(1749508766627);\n// Tue Jun 10 2025 00:39:26 GMT+0200 (Central European Summer Time)\n```\n\nOne may expect `new Date(0)` to generate the \"earliest\" date object, but JavaScript will convert the date to your local timezone, which means that only those around [GMT / with an UTC+0][defn-gmt] timezone will actually get the [Unix epoch][defn-unix-epoch] value.\n\n### **ISO 8601 timestamp (string)**\n\nYou can pass a string value representing a date to the `Date` constructor.\nThe **only** format that is consistent across implementations is the [simplified version][mdn-date-string-format] of the internationally recognized and standardized so-called [ISO 8601 timestamp strings][defn-iso8601].\n\nA moment in time at [UTC][defn-gmt] looks like this:\n\n```text\nYYYY-MM-DDTHH:mm:ss.mssZ\nYYYYMMDDTHHmmss.mssZ\n```\n\nWhere the following substitutions take place:\n\n| Key  | Description                                   | Default |\n| ---- | --------------------------------------------- | ------- |\n| YYYY | The calendar year, represented in 4 digits    |         |\n| MM   | The calendar month, represented in 2 digits   | 01      |\n| DD   | The calendar day, represented in 2 digits     | 01      |\n| T    | A literal letter T, separating date from time |         |\n| HH   | The hours in a 24-hour clock, 2 digits        | 00      |\n| mm   | The minutes, 2 digits                         | 00      |\n| ss   | The seconds, 2 digits                         | 00      |\n| mss  | The milliseconds, 3 digits                    | 000     |\n| Z    | A literal letter Z, or an offset `+/-HH:mm`   |         |\n\nThe literal letter `Z` indicates UTC (no timezone, no Day Light Savings).\n\nBecause there are default values for most components, leaving parts off at the end is valid:\n\n```text\nYYYY-MM-DD\n```\n\nDefaults to a time of 00:00:00.000\n\nIf the timestamp does not end in `Z`, and it does not end with `+HH:mm` or `-HH:mm` (indicating a timezone offset), because of historical reasons, the following applies:\n\n> When the time zone offset is absent, date-only forms are interpreted as a UTC time and date-time forms are interpreted as a local time.\n> The interpretation as a UTC time is due to a historical spec error that was not consistent with ISO 8601 but could not be changed due to web compatibility.\n> See [Broken Parser â€“ A Web Reality Issue][ref-broken-parser].\n\n<!-- prettier-ignore -->\n~~~exercism/caution\nOther formats that are accepted by `Date.parse` may or may not work.\nWhen working with Dates in JavaScript, _always_ use an ISO 8601 timestamp when converting from a `string` to a `Date`.\n\nDate-only forms are allowed, but not all ISO 8601 formats are supported.\nConsult the [simplified version explanation page on MDN][mdn-date-string-format].\n\n[mdn-date-string-format]: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Date#date_time_string_format\n~~~\n\n### **Date object**\n\nAn existing date object can also be used as a constructor argument.\nThis makes a copy of the existing `Date` object with the same date and time.\n\n```javascript\nconst t1 = new Date();\nconst t2 = new Date(t1);\n// Values of t1 and t2 will be the same.\n```\n\n### **Supplying individual date and time component values**\n\nA date representing a date can be created by passing three numbers.\nA date representing a date and time can be created by passing in 6 numbers.\n\n```javascript\nconst date1 = new Date(95, 11, 17);\n// Creates Date for Dec 17 1995 00:00 if your local timezone is equivalent to UTC.\n\nconst date2 = new Date(2013, 12, 5, 13, 24, 0);\n// Creates Date for Jan 5 2014 13:24 if your local timezone is equivalent to UTC.\n```\n\nThe second value is the `month`, which starts at `0` for January, up to `11` for December.\n\n## `Date.parse()`\n\nYou may find mentions of or references to a date parsing function `Date.parse`.\nBecause there are only a few invariants (truths) for this function and because the rest of the implementation is not specified (and thus not standard), one should not use it.\n\n## Accessing `Date` components\n\nThere are various methods on date objects that return the components of the date:\n\n```javascript\ngetFullYear(); // Get the year (4 digits)\ngetMonth(); // Get the month, from 0 to 11.\ngetDate(); // Get the day of month, from 1 to 31.\ngetHours(); // Get the hour in a 24 clock, from 0 to 23\ngetMinutes(); // Get the minutes, from 0 to 59\ngetSeconds(); // Get the seconds, from 0 to 59\ngetMilliseconds(); // Get the milliseconds, from 0 and 999\ngetDay(); // Get the day of week, from 0 (Sunday) to 6 (Saturday).\n```\n\nEach of these has an applicable `set` variant (e.g. `setFullYear`) to update the value.\nAny overflowing value rolls over to the next component:\n\n```javascript\nconst date = new Date('2025-02-28T12:42:00Z');\n// => Fri Feb 28 2025 13:42:00 GMT+0100 (Central European Standard Time)\n\ndate.setDate(29);\n// there was no February 29th in 2025.\n\ndate.getDate();\n// => 1\n\ndate.toString();\n// => Sat Mar 01 2025 13:42:00 GMT+0100 (Central European Standard Time)\n```\n\nThere are UTC variants for all the methods that disregard the local timezone.\n\n## Converting from date\n\nDate objects have a method `getTime()` that returns the UNIX timestamp in milliseconds, ie. amount of milliseconds the midnight at the beginning of January 1, 1970, UTC.\nAdditionally, a method `toISOString()` is available to convert from a date object to a ISO 8601 timestamp string.\n\n## Comparing Dates\n\nGreater than (`>`) and greater than or equals (`>=`) as well as less than (`<`) and less than or equals (`<=`) can be used directly between two dates or a date and a number.\nThis works because JavaScript will try to coerce the date to a primitive.\n\n<!-- prettier-ignore -->\n~~~exercism/advanced\nWhen doing a comparison between two dates or date and a number, JavaScript calls [`[Symbol.toPrimitive](\"number\")`][mdn-to-primitive] which internally calls [`date.valueOf()`][mdn-date-value-of].\nThe latter is the same as calling [`date.getTime()`][mdn-date-get-time].\n\nIf you do not want to rely on this behaviour, convert to a number using `getTime()` first.\n\n[mdn-to-primitive]: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Date/Symbol.toPrimitive\n[mdn-date-value-of]: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Date/valueOf\n[mdn-date-get-time]: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Date/getTime\n~~~\n\nDates cannot be compared using equality (`==`, and `===`), but the result of `.getTime()` can.\n\n[defn-utc]: https://simple.wikipedia.org/wiki/Coordinated_Universal_Time\n[defn-gmt]: https://simple.wikipedia.org/wiki/Greenwich_Mean_Time\n[defn-unix-epoch]: https://en.wikipedia.org/wiki/Epoch_%28computing%29\n[defn-iso8601]: https://en.wikipedia.org/wiki/ISO_8601\n[mdn-date-string-format]: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Date#date_time_string_format\n[ref-broken-parser]: https://maggiepint.com/2017/04/11/fixing-javascript-date-web-compatibility-and-reality/\n",
    "instructions": "# Instructions\n\nIn this exercise you will work on some functions in order to manage appointments.\nThe system stores everything in ISO 8601 formatted strings, but that's not how people use the calendar.\nVarious functions are necessary to convert between the various formats.\n\n## 1. Create an appointment\n\nCreate an appointment `n` days from now at current time.\nThe function takes `n` days and return the appointment time of `n` days from now.\n\n```javascript\ncreateAppointment(4, now);\n// Given now is Sun Oct 05 2022 23:28:43 GMT+0600 (Bangladesh Standard Time)\n// => Sun Oct 09 2022 23:28:43 GMT+0600 (Bangladesh Standard Time)\n```\n\nIf the second parameter `now` is unused, the current time should be used instead.\n\n## 2. Convert a date into a timestamp\n\nVarious tools only work with the internationally standardized ISO 8601 format.\nWrite the function `getAppointmentTimestamp` to take a date and return a string in that format.\n\n```javascript\nconst appointment = new Date(Date.UTC(2010, 6, 16, 12, 42, 0, 0));\n\ngetAppointmentTimestamp(appointment);\n// => '2010-07-16T12:42:00.000Z'\n```\n\n## 3. Get the details of an appointment\n\nTimestamps are hard to read; a function to get the appointment details should help with that.\nThe function `getAppointmentDetails` takes a timestamp in the ISO 8601 format, and returns the year, month, date, hour, and minute.\n\n```javascript\ngetAppointmentDetails('2022-04-24T08:15:00.000');\n// => { year: 2022, month: 3, date: 24, hour: 8, minute: 15 }\n```\n\n## 4. Update an appointment with the given options\n\nThe function will receive first argument as appointment time and second argument of object of some options.\nYou have to update the appointment according to the options in the object and return the new appointment date.\nThe options object could have multiple options.\n\n```javascript\nupdateAppointment('2022-02-09T09:20:00.000', { month: 6 });\n// => { year: 2022, month: 6, date: 9, hour: 10, minute: 20 }\n```\n\n## 5. Get the available time between two appointments\n\nThe function will receive two appointments (timestamps) as arguments.\nYou have to return the difference between those two times in seconds.\n\nBecause half a second is almost meaningless, round the number before returning it.\n\n```javascript\ntimeBetween('2022-12-12T09:20:00.000', '2022-12-18T08:30:00.000');\n// => 515400\n```\n\n## 6. Check if an appointment is now valid or not\n\nFinally, when the appointment is made, the system needs to check if it's valid.\nIn other words, the appointment must be in the future, and not the past.\n\nWrite the function `isValid` which takes two arguments, an appointment timestamp (string), and the current time as a timestamp (string) and returns `true` if the appointment is in the future, given the current time.\n\n```javascript\nisValid('2022-02-11T23:00:00.000', '2022-02-08T23:00:00.000');\n// => true\n```\n",
    "hints": "# Hints\n\n## 1. Create an appointment\n\n- You need to create a new date. The introduction elaborates on the different ways.\n- `Date.now()` gives you current time in milliseconds\n- `Date` has several getter methods, listed in the introduction, to get date components. Can you use one of those methods?\n- Likewise, `Date` has matching setter methods to set those components, rolling over into \"higher\" components if needed.\n\n## 2. Convert a date into a timestamp\n\n- The introduction lists the various ways how to convert a date to different types. Can you use one of those methods?\n\n## 3. Get the details of an appointment\n\n- The introduction has all the required information to extract the information from a date.\n\n## 4. Update an appointment with the given options\n\n- The introduction has all the required information to extract the information from a date.\n- You can reuse `getAppointmentDetails`\n\n## 5. Get available times between two appointments\n\n- General subtraction between two dates will give you the timestamp between the two dates.\n- You probably want to convert to a number first, and not rely on type-coercion.\n\n## 6. Check if an appointment is now valid or not\n\n- Conditional operators will help you to decide which date is bigger or smaller between two dates.\n"
  },
  "starter_code": "// @ts-check\n\n/**\n * Create an appointment\n *\n * @param {number} days\n * @param {number} [now] (ms since the epoch, or undefined)\n *\n * @returns {Date} the appointment\n */\nexport function createAppointment(days, now = Date.now()) {\n  const date = new Date(now);\n  date.setDate(date.getDate() + days);\n\n  return date;\n}\n\n/**\n * Generate the appointment timestamp\n *\n * @param {Date} appointmentDate\n *\n * @returns {string} timestamp\n */\nexport function getAppointmentTimestamp(appointmentDate) {\n  return appointmentDate.toISOString();\n}\n\n/**\n * Get details of an appointment\n *\n * @param {string} timestamp (ISO 8601)\n *\n * @returns {Record<'year' | 'month' | 'date' | 'hour' | 'minute', number>} the appointment details\n */\nexport function getAppointmentDetails(timestamp) {\n  const appointmentDate = new Date(timestamp);\n\n  return {\n    year: appointmentDate.getFullYear(),\n    month: appointmentDate.getMonth(),\n    date: appointmentDate.getDate(),\n    hour: appointmentDate.getHours(),\n    minute: appointmentDate.getMinutes(),\n  };\n}\n\n/**\n * Update an appointment with given options\n *\n * @param {string} timestamp (ISO8601)\n * @param {Partial<Record<'year' | 'month' | 'date' | 'hour' | 'minute', number>>} options\n *\n * @returns {Record<'year' | 'month' | 'date' | 'hour' | 'minute', number>} the appointment details\n */\nexport function updateAppointment(timestamp, options) {\n  let appointmentDate = new Date(timestamp);\n\n  if (options.year !== undefined) appointmentDate.setFullYear(options.year);\n  if (options.month !== undefined) appointmentDate.setMonth(options.month);\n  if (options.date !== undefined) appointmentDate.setDate(options.date);\n  if (options.hour !== undefined) appointmentDate.setHours(options.hour);\n  if (options.minute !== undefined) appointmentDate.setMinutes(options.minute);\n\n  return getAppointmentDetails(appointmentDate.toISOString());\n}\n\n/**\n * Get available time in seconds (rounded) between two appointments\n *\n * @param {string} timestampA (ISO 8601)\n * @param {string} timestampB (ISO 8601)\n *\n * @returns {number} amount of seconds (rounded)\n */\nexport function timeBetween(timestampA, timestampB) {\n  return Math.round(\n    (new Date(timestampB).getTime() - new Date(timestampA).getTime()) / 1000,\n  );\n}\n\n/**\n * Checks if the appointment is in the past\n *\n * @param {string} appointmentTimestamp (ISO 8601)\n * @param {string} currentTimestamp (ISO 8601)\n */\nexport function isValid(appointmentTimestamp, currentTimestamp) {\n  return new Date(appointmentTimestamp) > new Date(currentTimestamp);\n}\n",
  "tests": "import { describe, test, expect } from '@jest/globals';\n\nimport {\n  createAppointment,\n  getAppointmentTimestamp,\n  getAppointmentDetails,\n  isValid,\n  updateAppointment,\n  timeBetween,\n} from './appointment-time';\n\ndescribe('createAppointment', () => {\n  test('uses the passed in current time', () => {\n    const currentTime = Date.UTC(2000, 6, 16, 12, 0, 0, 0);\n    const result = createAppointment(0, currentTime);\n\n    expect(result).toEqual(new Date(currentTime));\n  });\n\n  test('uses the actual current time when it is not passed in', () => {\n    const currentTime = Date.now();\n    const result = createAppointment(0);\n\n    expect(result).toEqual(new Date(currentTime));\n  });\n\n  test('creates appointment without DST change', () => {\n    const offset = 4; // days\n\n    const currentTime = Date.UTC(2000, 6, 1, 12, 0, 0, 0);\n    const expectedTime = currentTime + offset * 24 * 60 * 60 * 1000;\n\n    expect(createAppointment(offset, currentTime)).toEqual(\n      new Date(expectedTime),\n    );\n  });\n\n  test('creates appointment with potential DST change', () => {\n    const offset = 180; // days\n\n    const currentTime = Date.UTC(2000, 6, 1, 12, 0, 0, 0);\n    let expectedTime = currentTime + offset * 24 * 60 * 60 * 1000;\n    // Manually adjust for DST timezone offset:\n    expectedTime +=\n      (new Date(expectedTime).getTimezoneOffset() -\n        new Date(currentTime).getTimezoneOffset()) *\n      60 *\n      1000;\n\n    expect(createAppointment(offset, currentTime)).toEqual(\n      new Date(expectedTime),\n    );\n  });\n\n  test('rolls over days, months, and years', () => {\n    const currentTime = Date.UTC(1991, 16, 6, 2, 12, 0, 0);\n    const result = createAppointment(720, currentTime);\n\n    expect(result.getTime()).toStrictEqual(767326320000);\n  });\n});\n\ndescribe('getAppointmentTimestamp', () => {\n  test('returns the correct timestamp', () => {\n    const currentTime = new Date(Date.UTC(2000, 6, 16, 12, 0, 0, 0));\n\n    expect(getAppointmentTimestamp(currentTime)).toEqual(\n      '2000-07-16T12:00:00.000Z',\n    );\n  });\n});\n\ndescribe('getAppointment', () => {\n  test('extracts appointment details', () => {\n    expect(getAppointmentDetails('2022-04-24T08:15:00.000')).toStrictEqual({\n      year: 2022,\n      month: 3,\n      date: 24,\n      hour: 8,\n      minute: 15,\n    });\n  });\n});\n\ndescribe('updateAppointment', () => {\n  test('updates a field', () => {\n    expect(\n      updateAppointment('2022-02-09T09:20:00.000', { month: 6 }),\n    ).toStrictEqual({ year: 2022, month: 6, date: 9, hour: 9, minute: 20 });\n  });\n\n  test('update multiple fields', () => {\n    expect(\n      updateAppointment('2022-11-21T21:20:00.000', {\n        year: 2023,\n        month: 1,\n        date: 12,\n        hour: 1,\n        minute: 29,\n      }),\n    ).toStrictEqual({ year: 2023, month: 1, date: 12, hour: 1, minute: 29 });\n  });\n\n  test('updates even if option is 0', () => {\n    expect(\n      updateAppointment('2022-12-17T07:10:00.000', { minute: 0 }),\n    ).toStrictEqual({ year: 2022, month: 11, date: 17, hour: 7, minute: 0 });\n  });\n\n  test('rolls over values', () => {\n    expect(\n      updateAppointment('2029-02-28T23:59:00.000', { hour: 24, minute: 60 }),\n    ).toStrictEqual({ year: 2029, month: 2, date: 1, hour: 1, minute: 0 });\n  });\n});\n\ndescribe('availableTimes', () => {\n  test('retrieves number of seconds between two appointments', () => {\n    expect(\n      timeBetween('2022-12-12T09:20:00.000', '2022-12-18T08:30:00.000'),\n    ).toBe(515400);\n  });\n\n  test('rounds to seconds', () => {\n    expect(\n      timeBetween('2024-03-06T09:12:15.180', '2024-03-06T18:15:12.090'),\n    ).toBe(32577);\n  });\n});\n\ndescribe('isValid', () => {\n  test('is true when appointment datetime is in the future', () => {\n    expect(isValid('2022-02-11T23:00:00.000', '2022-02-08T23:00:00.000')).toBe(\n      true,\n    );\n  });\n\n  test('is true when appointment date is in the future', () => {\n    expect(isValid('2022-02-11', '2022-02-08')).toBe(true);\n  });\n\n  test('is false when appointment datetime is in the past', () => {\n    expect(isValid('2022-05-20T23:00:00.000', '2023-02-08T23:00:00.000')).toBe(\n      false,\n    );\n  });\n\n  test('is false when appointment date is in the past', () => {\n    expect(isValid('2022-05-21', '2022-05-22')).toBe(false);\n  });\n});\n"
}