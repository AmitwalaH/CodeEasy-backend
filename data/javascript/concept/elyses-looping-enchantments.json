{
  "language": "javascript",
  "slug": "elyses-looping-enchantments",
  "title": "Elyses Looping Enchantments",
  "docs": {
    "introduction": "# Introduction\n\nWhen working with arrays, you sometimes want to execute code for each value in the array.\nThis is called iterating or looping over the array.\n\nHere we will look at the case where you do not want to modify the array in the process.\nFor transforming arrays, see [Concept Array Transformations][concept-array-transformations] instead.\n\n## The `for` Loop\n\nThe most basic way to iterate over an array is to use a `for` loop, see [Concept For Loops][concept-for-loops].\n\n```javascript\nconst numbers = [6.0221515, 10, 23];\n\nfor (let i = 0; i < numbers.length; i++) {\n  console.log(numbers[i]);\n}\n// => 6.0221515\n// => 10\n// => 23\n```\n\n## The `for...of` Loop\n\nWhen you want to work with the value directly in each iteration and do not require the index at all, you can use a `for...of` loop.\n\n`for...of` works like the basic `for` loop shown above, but instead of having to deal with the _index_ as a variable in the loop, you are provided with the _value_ directly.\n\n```javascript\nconst numbers = [6.0221515, 10, 23];\n\n// Because re-assigning number inside the loop will be very\n// confusing, disallowing that via const is preferable.\nfor (const number of numbers) {\n  console.log(number);\n}\n// => 6.0221515\n// => 10\n// => 23\n```\n\nJust like in regular `for` loops, you can use `continue` to stop the current iteration and `break` to stop the execution of the loop entirely.\n\n## The `forEach` Method\n\nEvery array includes a `forEach` method that can be used to loop over the elements in the array.\n\n`forEach` accepts a [callback][concept-callbacks] as a parameter.\nThe callback function is called once for each element in the array.\nThe current element, its index and the full array are provided to the callback as arguments.\nOften, only the current element or the index are used.\n\n```javascript\nconst numbers = [6.0221515, 10, 23];\n\nnumbers.forEach((number, index) => console.log(number, index));\n// => 6.0221515 0\n// => 10 1\n// => 23 2\n```\n\nThere is no way to stop the iteration once the `forEach` loop was started.\nThe statements `break` and `continue` do not exist in this context.\n\n[concept-array-transformations]: /tracks/javascript/concepts/array-transformations\n[concept-for-loops]: /tracks/javascript/concepts/for-loops\n[concept-callbacks]: /tracks/javascript/concepts/callbacks\n",
    "instructions": "# Instructions\n\nAs a budding magician, Elyse needs to analyze her deck in lots of different ways.\nTo keep things simple, she only uses cards with values 1-10.\n\n## 1. Determine how many cards of a certain type are in the deck\n\nElyse wants to know how many cards of a particular type she has in her deck.\n\nWrite a function `cardTypeCheck` that takes two parameters: an array of cards (Elyse's deck) and the type of card to count.\n\n<!--prettier-ignore -->\n~~~exercism/note\nThe function should use `forEach` and return the number of cards in the deck of the specified type.\n~~~\n\n```javascript\nconst cardType = 3;\ncardTypeCheck([1, 2, 3, 4], cardType);\n// => 1\n```\n\n## 2. Determine how many odd or even cards there are\n\nFor another trick, Elyse needs to know how many odd or even cards there are in her deck.\n\nImplement a function `determineOddEvenCards` that takes in two parameters: an array of cards (Elyse's deck), and a boolean (true is analogous to 'even', and false is analogous to 'odd').\n\nThis function should return a single number: the number of odd or even cards there are (depending on the value of the second argument) in the deck.\n\n<!--prettier-ignore -->\n~~~exercism/note\nTo practice, use a `for...of` loop in the function implementation this time.\n~~~\n\n```javascript\ndetermineOddEvenCards([1, 2, 3, 1, 5, 6], true);\n// => 2\n\ndetermineOddEvenCards([1, 2, 3, 1, 5, 6], false);\n// => 4\n```\n",
    "hints": "# Hints\n\n## 1. Determine how many cards of a certain type are in the deck\n\n- First, set up an integer variable to track the number of cards for the given type.\n- Then as mentioned in the instructions, use [forEach][mdn-foreach] to iterate over the deck.\n- Increase your counter variable in the callback when you find a card of the desired type.\n\n## 2. Determine how many odd or even cards there are\n\n- First, set up an integer variable to track the number of cards for the desired type (odd or even).\n- Then as mentioned in the instructions, use [for...of][mdn-for-of] to iterate over the deck.\n- The remainder when dividing by 2 tells you whether a number is odd or even.\n  You can calculate the remainder using the [modulo operator][mdn-modulo] `%`.\n- Increase your counter variable when you visit a number with the desired remainder.\n\n[mdn-foreach]: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/forEach\n[mdn-for-of]: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/for...of\n[mdn-modulo]: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Remainder\n"
  },
  "starter_code": "// @ts-check\n\n/**\n * Determine how many cards of a certain type there are in the deck\n *\n * @param {number[]} stack\n * @param {number} card\n *\n * @returns {number} number of cards of a single type there are in the deck\n */\nexport function cardTypeCheck(stack, card) {\n  let count = 0;\n\n  stack.forEach((c) => {\n    if (c === card) {\n      count++;\n    }\n  });\n\n  return count;\n}\n\n/**\n * Determine how many cards are odd or even\n *\n * @param {number[]} stack\n * @param {boolean} type the type of value to check for - odd or even\n * @returns {number} number of cards that are either odd or even (depending on `type`)\n */\nexport function determineOddEvenCards(stack, type) {\n  const moduloResult = type ? 0 : 1;\n  let count = 0;\n\n  for (const card of stack) {\n    if (card % 2 === moduloResult) {\n      count++;\n    }\n  }\n\n  return count;\n}\n",
  "tests": "import { describe, expect, test } from '@jest/globals';\nimport { cardTypeCheck, determineOddEvenCards } from './enchantments';\n\nconst TYPE_IS_ODD = false;\nconst TYPE_IS_EVEN = true;\n\ndescribe('cardTypeCheck', () => {\n  test('a single matching card', () => {\n    expect(cardTypeCheck([1], 1)).toBe(1);\n  });\n\n  test('a single matching card among many', () => {\n    expect(cardTypeCheck([7, 4, 7, 3, 1, 2], 1)).toBe(1);\n  });\n\n  test('a single unmatched card', () => {\n    expect(cardTypeCheck([1], 2)).toBe(0);\n  });\n\n  test('multiple matching cards', () => {\n    expect(cardTypeCheck([7, 7, 7], 7)).toBe(3);\n  });\n\n  test('multiple matching cards among many', () => {\n    expect(cardTypeCheck([1, 2, 3, 7, 7, 7, 3, 2, 1], 7)).toBe(3);\n  });\n\n  test('no matching cards', () => {\n    expect(cardTypeCheck([1, 2, 3, 4, 5, 4, 3, 2, 1], 7)).toBe(0);\n  });\n});\n\ndescribe('determineOddEvenCards', () => {\n  test('a single odd card', () => {\n    expect(determineOddEvenCards([1], TYPE_IS_ODD)).toBe(1);\n    expect(determineOddEvenCards([1], TYPE_IS_EVEN)).toBe(0);\n  });\n\n  test('a single even card', () => {\n    expect(determineOddEvenCards([2], TYPE_IS_ODD)).toBe(0);\n    expect(determineOddEvenCards([2], TYPE_IS_EVEN)).toBe(1);\n  });\n\n  test('multiple odd cards', () => {\n    expect(determineOddEvenCards([1, 3, 5], TYPE_IS_ODD)).toBe(3);\n    expect(determineOddEvenCards([1, 3, 5], TYPE_IS_EVEN)).toBe(0);\n  });\n\n  test('multiple even cards', () => {\n    expect(determineOddEvenCards([2, 2, 4, 6, 6], TYPE_IS_ODD)).toBe(0);\n    expect(determineOddEvenCards([2, 2, 4, 6, 6], TYPE_IS_EVEN)).toBe(5);\n  });\n\n  test('a mix of odd and even cards', () => {\n    expect(determineOddEvenCards([1, 2, 1, 1, 2, 1, 9], TYPE_IS_ODD)).toBe(5);\n    expect(determineOddEvenCards([1, 2, 1, 1, 2, 1, 9], TYPE_IS_EVEN)).toBe(2);\n  });\n});\n"
}