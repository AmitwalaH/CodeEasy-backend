{
  "language": "javascript",
  "slug": "lasagna-master",
  "title": "Lasagna Master",
  "docs": {
    "introduction": "# Introduction\n\nA function is a block of organized, reusable code that is used to perform some action.\nThere are multiple ways to define functions in JavaScript.\nHere we will look at _function declarations_ and _function expressions_.\nOther possibilities like [arrow functions][concept-arrow-functions] will be covered in other concepts.\n\n## Function Declaration\n\nThe standard way of defining a function in JavaScript is a _function declaration_, also called _function definition_ or _function statement_.\n\nIt consists of the `function` keyword, the name of the function, and a comma-separated list of parameters in round brackets.\nThis is followed by the function body (collection of statements that defines what a function does) wrapped in curly brackets.\n\n```javascript\nfunction someName(param1, param2, param3) {\n  // ...\n}\n```\n\nIn JavaScript, a function is invoked (called) by stating the function name followed by parentheses that contain the arguments.\n\n```javascript\nsomeName(arg1, arg2, arg3);\n```\n\n## Parameters\n\nWhen working with parameters inside the function body, be aware of possible side effects.\n\n- Values of [primitive data types][mdn-primitives] are _immutable_.\n  The original value is never affected by what happens to the argument in the function body.\n- For all other values (objects, arrays, functions), a reassignment will not affect the original value.\n  However, if you modify such an argument (e.g. add a key to an object), that also modifies the original value that was passed in.\n\nBy default, all parameters defined in the function declaration are optional in JavaScript.\nIf you provide fewer arguments than there are parameters, the missing arguments will be `undefined` inside the function, see [Null and Undefined][concept-null-undefined].\nIn many cases, it makes sense to assign a more appropriate default value than `undefined`.\nThis can be done by specifying default parameters directly in the function definition.\n\n```javascript\nfunction someName(param1 = defaultValue1, param2 = defaultValue2) {\n  // ...\n}\n```\n\n## Return Statement\n\nA `return` statement ends the function execution and specifies a value to be returned to the function caller. A function can have multiple `return` statements.\n\n```javascript\nfunction checkNumber(num) {\n  if (num === 0) {\n    return 'You passed 0, please provide another number.';\n  }\n\n  return 'Thanks for passing such a nice number.';\n}\n```\n\nThe return value of a function can be stored in a variable.\n\n```javascript\nfunction sum(x, y) {\n  return x + y;\n}\n\nconst total = sum(5, 10);\n// => 15\n```\n\nThe result of a function that `return`s no value or does not have a `return` statement is `undefined`.\nThere are no implicit `return`s in JavaScript.\n\n```javascript\nfunction nakedReturn(a) {\n  a * 2;\n  return;\n}\n\nnakedReturn(1);\n// => undefined\n\nfunction noReturn(a) {\n  a * 2;\n}\n\nnoReturn(1);\n// => undefined\n```\n\nIn JavaScript, you can only return exactly one value.\nIf you want to pass more information, you need to combine it into one entity first, usually into an [object][concept-objects], or an [array][concept-arrays].\n\n```javascript\nfunction divide(a, b) {\n  return {\n    quotient: Math.floor(a / b),\n    remainder: a % b,\n  };\n}\n```\n\n## Function Expression\n\nA function declaration is a standalone statement.\nBut sometimes it is helpful to define a function as part of another expression, e.g., in an assignment, as a function parameter ([callback][concept-callbacks]) or as value in an [object][concept-objects].\nThis can be done with a function expression.\nIt has the same syntax as a function declaration, only that the function name can be omitted to create an _anonymous function_.\n\n```javascript\nconst someFunction = function (param) {\n  // ...\n};\n\nsomeOtherFunction(function (param) {\n  // ...\n});\n\nconst obj = {\n  someFunction: function (param) {\n    // ...\n  },\n};\n```\n\n[concept-arrow-functions]: /tracks/javascript/concepts/arrow-functions\n[concept-null-undefined]: /tracks/javascript/concepts/null-undefined\n[concept-objects]: /tracks/javascript/concepts/objects\n[concept-arrays]: /tracks/javascript/concepts/arrays\n[concept-callbacks]: /tracks/javascript/concepts/callbacks\n[mdn-primitives]: https://developer.mozilla.org/en-US/docs/Glossary/Primitive\n",
    "instructions": "# Instructions\n\nIn this exercise, you are going to write some more code related to preparing and cooking your brilliant lasagna from your favorite cookbook.\n\nYou have five tasks.\nThe first one is related to the cooking itself, the other four are about the perfect preparation.\n\n## 1. Determine whether the lasagna is done\n\nWhen you have lasagna in the oven, you want to know whether you can already take it out or not.\nTo make sure the lasagna does not burn in the oven, you usually set a timer.\nBut sometimes you forget about that.\n\nWrite a function `cookingStatus` that accepts the remaining time on the timer in minutes as a parameter.\nThe function has three possible results.\n\n- If the timer shows `0`, it should return `'Lasagna is done.'`.\n- If the timer shows any other number, the result should be `'Not done, please wait.'`.\n- If the function is called without a timer value, the result should be `'You forgot to set the timer.'`.\n\nThe timer will never show a value below 0.\n\n```javascript\ncookingStatus(12);\n// => 'Not done, please wait.'\n\ncookingStatus();\n// => 'You forgot to set the timer.'\n```\n\n## 2. Estimate the preparation time\n\nFor the next lasagna that you will prepare, you want to make sure you have enough time reserved so you can enjoy the cooking.\nYou already made a plan with all the layers your lasagna will have.\nNow you want to estimate how long the preparation will take based on that.\n\nImplement a function `preparationTime` that accepts an array of layers and the average preparation time per layer in minutes.\nThe function should return the estimate for the total preparation time based on the number of layers.\nIf the function is called without providing the average preparation time, `2` minutes should be assumed instead.\n\n```javascript\nconst layers = ['sauce', 'noodles', 'sauce', 'meat', 'mozzarella', 'noodles'];\npreparationTime(layers, 3);\n// => 18\n\npreparationTime(layers);\n// => 12\n```\n\n## 3. Compute the amounts of noodles and sauce needed\n\nBesides reserving the time, you also want to make sure you have enough sauce and noodles to cook the lasagna of your dreams.\nFor each noodle layer in your lasagna, you will need 50 grams of noodles.\nFor each sauce layer in your lasagna, you will need 0.2 liters of sauce.\n\nDefine the function `quantities` that takes an array of layers as a parameter.\nThe function will then determine the quantity of noodles and sauce needed to make your meal.\nThe result should be returned as an object with keys `noodles` and `sauce`.\n\n```javascript\nquantities(['sauce', 'noodles', 'sauce', 'meat', 'mozzarella', 'noodles']);\n// => { noodles: 100, sauce: 0.4 }\n```\n\n## 4. Add the secret ingredient\n\nA while ago you visited a friend and ate lasagna there.\nIt was amazing and had something special to it.\nThe friend sent you the list of ingredients and told you the last item on the list is the \"secret ingredient\" that made the meal so special.\nNow you want to add that secret ingredient to your recipe as well.\n\nWrite a function `addSecretIngredient` that accepts two arrays of ingredients as parameters.\nThe first parameter is the list your friend sent you and the second is the ingredient list for your own recipe.\nThe function should add the last item from your friend's list to the end of your list.\nThe array that represents your recipe should be modified directly and the function should not return anything.\nHowever, the first argument should not be modified.\n\n```javascript\nconst friendsList = ['noodles', 'sauce', 'mozzarella', 'kampot pepper'];\nconst myList = ['noodles', 'meat', 'sauce', 'mozzarella'];\n\naddSecretIngredient(friendsList, myList);\n// => undefined\n\nconsole.log(myList);\n// => ['noodles', 'meat', 'sauce', 'mozzarella', 'kampot pepper']\n```\n\n## 5. Scale the recipe\n\nThe amounts listed in your cookbook only yield enough lasagna for two portions.\nSince you want to cook for more people next time, you want to calculate the amounts for different numbers of portions.\n\nImplement a function `scaleRecipe` that takes two parameters.\n\n- A recipe object that holds the amounts needed for 2 portions.\n  The format of the object can be seen in the example below.\n- The number of portions you want to cook.\n\nThe function should return a recipe object with the amounts needed for the desired number of portions.\nYou want to keep the original recipe though.\nThis means, in this task the recipe argument should not be modified.\n\n```javascript\nconst recipe = {\n  noodles: 200,\n  sauce: 0.5,\n  mozzarella: 1,\n  meat: 100,\n};\n\nscaleRecipe(recipe, 4);\n// =>\n// {\n//   noodles: 400,\n//   sauce: 1,\n//   mozzarella: 2,\n//   meat: 200,\n// };\n\nconsole.log(recipe);\n// =>\n// {\n//   noodles: 200,\n//   sauce: 0.5,\n//   mozzarella: 1,\n//   meat: 100,\n// };\n```\n",
    "hints": "# Hints\n\n## 1. Determine whether the lasagna is done\n\n- Use an [if-statement][mdn-if-else] to return a result based on some condition.\n- The task can be best solved when checking for the two specific conditions first.\n- Remember that missing parameters will be `undefined` and you can check whether a variable is `undefined` using the strict equality operator `===`.\n\n## 2. Estimate the preparation time\n\n- Use a default parameter to set the average preparation time in case it was not provided when the function was called.\n- Revisit [arrays][concept-arrays] to find out how to determine the number of layers (length of the layers array).\n\n## 3. Compute the amounts of noodles and sauce needed\n\n- First, set up two variables to track the amount of noodles and sauce.\n  Define them with `let` so you can change the value later in your code.\n  Also, assign an appropriate initial value.\n- Use a [for loop][concept-for-loops] to iterate through the layers.\n- If you encounter a `'noodles'` or `'sauce'` layer in your loop, increase the amount stored in the respective variable accordingly.\n- Use an [object][concept-objects] to return both results.\n\n## 4. Add the secret ingredient\n\n- Revisit [arrays][concept-arrays] to find out how to retrieve an element from an array and how to add something to the end of an array.\n- The index of the last element in an array `a` is `a.length - 1`.\n- The function should not have a `return` statement.\n\n## 5. Scale the recipe\n\n- First, calculate the factor that you need to apply to all amounts based on the target portions.\n- One way to ensure the arguments is not modified is to use a new object to save the results.\n- Use a [`for...in` loop][mdn-for-in] to go through all the entries in the original recipe and fill the object accordingly.\n\n[mdn-if-else]: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/if...else\n[concept-arrays]: /tracks/javascript/concepts/arrays\n[concept-for-loops]: /tracks/javascript/concepts/for-loops\n[concept-objects]: /tracks/javascript/concepts/objects\n[mdn-for-in]: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/for...in\n"
  },
  "starter_code": "/// <reference path=\"../global.d.ts\" />\n// @ts-check\n\n/**\n * Determines whether the lasagna is done based on the\n * remaining time on the timer.\n *\n * @param {number} time time left on the timer\n * @returns {string} cooking status\n */\nexport function cookingStatus(time) {\n  if (time === undefined) {\n    return 'You forgot to set the timer.';\n  }\n\n  if (time === 0) {\n    return 'Lasagna is done.';\n  }\n\n  return 'Not done, please wait.';\n}\n\n/**\n * Estimates the preparation time based on the number of layers.\n *\n * @param {string[]} layers\n * @param {number} avgPrepTime\n * @returns {number} total preparation time\n */\nexport function preparationTime(layers, avgPrepTime = 2) {\n  return layers.length * avgPrepTime;\n}\n\n/**\n * Calculates how many noodles and much sauce are needed for the\n * given layers.\n *\n * @param {string[]} layers\n * @returns {Quantities} quantities needed for the given layers\n */\nexport function quantities(layers) {\n  let noodles = 0;\n  let sauce = 0;\n\n  for (let i = 0; i < layers.length; i++) {\n    if (layers[i] === 'noodles') {\n      noodles += 50;\n    }\n\n    if (layers[i] === 'sauce') {\n      sauce += 0.2;\n    }\n  }\n\n  return { noodles, sauce };\n}\n\n/**\n * Adds the secret ingredient from the ingredient list that a\n * friend provided to your ingredient list.\n *\n * @param {string[]} friendsList\n * @param {string[]} myList\n */\nexport function addSecretIngredient(friendsList, myList) {\n  const lastIndex = friendsList.length - 1;\n  myList.push(friendsList[lastIndex]);\n}\n\n/**\n * Calculates the amounts of ingredients needed for a certain\n * amount of portions.\n * Assumes the original amounts were meant for 2 portions.\n * Does not modify the original recipe.\n *\n * @param {Record<string, number>} recipe\n * @param {number} targetPortions\n * @returns {Record<string, number>|{}} recipe with amounts for target portions\n */\nexport function scaleRecipe(recipe, targetPortions) {\n  const factor = targetPortions / 2;\n  const result = {};\n\n  for (const key in recipe) {\n    result[key] = recipe[key] * factor;\n  }\n\n  return result;\n}\n",
  "tests": "import { describe, expect, test } from '@jest/globals';\nimport {\n  addSecretIngredient,\n  cookingStatus,\n  preparationTime,\n  quantities,\n  scaleRecipe,\n} from './lasagna-master';\n\nconst DIFFERENCE_PRECISION_IN_DIGITS = 6;\n\ndescribe('cookingStatus', () => {\n  test('recognizes that there is time left on the timer', () => {\n    const expected = 'Not done, please wait.';\n    expect(cookingStatus(1)).toBe(expected);\n    expect(cookingStatus(42)).toBe(expected);\n    expect(cookingStatus(8.5)).toBe(expected);\n    expect(cookingStatus(0.1)).toBe(expected);\n  });\n\n  test('recognizes when there is no time left on the timer', () => {\n    expect(cookingStatus(0)).toBe('Lasagna is done.');\n  });\n\n  test('returns a special status when no timer value was passed', () => {\n    const expected = 'You forgot to set the timer.';\n    expect(cookingStatus()).toBe(expected);\n    expect(cookingStatus(undefined)).toBe(expected);\n  });\n});\n\ndescribe('preparationTime', () => {\n  test('applies the custom average time per layer', () => {\n    const manyLayers = [\n      'sauce',\n      'noodles',\n      'béchamel',\n      'meat',\n      'mozzarella',\n      'noodles',\n      'ricotta',\n      'eggplant',\n      'béchamel',\n      'noodles',\n      'sauce',\n      'mozzarella',\n    ];\n    expect(preparationTime(manyLayers, 1)).toBe(12);\n\n    const fewLayers = ['sauce', 'noodles'];\n    expect(preparationTime(fewLayers, 3.5)).toBe(7);\n  });\n\n  test('uses the default if no custom time was passed', () => {\n    const manyLayers = [\n      'sauce',\n      'noodles',\n      'béchamel',\n      'meat',\n      'mozzarella',\n      'noodles',\n      'ricotta',\n      'eggplant',\n      'béchamel',\n      'noodles',\n      'sauce',\n      'mozzarella',\n    ];\n    expect(preparationTime(manyLayers)).toBe(24);\n\n    const fewLayers = ['sauce', 'noodles'];\n    expect(preparationTime(fewLayers)).toBe(4);\n  });\n\n  test('works with an empty layers array', () => {\n    expect(preparationTime([])).toBe(0);\n  });\n});\n\ndescribe('quantities', () => {\n  test('calculates the amounts of noodles and sauce correctly', () => {\n    const fewLayers = ['noodles', 'sauce', 'noodles'];\n    expectObjectsToBeEqual(quantities(fewLayers), { noodles: 100, sauce: 0.2 });\n\n    const manyLayers = [\n      'sauce',\n      'noodles',\n      'béchamel',\n      'meat',\n      'mozzarella',\n      'noodles',\n      'ricotta',\n      'eggplant',\n      'béchamel',\n      'noodles',\n      'sauce',\n      'mozzarella',\n    ];\n    expectObjectsToBeEqual(quantities(manyLayers), {\n      noodles: 150,\n      sauce: 0.4,\n    });\n  });\n\n  test('works if there are no noodles or no sauce found in the layers', () => {\n    const noNoodles = ['sauce', 'béchamel', 'sauce', 'meat', 'sauce'];\n    expectObjectsToBeEqual(quantities(noNoodles), { noodles: 0, sauce: 0.6 });\n\n    const noSauce = ['eggplant', 'béchamel', 'noodles', 'béchamel'];\n    expectObjectsToBeEqual(quantities(noSauce), { noodles: 50, sauce: 0 });\n  });\n\n  test('works with an empty layers array', () => {\n    expect(quantities([])).toEqual({ noodles: 0, sauce: 0 });\n  });\n});\n\ndescribe('addSecretIngredient', () => {\n  test('adds the secret ingredient to the second array', () => {\n    const friendsList = ['sauce', 'noodles', 'béchamel', 'marjoram'];\n    const myList = ['sauce', 'noodles', 'meat', 'tomatoes'];\n    addSecretIngredient(friendsList, myList);\n\n    const expected = ['sauce', 'noodles', 'meat', 'tomatoes', 'marjoram'];\n    expect(myList).toEqual(expected);\n  });\n\n  test('does not modify the first array', () => {\n    const createFriendsList = () => [\n      'noodles',\n      'tomatoes',\n      'sauce',\n      'meat',\n      'mozzarella',\n      'eggplant',\n      'ricotta',\n      'parmesan',\n    ];\n\n    const friendsList = createFriendsList();\n    const myList = ['ricotta', 'béchamel', 'sauce', 'noodles', 'meat'];\n    addSecretIngredient(friendsList, myList);\n\n    expect(friendsList).toEqual(createFriendsList());\n  });\n\n  test('does not return anything', () => {\n    const friendsList = [\n      'sauce',\n      'noodles',\n      'béchamel',\n      'mozzarella',\n      'mustard',\n    ];\n    const myList = ['sauce', 'noodles', 'tomatoes'];\n    expect(addSecretIngredient(friendsList, myList)).toBeUndefined();\n  });\n});\n\ndescribe('scaleRecipe', () => {\n  test('scales up correctly', () => {\n    const recipe1 = {\n      sauce: 0.5,\n      noodles: 250,\n      meat: 150,\n      tomatoes: 3,\n      onion: 0.5,\n    };\n\n    const expected1 = {\n      sauce: 1.5,\n      noodles: 750,\n      meat: 450,\n      tomatoes: 9,\n      onion: 1.5,\n    };\n\n    expectObjectsToBeEqual(scaleRecipe(recipe1, 6), expected1);\n\n    // prettier-ignore\n    const recipe2 = {\n      'sauce': 0.6,\n      'noodles': 300,\n      'carrots': 1,\n      'mozzarella': 0.5,\n      'ricotta': 50,\n      'béchamel': 0.1,\n      'tofu': 100,\n    };\n\n    // prettier-ignore\n    const expected2 = {\n      'sauce': 0.9,\n      'noodles': 450,\n      'carrots': 1.5,\n      'mozzarella': 0.75,\n      'ricotta': 75,\n      'béchamel': 0.15,\n      'tofu': 150,\n    };\n\n    expectObjectsToBeEqual(scaleRecipe(recipe2, 3), expected2);\n  });\n\n  test('scales down correctly', () => {\n    const recipe = {\n      sauce: 0.5,\n      noodles: 250,\n      meat: 150,\n      tomatoes: 3,\n      onion: 0.5,\n    };\n\n    const expected = {\n      sauce: 0.25,\n      noodles: 125,\n      meat: 75,\n      tomatoes: 1.5,\n      onion: 0.25,\n    };\n    expectObjectsToBeEqual(scaleRecipe(recipe, 1), expected);\n  });\n\n  test('works for an empty recipe', () => {\n    expect(scaleRecipe({})).toEqual({});\n  });\n\n  test('does not modify the original recipe', () => {\n    const recipe = {\n      sauce: 1,\n      noodles: 250,\n      meat: 150,\n      tomatoes: 3,\n      onion: 2,\n    };\n\n    const copy = { ...recipe };\n\n    scaleRecipe(recipe, 4);\n    expect(recipe).toEqual(copy);\n  });\n});\n\n/**\n * Jest does not support comparing objects that contain floating point number values.\n * https://github.com/facebook/jest/issues/3654\n * This helper functions applies \"toBeCloseTo\" to compare object values.\n */\nfunction expectObjectsToBeEqual(actualObj, expectedObj) {\n  for (const key in expectedObj) {\n    expect(actualObj[key]).toBeCloseTo(\n      expectedObj[key],\n      DIFFERENCE_PRECISION_IN_DIGITS,\n    );\n  }\n  expect(Object.keys(actualObj).length).toBe(Object.keys(expectedObj).length);\n}\n"
}