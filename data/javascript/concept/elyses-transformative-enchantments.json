{
  "language": "javascript",
  "slug": "elyses-transformative-enchantments",
  "title": "Elyses Transformative Enchantments",
  "docs": {
    "introduction": "# Introduction\n\nIn JavaScript, the `Array` class has many powerful built-in methods for transforming arrays.\nThese methods make it much easier to convert one array into another than it otherwise would be using a simple for loop or more direct manipulation.\n\nSome methods are [_pure_][pure-function-definition], meaning that they do not modify the original array.\nThey return a new one instead.\nOther methods however manipulate the array they are called on and do **not** return the modified array.\n\nSome of the most commonly used methods to transform arrays are presented below.\nA full list of available methods can be found in the [MDN documentation][array-methods].\n\n### map (pure)\n\nCreate a new array by transforming each element according to a function passed as an argument.\nThese callback functions are often written as [arrow functions][concept-arrow-functions].\n\n```javascript\nlet arr = [1, 2, 3, 4];\n\nconst newArr = arr.map((value) => value - 1);\nconsole.log(newArr);\n// => [0, 1, 2, 3]\nconsole.log(arr);\n// => [1, 2, 3, 4]\n```\n\nIt is worth noting that the resulting array will always be of the same length as the original.\n\n### filter (pure)\n\nCreates an array by filtering the current one, given a filtering function (that returns true if the element should be kept and false if it should be removed).\n\n```javascript\nlet arr = [1, 2, 3, 4];\n\narr.filter((value) => value % 2 === 0);\n// => [2, 4]\n```\n\n### reduce (pure)\n\nReduces the array to a single value using a function that takes an _accumulator_ and the current element of the array as parameters.\nThis function instructs how the current element must be merged into the accumulator and returns the accumulator that will be used on the next iteration.\n\n```javascript\nlet arr = [1, 2, 3, 4];\n\n// Get the sum of elements\narr.reduce((accumulator, currentValue) => accumulator + currentValue, 0);\n// => 10\n\n// Classify the numbers by whether they are odd or not\narr.reduce(\n  (accumulator, currentValue) => {\n    if (currentValue % 2 === 0) {\n      accumulator.even.push(currentValue);\n    } else {\n      accumulator.odd.push(currentValue);\n    }\n\n    return accumulator;\n  },\n  { even: [], odd: [] },\n);\n// => { even: [2, 4], odd: [1, 3] }\n```\n\n### reverse\n\nReverses the elements of an array.\n\n```javascript\nconst arr = [1, 2, 3, 4];\n\narr.reverse();\n// => [4, 3, 2, 1]\n```\n\nThis method modifies the array it is called on.\n\n### slice (pure)\n\nGiven a start and an end index, creates a sub-array from the array passed as a parameter.\n\nThe element at the end index will not be included.\nAlso, all parameters are optional:\nthe start index defaults to `0`, and the end index defaults to the array length.\n\n```javascript\nconst arr = [1, 2, 3, 4];\n\narr.slice(1, 2); // [2]\narr.slice(1); // [2, 3, 4]\n// You can also use negative numbers, that represent the indexes\n// starting from the end of the array\narr.slice(-2); // [3, 4]\n```\n\n### splice\n\nRemoves or replaces and/or adds new elements of an array.\n\nIt takes the following parameters:\n\n- the index of the element where to start modifying the array\n- the number of elements to delete\n- the elements to insert in the array (optional)\n\n`splice` returns the elements that have been removed.\n\n```javascript\nconst arr = ['1', '2', '5', '6'];\n\n// Insert an element at index 2\narr.splice(2, 0, '3');\nconsole.log(arr);\n// => ['1', '2', '3', '5', '6']\n\n// Remove 2 elements, starting at index 3 and insert 2 elements\nconst removed = arr.splice(3, 2, '4', '5');\nconsole.log(removed);\n// => ['5', '6']\nconsole.log(arr);\n// => ['1', '2', '3', '4', '5']\n\n// Remove 1 element at index 1\narr.splice(1, 1);\nconsole.log(arr);\n// => ['1', '3', '4', '5']\n```\n\n### sort\n\nBy default, `sort` sorts the elements of an array by first converting them to strings and then applying string comparison (see [Concept Comparison][concept-comparison]).\nThe sorting happens _in-place_ which means the original array is modified.\n`sort` also returns that modified array which is convenient if you want to chain other methods to it.\n\n```javascript\nconst arr = ['c', 'a', 'z', 'b'];\nconst result = arr.sort();\nconsole.log(result);\n// => ['a', 'b', 'c', 'z']\nconsole.log(arr);\n// => ['a', 'b', 'c', 'z']\n```\n\nTo customize the sorting behavior, you can pass a comparison function as an argument.\nThe comparison function itself is called with two arguments which are two elements of the array.\nIt then needs to return the following:\n\n- a negative number if the first argument should be sorted before the second\n- a positive number if the first argument should be sorted after the second\n- `0` if the order of the elements should stay the same\n\nHere is an example of how to use a custom comparison function can be used to sort an array of objects.\n\n```javascript\nconst arr = [\n  { name: 'Lydia', age: 7 },\n  { name: 'Anne', age: 34 },\n  { name: 'Holger', age: 59 },\n];\n\narr.sort((item1, item2) => {\n  if (item1.name < item2.name) {\n    return -1;\n  }\n  if (item1.name > item2.name) {\n    return 1;\n  }\n  return 0;\n});\n// => [ { name: 'Anne', age: 34 }, { name: 'Holger', age: 59 },\n// { name: 'Lydia', age: 7 } ]\n```\n\n[pure-function-definition]: https://en.wikipedia.org/wiki/Pure_function\n[array-methods]: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array#instance_methods\n[concept-arrow-functions]: /tracks/javascript/concepts/arrow-functions\n[concept-comparison]: /tracks/javascript/concepts/comparison\n",
    "instructions": "# Instructions\n\nElyse, magician-to-be, continues her training. She will be given a deck of cards and attempt to transform that deck. She will make certain cards appear, disappear, change their values, or completely rearrange themselves.\nTo make things easier, she usually only starts with cards numbered 1 to 10, although some of the tricks may result in larger cards being created.\n\n## 1. Double every single card\n\nElyse wants to double the number of every card in the deck. This may result in higher cards than 1-10.\n\n```javascript\nconst deck = [1, 2, 3, 4, 10];\nseeingDouble(deck);\n// => [2, 4, 6, 8, 20]\n```\n\n## 2. Create multiple copies of every 3 found in the deck\n\nElyse wants to triplicate every 3 found in the deck. If a deck started with a single 3, after the trick the deck would have three 3's in place of the original.\n\n```javascript\nconst deck = [1, 3, 9, 3, 7];\nthreeOfEachThree(deck);\n// => [1, 3, 3, 3, 9, 3, 3, 3, 7]\n```\n\n## 3. Find two cards from the exact middle of the deck\n\nElyse will take a deck of ten cards, and make every card disappear except the middle two cards.\n\n```javascript\nconst deck = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10];\nmiddleTwo(deck);\n// => [5, 6]\n```\n\n## 4. The outside two cards will reappear in the middle of the deck\n\nElyse wants to move the top and bottom cards of the deck into the middle, in reverse order.\n\nYou can assume that the deck has an even number of cards.\n\n```javascript\nconst deck = [1, 2, 3, 5, 6, 10];\nsandwichTrick(deck);\n// => [2, 3, 10, 1, 5, 6]\n```\n\n## 5. Every card that isn't 2 disappears\n\nElyse's favorite number today is 2. In this trick, every card that isn't a 2 will disappear from the deck.\n\n```javascript\nconst deck = [1, 2, 3, 4, 10, 2];\ntwoIsSpecial(deck);\n// => [2, 2]\n```\n\n## 6. Convert a shuffled deck into a perfectly ordered deck\n\nElyse wishes to demonstrate her mastery of reordering the cards perfectly - no matter how well shuffled.\n\n```javascript\nconst deck = [10, 1, 5, 3, 2, 8, 7];\nperfectlyOrdered(deck);\n// => [1, 2, 3, 5, 7, 8, 10]\n```\n\n## 7. Reorder the deck\n\nElyse wants to change the order of the cards in the deck.\nAfter the trick, the card that is currently at the top should end up at the bottom of the deck. The second card should end up second last etc.\n\n```javascript\nconst deck = [10, 1, 5, 3, 2];\nreorder(deck);\n// => [2, 3, 5, 1, 10]\n```\n",
    "hints": "# Hints\n\n## 1. Double every single card\n\n- There is a built-in method great for [simple transforms][map_method_docs] like this.\n\n## 2. Create multiple copies of every 3 found in the deck\n\n- There is a built-in method perfect for custom transforms or [accumulations][reduce_method_docs] (like summing an array, etc.)\n\n## 3. Find two cards from the exact middle of the deck\n\n- There is a built-in method for [slicing and dicing][slice_method_docs] arrays into smaller segments.\n\n## 4. The outside two cards will reappear in the middle of the deck\n\n- There is a built-in method for [inserting or removing][splice_method_docs] items from the middle of an array.\n- Array also has built-ins for removing the first and last elements, see [MDN Array documentation][array_docs].\n\n## 5. Every card that isn't 2 disappears\n\n- There is a built-in method for [filtering][filter_method_docs] or excluding items in an array.\n\n## 6. Convert a shuffled deck into a perfectly ordered deck\n\n- There is a built-in method for [sorting][sort_method_docs].\n\n## 7. Reorder the deck\n\n- There is a built-in method for [reversing][reverse_method_docs] an array.\n\n[map_method_docs]: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/map\n[reduce_method_docs]: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/reduce\n[slice_method_docs]: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/slice\n[splice_method_docs]: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/splice\n[filter_method_docs]: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/filter\n[sort_method_docs]: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/sort\n[reverse_method_docs]: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/reverse\n[array_docs]: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/\n"
  },
  "starter_code": "// @ts-check\n\n/**\n * Double every card in the deck.\n *\n * @param {number[]} deck\n * @returns {number[]} deck with every card doubled\n */\nexport function seeingDouble(deck) {\n  return deck.map((card) => card * 2);\n}\n\n/**\n *  Creates triplicates of every 3 found in the deck.\n *\n * @param {number[]} deck\n * @returns {number[]} deck with triplicate 3s\n */\nexport function threeOfEachThree(deck) {\n  return deck.reduce((newDeck, card) => {\n    if (card === 3) {\n      newDeck.push(3, 3, 3);\n    } else {\n      newDeck.push(card);\n    }\n    return newDeck;\n  }, []);\n}\n\n/**\n * Extracts the middle two cards from a deck.\n * Assumes a deck is always 10 cards.\n *\n * @param {number[]} deck of 10 cards\n * @returns {number[]} deck with only two middle cards\n */\nexport function middleTwo(deck) {\n  return deck.slice(4, 6);\n}\n\n/**\n * Moves the outside two cards to the middle.\n *\n * @param {number[]} deck with even number of cards\n * @returns {number[]} transformed deck\n */\n\nexport function sandwichTrick(deck) {\n  const firstCard = deck.shift();\n  const lastCard = deck.pop();\n  const mid = deck.length / 2;\n  deck.splice(mid, 0, lastCard, firstCard);\n  return deck;\n}\n\n/**\n * Removes every card from the deck except 2s.\n *\n * @param {number[]} deck\n *\n * @returns {number[]} deck with only 2s\n */\nexport function twoIsSpecial(deck) {\n  return deck.filter((card) => card === 2);\n}\n\n/**\n * Returns a perfectly order deck from lowest to highest.\n *\n * @param {number[]} deck shuffled deck\n *\n * @returns {number[]} ordered deck\n */\nexport function perfectlyOrdered(deck) {\n  return deck.sort((a, b) => a - b);\n}\n\n/**\n * Reorders the deck so that the top card ends up at the bottom.\n *\n * @param {number[]} deck\n *\n * @returns {number[]} reordered deck\n */\nexport function reorder(deck) {\n  return deck.reverse();\n}\n",
  "tests": "import { describe, expect, test } from '@jest/globals';\nimport {\n  middleTwo,\n  perfectlyOrdered,\n  reorder,\n  sandwichTrick,\n  seeingDouble,\n  threeOfEachThree,\n  twoIsSpecial,\n} from './enchantments';\n\ndescribe('seeingDouble', () => {\n  test('doubles all the values', () => {\n    const deck1 = [1, 2, 3, 4];\n    const expected1 = [2, 4, 6, 8];\n    expect(seeingDouble(deck1)).toEqual(expected1);\n\n    const deck2 = [2, 5, 1, 9];\n    const expected2 = [4, 10, 2, 18];\n    expect(seeingDouble(deck2)).toEqual(expected2);\n  });\n\n  test('works for a large deck', () => {\n    const deck = [6, 3, 7, 2, 1, 9, 8, 10, 5, 4, 7, 1, 3];\n    const expected = [12, 6, 14, 4, 2, 18, 16, 20, 10, 8, 14, 2, 6];\n    expect(seeingDouble(deck)).toEqual(expected);\n  });\n\n  test('work for a small deck', () => {\n    expect(seeingDouble([3])).toEqual([6]);\n  });\n\n  test('can handle an empty deck', () => {\n    expect(seeingDouble([])).toEqual([]);\n  });\n\n  test('does not modify the original deck', () => {\n    const deck = [1, 2, 3, 4];\n    seeingDouble(deck);\n    expect(deck).toEqual([1, 2, 3, 4]);\n  });\n});\n\ndescribe('threeOfEachThree', () => {\n  test('one 3 is converted into three 3s', () => {\n    expect(threeOfEachThree([3])).toEqual([3, 3, 3]);\n  });\n\n  test('also converts multiple 3s', () => {\n    const deck = [3, 10, 2, 8, 3, 4];\n    const expected = [3, 3, 3, 10, 2, 8, 3, 3, 3, 4];\n    expect(threeOfEachThree(deck)).toEqual(expected);\n  });\n\n  test('returns the same elements if there are no 3s', () => {\n    expect(threeOfEachThree([1, 2, 4])).toEqual([1, 2, 4]);\n  });\n\n  test('can handle an empty deck', () => {\n    expect(threeOfEachThree([])).toEqual([]);\n  });\n});\n\ndescribe('middleTwo', () => {\n  test('extracts the middle two cards', () => {\n    const deck = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10];\n    const expected = [5, 6];\n    expect(middleTwo(deck)).toEqual(expected);\n  });\n\n  test('works with an unordered deck', () => {\n    const deck = [6, 10, 5, 9, 4, 3, 1, 2, 6, 8];\n    const expected = [4, 3];\n    expect(middleTwo(deck)).toEqual(expected);\n  });\n});\n\ndescribe('sandwichTrick', () => {\n  test('moves the outside two cards into the middle', () => {\n    const deck = [1, 6, 7, 7, 2, 1];\n    const expected = [6, 7, 1, 1, 7, 2];\n    expect(sandwichTrick(deck)).toEqual(expected);\n  });\n\n  test('switches the order of the moved cards', () => {\n    const deck = [3, 6, 1, 7, 2, 8];\n    const expected = [6, 1, 8, 3, 7, 2];\n    expect(sandwichTrick(deck)).toEqual(expected);\n  });\n\n  test('can handle a small deck', () => {\n    expect(sandwichTrick([1, 10])).toEqual([10, 1]);\n  });\n\n  test('can handle a large deck', () => {\n    const deck = [9, 10, 5, 9, 4, 3, 1, 2, 6, 7];\n    const expected = [10, 5, 9, 4, 7, 9, 3, 1, 2, 6];\n    expect(sandwichTrick(deck)).toEqual(expected);\n  });\n});\n\ndescribe('twoIsSpecial', () => {\n  test('keeps only the 2s', () => {\n    const deck = [1, 2, 9, 1, 2, 2, 6, 7];\n    const expected = [2, 2, 2];\n    expect(twoIsSpecial(deck)).toEqual(expected);\n  });\n\n  test('returns an empty deck if there are no 2s', () => {\n    expect(twoIsSpecial([1, 9, 1])).toEqual([]);\n  });\n\n  test('can handle an empty deck', () => {\n    expect(twoIsSpecial([])).toEqual([]);\n  });\n});\n\ndescribe('perfectlyOrdered', () => {\n  test('sorts the cards lowest to highest', () => {\n    const deck = [2, 1, 6, 9, 3];\n    const expected = [1, 2, 3, 6, 9];\n    expect(perfectlyOrdered(deck)).toEqual(expected);\n  });\n\n  test('can handle duplicated numbers', () => {\n    const deck = [2, 2, 6, 9, 3, 6];\n    const expected = [2, 2, 3, 6, 6, 9];\n    expect(perfectlyOrdered(deck)).toEqual(expected);\n  });\n\n  test('works for a large deck', () => {\n    const deck = [6, 10, 5, 9, 4, 3, 7, 7, 1, 2, 6, 8, 1, 3];\n    const expected = [1, 1, 2, 3, 3, 4, 5, 6, 6, 7, 7, 8, 9, 10];\n    expect(perfectlyOrdered(deck)).toEqual(expected);\n  });\n\n  test('can handle an empty deck', () => {\n    expect(perfectlyOrdered([])).toEqual([]);\n  });\n});\n\ndescribe('reorder', () => {\n  test('reorders the deck', () => {\n    const deck = [2, 1, 6, 9, 3];\n    const expected = [3, 9, 6, 1, 2];\n    expect(reorder(deck)).toEqual(expected);\n  });\n\n  test('works for a large deck', () => {\n    const deck = [6, 10, 5, 9, 4, 3, 7, 7, 1, 2, 6, 8, 1, 3];\n    const expected = [3, 1, 8, 6, 2, 1, 7, 7, 3, 4, 9, 5, 10, 6];\n    expect(reorder(deck)).toEqual(expected);\n  });\n\n  test('modifies the original deck', () => {\n    const deck = [2, 1, 6, 9, 3];\n    const expected = [3, 9, 6, 1, 2];\n    reorder(deck);\n    expect(deck).toEqual(expected);\n  });\n\n  test('can handle an empty deck', () => {\n    expect(reorder([])).toEqual([]);\n  });\n});\n"
}