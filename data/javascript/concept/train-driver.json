{
  "language": "javascript",
  "slug": "train-driver",
  "title": "Train Driver",
  "docs": {
    "introduction": "# Introduction\n\nJavaScript has a built-in `...` operator that makes it easier to work with indefinite numbers of elements. Depending on the context, it's called either a _rest operator_ or _spread operator_.\n\n## Rest operator\n\n### Rest elements\n\nWhen `...` appears on the left-hand side of an assignment, those three dots are known as the `rest` operator. The three dots together with a variable name is called a rest element. It collects zero or more values, and stores them into a single array.\n\n```javascript\nconst [a, b, ...everythingElse] = [0, 1, 1, 2, 3, 5, 8];\na;\n// => 0\nb;\n// => 1\neverythingElse;\n// => [1, 2, 3, 5, 8]\n```\n\nNote that in JavaScript, unlike some other languages, a `rest` element cannot have a trailing comma. It _must_ be the last element in a destructuring assignment. The example below throws a `SyntaxError`:\n\n```javascript\nconst [...items, last] = [2, 4, 8, 16]\n```\n\n### Rest properties\n\nSimilarly to arrays, the rest operator can also be used to collect one or more object properties and store them in a single object.\n\n```javascript\nconst { street, ...address } = {\n  street: 'Platz der Republik 1',\n  postalCode: '11011',\n  city: 'Berlin',\n};\nstreet;\n// => 'Platz der Republik 1'\naddress;\n// => {postalCode: '11011', city: 'Berlin'}\n```\n\n## Rest parameters\n\nWhen `...` appears in a function definition next to its last argument, that parameter is called a _rest parameter_. It allows the function to accept an indefinite number of arguments as an array.\n\n```javascript\nfunction concat(...strings) {\n  return strings.join(' ');\n}\nconcat('one');\n// => 'one'\nconcat('one', 'two', 'three');\n// => 'one two three'\n```\n\n## Spread\n\n### Spread elements\n\nWhen `...` appears on the right-hand side of an assignment, it's known as the `spread` operator. It expands an array into a list of elements. Unlike the rest element, it can appear anywhere in an array literal expression, and there can be more than one.\n\n```javascript\nconst oneToFive = [1, 2, 3, 4, 5];\nconst oneToTen = [...oneToFive, 6, 7, 8, 9, 10];\noneToTen;\n// => [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\nconst woow = ['A', ...oneToFive, 'B', 'C', 'D', 'E', ...oneToFive, 42];\nwoow;\n// =>  [\"A\", 1, 2, 3, 4, 5, \"B\", \"C\", \"D\", \"E\", 1, 2, 3, 4, 5, 42]\n```\n\n### Spread properties\n\nSimilarly to arrays, the spread operator can also be used to copy properties from one object to another.\n\n```javascript\nlet address = {\n  postalCode: '11011',\n  city: 'Berlin',\n};\naddress = { ...address, country: 'Germany' };\n// => {\n//   postalCode: '11011',\n//   city: 'Berlin',\n//   country: 'Germany',\n// }\n```\n",
    "instructions": "# Instructions\n\nYour friend Linus is a train driver who drives cargo trains between cities.\nAlthough they are amazing at handling trains, they are not amazing at handling logistics or computers.\nThey would like to enlist your programming help organizing train details and correcting mistakes in route data.\n\n```exercism/note\nTo practice, use the rest or spread operator to solve each of the tasks below.\n```\n\n## 1. Create a list of all wagons\n\nYour friend has been keeping track of each wagon identifier (ID), but they are never sure how many wagons the system is going to have to process at any given time.\nIt would be much easier for the rest of the logistics program to have this data packaged into a unified `array`.\n\nImplement a function `getListOfWagons` that accepts an arbitrary number of wagon IDs which are the IDs of each wagon.\nEach ID will be a positive integer.\nThe function should then return the given IDs as a single `array`.\n\n```javascript\ngetListOfWagons(1, 7, 12, 3, 14, 8, 5);\n// => [1, 7, 12, 3, 14, 8, 5]\n```\n\n## 2. Move the first two elements to the end of the array\n\nAt this point, you are starting to get a feel for the data and how it's used in the logistics program.\nThe ID system always assigns the locomotive an ID of **1**, with the remainder of the wagons in the train assigned a randomly chosen ID greater than **1**.\n\nYour friend had to connect two new wagons to the train and forgot to update the system!\nNow, the first two wagons in the train `array` have to be moved to the end, or everything will be out of order.\n\nLinus would be really grateful to you for fixing their mistakes.\n\nImplement a function `fixListOfWagons` that accepts an array of the id of each wagon.\nIt `return`s an `array` where the 2 first elements repositioned to the end of the `array` so that the locomotive can be in the front.\n\n```javascript\neachWagonsID = [2, 5, 1, 7, 4, 12, 6, 3, 13];\nfixListOfWagons(eachWagonsID);\n// => [1, 7, 4,  12, 6, 3, 13, 2, 5]\n```\n\n## 3. Add missing values\n\nUh-oh. some wagons seem to have gone missing.\n\nFortunately, your friend just found another `array` which appears to contain the missing wagon IDs, and would like you to add them into the main wagon ID `array`.\nAll they can remember is that the missing values should be placed directly after the designated locomotive.\n\nGiven this new information, write a function called `correctListOfWagons` that takes two arrays which have the IDs of each wagon as the arguments.\nThe wagon IDs of the second `array` should be added into the first `array` directly after the locomotive (ID 1).\n\n```javascript\neachWagonsID = [1, 5, 20, 7, 4, 8];\nmissingWagons = [3, 17, 6, 15];\ncorrectListOfWagons(eachWagonsID, missingWagons);\n// => [1, 3, 17, 6, 15, 5, 20, 7, 4, 8]\n```\n\n## 4. Extend routing information\n\nNow that all the wagon data is correct, your friend would like you to update the systems routing information.\nInitial routing information has been constructed as an `object`, and you friend would like you to update it with the additions provided.\nEvery route requires slightly different information, so your friend would really prefer a generic solution.\n\nImplement a function `extendRouteInformation` that accepts two `objects`.\nThe first `object` contains which cities the train route moves between.\n\nThe second `object` contains other routing details such as train speed or length.\nThe function should return a consolidated `object` with all routing information.\n\n```exercism/note\nThe variable `moreRouteInformation` can contain different properties.\n```\n\n```javascript\nroute = { from: 'Berlin', to: 'Hamburg' };\nmoreRouteInformation = { length: '100', speed: '50' };\nextendRouteInformation(route, moreRouteInformation);\n// => {from: \"Berlin\", to: \"Hamburg\", length: \"100\", speed: \"50\"}\n```\n\n## 5. Separate arrival time from routing information\n\nYour friend has noticed that they don't need the arrival time in the routing information.\nTherefore your friend would like you to separate the arrival time from the routing information.\n\nImplement a function `separateTimeOfArrival` that accepts an object with the routing information.\nThe function should return an array where the first element of the array is the arrival time and the second element is an object with the routing information without arrival time.\n\n```javascript\nrouteInformation = {\n  from: 'Berlin',\n  to: 'Hamburg',\n  length: '100',\n  timeOfArrival: '10:10',\n};\nseparateTimeOfArrival(routeInformation);\n// => [\"10:10\", {from: \"Berlin\", to: \"Hamburg\", length: \"100\"}]\n```\n",
    "hints": "# Hints\n\n## General\n\n- To extract multiple arguments in the function parameters so can you pack them with the `...<args>`.\n- To use rest and spread use the `...` operator.\n\n## 1. Create a list of all wagons\n\n- Multiple arguments in the function parameters can be packed with the [`...<args>` (spread) syntax][spread-syntax]. operator.\n\n## 2. Move the first two elements to the end of the array\n\n- You can unpack a series of parameters using [a destructuring assignment (`...`)][destructuring-assignment].\n  This lets you extract the first two elements of an `array` while keeping the rest intact.\n- To add another `array` into an existing `array`, you can use the `...` operator to \"spread\" the `array`.\n\n## 3. Add missing values\n\n- Using unpacking with the rest operator(`...`), you can extract the first element of an `array` while keeping the rest intact.\n- To add another `array` into an existing `array`, you can use the `...` operator to \"spread\" the `array`.\n\n## 4. Extend routing information\n\n- To add another `object` into an existing `object`, you can use the `...` operator to \"spread\" the `object`.\n\n## 5. Separate arrival time from routing information\n\n- To extract a value from an `object` while keeping the rest intact, you can use the rest operator(`...`).\n\n[spread-syntax]: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Spread_syntax\n[destructuring-assignment]: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Destructuring_assignment\n"
  },
  "starter_code": "// @ts-check\n//\n// The line above enables type checking for this file. Various IDEs interpret\n// the @ts-check directive. It will give you helpful autocompletion when\n// implementing this exercise.\n\n/**\n * Return each wagon's id in form of an array.\n *\n * @param {number[]} ids\n * @returns {number[]} wagon ids\n */\nexport function getListOfWagons(...ids) {\n  return ids;\n}\n\n/**\n * Reorder the array of wagons by moving the first 2 wagons to the end of the array.\n *\n * @param {Iterable<number>} ids\n * @returns {number[]} reordered list of wagons\n */\nexport function fixListOfWagons([first, second, ...rest]) {\n  return [...rest, first, second];\n}\n\n/**\n * Fixes the array of wagons by inserting an array of wagons after the first element in eachWagonsID.\n *\n * @param {Iterable<number>} ids\n * @param {Iterable<number>} missingWagons\n * @returns {number[]} corrected list of wagons\n */\nexport function correctListOfWagons([first, ...rest], missingWagons) {\n  return [first, ...missingWagons, ...rest];\n}\n\n/**\n * Extend route information by adding another object\n *\n * @param {Record<string, string>} information\n * @param {Record<string, string>} additional\n * @returns {Record<string, string>} extended route information\n */\nexport function extendRouteInformation(information, additional) {\n  return { ...information, ...additional };\n}\n\n/**\n * Separate arrival time from the route information object\n *\n * @param {Record<string, string>} information\n * @returns {[string, Record<string, string>]} array with arrival time and object without arrival time\n */\nexport function separateTimeOfArrival(information) {\n  const { timeOfArrival, ...rest } = information;\n\n  return [timeOfArrival, rest];\n}\n",
  "tests": "import { describe, test, expect } from '@jest/globals';\n\nimport {\n  getListOfWagons,\n  fixListOfWagons,\n  correctListOfWagons,\n  extendRouteInformation,\n  separateTimeOfArrival,\n} from './train-driver';\n\nconst customInspectSymbol = Symbol.for('nodejs.util.inspect.custom');\nconst customLogSymbol = Symbol.for('exercism.javascript.util.log');\n\n// Follow the instructions in case you are stuck on \"list.method is not a function\"\nclass LimitedArray {\n  constructor(values) {\n    this.values = values;\n  }\n\n  // Enables rest syntax and spread operator, as wel as for of, etc.\n  [Symbol.iterator]() {\n    return this.values[Symbol.iterator]();\n  }\n\n  // Log value in non-upgraded environments\n  toString() {\n    return this.values.toString();\n  }\n\n  // Overrides logging in node (ie. students working locally)\n  [customInspectSymbol](depth, inspectOptions, inspect) {\n    const inner = this.values[customInspectSymbol]\n      ? this.values[customInspectSymbol](depth, inspectOptions, inspect)\n      : this.values.toString();\n\n    return `List of (${inner})`;\n  }\n\n  // Overrides log overrides in web environment (ie. students working in editor)\n  [customLogSymbol](depth, inspectOptions, inspect) {\n    const inner = this.values[customLogSymbol]\n      ? this.values[customLogSymbol](depth, inspectOptions, inspect)\n      : this.values.toString();\n\n    return `List of (${inner})`;\n  }\n}\n\nfunction list(...values) {\n  return new LimitedArray(values);\n}\n\nfunction time(timeOfArrival, route) {\n  Object.defineProperty(route, 'timeOfArrival', {\n    configurable: false,\n    writable: false,\n    enumerable: true,\n    value: timeOfArrival,\n  });\n\n  return route;\n}\n\ndescribe('getListOfWagons', () => {\n  test('returns the correct array', () => {\n    expect(getListOfWagons(1, 5, 2, 7, 4)).toStrictEqual([1, 5, 2, 7, 4]);\n  });\n\n  test('works for a few arguments', () => {\n    expect(getListOfWagons(1, 5)).toStrictEqual([1, 5]);\n  });\n\n  test('works for a one argument', () => {\n    expect(getListOfWagons(1)).toStrictEqual([1]);\n  });\n\n  test('works for many arguments', () => {\n    expect(getListOfWagons(1, 5, 6, 3, 9, 8, 4, 14, 24, 7)).toStrictEqual([\n      1, 5, 6, 3, 9, 8, 4, 14, 24, 7,\n    ]);\n  });\n});\n\ndescribe('fixListOfWagons', () => {\n  test('reorders the first 2 wagons to the end of the array', () => {\n    const eachWagonsID = list(3, 7, 1, 14, 10, 4, 12, 6, 23, 17, 13, 20, 8, 19);\n    const expected = [1, 14, 10, 4, 12, 6, 23, 17, 13, 20, 8, 19, 3, 7];\n\n    expect(fixListOfWagons(eachWagonsID)).toStrictEqual(expected);\n  });\n\n  test('works when only 3 wagons given', () => {\n    const eachWagonsID = list(4, 2, 1);\n\n    expect(fixListOfWagons(eachWagonsID)).toStrictEqual([1, 4, 2]);\n  });\n\n  test('works for a few wagons', () => {\n    const eachWagonsID = list(3, 4, 1, 5, 7, 9, 10);\n\n    expect(fixListOfWagons(eachWagonsID)).toStrictEqual([1, 5, 7, 9, 10, 3, 4]);\n  });\n});\n\ndescribe('correctListOfWagons', () => {\n  test('returns a wagon weight list with the inserted array of values', () => {\n    const eachWagonsID = list(1, 6, 11, 15, 13, 14, 17, 22, 2, 16, 19, 21);\n    const missingWagons = list(8, 10, 5, 9, 3, 7, 20);\n    const expected = [\n      1, 8, 10, 5, 9, 3, 7, 20, 6, 11, 15, 13, 14, 17, 22, 2, 16, 19, 21,\n    ];\n\n    expect(correctListOfWagons(eachWagonsID, missingWagons)).toStrictEqual(\n      expected,\n    );\n  });\n\n  test('works for short arrays', () => {\n    const eachWagonsID = list(1, 7, 15, 24);\n    const missingWagons = list(8, 6, 4);\n    const expected = [1, 8, 6, 4, 7, 15, 24];\n\n    expect(correctListOfWagons(eachWagonsID, missingWagons)).toStrictEqual(\n      expected,\n    );\n  });\n\n  test('works when missingWagons is longer', () => {\n    const eachWagonsID = list(1, 7, 15, 24);\n    const missingWagons = list(8, 6, 4, 5, 9, 21, 2, 13);\n    const expected = [1, 8, 6, 4, 5, 9, 21, 2, 13, 7, 15, 24];\n\n    expect(correctListOfWagons(eachWagonsID, missingWagons)).toStrictEqual(\n      expected,\n    );\n  });\n});\n\ndescribe('extendRouteInformation', () => {\n  test('correctly extends route information', () => {\n    const route = { from: 'Berlin', to: 'Hamburg' };\n    const moreRouteInformation = {\n      timeOfArrival: '12:00',\n      precipitation: '10',\n      temperature: '5',\n    };\n\n    const expected = {\n      from: 'Berlin',\n      to: 'Hamburg',\n      timeOfArrival: '12:00',\n      precipitation: '10',\n      temperature: '5',\n    };\n\n    expect(extendRouteInformation(route, moreRouteInformation)).toStrictEqual(\n      expected,\n    );\n  });\n\n  test('works when not adding precipitation', () => {\n    const route = { from: 'Paris', to: 'London' };\n    const moreRouteInformation = { timeOfArrival: '10:30', temperature: '20' };\n\n    const expected = {\n      from: 'Paris',\n      to: 'London',\n      timeOfArrival: '10:30',\n      temperature: '20',\n    };\n\n    expect(extendRouteInformation(route, moreRouteInformation)).toStrictEqual(\n      expected,\n    );\n  });\n\n  test('works when written in different order', () => {\n    const route = { from: 'Gothenburg', to: 'Copenhagen' };\n    const moreRouteInformation = {\n      precipitation: '1',\n      timeOfArrival: '21:20',\n      temperature: '-6',\n    };\n\n    const expected = {\n      from: 'Gothenburg',\n      to: 'Copenhagen',\n      precipitation: '1',\n      timeOfArrival: '21:20',\n      temperature: '-6',\n    };\n\n    expect(extendRouteInformation(route, moreRouteInformation)).toStrictEqual(\n      expected,\n    );\n  });\n});\n\ndescribe('separateTimeOfArrival', () => {\n  test('separates timeOfArrival from complete object', () => {\n    const route = time('12:00', {\n      from: 'Berlin',\n      to: 'Hamburg',\n      precipitation: '10',\n      temperature: '5',\n    });\n\n    const expected = [\n      '12:00',\n      { from: 'Berlin', to: 'Hamburg', precipitation: '10', temperature: '5' },\n    ];\n\n    expect(separateTimeOfArrival(route)).toStrictEqual(expected);\n  });\n\n  test('separates timeOfArrival with smaller object', () => {\n    const route = time('10:30', {\n      from: 'Paris',\n      to: 'London',\n      temperature: '20',\n    });\n\n    const expected = [\n      '10:30',\n      { from: 'Paris', to: 'London', temperature: '20' },\n    ];\n\n    expect(separateTimeOfArrival(route)).toStrictEqual(expected);\n  });\n\n  test('separates timeOfArrival from differently ordered object', () => {\n    const route = time('21:20', {\n      from: 'Gothenburg',\n      to: 'Copenhagen',\n      precipitation: '1',\n      temperature: '-6',\n    });\n\n    const expected = [\n      '21:20',\n      {\n        from: 'Gothenburg',\n        to: 'Copenhagen',\n        precipitation: '1',\n        temperature: '-6',\n      },\n    ];\n\n    expect(separateTimeOfArrival(route)).toStrictEqual(expected);\n  });\n});\n"
}