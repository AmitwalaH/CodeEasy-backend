{
  "concept": "promises",
  "about": "# About\n\nThe [`Promise`][promise-docs] object represents the eventual completion (or failure) of an asynchronous operation and its resulting value.\n\n<!-- prettier-ignore -->\n~~~exercism/note\nThis is a hard topic for many people, specially if you know programming in a language that is completely _synchronous_.\nIf you feel overwhelmed, or you would like to learn more about **concurrency** and **parallelism**, [watch (via go.dev)][talk-blog] or [watch directly via vimeo][talk-video] and [read the slides][talk-slides] of the brilliant talk \"Concurrency is not parallelism\".\n\n[talk-slides]: https://go.dev/talks/2012/waza.slide#1\n[talk-blog]: https://go.dev/blog/waza-talk\n[talk-video]: https://vimeo.com/49718712\n~~~\n\n## Lifecycle of a promise\n\nA `Promise` has three states:\n\n1. pending\n2. fulfilled\n3. rejected\n\nWhen it is created, a promise is pending.\nAt some point in the future it may _resolve_ or _reject_.\nOnce a promise is resolved or rejected once, it can never be resolved or rejected again, nor can its state change.\n\nIn other words:\n\n1. When pending, a promise:\n   - may transition to either the fulfilled or rejected state.\n2. When fulfilled, a promise:\n   - must not transition to any other state.\n   - must have a value, which must not change.\n3. When rejected, a promise:\n   - must not transition to any other state.\n   - must have a reason, which must not change.\n\n## Resolving a promise\n\nA promise may be resolved in various ways:\n\n```javascript\n// Creates a promise that is immediately resolved\nPromise.resolve(value);\n\n// Creates a promise that is immediately resolved\nnew Promise((resolve) => {\n  resolve(value);\n});\n\n// Chaining a promise leads to a resolved promise\nsomePromise.then(() => {\n  // ...\n  return value;\n});\n```\n\nIn the examples above `value` can be _anything_, including an error, `undefined`, `null` or another promise.\nUsually you want to resolve with a value that's not an error.\n\n## Rejecting a promise\n\nA promise may be rejected in various ways:\n\n```javascript\n// Creates a promise that is immediately rejected\nPromise.reject(reason)\n\n// Creates a promise that is immediately rejected\nnew Promise((_, reject) {\n  reject(reason)\n})\n\n// Chaining a promise with an error leads to a rejected promise\nsomePromise.then(() => {\n  // ...\n  throw reason\n})\n```\n\nIn the examples above `reason` can be _anything_, including an error, `undefined` or `null`.\nUsually you want to reject with an error.\n\n## Chaining a promise\n\nA promise may be _continued_ with a future action once it resolves or rejects.\n\n- [`promise.then()`][promise-then] is called once `promise` resolves\n- [`promise.catch()`][promise-catch] is called once `promise` rejects\n- [`promise.finally()`][promise-finally] is called once `promise` either resolves or rejects\n\n### **then**\n\nEvery promise is \"thenable\".\nThat means that there is a function `then` available that will be executed once the original promise is resolves.\nGiven `promise.then(onResolved)`, the callback `onResolved` receives the value the original promise was resolved with.\nThis will always return a _new_ \"chained\" promise.\n\nReturning a `value` from `then` resolves the \"chained\" promise.\nThrowing a `reason` in `then` rejects the \"chained\" promise.\n\n```javascript\nconst promise1 = new Promise(function (resolve, reject) {\n  setTimeout(() => {\n    resolve('Success!');\n  }, 1000);\n});\n\nconst promise2 = promise1.then(function (value) {\n  console.log(value);\n  // expected output: \"Success!\"\n\n  return true;\n});\n```\n\nThis will log `\"Success!\"` after approximately 1000 ms.\nThe state & value of `promise1` will be `resolved` and `\"Success!\"`.\nThe state & value of `promise2` will be `resolved` and `true`.\n\nThere is a second argument available that runs when the original promise rejects.\nGiven `promise.then(onResolved, onRejected)`, the callback `onResolved` receives the value the original promise was resolved with, or the callback `onRejected` receives the reason the promise was rejected.\n\n```javascript\nconst promise1 = new Promise(function (resolve, reject) {\n  setTimeout(() => {\n    resolve('Success!');\n  }, 1000);\n\n  if (Math.random() < 0.5) {\n    reject('Nope!');\n  }\n});\n\nfunction log(value) {\n  console.log(value);\n  return true;\n}\n\nfunction shout(reason) {\n  console.error(reason.toUpperCase());\n  return false;\n}\n\nconst promise2 = promise1.then(log, shout);\n```\n\n- In about 1/2 of the cases, this will log `\"Success!\"` after approximately 1000 ms.\n  - The state & value of `promise1` will be `resolved` and `\"Success!\"`.\n  - The state & value of `promise2` will be `resolved` and `true`.\n- In about 1/2 of the cases, this will immediately log `\"NOPE!\"`.\n  - The state & value of `promise1` will be `rejected` and `Nope!`.\n  - The state & value of `promise2` will be `resolved` and `false`.\n\nIt is important to understand that because of the rules of the lifecycle, when it `reject`s, the `resolve` that comes in ~1000ms later is silently ignored, as the internal state cannot change once it has rejected or resolved.\nIt is important to understand that returning a value from a promise resolves it, and throwing a value rejects it.\nWhen `promise1` resolves and there is a chained `onResolved`: `then(onResolved)`, then that follow-up is a new promise that can resolve or reject.\nWhen `promise1` rejects but there is a chained `onRejected`: `then(, onRejected)`, then that follow-up is a new promise that can resolve or reject.\n\n### **catch**\n\nSometimes you want to capture errors and only continue when the original promise `reject`s.\nGiven `promise.catch(onCatch)`, the callback `onCatch` receives the reason the original promise was rejected.\nThis will always return a _new_ \"chained\" promise.\n\nReturning a `value` from `catch` resolves the \"chained\" promise.\nThrowing a `reason` in `catch` rejects the \"chained\" promise.\n\n```javascript\nconst promise1 = new Promise(function (resolve, reject) {\n  setTimeout(() => {\n    resolve('Success!');\n  }, 1000);\n\n  if (Math.random() < 0.5) {\n    reject('Nope!');\n  }\n});\n\nfunction log(value) {\n  console.log(value);\n  return 'done';\n}\n\nfunction recover(reason) {\n  console.error(reason.toUpperCase());\n  return 42;\n}\n\nconst promise2 = promise1.catch(recover).then(log);\n```\n\nIn about 1/2 of the cases, this will log `\"Success!\"` after approximately 1000 ms.\nIn the other 1/2 of the cases, this will immediately log `42`.\n\n- If `promise1` resolves, `catch` is skipped and it reaches `then`, and logs the value.\n  - The state & value of `promise1` will be `resolved` and `\"Success!\"`.\n  - The state & value of `promise2` will be `resolved` and `\"done\"`;\n- If `promise1` rejects, `catch` is executed, which _returns a value_, and thus the chain is now `resolved`, and it reaches `then`, and logs the value.\n  - The state & value of `promise1` will be `rejected` and `\"Nope!\"`.\n  - The state & value of `promise2` will be `resolved` and `\"done\"`;\n\n### **finally**\n\nSometimes you want to execute code after a promise settles, regardless if the promise resolves or rejects.\nGiven `promise.finally(onSettled)`, the callback `onSettled` receives nothing.\nThis will always return a _new_ \"chained\" promise.\n\nReturning a `value` from `finally` copies the status & value from the original promise, ignoring the `value`.\nThrowing a `reason` in `finally` rejects the \"chained\" promise, overwriting any status & value or reason from the original promise.\n\n## Example\n\nVarious of the methods together:\n\n```javascript\nconst myPromise = new Promise(function (resolve, reject) {\n  const sampleData = [2, 4, 6, 8];\n  const randomNumber = Math.round(Math.random() * 5);\n\n  if (sampleData[randomNumber]) {\n    resolve(sampleData[randomNumber]);\n  } else {\n    reject('Sampling did not result in a sample');\n  }\n});\n\nconst finalPromise = myPromise\n  .then(function (sampled) {\n    // If the random number was 0, 1, 2, or 3, this will be\n    // reached and the number 2, 4, 6, or 8 will be logged.\n    console.log(`Sampled data: ${sampled}`);\n    return 'yay';\n  })\n  .catch(function (reason) {\n    // If the random number was 4 or 5, this will be reached and\n    // reason will be \"An error occurred\". The entire chain will\n    // then reject with an Error with the reason as message.\n    throw new Error(reason);\n  })\n  .finally(function () {\n    // This will always log after either the sampled data is\n    // logged or the error is raised.\n    console.log('Promise completed');\n  });\n```\n\n- In the cases `randomNumber` is `0-3`:\n  - `myPromise` will be resolved with the value `2, 4, 6, or 8`\n  - `finalPromise` will be resolved with the value `'yay'`\n  - There will be two logs:\n    - `Sampled data: ...`\n    - `Promise completed`\n- In the cases `randomNumber` is `4-5`:\n  - `myPromise` will be rejected with the reason `'Sampling did not result in a sample'`\n  - `finalPromise` will be rejected with the reason `Error('Sampling did not result in a sample')`\n  - There will be one log:\n    - `Promise completed`\n    - _in some environments_ this will yield an `\"uncaught rejected promise: Error('Sampling did not result in a sample')\"` log\n\nAs shown above, `reject` works with a string, and a promise can also reject with an `Error`.\n\n<!-- prettier-ignore -->\n~~~exercism/note\nIf chaining promises or general usage is unclear, the [tutorial on MDN][mdn-promises] is a good resource to consume.\n\n[mdn-promises]: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Using_promises\n~~~\n\n[promise-docs]: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise\n[promise-catch]: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise/catch\n[promise-then]: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise/then\n[promise-finally]: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise/finally\n",
  "introduction": "# Introduction\n\nThe [`Promise`][promise-docs] object represents the eventual completion (or failure) of an asynchronous operation and its resulting value.\n\n<!-- prettier-ignore -->\n~~~exercism/note\nThis is a hard topic for many people, especially if you know programming in a language that is completely _synchronous_.\nIf you feel overwhelmed, or you would like to learn more about **concurrency** and **parallelism**, [watch (via go.dev)][talk-blog] or [watch directly via vimeo][talk-video] and [read the slides][talk-slides] of the brilliant talk \"Concurrency is not parallelism\".\n\n[talk-slides]: https://go.dev/talks/2012/waza.slide#1\n[talk-blog]: https://go.dev/blog/waza-talk\n[talk-video]: https://vimeo.com/49718712\n~~~\n\n## Lifecycle of a promise\n\nA `Promise` has three states:\n\n1. pending\n2. fulfilled\n3. rejected\n\nWhen it is created, a promise is pending.\nAt some point in the future it may _resolve_ or _reject_.\nOnce a promise is resolved or rejected once, it can never be resolved or rejected again, nor can its state change.\n\nIn other words:\n\n1. When pending, a promise:\n   - may transition to either the fulfilled or rejected state.\n2. When fulfilled, a promise:\n   - must not transition to any other state.\n   - must have a value, which must not change.\n3. When rejected, a promise:\n   - must not transition to any other state.\n   - must have a reason, which must not change.\n\n## Chaining promises\n\nIn JavaScript, there are various methods to chain promises.\nCalling a chaining method on a promise returns another promise.\n\n<!-- prettier-ignore -->\n~~~exercism/note\nThe [tutorial on MDN][mdn-promises] is a good resource to consume if you want to learn more about promises before completing the concept exercise.\n\n[mdn-promises]: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Using_promises\n~~~\n\n[promise-docs]: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise\n",
  "links": [
    {
      "url": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Using_promises",
      "description": "MDN: Using promises"
    },
    {
      "url": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise",
      "description": "MDN: Introduction to Promises"
    }
  ],
  "config": {}
}