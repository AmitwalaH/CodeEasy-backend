{
  "concept": "classes",
  "about": "# About\n\nJavaScript includes the capabilities for object-oriented programming ([OOP][wiki-oop]).\nIn OOP, you want to create objects (_instances_) from \"templates\" (_classes_) so that they include certain data and functionality.\nThe data properties are called _fields_ in the OOP context, the function properties are called _methods_.\n\nJavaScript did not have classes at all before they were added to the language specification in 2015 but allowed for object-oriented programming using prototype-based inheritance.\nAnd even though a `class` keyword is available nowadays, JavaScript is still a _prototype-based_ language.\n\nTo understand what it means to be a prototype-based language and how JavaScript actually works, we will go back to the time when there were no classes.\n\n## Prototype Syntax\n\n### Constructor Function\n\nIn JavaScript, the template (class) is facilitated by a regular function.\nWhen a function is supposed to be used as such a template, it is called a _constructor function_ and the convention is that the function name should start with a capital letter.\nInstances (objects) are derived from the template using the `new` keyword when invoking the constructor function.\n\n```javascript\nfunction Car() {\n  // ...\n}\n\nconst myCar = new Car();\nconst yourCar = new Car();\n```\n\nIt is important to note that in JavaScript, the instances and the constructor function keep a relationship to each other even after the instances were created.\nEvery instance object includes a hidden, internal property referred to as `[[prototype]]` in the language specification.\nIt holds a reference to the value of the `prototype` key of the constructor function.\nYes, you read that correctly, a JavaScript function can have key/value pairs because it is also an object behind the scenes.\n\nSince 2015, `[[prototype]]` can be accessed via `Object.getPrototypeOf()`.\nBefore that, it was accessible via the key `__proto__` in many environments.\n\nDo not confuse the prototype of an object (`[[prototype]]`) with the `prototype` property of the constructor function.\n\n<!-- prettier-ignore-start -->\n~~~~exercism/note\nTo summarize:\n\n- Constructors in JavaScript are regular functions.\n- Constructing a new instance creates an object with a relation to its constructor called its _prototype_.\n- Functions are objects (callable objects) and therefore they can have properties.\n- The constructor's (function) `prototype` property will become the instance's _prototype_.\n~~~~\n<!-- prettier-ignore-end -->\n\n### Instance Fields\n\nOften, you want all the derived objects (instances) to include some fields and pass some initial values for those when the object is constructed.\nThis can be facilitated via the [`this` keyword][mdn-this].\nInside the constructor function, `this` represents the new object that will be created via `new`.\n`this` is automatically returned from the constructor function when it is called with `new`.\n\nThat means we can add fields to the new instance by adding them to `this` in the constructor function.\n\n```javascript\nfunction Car(color, weight) {\n  this.color = color;\n  this.weight = weight;\n  this.engineRunning = false;\n}\n\nconst myCar = new Car('red', '2mt');\nmyCar.color;\n// => 'red'\nmyCar.engineRunning;\n// => false\n```\n\n### Instance Methods\n\nMethods are added via the `prototype` property of the constructor function.\nInside a method, you can access the fields of the instance via `this`.\nThis works because of the following general rule.\n\n> When a function is called as a method of an object, its `this` is set to the object the method is called on. [^1]\n\n```javascript\nfunction Car() {\n  this.engineRunning = false;\n  // ...\n}\n\nCar.prototype.startEngine = function () {\n  this.engineRunning = true;\n};\n\nCar.prototype.addGas = function (litre) {\n  // ...\n};\n\nconst myCar = new Car();\nmyCar.startEngine();\nmyCar.engineRunning;\n// => true\n```\n\n### The Prototype Chain\n\n`myCar` in the example above is a regular JavaScript object and if we would inspect it (e.g. in the browser console), we would not find a property `startEngine` with a function as a value directly inside the `myCar` object.\nSo how does the code above even work then?\n\nThe secret here is called the _prototype chain_.\nWhen you try to access any property (field or method) of an object, JavaScript first checks whether the respective key can be found directly in the object itself.\nIf not, it continues to look for the key in the object referenced by the `[[prototype]]` property of the original object.\nAs mentioned before, in our example `[[prototype]]` points to the `prototype` property of the constructor function.\nThat is where JavaScript would find the `startEngine` function because we added it there.\n\n```javascript\nfunction Car() {\n  // ...\n}\n\nCar.prototype.startEngine = function () {\n  // ...\n};\n```\n\nAnd the chain does not end there.\nThe `[[prototype]]` property of `Car.prototype` (`myCar.[[prototype]].[[prototype]]`) references `Object.prototype` (the `prototype` property of the `Object` constructor function).\nIt contains general methods that are available for all JavaScript objects, e.g. `toString()`.\nThe `[[prototype]]` of `Object` is usually `null` so the prototype chain ends there.\nIn conclusion, you can call `myCar.toString()` and that method will exist because JavaScript searches for that method throughout the whole prototype chain.\nYou can find a detailed example in the [MDN article \"Inheritance and the prototype chain\"][mdn-prototype-chain-example].\n\n<!-- prettier-ignore-start -->\n~~~~exercism/caution\nNote that the prototype chain is only travelled when retrieving a value.\nSetting a property directly or deleting a property of an instance object only targets that specific instance.\nThis might not be what you would expect when you are used to a language with class-based inheritance.\n~~~~\n<!-- prettier-ignore-end -->\n\n### Dynamic Methods (Adding Methods to All Existing Instances)\n\nJavaScript allows you to add methods to all existing instances even after they were created.\n\nWe learned that every instance keeps a reference to the `prototype` property of the constructor function.\nThat means if you add an entry to that `prototype` object, that new entry (e.g. a new method) is immediately available to all instances created from that constructor function.\n\n```javascript\nfunction Car() {\n  this.engineRunning = false;\n}\n\nconst myCar = new Car();\n// Calling myCar.startEngine() here would result in \"TypeError:\n// myCar.startEngine is not a function\".\n\nCar.prototype.startEngine = function () {\n  this.engineRunning = true;\n};\n\nmyCar.startEngine();\n// This works, even though myCar was created before the method\n// was added.\n```\n\nIn theory, dynamic methods can even be used to extend the functionality of built-in objects like `Object` or `Array` by modifying their prototype.\nThis is called _monkey patching_.\nBecause this change affects the whole application, it should be avoided to prevent unintended side effects.\nThe only reasonable use case is to provide a [polyfill][wiki-polyfill] for a missing method in older environments.\n\n## Class Syntax\n\nNowadays, JavaScript supports defining classes with a `class` keyword.\nThis was added to the language specification in 2015.\nOn the one hand, this provides syntactic sugar that makes classes easier to read and write.\nThe new syntax is more similar to how classes are written in languages like C++ or Java.\nDevelopers switching over from those languages have an easier time adapting.\nOn the other hand, class syntax paves the way for new language features that are not available in the prototype syntax.\n\n### Class Declarations\n\nWith the new syntax, classes are defined with the `class` keyword, followed by the name of the class and the class body in curly brackets.\nThe body contains the definition of the constructor function, i.e. a special method with the name `constructor`.\nThis function works just like the constructor function in the prototype syntax.\nThe class body also contains all method definitions.\nThe syntax for the methods is similar to the shorthand notation we have seen for adding functions as values inside an object, see [Concept Objects][concept-objects].\n\n```javascript\nclass Car {\n  constructor(color, weight) {\n    this.color = color;\n    this.weight = weight;\n    this.engineRunning = false;\n  }\n\n  startEngine() {\n    this.engineRunning = true;\n  }\n\n  addGas(litre) {\n    // ...\n  }\n}\n\nconst myCar = new Car();\nmyCar.startEngine();\nmyCar.engineRunning;\n// => true\n```\n\nSimilar to function declarations and function expressions, JavaScript also supports [class expressions][mdn-class-expression] in addition to the _class declaration_ shown above.\n\nKeep in mind that behind the scenes, JavaScript is still a prototype-based language.\nAll the mechanisms we learned about in the \"Prototype Syntax\" section above still apply.\n\n### Private Fields, Getters and Setters\n\nBy default, all instance fields are public in JavaScript.\nThey can be directly accessed and assigned to.\n\nAdding actual private fields to the language specification is a work in progress, see the [proposal document][proposal-private-fields] for details.\n\nIn the meantime, you can make use of the established convention that fields and methods that start with an underscore should be treated as private.\nThey should never be accessed directly from outside the class.\n\nPrivate fields are sometimes accompanied by [getters][mdn-get] and [setters][mdn-set].\nWith the keywords `get` and `set` you can define functions that are executed when a property with the same name as the function is accessed or assigned to.\n\n```javascript\nclass Car {\n  constructor() {\n    this._mileage = 0;\n  }\n\n  get mileage() {\n    return this._mileage;\n  }\n\n  set mileage(value) {\n    throw new Error(`Mileage cannot be manipulated, ${value} is ignored.`);\n    // Just an example, usually you would not provide a setter in this case.\n  }\n}\n\nconst myCar = new Car();\nmyCar.mileage;\n// => 0\nmyCar.mileage = 100;\n// => Error: Mileage cannot be manipulated, 100 is ignored.\n```\n\n### Class Fields and Class Methods\n\nIn OOP, you sometimes want to provide utility fields or methods that do not depend on the specific instance.\nInstead, they are defined for the class itself.\nThis can be achieved with the `static` keyword.\n\n```javascript\nclass Car {\n  static type = 'vehicle';\n\n  static isType(targetType) {\n    return targetType === 'vehicle';\n  }\n}\n\nCar.type;\n// => 'vehicle'\n\nCar.isType('road sign');\n// => false\n```\n\n### Class-Based Inheritance\n\nBesides the type of [inheritance][wiki-inheritance] along the prototype chain we saw earlier, you can also represent inheritance between classes in JavaScript.\nThis is covered in the [Concept Inheritance][concept-inheritance].\n\n---\n\n[^1]: `this` Examples - As an object method, MDN. <https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/this#as_an_object_method> (referenced December 03, 2021)\n\n[wiki-oop]: https://en.wikipedia.org/wiki/Object-oriented_programming\n[mdn-prototype-chain-example]: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Inheritance_and_the_prototype_chain#inheritance_with_the_prototype_chain\n[concept-inheritance]: /tracks/javascript/concepts/inheritance\n[mdn-class-expression]: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Classes#Class_expressions\n[wiki-inheritance]: https://en.wikipedia.org/wiki/Inheritance_(object-oriented_programming)\n[proposal-private-fields]: https://github.com/tc39/proposal-private-methods#private-methods-and-fields\n[mdn-get]: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/get\n[mdn-set]: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/set\n[wiki-polyfill]: https://en.wikipedia.org/wiki/Polyfill_(programming)\n[mdn-this]: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/this\n[concept-objects]: /tracks/javascript/concepts/objects\n",
  "introduction": "# Introduction\n\nJavaScript includes the capabilities for object-oriented programming ([OOP][wiki-oop]).\nIn OOP, you want to create objects (_instances_) from \"templates\" (_classes_) so that they include certain data and functionality.\nThe data properties are called _fields_ in the OOP context, the function properties are called _methods_.\n\nJavaScript did not have classes at all before they were added to the language specification in 2015 but allowed for object-oriented programming using prototype-based inheritance.\nAnd even though a `class` keyword is available nowadays, JavaScript is still a _prototype-based_ language.\n\nTo understand what it means to be a prototype-based language and how JavaScript actually works, we will go back to the time when there were no classes.\n\n## Prototype Syntax\n\n### Constructor Function\n\nIn JavaScript, the template (class) is facilitated by a regular function.\nWhen a function is supposed to be used as such a template, it is called a _constructor function_ and the convention is that the function name should start with a capital letter.\nInstances (objects) are derived from the template using the `new` keyword when invoking the constructor function.\n\n```javascript\nfunction Car() {\n  // ...\n}\n\nconst myCar = new Car();\nconst yourCar = new Car();\n```\n\nIt is important to note that in JavaScript, the instances and the constructor function keep a relationship to each other even after the instances were created.\nEvery instance object includes a hidden, internal property referred to as `[[prototype]]` in the language specification.\nIt holds a reference to the value of the `prototype` key of the constructor function.\nYes, you read that correctly, a JavaScript function can have key/value pairs because it is also an object behind the scenes.\n\n<!-- prettier-ignore-start -->\n~~~~exercism/note\nTo summarize:\n\n- Constructors in JavaScript are regular functions.\n- Constructing a new instance creates an object with a relation to its constructor called its _prototype_.\n- Functions are objects (callable objects) and therefore they can have properties.\n- The constructor's (function) `prototype` property will become the instance's _prototype_.\n~~~~\n<!-- prettier-ignore-end -->\n\n### Instance Fields\n\nOften, you want all the derived objects (instances) to include some fields and pass some initial values for those when the object is constructed.\nThis can be facilitated via the [`this` keyword][mdn-this].\nInside the constructor function, `this` represents the new object that will be created via `new`.\n`this` is automatically returned from the constructor function when it is called with `new`.\n\nThat means we can add fields to the new instance by adding them to `this` in the constructor function.\n\n```javascript\nfunction Car(color, weight) {\n  this.color = color;\n  this.weight = weight;\n  this.engineRunning = false;\n}\n\nconst myCar = new Car('red', '2mt');\nmyCar.color;\n// => 'red'\nmyCar.engineRunning;\n// => false\n```\n\n### Instance Methods\n\nMethods are added via the `prototype` property of the constructor function.\nInside a method, you can access the fields of the instance via `this`.\nThis works because of the following general rule.\n\n> When a function is called as a method of an object, its `this` is set to the object the method is called on. [^1]\n\n```javascript\nfunction Car() {\n  this.engineRunning = false;\n  // ...\n}\n\nCar.prototype.startEngine = function () {\n  this.engineRunning = true;\n};\n\nCar.prototype.addGas = function (litre) {\n  // ...\n};\n\nconst myCar = new Car();\nmyCar.startEngine();\nmyCar.engineRunning;\n// => true\n```\n\n### The Prototype Chain\n\n`myCar` in the example above is a regular JavaScript object and if we would inspect it (e.g. in the browser console), we would not find a property `startEngine` with a function as a value directly inside the `myCar` object.\nSo how does the code above even work then?\n\nThe secret here is called the _prototype chain_.\nWhen you try to access any property (field or method) of an object, JavaScript first checks whether the respective key can be found directly in the object itself.\nIf not, it continues to look for the key in the object referenced by the `[[prototype]]` property of the original object.\nAs mentioned before, in our example `[[prototype]]` points to the `prototype` property of the constructor function.\nThat is where JavaScript would find the `startEngine` function because we added it there.\n\n```javascript\nfunction Car() {\n  // ...\n}\n\nCar.prototype.startEngine = function () {\n  // ...\n};\n```\n\nAnd the chain does not end there.\nThe `[[prototype]]` property of `Car.prototype` (`myCar.[[prototype]].[[prototype]]`) references `Object.prototype` (the `prototype` property of the `Object` constructor function).\nIt contains general methods that are available for all JavaScript objects, e.g. `toString()`.\nIn conclusion, you can call `myCar.toString()` and that method will exist because JavaScript searches for that method throughout the whole prototype chain.\n\n<!-- prettier-ignore-start -->\n~~~~exercism/caution\nNote that the prototype chain is only travelled when retrieving a value.\nSetting a property directly or deleting a property of an instance object only targets that specific instance.\nThis might not be what you would expect when you are used to a language with class-based inheritance.\n~~~~\n<!-- prettier-ignore-end -->\n\n## Class Syntax\n\nNowadays, JavaScript supports defining classes with a `class` keyword.\nThis was added to the language specification in 2015.\nOn the one hand, this provides syntactic sugar that makes classes easier to read and write.\nThe new syntax is more similar to how classes are written in languages like C++ or Java.\nDevelopers switching over from those languages have an easier time adapting.\nOn the other hand, class syntax paves the way for new language features that are not available in the prototype syntax.\n\n### Class Declarations\n\nWith the new syntax, classes are defined with the `class` keyword, followed by the name of the class and the class body in curly brackets.\nThe body contains the definition of the constructor function, i.e. a special method with the name `constructor`.\nThis function works just like the constructor function in the prototype syntax.\nThe class body also contains all method definitions.\nThe syntax for the methods is similar to the shorthand notation we have seen for adding functions as values inside an object, see [Concept Objects][concept-objects].\n\n```javascript\nclass Car {\n  constructor(color, weight) {\n    this.color = color;\n    this.weight = weight;\n    this.engineRunning = false;\n  }\n\n  startEngine() {\n    this.engineRunning = true;\n  }\n\n  addGas(litre) {\n    // ...\n  }\n}\n\nconst myCar = new Car();\nmyCar.startEngine();\nmyCar.engineRunning;\n// => true\n```\n\nKeep in mind that behind the scenes, JavaScript is still a prototype-based language.\nAll the mechanisms we learned about in the \"Prototype Syntax\" section above still apply.\n\n### Private Fields, Getters and Setters\n\nBy default, all instance fields are public in JavaScript.\nThey can be directly accessed and assigned to.\n\nHowever, there is an established convention that fields and methods that start with an underscore should be treated as private.\nThey should never be accessed directly from outside the class.\n\nPrivate fields are sometimes accompanied by [getters][mdn-get] and [setters][mdn-set].\nWith the keywords `get` and `set` you can define functions that are executed when a property with the same name as the function is accessed or assigned to.\n\n```javascript\nclass Car {\n  constructor() {\n    this._mileage = 0;\n  }\n\n  get mileage() {\n    return this._mileage;\n  }\n\n  set mileage(value) {\n    throw new Error(`Mileage cannot be manipulated, ${value} is ignored.`);\n    // Just an example, usually you would not provide a setter in this case.\n  }\n}\n\nconst myCar = new Car();\nmyCar.mileage;\n// => 0\nmyCar.mileage = 100;\n// => Error: Mileage cannot be manipulated, 100 is ignored.\n```\n\n---\n\n[^1]: `this` Examples - As an object method, MDN. <https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/this#as_an_object_method> (referenced December 03, 2021)\n\n[wiki-oop]: https://en.wikipedia.org/wiki/Object-oriented_programming\n[mdn-get]: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/get\n[mdn-set]: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/set\n[mdn-this]: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/this\n[concept-objects]: /tracks/javascript/concepts/objects\n",
  "links": [
    {
      "url": "https://developer.mozilla.org/en-US/docs/Learn/JavaScript/Objects/Object_prototypes",
      "description": "MDN: Object prototypes"
    },
    {
      "url": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Inheritance_and_the_prototype_chain",
      "description": "MDN: Inheritance and the prototype chain"
    },
    {
      "url": "https://javascript.info/prototypes",
      "description": "javascript.info: Prototypes, inheritance"
    },
    {
      "url": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Classes",
      "description": "MDN: Classes"
    }
  ],
  "config": {}
}