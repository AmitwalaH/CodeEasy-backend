{
  "concept": "closures",
  "about": "# About\n\n_Closures_ are a programming pattern in JavaScript that allows variables from an outer [lexical scope][wiki-lexical-scope] to be used inside of a nested block of code. JavaScript supports closures transparently, and they are often used without knowing what they are.\n\n```javascript\n// Top-level declarations are global-scope\nconst dozen = 12;\n\n// Functions create a new function-scope and block-scope.\n// Referencing the outer variable here is a closure.\nfunction nDozen(n) {\n  return dozen * n;\n}\n```\n\nThe name _closure_ is historically derived from [_λ-calculus_][wiki-lambda-calculus] and popularized by [_scheme_][wiki-scheme] ([source][wiki-closure]) to reference a function's open and closed variable bindings.\n\n## Reasons to use closures in JavaScript\n\n1. Data Privacy / Data Encapsulation\n   - Unlike other languages, in 2020, there was no way to specify _private_ variables. So closures can be used to effectively emulate _private_ variables (there was a proposal to introduce private variable notation, which might have become standard by the time you read this).\n\n   ```javascript\n   // Consider this function:\n\n   const saveNumber = (number) => {\n     // The saved value is unaccessible by the outer lexical scope.\n     const value = number;\n\n     // We can provide access to the primitive value with a function, but the original will never change\n     return () => value;\n   };\n\n   // Attempting to set the variable outside of its lexical scope results in an error\n   value = 42;\n   ```\n\n2. Partial Application\n   - Functions may return functions, and when a returned function uses the argument of the function that created it, this is an example of using a closure to perform partial application. Sometimes this is called _currying_ a function.\n\n   ```javascript\n   // The arguments are applied one-by-one, using closures to arrive at the final result\n   function partialBuildUri(scheme) {\n     return function (domain) {\n       return function (path) {\n         return `${scheme}://${domain}/${path}`;\n       };\n     };\n   }\n\n   // A function could apply them all at once.\n   function buildUri(scheme, domain, path) {\n     return partialBuildUri(scheme)(domain)(path);\n   }\n\n   // Or apply a few to create a flexible system of functions for reuse.\n   function buildHttpsExercismUri(path) {\n     return partialBuildUri('https')('exercism.org');\n   }\n   ```\n\n## Lexical Scope for variables\n\nIn any programming language, **Closures** are closely related to variable scope. In JavaScript, there are 3 types of lexical scope for variables:\n\n1. **Global-scope**: These are variables that are declared outside of functions and blocks.\n1. **Function-scope**: These are variables declared within a function using the `var` keyword.\n1. **Block-scope**: These are variables declared within a block (`{...}`) using the `let` and `const` keywords.\n\nIn practice, a closure often occurs when a function (or block) uses a variable from an outer scope. In JavaScript, this is supported transparently, so closures are often used without specific reference.\n\n### Function-scope\n\nThe `var` keyword defines a **function-scoped** variable. This means that variables defined by `var` are available anywhere in the function where they are defined and any nested lexical scope (either **function** or **block**).\n\n```javascript\n{\n  var five = 5;\n}\n\n// This will succeed because 'five' exists in the same scope\nvar tenTimes = five * 10;\n```\n\n### Block-scope\n\nThe `let` and `const` keywords define **block-scoped** variables. `let` defines a mutable variable, whose value may be set multiple times and may be defined but not initialized. `const` defines a variable which must be initialized when it is defined, and its value then may not change. If the `const` variable is set to a primitive value, it may not be mutated. If the `const` variable is set to a reference value, like an _array_ or _object_, the reference may not change but the array's contents may be mutated.\n\nConsider this block:\n\n```javascript\n// 'two' is defined at the top-level, therefore available to the global-scope\nconst two = 2;\n\n{\n  // This succeeds, as 'two' is available from the outer lexical scope\n  const oneLess = two - 1;\n}\n\n// This throws an error because oneLess is not defined outside of the previous inner lexical scope\nconsole.log(oneLess);\n```\n\nWhile we can use braces (`{...}`) arbitrarily to create blocks, they are most often encountered surrounding _if-statements_, _functions_, and _classes_.\n\n```javascript\nconst PI = 3.14;\n\n// This function uses a closure for the value of PI (π)\nfunction areaOfCircle(radius) {\n  return PI * radius * radius;\n}\n```\n\n[wiki-lexical-scope]: https://en.wikipedia.org/wiki/Scope_(computer_science)#Lexical_scoping\n[what-the-fork-is-a-closure]: https://whatthefork.is/closure\n[wiki-lambda-calculus]: https://en.wikipedia.org/wiki/%CE%9B-calculus\n[wiki-scheme]: https://en.wikipedia.org/wiki/Scheme_(programming_language)\n[wiki-closure]: https://en.wikipedia.org/wiki/Closure_(computer_programming)\n",
  "introduction": "# Introduction\n\n**Closures** are a programming pattern in JavaScript which allows variables from an outer [lexical scope][wiki-lexical-scope] to be used inside of a nested block of code.\nJavaScript supports closures transparently, and they are often used without knowing what they are.\n\n```javascript\n// Top-level declarations are global-scope\nconst dozen = 12;\n\n{\n  // Braces create a new block-scope\n  // Referencing the outer variable is a closure.\n  const twoDozen = dozen * 2;\n}\n\n// Because of the block-scope declaration, twoDozen is not available here.\ntwoDozen;\n// => Uncaught ReferenceError: twoDozen is not defined\n```\n\nExcept for braces `{}`, functions (and classes) also create new scopes, which can _enclose_ values:\n\n```javascript\nconst dozen = 12;\n\n// Functions create a new function-scope and block-scope.\n// Referencing the outer variable here is a closure.\nfunction nDozen(n) {\n  // This is declared inside the function scope, and uses the top-level scope.\n  // This works, and encloses the value 12.\n  const twoDozen = dozen * 2;\n\n  // This only uses the locally declared variable and the passed argument to the parameter `n`\n  return (twoDozen / 2) * n;\n}\n\n// Because of the function-scope declaration, twoDozen is not available here.\ntwoDozen;\n// => Uncaught ReferenceError: twoDozen is not defined\n```\n\nAs the `twoDozen` examples show, values can be enclosed in a _nested_ scope (function, block, etc.), but cannot be pulled out of that context.\nIn the majority of cases, it is intended in Modern JavaScript that a value does not _leak_ to an outside scope.\n\n## Closures to save state and pass along values\n\nUsing a mutable variable declaration (like `let` or `var`) allows for some state to be preserved:\n\n```javascript\nlet counter = 0;\n\n// This function closure increments the counter's state in the outer lexical context.\n// This way the counter can be shared between many calling contexts.\nexport function increment() {\n  counter += 1;\n  return counter;\n}\n\nincrement();\n// => 1\n\ncounter;\n// => 1\n```\n\n## Enclosing values without leaking the state\n\nCombining the two ideas: enclosing a value to preserve state, and enclosed values do not leak to the outside, it's possible to create private values.\n\nThe most common method is to make a function that returns a function which encloses some state.\n\n```javascript\nexport function makeCounter() {\n  let counter = 0;\n\n  // This returns a new function that encloses the local variable counter\n  return function increment() {\n    counter += 1;\n    return counter;\n  };\n}\n\n// Counter did not leak\ncounter;\n// => Uncaught ReferenceError: counter is not defined\n\n// This creates a new counter.\n// This assigns the increment function to the variable myFirstCounter.\nconst myFirstCounter = makeCounter();\n\ntypeof myFirstCounter;\n// => function\n\nmyFirstCounter.name;\n// => increment\n\nmyFirstCounter();\n// => 1\nmyFirstCounter();\n// => 2\n\n// This creates new counter (with new, separate local state / enclosed counter variable)\nconst mySecondCounter = makeCounter();\n\nmySecondCounter();\n// => 1\n\n// It is not affect the first counter.\n\nmyFirstCounter();\n// => 3\n```\n\n```exercism/note\nMany programmers find closures a hard concept, and returning a function from a function is not common or not even possible in all programming languages.\nIf you want more reading material, the [guide on MDN on Closures][mdn-closures] is quite comprehensive.\n\n[mdn-closures]: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Closures\n```\n\n[wiki-lexical-scope]: https://en.wikipedia.org/wiki/Scope_(computer_science)#Lexical_scoping\n",
  "links": [
    {
      "url": "https://javascript.info/closure",
      "description": "javascript.info: Closure"
    },
    {
      "url": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Closures",
      "description": "MDN: Closures"
    },
    {
      "url": "https://en.wikipedia.org/wiki/Closure_(computer_programming)",
      "description": "Wikipedia: Closure"
    }
  ],
  "config": {}
}