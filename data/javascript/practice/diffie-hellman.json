{
  "language": "javascript",
  "type": "practice",
  "slug": "diffie-hellman",
  "title": "Diffie Hellman",
  "docs": {
    "instructions": "# Instructions\n\nDiffie-Hellman key exchange.\n\nAlice and Bob use Diffie-Hellman key exchange to share secrets.\nThey start with prime numbers, pick private keys, generate and share public keys, and then generate a shared secret key.\n\n## Step 0\n\nThe test program supplies prime numbers p and g.\n\n## Step 1\n\nAlice picks a private key, a, greater than 1 and less than p.\nBob does the same to pick a private key b.\n\n## Step 2\n\nAlice calculates a public key A.\n\n    A = gᵃ mod p\n\nUsing the same p and g, Bob similarly calculates a public key B from his private key b.\n\n## Step 3\n\nAlice and Bob exchange public keys.\nAlice calculates secret key s.\n\n    s = Bᵃ mod p\n\nBob calculates\n\n    s = Aᵇ mod p\n\nThe calculations produce the same result!\nAlice and Bob now share secret s.\n",
    "hints": ""
  },
  "starter_code": "//\n// This is only a SKELETON file for the 'Diffie Hellman' exercise. It's been provided as a\n// convenience to get you started writing code faster.\n//\n\nexport class DiffieHellman {\n  constructor(p, g) {\n    throw new Error('Remove this line and implement the function');\n  }\n\n  getPublicKey(privateKey) {\n    throw new Error('Remove this line and implement the function');\n  }\n\n  getSecret(theirPublicKey, myPrivateKey) {\n    throw new Error('Remove this line and implement the function');\n  }\n\n  getPrivateKey() {\n    throw new Error('Remove this line and implement the function');\n  }\n}\n",
  "tests": "import { describe, expect, test, xtest } from '@jest/globals';\nimport { DiffieHellman } from './diffie-hellman';\n\ndescribe('diffie-hellman', () => {\n  test('throws an error if the constructor arguments are out of range', () => {\n    expect(() => {\n      new DiffieHellman(0, 9999);\n    }).toThrow();\n  });\n\n  xtest('throws an error if the constructor arguments are not prime', () => {\n    expect(() => {\n      new DiffieHellman(10, 13);\n    }).toThrow();\n  });\n\n  describe('private key is greater than 1 and less than p', () => {\n    const p = 23;\n    const g = 5;\n    const diffieHellman = new DiffieHellman(p, g);\n\n    xtest('throws an error if private key is negative', () => {\n      expect(() => {\n        diffieHellman.getPublicKey(-1);\n      }).toThrow();\n    });\n\n    xtest('throws an error if private key is zero', () => {\n      expect(() => {\n        diffieHellman.getPublicKey(0);\n      }).toThrow();\n    });\n\n    xtest('throws an error if private key is one', () => {\n      expect(() => {\n        diffieHellman.getPublicKey(1);\n      }).toThrow();\n    });\n\n    xtest('throws an error if private key equals the modulus parameter p', () => {\n      expect(() => {\n        diffieHellman.getPublicKey(p);\n      }).toThrow();\n    });\n\n    xtest('throws an error if private key is greater than the modulus parameter p', () => {\n      expect(() => {\n        diffieHellman.getPublicKey(p + 1);\n      }).toThrow();\n    });\n  });\n\n  describe('stateless calculation', () => {\n    const diffieHellman = new DiffieHellman(23, 5);\n\n    const alicePrivateKey = 6;\n    const alicePublicKey = 8;\n\n    const bobPrivateKey = 15;\n    const bobPublicKey = 19;\n\n    xtest('can calculate public key using private key', () => {\n      expect(diffieHellman.getPublicKey(alicePrivateKey)).toEqual(\n        alicePublicKey,\n      );\n    });\n\n    xtest('can calculate public key when given a different private key', () => {\n      expect(diffieHellman.getPublicKey(bobPrivateKey)).toEqual(bobPublicKey);\n    });\n  });\n\n  xtest(\"can calculate secret using other party's public key\", () => {\n    expect(new DiffieHellman(23, 5).getSecret(19, 6)).toEqual(2);\n  });\n\n  xtest('key exchange', () => {\n    const diffieHellman = new DiffieHellman(23, 5);\n\n    const alicePrivateKey = 6;\n    const bobPrivateKey = 15;\n    const alicePublicKey = diffieHellman.getPublicKey(alicePrivateKey);\n    const bobPublicKey = diffieHellman.getPublicKey(bobPrivateKey);\n\n    const secretA = diffieHellman.getSecret(bobPublicKey, alicePrivateKey);\n    const secretB = diffieHellman.getSecret(alicePublicKey, bobPrivateKey);\n\n    expect(secretA).toEqual(secretB);\n  });\n\n  xtest('private key is greater than 1 and less than p', () => {\n    let p = 23;\n    for (let i = 0; i < 10; i++) {\n      let privateKey = DiffieHellman.getPrivateKey(p);\n      expect(privateKey).toBeGreaterThan(1);\n      expect(privateKey).toBeLessThan(p);\n    }\n  });\n\n  xtest('private key is random', () => {\n    let p = 7919;\n    let uniqueKeys = new Set();\n    let testIterations = 1000;\n\n    for (let i = 0; i < testIterations; i++) {\n      uniqueKeys.add(DiffieHellman.getPrivateKey(p));\n    }\n\n    expect(uniqueKeys.size).toBeGreaterThan(testIterations - 100);\n  });\n});\n"
}