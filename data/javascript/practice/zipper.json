{
  "language": "javascript",
  "type": "practice",
  "slug": "zipper",
  "title": "Zipper",
  "docs": {
    "instructions": "# Instructions\n\nCreating a zipper for a binary tree.\n\n[Zippers][zipper] are a purely functional way of navigating within a data structure and manipulating it.\nThey essentially contain a data structure and a pointer into that data structure (called the focus).\n\nFor example given a rose tree (where each node contains a value and a list of child nodes) a zipper might support these operations:\n\n- `from_tree` (get a zipper out of a rose tree, the focus is on the root node)\n- `to_tree` (get the rose tree out of the zipper)\n- `value` (get the value of the focus node)\n- `prev` (move the focus to the previous child of the same parent,\n  returns a new zipper)\n- `next` (move the focus to the next child of the same parent, returns a\n  new zipper)\n- `up` (move the focus to the parent, returns a new zipper)\n- `set_value` (set the value of the focus node, returns a new zipper)\n- `insert_before` (insert a new subtree before the focus node, it\n  becomes the `prev` of the focus node, returns a new zipper)\n- `insert_after` (insert a new subtree after the focus node, it becomes\n  the `next` of the focus node, returns a new zipper)\n- `delete` (removes the focus node and all subtrees, focus moves to the\n  `next` node if possible otherwise to the `prev` node if possible,\n  otherwise to the parent node, returns a new zipper)\n\n[zipper]: https://en.wikipedia.org/wiki/Zipper_%28data_structure%29\n",
    "hints": ""
  },
  "starter_code": "//\n// This is only a SKELETON file for the 'Zipper' exercise. It's been provided as a\n// convenience to get you started writing code faster.\n//\n\nexport class Zipper {\n  constructor() {\n    throw new Error('Remove this line and implement the function');\n  }\n\n  static fromTree() {\n    throw new Error('Remove this line and implement the function');\n  }\n\n  toTree() {\n    throw new Error('Remove this line and implement the function');\n  }\n\n  value() {\n    throw new Error('Remove this line and implement the function');\n  }\n\n  left() {\n    throw new Error('Remove this line and implement the function');\n  }\n\n  right() {\n    throw new Error('Remove this line and implement the function');\n  }\n\n  up() {\n    throw new Error('Remove this line and implement the function');\n  }\n\n  setValue() {\n    throw new Error('Remove this line and implement the function');\n  }\n\n  setLeft() {\n    throw new Error('Remove this line and implement the function');\n  }\n\n  setRight() {\n    throw new Error('Remove this line and implement the function');\n  }\n}\n",
  "tests": "import { beforeEach, describe, expect, test, xtest } from '@jest/globals';\nimport { Zipper } from './zipper';\n\nfunction bt(value, left, right) {\n  return {\n    value,\n    left,\n    right,\n  };\n}\n\nfunction leaf(value) {\n  return bt(value, null, null);\n}\n\ndescribe('Zipper', () => {\n  const t1 = bt(1, bt(2, null, leaf(3)), leaf(4));\n  const t2 = bt(1, bt(5, null, leaf(3)), leaf(4));\n  const t3 = bt(1, bt(2, leaf(5), leaf(3)), leaf(4));\n  const t4 = bt(1, leaf(2), leaf(4));\n  const t5 = bt(1, bt(2, null, leaf(3)), bt(6, leaf(7), leaf(8)));\n  const t6 = bt(1, bt(2, null, leaf(5)), leaf(4));\n  let zipper;\n\n  beforeEach(() => {\n    zipper = Zipper.fromTree(t1);\n  });\n\n  test('data is retained', () => {\n    expect(zipper.toTree()).toEqual(t1);\n  });\n\n  xtest('left, right and value', () => {\n    expect(zipper.left().right().value()).toEqual(3);\n  });\n\n  xtest('dead end', () => {\n    expect(zipper.left().left()).toBe(null);\n  });\n\n  xtest('tree from deep focus', () => {\n    expect(zipper.left().right().toTree()).toEqual(t1);\n  });\n\n  xtest('traversing up from top', () => {\n    expect(zipper.up()).toEqual(null);\n  });\n\n  xtest('left, right and up', () => {\n    expect(zipper.left().up().right().up().left().right().value()).toEqual(3);\n  });\n\n  xtest('ability to descend multiple levels and return', () => {\n    expect(zipper.left().right().up().up().value()).toEqual(1);\n  });\n\n  xtest('setValue', () => {\n    expect(zipper.left().setValue(5).toTree()).toEqual(t2);\n  });\n\n  xtest('setValue after traversing up', () => {\n    expect(zipper.left().right().up().setValue(5).toTree()).toEqual(t2);\n  });\n\n  xtest('setLeft with leaf', () => {\n    expect(zipper.left().setLeft(leaf(5)).toTree()).toEqual(t3);\n  });\n\n  xtest('setRight with null', () => {\n    expect(zipper.left().setRight(null).toTree()).toEqual(t4);\n  });\n\n  xtest('setRight with subtree', () => {\n    expect(zipper.setRight(bt(6, leaf(7), leaf(8))).toTree()).toEqual(t5);\n  });\n\n  xtest('setValue on deep focus', () => {\n    expect(zipper.left().right().setValue(5).toTree()).toEqual(t6);\n  });\n\n  xtest('left returns a new Zipper', () => {\n    const left = zipper.left();\n    expect(left).not.toBe(zipper);\n  });\n\n  xtest('right returns a new Zipper', () => {\n    const right = zipper.right();\n    expect(right).not.toBe(zipper);\n  });\n\n  xtest('setValue returns a new Zipper', () => {\n    const anotherZipper = zipper.setValue(99);\n    expect(anotherZipper).not.toBe(zipper);\n  });\n\n  xtest('setRight returns a new Zipper', () => {\n    const right = zipper.setRight(bt(55, null, null));\n    expect(right).not.toBe(zipper);\n  });\n\n  xtest('setLeft returns a new Zipper', () => {\n    const left = zipper.setLeft(bt(55, null, null));\n    expect(left).not.toBe(zipper);\n  });\n\n  xtest('up returns a new Zipper', () => {\n    const up = zipper.right().up();\n    expect(zipper).not.toBe(up);\n  });\n\n  xtest('should return same zipper from different paths', () => {\n    const z1 = zipper.left().up().right();\n    const z2 = zipper.right();\n    expect(z1).toEqual(z2);\n  });\n});\n"
}