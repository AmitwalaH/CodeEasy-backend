{
  "language": "javascript",
  "type": "practice",
  "slug": "react",
  "title": "React",
  "docs": {
    "instructions": "# Instructions\n\nImplement a basic reactive system.\n\nReactive programming is a programming paradigm that focuses on how values are computed in terms of each other to allow a change to one value to automatically propagate to other values, like in a spreadsheet.\n\nImplement a basic reactive system with cells with settable values (\"input\" cells) and cells with values computed in terms of other cells (\"compute\" cells).\nImplement updates so that when an input value is changed, values propagate to reach a new stable system state.\n\nIn addition, compute cells should allow for registering change notification callbacks.\nCall a cell’s callbacks when the cell’s value in a new stable state has changed from the previous stable state.\n",
    "hints": ""
  },
  "starter_code": "//\n// This is only a SKELETON file for the 'React' exercise. It's been provided as a\n// convenience to get you started writing code faster.\n//\n\nexport class InputCell {\n  constructor(value) {\n    throw new Error('Remove this line and implement the function');\n  }\n\n  setValue(value) {\n    throw new Error('Remove this line and implement the function');\n  }\n}\n\nexport class ComputeCell {\n  constructor(inputCells, fn) {\n    throw new Error('Remove this line and implement the function');\n  }\n\n  addCallback(cb) {\n    throw new Error('Remove this line and implement the function');\n  }\n\n  removeCallback(cb) {\n    throw new Error('Remove this line and implement the function');\n  }\n}\n\nexport class CallbackCell {\n  constructor(fn) {\n    throw new Error('Remove this line and implement the function');\n  }\n}\n",
  "tests": "import { describe, expect, test, xtest } from '@jest/globals';\nimport { CallbackCell, ComputeCell, InputCell } from './react';\n\ndescribe('React module', () => {\n  test('accepts input', () => {\n    const inputCell = new InputCell(10);\n    expect(inputCell.value).toEqual(10);\n  });\n\n  xtest('allows input cell value to be set', () => {\n    const inputCell = new InputCell(4);\n    inputCell.setValue(20);\n    expect(inputCell.value).toEqual(20);\n  });\n\n  xtest('allows setting compute cells', () => {\n    const inputCell = new InputCell(1);\n    const fn = (inputCells) => inputCells[0].value + 1;\n    const computeCell = new ComputeCell([inputCell], fn);\n    expect(computeCell.value).toEqual(2);\n  });\n\n  xtest('compute cell takes inputs in correct order', () => {\n    const inputCells = [new InputCell(1), new InputCell(2)];\n\n    const computeCell = new ComputeCell(\n      inputCells,\n      (inputs) => inputs[0].value + inputs[1].value * 10,\n    );\n\n    expect(computeCell.value).toEqual(21);\n  });\n\n  xtest('compute cells update value when inputs are changed', () => {\n    const inputCell = new InputCell(1);\n    const computeCell = new ComputeCell(\n      [inputCell],\n      (inputs) => inputs[0].value + 1,\n    );\n    inputCell.setValue(3);\n    expect(computeCell.value).toEqual(4);\n  });\n\n  xtest('compute cells can depend on other compute cells', () => {\n    const inputCell = new InputCell(1);\n    const timesTwo = new ComputeCell(\n      [inputCell],\n      (inputs) => inputs[0].value * 2,\n    );\n\n    const timesThirty = new ComputeCell(\n      [inputCell],\n      (inputs) => inputs[0].value * 30,\n    );\n\n    const sum = new ComputeCell(\n      [timesTwo, timesThirty],\n      (inputs) => inputs[0].value + inputs[1].value,\n    );\n\n    expect(sum.value).toEqual(32);\n\n    inputCell.setValue(3);\n    expect(sum.value).toEqual(96);\n  });\n\n  xtest('compute cells fire callbacks', () => {\n    const inputCell = new InputCell(1);\n    const output = new ComputeCell(\n      [inputCell],\n      (inputs) => inputs[0].value + 1,\n    );\n\n    const callback = new CallbackCell((cell) => cell.value);\n    output.addCallback(callback);\n\n    inputCell.setValue(3);\n    expect(callback.values).toEqual([4]);\n  });\n\n  xtest('callbacks fire only when output values change', () => {\n    const inputCell = new InputCell(1);\n    const output = new ComputeCell([inputCell], (inputs) =>\n      inputs[0].value < 3 ? 111 : 222,\n    );\n\n    const callback = new CallbackCell((cell) => cell.value);\n    output.addCallback(callback);\n\n    inputCell.setValue(2);\n    expect(callback.values).toEqual([]);\n\n    inputCell.setValue(4);\n    expect(callback.values).toEqual([222]);\n  });\n\n  xtest('static callbacks fire even if their own value has not changed', () => {\n    const inputCell = new InputCell(1);\n    const output = new ComputeCell([inputCell], (inputs) =>\n      inputs[0].value < 3 ? 111 : 222,\n    );\n\n    const callback = new CallbackCell(() => 'cell changed');\n    output.addCallback(callback);\n\n    inputCell.setValue(2);\n    expect(callback.values).toEqual([]);\n\n    inputCell.setValue(4);\n    inputCell.setValue(2);\n    inputCell.setValue(4);\n    expect(callback.values).toEqual([\n      'cell changed',\n      'cell changed',\n      'cell changed',\n    ]);\n  });\n\n  xtest('callbacks can be added and removed', () => {\n    const inputCell = new InputCell(1);\n    const output = new ComputeCell(\n      [inputCell],\n      (inputs) => inputs[0].value + 1,\n    );\n\n    const callback1 = new CallbackCell((cell) => cell.value);\n    const callback2 = new CallbackCell((cell) => cell.value);\n\n    output.addCallback(callback1);\n    output.addCallback(callback2);\n\n    inputCell.setValue(31);\n\n    output.removeCallback(callback1);\n\n    const callback3 = new CallbackCell((cell) => cell.value);\n    output.addCallback(callback3);\n\n    inputCell.setValue(41);\n\n    expect(callback1.values).toEqual([32]);\n    expect(callback2.values).toEqual([32, 42]);\n    expect(callback3.values).toEqual([42]);\n  });\n\n  xtest(\"removing a callback multiple times doesn't interfere with other callbacks\", () => {\n    const inputCell = new InputCell(1);\n    const output = new ComputeCell(\n      [inputCell],\n      (inputs) => inputs[0].value + 1,\n    );\n\n    const callback1 = new CallbackCell((cell) => cell.value);\n    const callback2 = new CallbackCell((cell) => cell.value);\n\n    output.addCallback(callback1);\n    output.addCallback(callback2);\n\n    output.removeCallback(callback1);\n    output.removeCallback(callback1);\n    output.removeCallback(callback1);\n\n    inputCell.setValue(2);\n\n    expect(callback1.values).toEqual([]);\n    expect(callback2.values).toEqual([3]);\n  });\n\n  xtest('callbacks should only be called once, even if multiple dependencies change', () => {\n    const inputCell = new InputCell(1);\n    const plusOne = new ComputeCell(\n      [inputCell],\n      (inputs) => inputs[0].value + 1,\n    );\n\n    const minusOne1 = new ComputeCell(\n      [inputCell],\n      (inputs) => inputs[0].value - 1,\n    );\n\n    const minusOne2 = new ComputeCell(\n      [minusOne1],\n      (inputs) => inputs[0].value - 1,\n    );\n\n    const output = new ComputeCell(\n      [plusOne, minusOne2],\n      (inputs) => inputs[0].value * inputs[1].value,\n    );\n\n    const callback1 = new CallbackCell((cell) => cell.value);\n    output.addCallback(callback1);\n\n    inputCell.setValue(4);\n\n    expect(callback1.values).toEqual([10]);\n  });\n\n  xtest(\"callbacks should not be called if dependencies change but output value doesn't change\", () => {\n    const inputCell = new InputCell(1);\n    const plusOne = new ComputeCell(\n      [inputCell],\n      (inputs) => inputs[0].value + 1,\n    );\n\n    const minusOne = new ComputeCell(\n      [inputCell],\n      (inputs) => inputs[0].value - 1,\n    );\n\n    const alwaysTwo = new ComputeCell(\n      [plusOne, minusOne],\n      (inputs) => inputs[0].value - inputs[1].value,\n    );\n\n    const callback = new CallbackCell((cell) => cell.value);\n    alwaysTwo.addCallback(callback);\n\n    inputCell.setValue(2);\n    inputCell.setValue(3);\n    inputCell.setValue(4);\n    inputCell.setValue(5);\n\n    expect(callback.values).toEqual([]);\n  });\n});\n"
}