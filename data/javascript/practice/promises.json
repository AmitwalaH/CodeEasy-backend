{
  "language": "javascript",
  "type": "practice",
  "slug": "promises",
  "title": "Promises",
  "docs": {
    "instructions": "# Instructions\n\nThe two objectives of this exercise are :\n\n1. Implement a `promisify` function that turns a function using the \"callback pattern\" into a function that returns a `Promise`. See the example below.\n\n```javascript\nfunction fetchProduct(productId, function(error, data) {\n    if (error) {\n        // Handle the error\n    } else {\n        // Make something with your data\n    }\n})\n\nconst fetchProductAsPromise = promisify(fetchProduct);\n\n// Now you got a function `fetchProductAsPromise`\n// that returns a promise\nfetchProductAsPromise(productId)\n    .then((data) => {})\n    .catch((error) => {});\n```\n\n2. Re-implement the following built-ins `Promise` methods (without using them)\n\n- `all`: takes an array of promises and resolves when _all_ of them are resolved, or rejects when _one_ of them rejects.\n- `allSettled`: takes an array of promises and resolves when _all_ of them either resolve or reject.\n- `race`: takes an array of promises and resolves or rejects with the value of the _first_ promise that resolves or rejects.\n- `any`: takes an array of promises and resolves when _one_ of them resolves, or rejects when _all_ of them reject.\n",
    "hints": ""
  },
  "starter_code": "//\n// This is only a SKELETON file for the 'Promises' exercise. It's been provided as a\n// convenience to get you started writing code faster.\n//\n\nexport const promisify = () => {\n  throw new Error('Remove this line and implement the function');\n};\n\nexport const all = () => {\n  throw new Error('Remove this line and implement the function');\n};\n\nexport const allSettled = () => {\n  throw new Error('Remove this line and implement the function');\n};\n\nexport const race = () => {\n  throw new Error('Remove this line and implement the function');\n};\n\nexport const any = () => {\n  throw new Error('Remove this line and implement the function');\n};\n",
  "tests": "import { describe, expect, test, xtest } from '@jest/globals';\nimport { all, allSettled, any, promisify, race } from './promises';\n\ndescribe('promises', () => {\n  const failedCallback = new Error('Failed callback');\n\n  const createCallbackFn = (speed) => (value, callback) =>\n    setTimeout(() => callback(null, value), speed);\n  const createFailedCallback = (speed) => (_, callback) =>\n    setTimeout(() => callback(failedCallback), speed);\n\n  const slowestCallbackFn = createCallbackFn(20);\n  const slowerCallbackFn = createCallbackFn(10);\n  const fastCallbackFn = createCallbackFn(0);\n  const failedCallbackFn = createFailedCallback(10);\n\n  describe('promisify', () => {\n    test('returns a function', () => {\n      expect(typeof promisify(fastCallbackFn)).toBe('function');\n    });\n\n    xtest('promisified function call returns a Promise', () => {\n      const fastPromise = promisify(fastCallbackFn);\n      expect(fastPromise('fast')).toBeInstanceOf(Promise);\n    });\n\n    xtest(\"promisified function resolves to a callback's success value\", () => {\n      const SUCCESS = 'success';\n      const fastPromise = promisify(fastCallbackFn);\n      return expect(fastPromise(SUCCESS)).resolves.toEqual(SUCCESS);\n    });\n\n    xtest(\"promisified function rejects a callback's error\", () => {\n      const failedPromise = promisify(failedCallbackFn);\n      return expect(failedPromise(null)).rejects.toEqual(failedCallback);\n    });\n  });\n\n  describe('all', () => {\n    const [slowestPromise, slowerPromise, fastPromise, failedPromise] = [\n      slowestCallbackFn,\n      slowerCallbackFn,\n      fastCallbackFn,\n      failedCallbackFn,\n    ].map((fn) => promisify(fn));\n\n    xtest('returns a Promise', () => {\n      expect(all([])).toBeInstanceOf(Promise);\n    });\n\n    xtest('resolves when given no promises', () => {\n      return expect(all([])).resolves.toEqual([]);\n    });\n\n    xtest('resolves when given no arguments', () => {\n      return expect(all()).resolves.toBeUndefined();\n    });\n\n    xtest('resolved values appear in the order they are passed in', () => {\n      const FIRST = 'FIRST';\n      const SECOND = 'SECOND';\n      const THIRD = 'THIRD';\n      const result = all([\n        slowestPromise(FIRST),\n        slowerPromise(SECOND),\n        fastPromise(THIRD),\n      ]);\n      return expect(result).resolves.toEqual([FIRST, SECOND, THIRD]);\n    });\n\n    xtest('rejects if any promises fail', () => {\n      const result = all([fastPromise('fast'), failedPromise(null)]);\n      return expect(result).rejects.toEqual(failedCallback);\n    });\n  });\n\n  describe('allSettled', () => {\n    const [slowestPromise, slowerPromise, fastPromise, failedPromise] = [\n      slowestCallbackFn,\n      slowerCallbackFn,\n      fastCallbackFn,\n      failedCallbackFn,\n    ].map((fn) => promisify(fn));\n\n    xtest('returns a Promise', () => {\n      expect(allSettled([])).toBeInstanceOf(Promise);\n    });\n\n    xtest('resolves when given no promises', () => {\n      return expect(allSettled([])).resolves.toEqual([]);\n    });\n\n    xtest('resolves when given no arguments', () => {\n      return expect(allSettled()).resolves.toBeUndefined();\n    });\n\n    xtest('resolved values appear in the order they are passed in', () => {\n      const FIRST = 'FIRST';\n      const SECOND = 'SECOND';\n      const THIRD = 'THIRD';\n      const result = allSettled([\n        slowestPromise(FIRST),\n        slowerPromise(SECOND),\n        fastPromise(THIRD),\n      ]);\n      return expect(result).resolves.toEqual([FIRST, SECOND, THIRD]);\n    });\n\n    xtest('resolves even if some promises fail', () => {\n      const FIRST = 'FIRST';\n      const result = allSettled([fastPromise(FIRST), failedPromise(null)]);\n      return expect(result).resolves.toEqual([FIRST, failedCallback]);\n    });\n  });\n\n  describe('race', () => {\n    const [slowestPromise, slowerPromise, fastPromise, failedPromise] = [\n      slowestCallbackFn,\n      slowerCallbackFn,\n      fastCallbackFn,\n      failedCallbackFn,\n    ].map((fn) => promisify(fn));\n\n    xtest('returns a Promise', () => {\n      expect(race([])).toBeInstanceOf(Promise);\n    });\n\n    xtest('resolves when given no promises', () => {\n      return expect(race([])).resolves.toEqual([]);\n    });\n\n    xtest('resolves when given no arguments', () => {\n      return expect(race()).resolves.toBeUndefined();\n    });\n\n    xtest('resolves with value of the fastest successful promise', () => {\n      const FAST = 'FAST';\n      return expect(\n        race([\n          slowestPromise('SLOWEST'),\n          slowerPromise('SLOWER'),\n          fastPromise(FAST),\n        ]),\n      ).resolves.toEqual(FAST);\n    });\n\n    xtest('resolves with value of the fastest promise even if other slower promises fail', () => {\n      const FAST = 'FAST';\n      return expect(\n        race([failedPromise(null), fastPromise(FAST)]),\n      ).resolves.toEqual(FAST);\n    });\n\n    xtest('rejects if the fastest promise fails even if other slower promises succeed', () => {\n      return expect(\n        race([slowestPromise('SLOWEST'), failedPromise(null)]),\n      ).rejects.toEqual(failedCallback);\n    });\n  });\n\n  describe('any', () => {\n    const [slowestPromise, slowerPromise, fastPromise, failedPromise] = [\n      slowestCallbackFn,\n      slowerCallbackFn,\n      fastCallbackFn,\n      failedCallbackFn,\n    ].map((fn) => promisify(fn));\n\n    xtest('returns a Promise', () => {\n      expect(any([]).catch(() => null)).toBeInstanceOf(Promise);\n    });\n\n    xtest('resolves when given no promises', () => {\n      return expect(race([])).resolves.toEqual([]);\n    });\n\n    xtest('resolves when given no arguments', () => {\n      return expect(race()).resolves.toBeUndefined();\n    });\n\n    xtest('resolves with value of fastest successful promise', () => {\n      const FAST = 'FAST';\n      return expect(\n        any([\n          slowestPromise('SLOWEST'),\n          slowerPromise('SLOWER'),\n          fastPromise(FAST),\n        ]),\n      ).resolves.toEqual(FAST);\n    });\n\n    xtest('resolves with value of the fastest successful promise even if slower promises fail', () => {\n      const FAST = 'FAST';\n      return expect(\n        any([failedPromise(null), fastPromise(FAST)]),\n      ).resolves.toEqual(FAST);\n    });\n\n    xtest('resolves with value of fastest successful promise even if faster promises fail', () => {\n      const SLOWEST = 'SLOWEST';\n      return expect(\n        any([failedPromise(null), slowestPromise(SLOWEST)]),\n      ).resolves.toEqual(SLOWEST);\n    });\n\n    xtest('rejects with array of errors if all promises fail', () => {\n      return expect(\n        any([failedPromise(null), failedPromise(null)]),\n      ).rejects.toEqual([failedCallback, failedCallback]);\n    });\n  });\n});\n"
}