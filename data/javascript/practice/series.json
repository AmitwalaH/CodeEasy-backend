{
  "language": "javascript",
  "type": "practice",
  "slug": "series",
  "title": "Series",
  "docs": {
    "instructions": "# Instructions\n\nGiven a string of digits, output all the contiguous substrings of length `n` in that string in the order that they appear.\n\nFor example, the string \"49142\" has the following 3-digit series:\n\n- \"491\"\n- \"914\"\n- \"142\"\n\nAnd the following 4-digit series:\n\n- \"4914\"\n- \"9142\"\n\nAnd if you ask for a 6-digit series from a 5-digit string, you deserve whatever you get.\n\nNote that these series are only required to occupy _adjacent positions_ in the input;\nthe digits need not be _numerically consecutive_.\n",
    "hints": ""
  },
  "starter_code": "//\n// This is only a SKELETON file for the 'Series' exercise. It's been provided as a\n// convenience to get you started writing code faster.\n//\n\nexport class Series {\n  constructor(series) {\n    throw new Error('Remove this line and implement the function');\n  }\n\n  slices(sliceLength) {\n    throw new Error('Remove this line and implement the function');\n  }\n}\n",
  "tests": "import { describe, expect, test, xtest } from '@jest/globals';\nimport { Series } from './series';\n\ndescribe('Series', () => {\n  test('slices of one from one', () => {\n    expect(new Series('1').slices(1)).toEqual([[1]]);\n  });\n\n  xtest('slices of one from two', () => {\n    expect(new Series('12').slices(1)).toEqual([[1], [2]]);\n  });\n\n  xtest('slices of two', () => {\n    expect(new Series('35').slices(2)).toEqual([[3, 5]]);\n  });\n\n  xtest('slices of two overlap', () => {\n    expect(new Series('9142').slices(2)).toEqual([\n      [9, 1],\n      [1, 4],\n      [4, 2],\n    ]);\n  });\n\n  xtest('slices can include duplicates', () => {\n    expect(new Series('777777').slices(3)).toEqual([\n      [7, 7, 7],\n      [7, 7, 7],\n      [7, 7, 7],\n      [7, 7, 7],\n    ]);\n  });\n\n  xtest('slices of long series', () => {\n    expect(new Series('918493904243').slices(5)).toEqual([\n      [9, 1, 8, 4, 9],\n      [1, 8, 4, 9, 3],\n      [8, 4, 9, 3, 9],\n      [4, 9, 3, 9, 0],\n      [9, 3, 9, 0, 4],\n      [3, 9, 0, 4, 2],\n      [9, 0, 4, 2, 4],\n      [0, 4, 2, 4, 3],\n    ]);\n  });\n\n  xtest('slice length is too large', () => {\n    expect(() => {\n      new Series('12345').slices(6);\n    }).toThrow(new Error('slice length cannot be greater than series length'));\n  });\n\n  xtest('slice length is way too large', () => {\n    expect(() => {\n      new Series('12345').slices(42);\n    }).toThrow(new Error('slice length cannot be greater than series length'));\n  });\n\n  xtest('slice length cannot be zero', () => {\n    expect(() => {\n      new Series('12345').slices(0);\n    }).toThrow(new Error('slice length cannot be zero'));\n  });\n\n  xtest('slice length cannot be negative', () => {\n    expect(() => {\n      new Series('123').slices(-1);\n    }).toThrow(new Error('slice length cannot be negative'));\n  });\n\n  xtest('empty series is invalid', () => {\n    expect(() => {\n      new Series('').slices(1);\n    }).toThrow(new Error('series cannot be empty'));\n  });\n});\n"
}