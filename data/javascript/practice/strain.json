{
  "language": "javascript",
  "type": "practice",
  "slug": "strain",
  "title": "Strain",
  "docs": {
    "instructions": "# Instructions\n\nImplement the `keep` and `discard` operation on collections.\nGiven a collection and a predicate on the collection's elements, `keep` returns a new collection containing those elements where the predicate is true, while `discard` returns a new collection containing those elements where the predicate is false.\n\nFor example, given the collection of numbers:\n\n- 1, 2, 3, 4, 5\n\nAnd the predicate:\n\n- is the number even?\n\nThen your keep operation should produce:\n\n- 2, 4\n\nWhile your discard operation should produce:\n\n- 1, 3, 5\n\nNote that the union of keep and discard is all the elements.\n\nThe functions may be called `keep` and `discard`, or they may need different names in order to not clash with existing functions or concepts in your language.\n\n## Restrictions\n\nKeep your hands off that filter/reject/whatchamacallit functionality provided by your standard library!\nSolve this one yourself using other basic tools instead.\n",
    "hints": ""
  },
  "starter_code": "//\n// This is only a SKELETON file for the 'Strain' exercise. It's been provided as a\n// convenience to get you started writing code faster.\n//\n\nexport const keep = () => {\n  throw new Error('Remove this line and implement the function');\n};\n\nexport const discard = () => {\n  throw new Error('Remove this line and implement the function');\n};\n",
  "tests": "import { describe, expect, test, xtest } from '@jest/globals';\nimport { discard, keep } from './strain';\n\ndescribe('strain', () => {\n  test('keeps on empty array returns empty array', () => {\n    expect(keep([], (e) => e < 10)).toEqual([]);\n  });\n\n  xtest('keeps everything', () => {\n    expect(keep([1, 2, 3], (e) => e < 10)).toEqual([1, 2, 3]);\n  });\n\n  xtest('keeps nothing', () => {\n    expect(keep([1, 2, 3], (e) => e > 10)).toEqual([]);\n  });\n\n  xtest('keeps first and last', () => {\n    expect(keep([1, 2, 3], (e) => e % 2 === 1)).toEqual([1, 3]);\n  });\n\n  xtest('keeps neither first nor last', () => {\n    expect(keep([1, 2, 3, 4, 5], (e) => e % 2 === 0)).toEqual([2, 4]);\n  });\n\n  xtest('keeps strings', () => {\n    const words = 'apple zebra banana zombies cherimoya zelot'.split(' ');\n    const result = keep(words, (word) => word.indexOf('z') === 0);\n    expect(result).toEqual('zebra zombies zelot'.split(' '));\n  });\n\n  xtest('keeps lists', () => {\n    const rows = [\n      [1, 2, 3],\n      [5, 5, 5],\n      [5, 1, 2],\n      [2, 1, 2],\n      [1, 5, 2],\n      [2, 2, 1],\n      [1, 2, 5],\n    ];\n    const result = keep(rows, (row) => row.indexOf(5) > -1);\n    expect(result).toEqual([\n      [5, 5, 5],\n      [5, 1, 2],\n      [1, 5, 2],\n      [1, 2, 5],\n    ]);\n  });\n\n  xtest('discard on empty list returns empty list', () => {\n    expect(discard([], (e) => e < 10)).toEqual([]);\n  });\n\n  xtest('discards everything', () => {\n    expect(discard([1, 3, 5], (e) => e < 10)).toEqual([]);\n  });\n\n  xtest('discards nothing', () => {\n    expect(discard([1, 2, 3], (e) => e > 10)).toEqual([1, 2, 3]);\n  });\n\n  xtest('discards first and last', () => {\n    expect(discard([1, 2, 3], (e) => e % 2 === 1)).toEqual([2]);\n  });\n\n  xtest('discards neither first nor last', () => {\n    const result = discard([1, 2, 3, 4, 5], (e) => e % 2 === 0);\n    expect(result).toEqual([1, 3, 5]);\n  });\n\n  xtest('discards strings', () => {\n    const words = 'apple zebra banana zombies cherimoya zelot'.split(' ');\n    const result = discard(words, (word) => word.indexOf('z') === 0);\n    expect(result).toEqual('apple banana cherimoya'.split(' '));\n  });\n\n  xtest('discards lists', () => {\n    const rows = [\n      [1, 2, 3],\n      [5, 5, 5],\n      [5, 1, 2],\n      [2, 1, 2],\n      [1, 5, 2],\n      [2, 2, 1],\n      [1, 2, 5],\n    ];\n    const result = discard(rows, (row) => row.indexOf(5) > -1);\n    expect(result).toEqual([\n      [1, 2, 3],\n      [2, 1, 2],\n      [2, 2, 1],\n    ]);\n  });\n});\n"
}