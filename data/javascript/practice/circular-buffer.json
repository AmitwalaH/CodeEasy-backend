{
  "language": "javascript",
  "type": "practice",
  "slug": "circular-buffer",
  "title": "Circular Buffer",
  "docs": {
    "instructions": "# Instructions\n\nA circular buffer, cyclic buffer or ring buffer is a data structure that uses a single, fixed-size buffer as if it were connected end-to-end.\n\nA circular buffer first starts empty and of some predefined length.\nFor example, this is a 7-element buffer:\n\n```text\n[ ][ ][ ][ ][ ][ ][ ]\n```\n\nAssume that a 1 is written into the middle of the buffer (exact starting location does not matter in a circular buffer):\n\n```text\n[ ][ ][ ][1][ ][ ][ ]\n```\n\nThen assume that two more elements are added — 2 & 3 — which get appended after the 1:\n\n```text\n[ ][ ][ ][1][2][3][ ]\n```\n\nIf two elements are then removed from the buffer, the oldest values inside the buffer are removed.\nThe two elements removed, in this case, are 1 & 2, leaving the buffer with just a 3:\n\n```text\n[ ][ ][ ][ ][ ][3][ ]\n```\n\nIf the buffer has 7 elements then it is completely full:\n\n```text\n[5][6][7][8][9][3][4]\n```\n\nWhen the buffer is full an error will be raised, alerting the client that further writes are blocked until a slot becomes free.\n\nWhen the buffer is full, the client can opt to overwrite the oldest data with a forced write.\nIn this case, two more elements — A & B — are added and they overwrite the 3 & 4:\n\n```text\n[5][6][7][8][9][A][B]\n```\n\n3 & 4 have been replaced by A & B making 5 now the oldest data in the buffer.\nFinally, if two elements are removed then what would be returned is 5 & 6 yielding the buffer:\n\n```text\n[ ][ ][7][8][9][A][B]\n```\n\nBecause there is space available, if the client again uses overwrite to store C & D then the space where 5 & 6 were stored previously will be used not the location of 7 & 8.\n7 is still the oldest element and the buffer is once again full.\n\n```text\n[C][D][7][8][9][A][B]\n```\n",
    "hints": ""
  },
  "starter_code": "//\n// This is only a SKELETON file for the 'Circular Buffer' exercise. It's been provided as a\n// convenience to get you started writing code faster.\n//\n\nclass CircularBuffer {\n  constructor() {\n    throw new Error('Remove this line and implement the function');\n  }\n\n  write() {\n    throw new Error('Remove this line and implement the function');\n  }\n\n  read() {\n    throw new Error('Remove this line and implement the function');\n  }\n\n  forceWrite() {\n    throw new Error('Remove this line and implement the function');\n  }\n\n  clear() {\n    throw new Error('Remove this line and implement the function');\n  }\n}\n\nexport default CircularBuffer;\n\nexport class BufferFullError extends Error {\n  constructor() {\n    throw new Error('Remove this line and implement the function');\n  }\n}\n\nexport class BufferEmptyError extends Error {\n  constructor() {\n    throw new Error('Remove this line and implement the function');\n  }\n}\n",
  "tests": "import { describe, expect, test, xtest } from '@jest/globals';\nimport CircularBuffer, {\n  BufferEmptyError,\n  BufferFullError,\n} from './circular-buffer';\n\ndescribe('CircularBuffer', () => {\n  test('reading empty buffer should fail', () => {\n    const buffer = new CircularBuffer(1);\n    expect(() => buffer.read()).toThrow(BufferEmptyError);\n  });\n\n  xtest('can read an item just written', () => {\n    const buffer = new CircularBuffer(1);\n    buffer.write('1');\n    expect(buffer.read()).toBe('1');\n  });\n\n  xtest('each item may only be read once', () => {\n    const buffer = new CircularBuffer(1);\n    buffer.write('1');\n    expect(buffer.read()).toBe('1');\n    expect(() => buffer.read()).toThrow(BufferEmptyError);\n  });\n\n  xtest('items are read in the order they are written', () => {\n    const buffer = new CircularBuffer(2);\n    buffer.write('1');\n    buffer.write('2');\n    expect(buffer.read()).toBe('1');\n    expect(buffer.read()).toBe('2');\n  });\n\n  xtest(\"full buffer can't be written to\", () => {\n    const buffer = new CircularBuffer(1);\n    buffer.write('1');\n    expect(() => buffer.write(2)).toThrow(BufferFullError);\n  });\n\n  xtest('a read frees up capacity for another write', () => {\n    const buffer = new CircularBuffer(1);\n    buffer.write('1');\n    expect(buffer.read()).toBe('1');\n    buffer.write('2');\n    expect(buffer.read()).toBe('2');\n  });\n\n  xtest('read position is maintained even across multiple writes', () => {\n    const buffer = new CircularBuffer(3);\n    buffer.write('1');\n    buffer.write('2');\n    expect(buffer.read()).toBe('1');\n    buffer.write('3');\n    expect(buffer.read()).toBe('2');\n    expect(buffer.read()).toBe('3');\n  });\n\n  xtest(\"items cleared out of buffer can't be read\", () => {\n    const buffer = new CircularBuffer(1);\n    buffer.write('1');\n    buffer.clear();\n    expect(() => buffer.read()).toThrow(BufferEmptyError);\n  });\n\n  xtest('clear frees up capacity for another write', () => {\n    const buffer = new CircularBuffer(1);\n    buffer.write('1');\n    buffer.clear();\n    buffer.write('2');\n    expect(buffer.read()).toBe('2');\n  });\n\n  xtest('clear does nothing on empty buffer', () => {\n    const buffer = new CircularBuffer(1);\n    buffer.clear();\n    buffer.write('1');\n    expect(buffer.read()).toBe('1');\n  });\n\n  xtest('forceWrite acts like write on non-full buffer', () => {\n    const buffer = new CircularBuffer(2);\n    buffer.write('1');\n    buffer.forceWrite('2');\n    expect(buffer.read()).toBe('1');\n    expect(buffer.read()).toBe('2');\n  });\n\n  xtest('forceWrite replaces the oldest item on full buffer', () => {\n    const buffer = new CircularBuffer(2);\n    buffer.write('1');\n    buffer.write('2');\n    buffer.forceWrite('3');\n    expect(buffer.read()).toBe('2');\n    expect(buffer.read()).toBe('3');\n  });\n\n  xtest('forceWrite replaces the oldest item remaining in buffer following a read', () => {\n    const buffer = new CircularBuffer(3);\n    buffer.write('1');\n    buffer.write('2');\n    buffer.write('3');\n    expect(buffer.read()).toBe('1');\n    buffer.write('4');\n    buffer.forceWrite('5');\n    expect(buffer.read()).toBe('3');\n    expect(buffer.read()).toBe('4');\n    expect(buffer.read()).toBe('5');\n  });\n\n  xtest('initial clear does not affect wrapping around', () => {\n    const buffer = new CircularBuffer(2);\n    buffer.clear();\n    buffer.write('1');\n    buffer.write('2');\n    buffer.forceWrite('3');\n    buffer.forceWrite('4');\n    expect(buffer.read()).toBe('3');\n    expect(buffer.read()).toBe('4');\n    expect(() => buffer.read()).toThrow(BufferEmptyError);\n  });\n});\n"
}