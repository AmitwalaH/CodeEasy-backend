{
  "language": "javascript",
  "type": "practice",
  "slug": "dominoes",
  "title": "Dominoes",
  "docs": {
    "instructions": "# Instructions\n\nMake a chain of dominoes.\n\nCompute a way to order a given set of domino stones so that they form a correct domino chain.\nIn the chain, the dots on one half of a stone must match the dots on the neighboring half of an adjacent stone.\nAdditionally, the dots on the halves of the stones without neighbors (the first and last stone) must match each other.\n\nFor example given the stones `[2|1]`, `[2|3]` and `[1|3]` you should compute something\nlike `[1|2] [2|3] [3|1]` or `[3|2] [2|1] [1|3]` or `[1|3] [3|2] [2|1]` etc, where the first and last numbers are the same.\n\nFor stones `[1|2]`, `[4|1]` and `[2|3]` the resulting chain is not valid: `[4|1] [1|2] [2|3]`'s first and last numbers are not the same.\n4 != 3\n\nSome test cases may use duplicate stones in a chain solution, assume that multiple Domino sets are being used.\n",
    "hints": ""
  },
  "starter_code": "//\n// This is only a SKELETON file for the 'Dominoes' exercise. It's been provided as a\n// convenience to get you started writing code faster.\n//\n\nexport const chain = () => {\n  throw new Error('Remove this line and implement the function');\n};\n",
  "tests": "import { describe, xdescribe, expect, test, xtest } from '@jest/globals';\nimport { chain } from './dominoes';\n\nfunction runTest(dominoes, expected) {\n  if (expected) {\n    runTestsExpectingChain(dominoes);\n  } else {\n    runTestsExpectingNull(dominoes);\n  }\n}\n\nfunction runTestsExpectingNull(dominoes) {\n  const result = chain(dominoes);\n\n  test('Should not have a chain', () => {\n    expect(result).toBe(null);\n  });\n}\n\nfunction runTestsExpectingChain(dominoes) {\n  const result = chain(dominoes);\n\n  test('Should have a chain', () => {\n    expect(result).not.toBe(null);\n  });\n\n  xtest('The number of dominoes in the output equals the number of dominoes in the input.', () => {\n    expect(result).toHaveLength(dominoes.length);\n  });\n\n  xtest('For each adjacent pair of dominoes ... (a, b), (c, d) ...: b is equal to c.', () => {\n    expect(\n      result\n        .map((v, i) => {\n          if (i === result.length - 1) return true;\n          return v[1] === result[i + 1][0];\n        })\n        .every(Boolean),\n    ).toBe(true);\n  });\n\n  if (dominoes.length > 0) {\n    xtest('For the dominoes on the ends (a, b) ... (c, d): a is equal to d.', () => {\n      expect(result[0][0] === result[result.length - 1][1]).toBe(true);\n    });\n  }\n\n  // 4. Every domino appears in the output an equal number of times as the number of times it appears in the input.\n  // (in other words, the dominoes in the output are the same dominoes as the ones in the input)\n  xtest('Should have the same dominoes', () => {\n    const sortDomino = (domino) => [...domino].sort();\n    expect([...dominoes].map(sortDomino).sort()).toEqual(\n      [...result].map(sortDomino).sort(),\n    );\n  });\n}\n\ndescribe('Dominoes', () => {\n  describe('empty input = empty output', () => {\n    runTest([], true);\n  });\n\n  xdescribe('singleton input = singleton output', () => {\n    runTest([[1, 1]], true);\n  });\n\n  xdescribe(\"singleton that can't be chained\", () => {\n    runTest([[1, 2]], false);\n  });\n\n  xdescribe('three elements', () => {\n    runTest(\n      [\n        [1, 2],\n        [3, 1],\n        [2, 3],\n      ],\n      true,\n    );\n  });\n\n  xdescribe('can reverse dominoes', () => {\n    runTest(\n      [\n        [1, 2],\n        [1, 3],\n        [2, 3],\n      ],\n      true,\n    );\n  });\n\n  xdescribe(\"can't be chained\", () => {\n    runTest(\n      [\n        [1, 2],\n        [4, 1],\n        [2, 3],\n      ],\n      false,\n    );\n  });\n\n  xdescribe('disconnected - simple', () => {\n    runTest(\n      [\n        [1, 1],\n        [2, 2],\n      ],\n      false,\n    );\n  });\n\n  xdescribe('disconnected - double loop', () => {\n    runTest(\n      [\n        [1, 2],\n        [2, 1],\n        [3, 4],\n        [4, 3],\n      ],\n      false,\n    );\n  });\n\n  xdescribe('disconnected - single isolated', () => {\n    runTest(\n      [\n        [1, 2],\n        [2, 3],\n        [3, 1],\n        [4, 4],\n      ],\n      false,\n    );\n  });\n\n  xdescribe('need backtrack', () => {\n    runTest(\n      [\n        [1, 2],\n        [2, 3],\n        [3, 1],\n        [2, 4],\n        [2, 4],\n      ],\n      true,\n    );\n  });\n\n  xdescribe('separate loops', () => {\n    runTest(\n      [\n        [1, 2],\n        [2, 3],\n        [3, 1],\n        [1, 1],\n        [2, 2],\n        [3, 3],\n      ],\n      true,\n    );\n  });\n\n  xdescribe('nine elements', () => {\n    runTest(\n      [\n        [1, 2],\n        [5, 3],\n        [3, 1],\n        [1, 2],\n        [2, 4],\n        [1, 6],\n        [2, 3],\n        [3, 4],\n        [5, 6],\n      ],\n      true,\n    );\n  });\n\n  xdescribe('separate three-domino loops', () => {\n    runTest(\n      [\n        [1, 2],\n        [2, 3],\n        [3, 1],\n        [4, 5],\n        [5, 6],\n        [6, 4],\n      ],\n      false,\n    );\n  });\n});\n"
}