{
  "language": "javascript",
  "type": "practice",
  "slug": "lens-person",
  "title": "Lens Person",
  "docs": {
    "instructions": "# Instructions\n\nUse lenses to update nested records (specific to languages with immutable data).\n\nUpdating fields of nested, immutable records is kind of annoying.\nThe code for such cases is as cumbersome as the structure is deep.\nIf you have, say, a Person, that contains an Address, which has a Street, that has a Number, updating the Number requires creating a new Street with the new Number, then a new Address with the new Street and, finally, a new Person with the new Address.\nConfused already?\n\nOne solution to this problem is to use [lenses][lenses].\n\nImplement several record accessing functions using lenses.\nThe test suite also allows you to avoid lenses altogether so you can experiment with different approaches.\n\n[lenses]: https://en.wikibooks.org/wiki/Haskell/Lenses_and_functional_references\n",
    "hints": ""
  },
  "starter_code": "//\n// This is only a SKELETON file for the 'Lens Person' exercise. It's been provided as a\n// convenience to get you started writing code faster.\n//\n\n/* eslint-disable no-unused-vars */\nimport { Person } from './person';\nimport { Name } from './name';\nimport { Born } from './born';\nimport { Address } from './address';\nimport { Lens } from './lens';\n\n// Implement the nameLens with the getter and setter\nexport const nameLens = new Lens(\n  () => {\n    throw new Error('Remove this line and implement the function');\n  },\n  () => {\n    throw new Error('Remove this line and implement the function');\n  },\n);\n\n// Implement the bornAtLens with the getter and setter\nexport const bornAtLens = new Lens(\n  () => {\n    throw new Error('Remove this line and implement the function');\n  },\n  () => {\n    throw new Error('Remove this line and implement the function');\n  },\n);\n\n// Implement the streetLens with the getter and setter\nexport const streetLens = new Lens(\n  () => {\n    throw new Error('Remove this line and implement the function');\n  },\n  () => {\n    throw new Error('Remove this line and implement the function');\n  },\n);\n",
  "tests": "import { describe, expect, test, xtest } from '@jest/globals';\nimport { Address } from './address';\nimport { Born } from './born';\nimport { Name } from './name';\nimport { Person } from './person';\n\nimport { bornAtLens, nameLens, streetLens } from './lens-person';\n\n// test data\nconst person = new Person(\n  new Name('Saravanan', 'Lakshmanan'),\n  new Born(\n    new Address(100, 'Hospital street', 'Tamil Nadu', 'India'),\n    new Date(),\n  ),\n  new Address(1, 'Coder street', 'Tamil Nadu', 'India'),\n);\n\n// test suite for nameLens\ndescribe('nameLens', () => {\n  test('should get the name of the person', () => {\n    expect(nameLens.get(person)).toEqual(person.name);\n  });\n\n  xtest('should set a new forename for the person', () => {\n    const updatedPerson = nameLens.set(person, new Name('Sara', 'Lakshmanan'));\n    expect(nameLens.get(updatedPerson)).toEqual(updatedPerson.name);\n  });\n\n  xtest('should set a new surname for the person', () => {\n    const updatedPerson = nameLens.set(person, new Name('Saravanan', 'Laksh'));\n    expect(nameLens.get(updatedPerson)).toEqual(updatedPerson.name);\n  });\n\n  xtest('should ensure immutability when setting a new name', () => {\n    const originalName = new Name('Saravanan', 'Lakshmanan');\n    nameLens.set(person, new Name('Subhash', 'Forst'));\n    expect(person.name).toStrictEqual(originalName);\n  });\n});\n\n// Test suite for bornAtLens\ndescribe('bornAtLens', () => {\n  xtest('should get the address for where the person was born', () => {\n    expect(bornAtLens.get(person)).toEqual(person.born.bornAt);\n  });\n\n  xtest('should set a new address for where the person was born', () => {\n    const updatedPerson = bornAtLens.set(\n      person,\n      new Address(2, 'Exercism street', 'Tamil Nadu', 'India'),\n    );\n    expect(bornAtLens.get(updatedPerson)).toEqual(updatedPerson.born.bornAt);\n  });\n\n  xtest('should ensure immutability when setting a new birth address', () => {\n    const originalBirthAddress = new Address(\n      100,\n      'Hospital street',\n      'Tamil Nadu',\n      'India',\n    );\n    bornAtLens.set(person, new Address(15, 'Clinic street', 'Kerala', 'India'));\n    expect(person.born.bornAt).toStrictEqual(originalBirthAddress);\n  });\n});\n\n// Test suite for streetLens\ndescribe('streetLens', () => {\n  xtest('should get the current street of the person', () => {\n    expect(streetLens.get(person)).toEqual(person.address.street);\n  });\n\n  xtest('should set a new street for the current address of the person', () => {\n    const updatedPerson = streetLens.set(person, 'Exercism street');\n    expect(streetLens.get(updatedPerson)).toEqual(updatedPerson.address.street);\n  });\n\n  xtest('should ensure immutability when setting a new street', () => {\n    const originalAddress = new Address(\n      1,\n      'Coder street',\n      'Tamil Nadu',\n      'India',\n    );\n    streetLens.set(person, 'Mimic street');\n    expect(person.address).toStrictEqual(originalAddress);\n  });\n});\n"
}