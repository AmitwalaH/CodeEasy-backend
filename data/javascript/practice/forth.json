{
  "language": "javascript",
  "type": "practice",
  "slug": "forth",
  "title": "Forth",
  "docs": {
    "instructions": "# Instructions\n\nImplement an evaluator for a very simple subset of Forth.\n\n[Forth][forth]\nis a stack-based programming language.\nImplement a very basic evaluator for a small subset of Forth.\n\nYour evaluator has to support the following words:\n\n- `+`, `-`, `*`, `/` (integer arithmetic)\n- `DUP`, `DROP`, `SWAP`, `OVER` (stack manipulation)\n\nYour evaluator also has to support defining new words using the customary syntax: `: word-name definition ;`.\n\nTo keep things simple the only data type you need to support is signed integers of at least 16 bits size.\n\nYou should use the following rules for the syntax: a number is a sequence of one or more (ASCII) digits, a word is a sequence of one or more letters, digits, symbols or punctuation that is not a number.\n(Forth probably uses slightly different rules, but this is close enough.)\n\nWords are case-insensitive.\n\n[forth]: https://en.wikipedia.org/wiki/Forth_%28programming_language%29\n",
    "hints": ""
  },
  "starter_code": "//\n// This is only a SKELETON file for the 'Forth' exercise. It's been provided as a\n// convenience to get you started writing code faster.\n//\n\nexport class Forth {\n  constructor() {\n    throw Error('Remove this statement and implement this function');\n  }\n\n  evaluate() {\n    throw Error('Remove this statement and implement this function');\n  }\n\n  get stack() {\n    throw Error('Remove this statement and implement this function');\n  }\n}\n",
  "tests": "import { beforeEach, describe, expect, test, xtest } from '@jest/globals';\nimport { Forth } from './forth';\n\ndescribe('Forth', () => {\n  let forth;\n\n  beforeEach(() => {\n    forth = new Forth();\n  });\n\n  describe('parsing and numbers', () => {\n    test('numbers just get pushed onto the stack', () => {\n      forth.evaluate('1 2 3 4 5');\n      expect(forth.stack).toEqual([1, 2, 3, 4, 5]);\n    });\n\n    xtest('pushes negative numbers onto the stack', () => {\n      forth.evaluate('-1 -2 -3 -4 -5');\n      expect(forth.stack).toEqual([-1, -2, -3, -4, -5]);\n    });\n  });\n\n  describe('addition', () => {\n    xtest('can add two numbers', () => {\n      forth.evaluate('1 2 +');\n      expect(forth.stack).toEqual([3]);\n    });\n\n    xtest('errors if there is nothing on the stack', () => {\n      expect(() => {\n        forth.evaluate('+');\n      }).toThrow(new Error('Stack empty'));\n    });\n\n    xtest('errors if there is only one value on the stack', () => {\n      expect(() => {\n        forth.evaluate('1 +');\n      }).toThrow(new Error('Only one value on the stack'));\n    });\n\n    xtest('more than two values on the stack', () => {\n      forth.evaluate('1 2 3 +');\n      expect(forth.stack).toEqual([1, 5]);\n    });\n  });\n\n  describe('subtraction', () => {\n    xtest('can subtract two numbers', () => {\n      forth.evaluate('3 4 -');\n      expect(forth.stack).toEqual([-1]);\n    });\n\n    xtest('errors if there is nothing on the stack', () => {\n      expect(() => {\n        forth.evaluate('-');\n      }).toThrow(new Error('Stack empty'));\n    });\n\n    xtest('errors if there is only one value on the stack', () => {\n      expect(() => {\n        forth.evaluate('1 -');\n      }).toThrow(new Error('Only one value on the stack'));\n    });\n\n    xtest('more than two values on the stack', () => {\n      forth.evaluate('1 12 3 -');\n      expect(forth.stack).toEqual([1, 9]);\n    });\n  });\n\n  describe('multiplication', () => {\n    xtest('can multiply two numbers', () => {\n      forth.evaluate('2 4 *');\n      expect(forth.stack).toEqual([8]);\n    });\n\n    xtest('errors if there is nothing on the stack', () => {\n      expect(() => {\n        forth.evaluate('*');\n      }).toThrow(new Error('Stack empty'));\n    });\n\n    xtest('errors if there is only one value on the stack', () => {\n      expect(() => {\n        forth.evaluate('1 *');\n      }).toThrow(new Error('Only one value on the stack'));\n    });\n\n    xtest('more than two values on the stack', () => {\n      forth.evaluate('1 2 3 *');\n      expect(forth.stack).toEqual([1, 6]);\n    });\n  });\n\n  describe('division', () => {\n    xtest('can divide two numbers', () => {\n      forth.evaluate('12 3 /');\n      expect(forth.stack).toEqual([4]);\n    });\n\n    xtest('performs integer division', () => {\n      forth.evaluate('8 3 /');\n      expect(forth.stack).toEqual([2]);\n    });\n\n    xtest('errors if dividing by zero', () => {\n      expect(() => {\n        forth.evaluate('4 0 /');\n      }).toThrow(new Error('Division by zero'));\n    });\n\n    xtest('errors if there is nothing on the stack', () => {\n      expect(() => {\n        forth.evaluate('/');\n      }).toThrow(new Error('Stack empty'));\n    });\n\n    xtest('errors if there is only one value on the stack', () => {\n      expect(() => {\n        forth.evaluate('1 /');\n      }).toThrow(new Error('Only one value on the stack'));\n    });\n\n    xtest('more than two values on the stack', () => {\n      forth.evaluate('1 12 3 /');\n      expect(forth.stack).toEqual([1, 4]);\n    });\n  });\n\n  describe('combined arithmetic', () => {\n    xtest('addition and subtraction', () => {\n      forth.evaluate('1 2 + 4 -');\n      expect(forth.stack).toEqual([-1]);\n    });\n\n    xtest('multiplication and division', () => {\n      forth.evaluate('2 4 * 3 /');\n      expect(forth.stack).toEqual([2]);\n    });\n\n    xtest('multiplication and addition', () => {\n      forth.evaluate('1 3 4 * +');\n      expect(forth.stack).toEqual([13]);\n    });\n\n    xtest('addition and multiplication', () => {\n      forth.evaluate('1 3 4 + *');\n      expect(forth.stack).toEqual([7]);\n    });\n  });\n\n  describe('dup', () => {\n    xtest('copies a value on the stack', () => {\n      forth.evaluate('1 dup');\n      expect(forth.stack).toEqual([1, 1]);\n    });\n\n    xtest('copies the top value on the stack', () => {\n      forth.evaluate('1 2 dup');\n      expect(forth.stack).toEqual([1, 2, 2]);\n    });\n\n    xtest('errors if there is nothing on the stack', () => {\n      expect(() => {\n        forth.evaluate('dup');\n      }).toThrow(new Error('Stack empty'));\n    });\n  });\n\n  describe('drop', () => {\n    xtest('removes the top value on the stack if it is the only one', () => {\n      forth.evaluate('1 drop');\n      expect(forth.stack).toEqual([]);\n    });\n\n    xtest('removes the top value on the stack if it is not the only one', () => {\n      forth.evaluate('1 2 drop');\n      expect(forth.stack).toEqual([1]);\n    });\n\n    xtest('errors if there is nothing on the stack', () => {\n      expect(() => {\n        forth.evaluate('drop');\n      }).toThrow(new Error('Stack empty'));\n    });\n  });\n\n  describe('swap', () => {\n    xtest('swaps the top two values on the stack if they are the only ones', () => {\n      forth.evaluate('1 2 swap');\n      expect(forth.stack).toEqual([2, 1]);\n    });\n\n    xtest('swaps the top two values on the stack if they are not the only ones', () => {\n      forth.evaluate('1 2 3 swap');\n      expect(forth.stack).toEqual([1, 3, 2]);\n    });\n\n    xtest('errors if there is nothing on the stack', () => {\n      expect(() => {\n        forth.evaluate('swap');\n      }).toThrow(new Error('Stack empty'));\n    });\n\n    xtest('errors if there is only one value on the stack', () => {\n      expect(() => {\n        forth.evaluate('1 swap');\n      }).toThrow(new Error('Only one value on the stack'));\n    });\n  });\n\n  describe('over', () => {\n    xtest('copies the second element if there are only two', () => {\n      forth.evaluate('1 2 over');\n      expect(forth.stack).toEqual([1, 2, 1]);\n    });\n\n    xtest('copies the second element if there are more than two', () => {\n      forth.evaluate('1 2 3 over');\n      expect(forth.stack).toEqual([1, 2, 3, 2]);\n    });\n\n    xtest('errors if there is nothing on the stack', () => {\n      expect(() => {\n        forth.evaluate('over');\n      }).toThrow(new Error('Stack empty'));\n    });\n\n    xtest('errors if there is only one value on the stack', () => {\n      expect(() => {\n        forth.evaluate('1 over');\n      }).toThrow(new Error('Only one value on the stack'));\n    });\n  });\n\n  describe('user-defined words', () => {\n    xtest('can consist of built-in words', () => {\n      forth.evaluate(': dup-twice dup dup ;');\n      forth.evaluate('1 dup-twice');\n      expect(forth.stack).toEqual([1, 1, 1]);\n    });\n\n    xtest('execute in the right order', () => {\n      forth.evaluate(': countup 1 2 3 ;');\n      forth.evaluate('countup');\n      expect(forth.stack).toEqual([1, 2, 3]);\n    });\n\n    xtest('can override other user-defined words', () => {\n      forth.evaluate(': foo dup ;');\n      forth.evaluate(': foo dup dup ;');\n      forth.evaluate('1 foo');\n      expect(forth.stack).toEqual([1, 1, 1]);\n    });\n\n    xtest('can override built-in words', () => {\n      forth.evaluate(': swap dup ;');\n      forth.evaluate('1 swap');\n      expect(forth.stack).toEqual([1, 1]);\n    });\n\n    xtest('can override built-in operators', () => {\n      forth.evaluate(': + * ;');\n      forth.evaluate('3 4 +');\n      expect(forth.stack).toEqual([12]);\n    });\n\n    xtest('can use different words with the same name', () => {\n      forth.evaluate(': foo 5 ;');\n      forth.evaluate(': bar foo ;');\n      forth.evaluate(': foo 6 ;');\n      forth.evaluate('bar foo');\n      expect(forth.stack).toEqual([5, 6]);\n    });\n\n    xtest('can define word that uses word with the same name', () => {\n      forth.evaluate(': foo 10 ;');\n      forth.evaluate(': foo foo 1 + ;');\n      forth.evaluate('foo');\n      expect(forth.stack).toEqual([11]);\n    });\n\n    xtest('cannot redefine non-negative numbers', () => {\n      expect(() => {\n        forth.evaluate(': 1 2 ;');\n      }).toThrow(new Error('Invalid definition'));\n    });\n\n    xtest('cannot redefine negative numbers', () => {\n      expect(() => {\n        forth.evaluate(': -1 2 ;');\n      }).toThrow(new Error('Invalid definition'));\n    });\n\n    xtest('errors if executing a non-existent word', () => {\n      expect(() => {\n        forth.evaluate('foo');\n      }).toThrow(new Error('Unknown command'));\n    });\n\n    xtest('only defines locally', () => {\n      const first = new Forth();\n      const second = new Forth();\n      first.evaluate(': + - ;');\n      first.evaluate('1 1 +');\n      second.evaluate('1 1 +');\n      expect(first.stack).toEqual([0]);\n      expect(second.stack).toEqual([2]);\n    });\n  });\n\n  describe('case-insensitivity', () => {\n    xtest('DUP is case-insensitive', () => {\n      forth.evaluate('1 DUP Dup dup');\n      expect(forth.stack).toEqual([1, 1, 1, 1]);\n    });\n\n    xtest('DROP is case-insensitive', () => {\n      forth.evaluate('1 2 3 4 DROP Drop drop');\n      expect(forth.stack).toEqual([1]);\n    });\n\n    xtest('SWAP is case-insensitive', () => {\n      forth.evaluate('1 2 SWAP 3 Swap 4 swap');\n      expect(forth.stack).toEqual([2, 3, 4, 1]);\n    });\n\n    xtest('OVER is case-insensitive', () => {\n      forth.evaluate('1 2 OVER Over over');\n      expect(forth.stack).toEqual([1, 2, 1, 2, 1]);\n    });\n\n    xtest('user-defined words are case-insensitive', () => {\n      forth.evaluate(': foo dup ;');\n      forth.evaluate('1 FOO Foo foo');\n      expect(forth.stack).toEqual([1, 1, 1, 1]);\n    });\n\n    xtest('definitions are case-insensitive', () => {\n      forth.evaluate(': SWAP DUP Dup dup ;');\n      forth.evaluate('1 swap');\n      expect(forth.stack).toEqual([1, 1, 1, 1]);\n    });\n  });\n});\n"
}